<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="C语言入门学习教程" />
    <meta name="hexo-theme-A4" content="v1.8.3" />
    <link rel="alternate icon" type="image/webp" href="/images/icon1.webp">
    <title>Fingsinz&#39;s space | 风信梓的博客</title>

    
        
<link rel="stylesheet" href="/css/a11y-dark.min.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    
    

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: white;  
        }
        body {
            color: #000000;
            background: #bed2bb;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: white; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: #6b798e;
        }

        .post-md a {
            color: #6b798e;
        }

        .nav li a {
            color: #6b798e;
        }

        .archive-main a:link {
            color: #6b798e;
        }
        .archive-main a:visited {
            color: #6b798e; 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: white;
        }

        .paper {
            background: #bed2bb;
        }

        .index-main {
            background: white;
        }

        .paper-main {
            background: white;
        }

        .wl-panel {
            background: white;
        }

        .archive li:nth-child(odd) {
            background: white;
            ;
        }

        .archive li:nth-child(even) {
            background: white;
        }

        .post-md>table tr:nth-child(odd) td {
            background: white;
        }

        .post-md>table tr:nth-child(even) td {
            background: white;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #6b798e;
            border-left-color: #6b798e;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Fingsinz&#39;s space</a> 
            <span class="description">不忘初心，方得始终</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页🏚️</a></li>
            
        
            
                <li><a href="/list/">文章📄</a></li>
            
        
            
                <li><a href="/categories/">分类🗂️</a></li>
            
        
            
                <li><a href="/about/">关于🧑</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            C语言入门学习教程
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅰ —— 基础知识介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-c%E8%AF%AD%E8%A8%80%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="post-toc-text">1.1 C语言背景知识</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-%E7%94%A8%E4%BB%80%E4%B9%88%E5%86%99c%E8%AF%AD%E8%A8%80"><span class="post-toc-text">1.2 用什么写C语言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="post-toc-text">1.3 从代码到执行程序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-%E8%AE%A4%E8%AF%86%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81"><span class="post-toc-text">1.4 认识最基础的C语言代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-5-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="post-toc-text">1.5 头文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-6-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="post-toc-text">1.6 关键字</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅱ —— 函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="post-toc-text">2.1 函数的基本结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="post-toc-text">2.2 函数声明和定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="post-toc-text">2.3 调用函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="post-toc-text">2.4 函数参数传递</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅲ —— 数据、运算符及语句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="post-toc-text">3.1 数据的表现形式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">3.2 数据的类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-1-%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="post-toc-text">3.2.1 整型数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-2-%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="post-toc-text">3.2.2 浮点型数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-3-void%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">3.2.3 Void类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-4-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">3.2.4 类型转换</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3 运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3.1 算术运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3.2 关系运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3.3 逻辑运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-4-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3.4 位运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3.5 赋值运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-6-%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">3.3.6 其他运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-7-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="post-toc-text">3.3.7 运算符优先级</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-4-%E8%AF%AD%E5%8F%A5"><span class="post-toc-text">3.4 语句</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-5-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="post-toc-text">3.5 变量的作用范围</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅳ —— 格式化输入输出</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E8%BE%93%E5%87%BA"><span class="post-toc-text">4.1 格式化的输出</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E8%BE%93%E5%85%A5"><span class="post-toc-text">4.2 格式化的输入</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅴ —— 条件结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-if%E6%9E%84%E6%88%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="post-toc-text">5.1 if构成的条件结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-switch%E6%9E%84%E6%88%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="post-toc-text">5.2 switch构成的条件结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅵ —— 循环结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-while%E6%9E%84%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="post-toc-text">6.1 while构成的循环结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-do-while%E6%9E%84%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="post-toc-text">6.2 do-while构成的循环结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-for%E6%9E%84%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="post-toc-text">6.3 for构成的循环结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-4-%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%BB%88%E6%AD%A2%E4%B8%8E%E7%BB%A7%E7%BB%AD"><span class="post-toc-text">6.4 循环的终止与继续</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅶ —— 枚举</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅷ —— 数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-1-%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84"><span class="post-toc-text">8.1 数组结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="post-toc-text">8.2 数组的定义和访问</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-3-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-text">8.3 数组的初始化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="post-toc-text">8.4 多维数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-5-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="post-toc-text">8.5 数组的使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅸ —— 指针</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-1-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="post-toc-text">9.1 指针变量的定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-2-%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="post-toc-text">9.2 指针的运算</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-3-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="post-toc-text">9.3 指针的使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅹ —— 共用体与结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-1-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="post-toc-text">10.1 共用体</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-2-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-text">10.2 结构体</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅺ —— 链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-1-%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E6%9E%84%E6%88%90"><span class="post-toc-text">11.1 链表及其构成</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0"><span class="post-toc-text">11.2 内存管理的函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-3-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="post-toc-text">11.3 单向链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-4-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="post-toc-text">11.4 双向链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-5-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="post-toc-text">11.5 循环链表</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link"><span class="post-toc-text">Ⅻ —— 对文件的读写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-1-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="post-toc-text">12.1 打开文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-2-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="post-toc-text">12.2 写入文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-3-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="post-toc-text">12.3 读取文件</span></a></li></ol></li></ol>
            
        
        <p>个人整理面向入门基础级别的C语言学习教程。</p>
<p>关键词：C语言</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h1>Ⅰ —— 基础知识介绍</h1>
<p>此教程会用一些注记符号，表示某种格式。</p>
<h2 id="1-1-c语言背景知识">1.1 C语言背景知识</h2>
<p>C语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。</p>
<p>C语言标准有C89、C99、C11、C17、C2x ……等，后面的数字是标准发布的年份。如果想了解每个标准有什么差异，自行必应搜索。本教程的完整代码在GNU C17下成功运行。</p>
<h2 id="1-2-用什么写c语言">1.2 用什么写C语言</h2>
<p>编写C语言，就连基本的文本编辑器——记事本也可以完成。但我们并不会只想着使用那么奇奇怪怪的记事本，去编写十来行代码甚至上千行代码，至少是真的不习惯。</p>
<p>接触C语言，会有很多人推荐你用那个什么什么写啊，一点一动就行；但如果在大学学习，教师可能会让你使用Visual C++ 6.0（下简称VC 6.0）去写。</p>
<p>感受过VC 6.0软件界面的人都知道，很不舒服，甚至降低自己的效率。VC 6.0甚至比我的年龄还大，算是老古董了。但是目前教材用的是VC 6.0，实验室配置的是VC 6.0，乃至你的考试，甚至计算机二级，都是VC 6.0，所以用VC 6.0而不是别的软件，更加容易应付教学。</p>
<p>所以在此，我推荐使用的C语言编辑器是：</p>
<ul>
<li>
<p>基础小白或图方便可使用<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/dev-cpp-2020/">Dev-C++</a></p>
</li>
<li>
<p>非基础小白可使用Visual Studio或Visual Studio Code</p>
</li>
</ul>
<p>此教程的代码使用Dev-C++，均在Dev-C++下成功运行。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_devcpp.jpg" alt="Dev-C++界面"></p>
<p>按 <code>Ctrl</code> + <code>N</code> 可以新建文件，或者点击左上角文件新建文件。</p>
<p>在 工具 → 编译选项 → 代码生成/优化 → 代码生成 处可以找到语言标准。</p>
<h2 id="1-3-从代码到执行程序">1.3 从代码到执行程序</h2>
<p>在上一节我提到了用什么写C语言，这是关于编辑器（Editor）的事情。字面意思，它只负责编辑，也就是敲上一个个的字母数字，就像写英语日记、写英语文章一样。</p>
<p>事实上，你在编辑器上写的内容，还不能完全算是程序，这个内容称为 <strong>源代码（Source Code）</strong> 。存放源代码的文件称为 <strong>源文件</strong> 。</p>
<p>我们还需要经过一些步骤，使得源代码变成 <strong>可执行文件（Executable file）</strong> ，也就是你计算机里面那些.exe文件。把这些步骤称之为 <strong>编译（Build）</strong> 和 <strong>链接（Link）</strong> 。</p>
<ul>
<li>
<p>编译：编译需要 <strong>编译器</strong> 完成。编译器把一个源代码翻译成可执行文件的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。常见的编译器有：MinGW、MSVC等。</p>
</li>
<li>
<p>链接：链接需要 <strong>链接器</strong> 完成。链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。链接的意义在于我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
</li>
</ul>
<p>这些只是一些知识补充，想详细了解可参阅编译原理。另外，如果你选择了Dev-C++或者Visual Studio这样的集成软件，编译器和链接器的配置会相对简单。</p>
<h2 id="1-4-认识最基础的c语言代码">1.4 认识最基础的C语言代码</h2>
<p>学习C语言的开始，从输出一个“Hello World！”开始，这似乎是所有编程语言一开始都经历的事情。</p>
<p>我在此直接给出完整代码，心急的可以复制到Dev-C++运行试试。</p>
<pre><code class="language-c">// Hello World.c 
#include &lt;stdio.h&gt;

int main()
{
	printf("Hello World!");
	return 0;
}
</code></pre>
<p>现在来逐行认识基本的C语言代码结构。</p>
<ul>
<li>
<p><code>//</code> 表示当前整行被编译器忽略，又称注释，供程序员理解语句。</p>
</li>
<li>
<p><code>#include&lt;stdio.h&gt;</code>中的 <code>#</code>（井号）表示预处理命令，即在程序编译前进行提前处理的部分。若是头文件，可用 <code>&lt;&gt;</code>（单书名号）括起来，也可用 <code>" "</code>（引号）包含起来。 <strong>其中由 <code>&lt;&gt;</code> 括起来的头文件表示在系统头文件的文件夹中查找，由 <code>""</code> 括起来的头文件表示在源文件当前文件夹查找。</strong></p>
</li>
<li>
<p><code>int main()</code> 是一个函数的开头，再加以 <code>{}</code>（大括号）包含主函数内容。此处是主函数，主函数是一个程序最重要的函数，程序从此开始编译。</p>
</li>
<li>
<p><code>printf("Hello World!");</code> 为程序工作语句，其作用是输出“Hello World！”。</p>
</li>
<li>
<p>C语言中以 <code>;</code>（分号）作为一条语句的结束标志。</p>
</li>
<li>
<p><code>return 0;</code>是函数的结构之一，在函数一节介绍。</p>
</li>
</ul>
<p>一般情况下， <strong>一个C语言程序包含预处理器指令、函数、变量、语句（表达式和注释）等</strong> 。函数是一个进行某种功能操作的模块，目前认识到的是主函数，还可以自定义函数。变量即程序运行时其值可以改变的量，变量的功能就是存储数据。</p>
<p>C语言代码按 <strong>顺序结构</strong> ，由上到下顺序执行代码。</p>
<p>还有一件比较重要的事情，养成良好的代码风格，即令人舒适的缩进、空格位置等；千万不要所有代码都挤到一块或者全都左对齐。</p>
<h2 id="1-5-头文件">1.5 头文件</h2>
<p>在上一节提到了预处理命令包含的头文件，那么头文件是什么？</p>
<p>头文件是扩展名为.h的文件，包含了C语言一些函数甚至几乎所有函数的提前 <strong>声明（Statement）</strong> 和 <strong>定义（Definition）</strong> ，没有这些声明和定义，编译器不会认识这些函数，故而不能运行。</p>
<p>有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用预处理指令 #include 来引用它，引用头文件相当于复制头文件的内容。如stdio.h头文件，它包含了<code>printf()</code>这一函数。</p>
<h2 id="1-6-关键字">1.6 关键字</h2>
<p>C语言的关键字是C语言的基本构成要素，共有32个，根据关键字的作用，可分其为数据类型关键字、控制语句关键字、存储类型关键字和其它关键字四类。</p>
<p><strong>1 数据类型关键字（12个）：</strong><br>
(1)  <code>char</code> ：声明字符型变量或函数<br>
(2) <code>double</code> ：声明双精度变量或函数<br>
(3) <code>enum</code> ：声明枚举类型<br>
(4) <code>float</code> ：声明浮点型变量或函数<br>
(5) <code>int</code> ：声明整型变量或函数<br>
(6) <code>long</code> ：声明长整型变量或函数<br>
(7) <code>short</code> ：声明短整型变量或函数<br>
(8) <code>signed</code> ：声明有符号类型变量或函数<br>
(9) <code>struct</code> ：声明结构体变量或函数<br>
(10) <code>union</code> ：声明共用体（联合）数据类型<br>
(11) <code>unsigned</code> ：声明无符号类型变量或函数<br>
(12) <code>void</code> ：声明函数无返回值或无参数，声明无类型指针</p>
<p><strong>2 控制语句关键字（12个）：</strong><br>
A循环语句<br>
(1) <code>for</code> ：一种循环语句(可意会不可言传）<br>
(2) <code>do</code> ：循环语句的循环体<br>
(3) <code>while</code> ：循环语句的循环条件<br>
(4) <code>break</code> ：跳出当前循环<br>
(5) <code>continue</code> ：结束当前循环，开始下一轮循环<br>
B条件语句<br>
(1) <code>if</code> : 条件语句<br>
(2) <code>else</code> ：条件语句否定分支（与 if 连用）<br>
(3) <code>goto</code> ：无条件跳转语句<br>
C开关语句<br>
(1) <code>switch</code> :用于开关语句<br>
(2) <code>case</code>：开关语句分支<br>
(3) <code>default</code>：开关语句中的“其他”分支<br>
D返回语句<br>
<code>return</code> ：函数返回语句（可以带参数，也可不带参数）</p>
<p><strong>3 存储类型关键字（4个）</strong><br>
(1) <code>auto</code> ：声明自动变量 一般不使用<br>
(2) <code>extern</code> ：声明变量是在其他文件正声明（也可以看做是引用变量）<br>
(3) <code>register</code>：声明积存器变量<br>
(4) <code>static</code> ：声明静态变量</p>
<p><strong>4 其它关键字（4个）：</strong><br>
(1) <code>const</code> ：声明只读变量<br>
(2) <code>sizeof</code> ：计算数据类型长度<br>
(3) <code>typedef</code> ：用以给数据类型取别名<br>
(4) <code>volatile</code> ：说明变量在程序执行中可被隐含地改变</p>
<p>你可能不明白这些关键字什么意思怎么用，但你只需要知道这些关键字不能随便用，它们被C语言内部定义占用了。</p>
<p><br><br><br></p>
<h1>Ⅱ —— 函数</h1>
<p>函数是用来完成特定任务的一组语句。在C语言中，每个程序至少有一个主函数 <code>main()</code> 。此外，C语言还提供了许多内置函数，可以在相应的头文件中找到。有时候，我们也可以称函数为方法。</p>
<p>当我们编写代码时，我们可以将其分割成不同的函数。划分代码到不同的函数中是我们自己决定的。但是从逻辑上来说，我们通常会根据每个函数执行特定的任务来进行划分。例如，如果我们正在编写一个计算器程序，我们可以使用四个函数分别处理加法、减法、乘法和除法。这样的划分可以让代码更有组织性，并且更易于理解和维护。</p>
<h2 id="2-1-函数的基本结构">2.1 函数的基本结构</h2>
<p>函数的结构应当如下，包括 <strong>函数返回类型return_type</strong> ， <strong>函数名字function_name</strong> 、 <strong>参数arguments</strong> 和 <strong>函数主体Body</strong> 等。</p>
<pre><code class="language-c">return_type function_name(arguments)
{
	// body
}
</code></pre>
<ul>
<li>
<p><strong>函数返回类型</strong>：一个函数可以返回一个值，return_type是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <code>void</code> 。</p>
</li>
<li>
<p><strong>函数名字</strong>：这是函数的实际名称。函数名和参数列表一起构成了 <strong>函数签名（Function signature）</strong> 。</p>
</li>
<li>
<p><strong>参数列表</strong>：当函数被调用时，可以向参数传递值。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</p>
</li>
<li>
<p><strong>函数主体</strong>：函数主体包含一组定义函数执行任务的语句。若有返回值的函数使用 <code>return</code> 返回。函数主体中遇到返回表示结束函数。</p>
</li>
</ul>
<h2 id="2-2-函数声明和定义">2.2 函数声明和定义</h2>
<p>函数的产生有两个概念： <strong>函数声明（Function Statement）</strong> 和 <strong>函数定义（Function Definition）</strong> 。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 <strong>使用函数之前必须先声明（也可以直接声明并定义）。</strong><br>
开玩笑地说，声明就是你骗机器有这么一个函数，但是当机器要找这个函数用的时候，你最好是有个定义。</p>
<pre><code class="language-c">// 函数声明
int add(int a, int b);

// 函数定义
int add(int a, int b)
{
	return a + b;
}
</code></pre>
<pre><code class="language-c">// 函数声明并定义
int sub(int a, int b)
{
	return a - b;
}
</code></pre>
<p>C语言从上到下运行，如果是先写了 main 函数，再写 sub 函数，而在 main 函数调用了 sub 函数的情况下，需要有一个声明在 main 函数的前面，告知编译器有这个函数，否则按从上到下的顺序，此时并未出现 sub 函数；</p>
<p>如果是先写了 sub 函数，再写 main 函数，而在 main 函数调用了 sub 函数的情况下，在 main 函数之前的 sub 函数就相当于函数声明并定义，main 函数调用 sub 函数也自然成功。</p>
<p>函数声明中的参数列表可以不具体写变量名，但函数定义中的参数列表必须写变量名。如上述代码的声明可以写成：</p>
<pre><code class="language-c">int add(int, int);
</code></pre>
<h2 id="2-3-调用函数">2.3 调用函数</h2>
<p>当我们写完我们的函数，使用时直接称呼 <strong>函数签名</strong>（函数名字+参数列表）即可。</p>
<pre><code class="language-c">// 声明并定义函数
int add(int a, int b)
{
	return a + b;
}

// 函数调用
add(c, d);
</code></pre>
<h2 id="2-4-函数参数传递">2.4 函数参数传递</h2>
<p>如果函数要使用参数，接受参数值的变量称为函数的 <strong>形式参数</strong> 。如上面 <code>int add(int a, int b)</code> 中的 <code>a</code> 和 <code>b</code>。</p>
<p>如果调用函数时，传递进入的参数称为 <strong>实际参数</strong>。如上面 <code>add(1, 2)</code>中的 <code>c</code> 和 <code>d</code> 。</p>
<p>参数传递有两种方式： <strong>值传递</strong> 和 <strong>地址传递</strong> 。</p>
<ul>
<li>
<p><strong>值传递</strong>：把参数的数值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</p>
</li>
<li>
<p><strong>地址（引用）传递</strong>：把参数的地址复制给函数的形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 <em>对于地址传递，经过指针的学习可能更清晰。</em></p>
</li>
</ul>
<p><br><br><br></p>
<h1>Ⅲ —— 数据、运算符及语句</h1>
<h2 id="3-1-数据的表现形式">3.1 数据的表现形式</h2>
<p>数据以常量、变量、常变量或标识符的形式出现。</p>
<p>变量、常变量的出现包括 <strong>声明</strong> 、 <strong>定义</strong> 、 <strong>初始化</strong> 三个步骤。 <strong>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。</strong></p>
<p>变量定义：用于为变量分配存储空间，还可为变量指定初始值，程序中，变量有且仅有一个定义。</p>
<p>变量声明：用于向程序表明变量的类型和名字。</p>
<p>定义也是声明：当定义变量时我们声明了它的类型和名字。</p>
<p><strong>所有变量使用之前需要有声明或定义。</strong></p>
<ul>
<li>
<p><strong>常量</strong> ，其值不能改变的量。其分为 <strong>整型常量</strong> （即整数，如1，2，1000，666）、 <strong>实型常量</strong> 、 <strong>字符常量</strong> 。</p>
</li>
<li>
<p><strong>实型常量</strong> ，包括十进制小数形式（由数字和小数点组成）和指数形式，指数形式以E或e代表以10为底的指数，如1e6，注意：e或E之前必须有数字，且e或E之后必须为整数；</p>
</li>
<li>
<p><strong>字符常量之字符常量</strong> ，由 <code>‘’</code> （单引号）包括的一个字符，如 <code>‘a’</code> 、 <code>‘A’</code> 等。普通字符，详见ASCII字符集；转义字符，特殊形式的字符，以 <code>\</code> 开头。  <em>引号在此充当界限符，字符常量和字符串常量不包括引号。</em></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">字符值</th>
<th style="text-align:center">输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\'</code></td>
<td style="text-align:center">一个单引号</td>
<td style="text-align:center"><code>'</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\"</code></td>
<td style="text-align:center">一个双引号</td>
<td style="text-align:center"><code>"</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\?</code></td>
<td style="text-align:center">一个问号</td>
<td style="text-align:center"><code>?</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">一个反斜杠</td>
<td style="text-align:center"><code>\</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\a</code></td>
<td style="text-align:center">警告alert</td>
<td style="text-align:center">产生声音或视觉信号</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">退格backspace</td>
<td style="text-align:center">将光标后退一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页form feed</td>
<td style="text-align:center">将光标移到下一页</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行</td>
<td style="text-align:center">将光标移到下一行</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车carriage return</td>
<td style="text-align:center">将光标移到本行开头</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">水平制表符</td>
<td style="text-align:center">将光标移到下一个Tab位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表符</td>
<td style="text-align:center">将光标移到下一个垂直制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\o</code></td>
<td style="text-align:center">与该八进制码对应的ASCII字符</td>
<td style="text-align:center">与该八进制码对应的ASCII字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\xh[h…]</code></td>
<td style="text-align:center">与该十六进制码对应的ASCII字符</td>
<td style="text-align:center">与该十六进制码对应的ASCII字符</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>字符常量之字符串常量</strong> ，由 <code>“ ”</code> （双引号）包括的一个字符串，可以超过一个字符，如 <code>“boy”</code> 。</p>
</li>
<li>
<p><strong>字符常量之符号常量</strong> ，用 <code>#define</code> 指令指定一个符号名称代表一个常量。</p>
</li>
</ul>
<pre><code class="language-c">#define Pi 3.14 //符号常量，之后所有语句中所有Pi用3.14替换
</code></pre>
<p><em>#define宏定义与常变量const的区别是，#define宏定义的值为实型常量，且#define为预处理命令，不分配内存，但常变量具有使程序稳定性提高的优点，使用方便。</em></p>
<ul>
<li><strong>变量</strong> ，在运行期间可以改变的量。变量必须先定义后使用。</li>
</ul>
<pre><code class="language-c">int a;  //定义整型变量 a
a = 3;  //把3赋值给变量 a
</code></pre>
<ul>
<li><strong>常变量</strong> ，在变量存在期间不可改变的量。也必须先定义后使用。用法是在定义变量前加上“const”。</li>
</ul>
<pre><code class="language-c">const int a = 3;  //定义一个整数常变量 a，后续不可修改。 
</code></pre>
<ul>
<li><strong>标识符</strong> ，简单来说就是一个对象的名字，遵守命名规则。</li>
</ul>
<p>变量的命名规则：</p>
<ol>
<li>
<p>变量名的开头必须是字母或下划线，不能是数字。实际编程中最常用的是以字母开头，而以下划线开头的变量名是系统专用的。</p>
</li>
<li>
<p>变量名中的字母是区分大小写的。比如 a 和 A 是不同的变量名，num 和 Num 也是不同的变量名。</p>
</li>
<li>
<p>变量名绝对不可以是C语言关键字。</p>
</li>
<li>
<p>变量名中不能有空格。这个可以这样理解：因为上面我们说过，变量名是字母、数字、下划线的组合，没有空格这一项。</p>
</li>
</ol>
<h2 id="3-2-数据的类型">3.2 数据的类型</h2>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_type.jpg" alt="数据类型"></p>
<h3 id="3-2-1-整型数据">3.2.1 整型数据</h3>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">存储大小</th>
<th style="text-align:center">表示值范围（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned char</code></td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">0~255</td>
</tr>
<tr>
<td style="text-align:center"><code>signed char</code></td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ）~2147483647（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">0~4294967295（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">-32768~32767</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned short</code></td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">0~65535</td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ）~2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">0~4294967295（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>long int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ）~2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">0~4294967295（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>long long int</code></td>
<td style="text-align:center">8字节</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">-2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long int</code></td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">0~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主，下同。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 <code>sizeof(type)</code> 得到对象或类型的存储字节大小。</p>
<p>上述只讨论十进制，实际上C语言还可以表示八进制(<code>int a = 010</code>)和十六进制(<code>int a = 0x10</code>)。</p>
<p>特别指出，unsigned表示无符号数据，即非负数，但只有整型和字符型数据可以加unsigned修饰符。</p>
<p>由于ASCII码的存在， <code>char</code> 类型的数据范围恰好最小完整表达字符，所以 <code>char</code> 类型又称为字符类型。</p>
<h3 id="3-2-2-浮点型数据">3.2.2 浮点型数据</h3>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">存储大小</th>
<th style="text-align:center">表示值范围</th>
<th style="text-align:center">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">1.2E-38~3.4E+38</td>
<td style="text-align:center">6位有效数字</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">2.3E-308~1.7E+308</td>
<td style="text-align:center">15位有效数字</td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">16字节</td>
<td style="text-align:center">3.4E-4932~1.1E+4932</td>
<td style="text-align:center">19位有效数字</td>
</tr>
</tbody>
</table>
<p>需要注意，计算机对于浮点数的存储并不完全精准。</p>
<p>若我们声明定义的变量超过数据类型的数据范围时，编译会警告我们，我们可在数据末尾加专用字符进行类型转换。如在 <code>float</code> 类型数据后加“f”，指定为 <code>float</code> 类型，如在实型变量后加“L”，指定为 <code>long double</code> 型。</p>
<pre><code class="language-c">float a = 3.14159;
//在某些系统中，会发出警告超出float类型，系统自动转化会影响精度
float a = 3.14159f;
//在数字后面加“f”，指定为float型，编译时不发出警告
</code></pre>
<h3 id="3-2-3-void类型">3.2.3 Void类型</h3>
<p><code>void</code> 它通常用于以下三种情况下：</p>
<ol>
<li>函数返回为空：C中有各种函数都不返回值，或者可以说它们返回空。不返回值的函数的返回类型为空。</li>
<li>函数参数为空：C中有各种函数不接受任何参数。不带参数的函数可以接受一个 <code>void</code> 。</li>
<li>指针指向 <code>void</code> ：类型为 <code>void *</code> 的指针代表对象的地址，而不是类型。返回指向 <code>void</code> 的指针，可以转换为任何数据类型。</li>
</ol>
<h3 id="3-2-4-类型转换">3.2.4 类型转换</h3>
<p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p>
<p>C 语言中有两种类型转换：</p>
<ul>
<li><strong>隐式类型转换</strong>：隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。</li>
</ul>
<pre><code class="language-c">int i = 10;
float f = 3.14;
double d = i + f; // 隐式将int类型转换为double类型
</code></pre>
<ul>
<li><strong>显式类型转换</strong>：显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。</li>
</ul>
<pre><code class="language-c">double d = 3.14159;
int i = (int)d; // 显式将double类型转换为int类型
</code></pre>
<h2 id="3-3-运算符">3.3 运算符</h2>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_cop.jpg" alt="运算符"></p>
<h3 id="3-3-1-算术运算符">3.3.1 算术运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">左操作数和右操作数相加</td>
<td style="text-align:center"><code>A + B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">左操作数减去右操作数</td>
<td style="text-align:center"><code>A - B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">左操作数和右操作数相乘</td>
<td style="text-align:center"><code>A * B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">左操作数除以右操作数</td>
<td style="text-align:center"><code>A / B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">左操作数除以右操作数后的余数</td>
<td style="text-align:center"><code>A % B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>++</code></td>
<td style="text-align:center">操作数整数值自增1</td>
<td style="text-align:center"><code>A ++</code></td>
</tr>
<tr>
<td style="text-align:center"><code>--</code></td>
<td style="text-align:center">操作数整数值自减1</td>
<td style="text-align:center"><code>A --</code></td>
</tr>
</tbody>
</table>
<p><code>%</code> 运算符的操作数只可以是整数。</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int a, b, ans1;
	int c, d, ans2;
	ans1 = a + b; //两个整型变量相加的结果仍为整型。
	ans1 = a - b; //两个整型变量相减的结果仍为整型。
	ans1 = a * b; //两个整型变量相乘的结果仍为整型。
	ans1 = a / b; //两个整型变量相除的结果仍为整型，多数为除不尽向零取整。
	//如 5/3=1，-5/3=-1；
	ans2 = c % d; // 取余运算要求运算对象均为整数，即整型。
	return 0;
}
</code></pre>
<p>应当注意， <code>++i</code> 和 <code>i++</code> ， <code>--i</code> 和 <code>i--</code> 是两回事。</p>
<pre><code class="language-c">// test2.c
//以下例子可能理解更加深刻
#include&lt;stdio.h&gt;
int main()
{
	int i,j;
  
	i = 1;
	i++;    //i使用后，使i的值加一,此时 i=1；
	j = i;    // j=i=2;
    
	i = 1;
	++i;    //i使用前，使i的值加一,此时 i=2；
	j = i;    // j=i=2;
    
	i = 1;
	i--;    //j使用后，使i的值减一，此时 i=1；
	j = i;    //j=i=0;
    
	i = 1;
	--i;    //j使用前，使i的值减一，此时 i=0；
	j = i;    //j=i=0;
	return 0; 
}
</code></pre>
<h3 id="3-3-2-关系运算符">3.3.2 关系运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">检查两个操作数的值是否相等，如果相等则条件为真</td>
<td style="text-align:center"><code>A == B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">检查两个操作数的值是否相等，如果不相等则条件为真</td>
<td style="text-align:center"><code>A != B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">检查左操作数的值是否大于右操作数的值，如果是则条件为真</td>
<td style="text-align:center"><code>A &gt; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td style="text-align:center"><code>A &lt; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td>
<td style="text-align:center"><code>A &gt;= B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td>
<td style="text-align:center"><code>A &lt;= B</code></td>
</tr>
</tbody>
</table>
<h3 id="3-3-3-逻辑运算符">3.3.3 逻辑运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">逻辑与运算符，如果两个操作数都非零，则条件为真。</td>
<td style="text-align:center"><code>A &amp;&amp; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|\|</code></td>
<td style="text-align:center">逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真</td>
<td style="text-align:center"><code>A \|\| B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td style="text-align:center"><code>!A</code></td>
</tr>
</tbody>
</table>
<h3 id="3-3-4-位运算符">3.3.4 位运算符</h3>
<p>位运算符是对数据转化为二进制，再逐位进行运算。如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><msub><mn>0</mn><mn>10</mn></msub><mo>=</mo><mn>0011110</mn><msub><mn>0</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">60_{10} = 00111100_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">6</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，再对每一位进行逻辑运算。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">按位与运算符，对两个操作数的每一位执行逻辑与操作</td>
<td style="text-align:center"><code>A &amp; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center">按位或运算符，对两个操作数的每一位执行逻辑或操作</td>
<td style="text-align:center"><code>A \| B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">按位异或运算符，对两个操作数的每一位执行逻辑异或操作</td>
<td style="text-align:center"><code>A ^ B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">按位取反运算符，对两个操作数的每一位执行逻辑取反操作</td>
<td style="text-align:center"><code>~A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">将操作数的所有位向左移动指定的位数。左移n位相当于乘以2的n次方</td>
<td style="text-align:center"><code>A &lt;&lt; n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">将操作数的所有位向右移动指定的位数。右移n位相当于除以2的n次方</td>
<td style="text-align:center"><code>A &gt;&gt; n</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c">// bit.c
#include &lt;stdio.h&gt;
 
int main()
{
 
	unsigned int a = 60;    /* 60 = 0011 1100 */  
	unsigned int b = 13;    /* 13 = 0000 1101 */
	int c = 0;           
 
	c = a &amp; b;       /* 12 = 0000 1100 */ 
	printf("c 的值是 %d\n", c ); // 一个输出的函数
 
	c = a | b;       /* 61 = 0011 1101 */
	printf("c 的值是 %d\n", c );
 
	c = a ^ b;       /* 49 = 0011 0001 */
	printf("c 的值是 %d\n", c );
 
	c = ~a;          /*-61 = 1100 0011 */
	printf("c 的值是 %d\n", c );
 
	c = a &lt;&lt; 2;     /* 240 = 1111 0000 */
	printf("c 的值是 %d\n", c );
 
	c = a &gt;&gt; 2;     /* 15 = 0000 1111 */
	printf("c 的值是 %d\n", c );
	return 0;
}
</code></pre>
<h3 id="3-3-5-赋值运算符">3.3.5 赋值运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">把右操作数的值赋给左操作数</td>
<td style="text-align:center"><code>C = A + B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center">把右边操作数加上左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C += A</code> 相当于 <code>C = C + A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center">把右边操作数减去左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C -= A</code> 相当于 <code>C = C - A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center">把右边操作数乘以左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C *= A</code> 相当于 <code>C = C * A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center">把右边操作数除以左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C /= A</code> 相当于 <code>C = C / A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center">把右边操作数取余左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C %= A</code> 相当于 <code>C = C % A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;=</code></td>
<td style="text-align:center">左移且赋值运算符</td>
<td style="text-align:center"><code>C &lt;&lt;= A</code> 相当于 <code>C = C &lt;&lt; A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;=</code></td>
<td style="text-align:center">右移且赋值运算符</td>
<td style="text-align:center"><code>C &gt;&gt;= A</code> 相当于 <code>C = C &gt;&gt; A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;=</code></td>
<td style="text-align:center">按位与且赋值运算符</td>
<td style="text-align:center"><code>C &amp;= A</code> 相当于 <code>C = C &amp; A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>^=</code></td>
<td style="text-align:center">按位异或且赋值运算符</td>
<td style="text-align:center"><code>C ^= A</code> 相当于 <code>C = C ^ A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|=</code></td>
<td style="text-align:center">按位或且赋值运算符</td>
<td style="text-align:center"><code>C \|= A</code> 相当于 <code>C = C \| A</code></td>
</tr>
</tbody>
</table>
<p>赋值运算符参与的表达式中，赋值表达式返回赋值符号右边的值。</p>
<h3 id="3-3-6-其他运算符">3.3.6 其他运算符</h3>
<ul>
<li><strong>条件运算符</strong> <code>（? : ）</code> ：其形式为 <code>(表达式1)? 表达式2 : 表达式3</code> ，先求解表达式1，若其值为真（非0）则将表达式2的值作为整个表达式的取值，否则（表达式1的值为0）将表达式3的值作为整个表达式的取值。</li>
</ul>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int i = 9, o = 6, q;
	i &gt; o ? i : o;
	// i大于o吗，大于（真）则返回i的值，小于（假）则返回o的值。
	return 0;
}
</code></pre>
<ul>
<li><strong>逗号运算符</strong> <code>,</code> ：其形式为 <code>表达式1,表达式2</code> ，逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果，而左操作数只是当作副作用被计算，其值和类型不会被返回。</li>
</ul>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int i = 9, o = 6, q;
	q = (i + o, i - o);
	// q = 3
	return 0;
}
</code></pre>
<ul>
<li>
<p><strong>指针运算符</strong> <code>&amp;</code> 和 <code>*</code> 。 <code>*</code> ：取值符，指向一个变量； <code>&amp;</code> ：取地址符，取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象。</p>
</li>
<li>
<p><strong>成员运算符</strong> <code>.</code> 和 <code>-&gt;</code> 。用于返回复杂数据类型的子成员。</p>
</li>
<li>
<p><strong>下标运算符</strong> <code>[]</code> 。用于访问下标，在数组中用到。</p>
</li>
<li>
<p><strong>求字节运算符</strong> <code>sizeof()</code> 。返回变量的大小，将需要求字节内存的变量或其他数据结构放于括号中。</p>
</li>
<li>
<p><strong>强制类型转换运算符</strong> <code>(类型名)(表达式)</code> 。 如 <code>(float)(a + b)</code> 。</p>
</li>
</ul>
<h3 id="3-3-7-运算符优先级">3.3.7 运算符优先级</h3>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pre.jpg" alt="运算符优先级"></p>
<h2 id="3-4-语句">3.4 语句</h2>
<ol>
<li><strong>控制语句</strong></li>
</ol>
<pre><code class="language-c">//条件语句
if(条件)  //如果小括号里面的条件为真，则运行大括号的语句。
{
  …… 
}
</code></pre>
<pre><code class="language-c">//循环语句
for(语句1;语句2;语句3)  //语句2为条件，为真则运行大括号的语句，直至条件为假
{
  …… 
}
//注意，小括号内必须得有两个分号，即使没有语句
</code></pre>
<pre><code class="language-c">//循环语句
while(条件)  //如果小括号的条件为真，则运行大括号的语句，直至条件为假
{
  …… 
}

do
{
  …… 
}while(条件);  //如果小括号的条件为真，则运行大括号的语句，直至条件为假

// 注意，while(…){…}和do{…}while;的区别是，do-while至少循环一次，无视条件真或假。
</code></pre>
<pre><code class="language-c">continue;
//用于循环语句
//作用是结束该次循环，转至下一次循环，不改变总循环次数

break;
//用于循环语句或者switch语句
//作用是结束整个循环，改变总循环次数
</code></pre>
<pre><code class="language-c">//条件语句
switch (对象)
{
  case 值1:
    语句1 
    break;
  case 值2:
    语句2 
    break;
  default:  //default表示除以上case之外的情况
    语句3
    break;
}
//该语句每个case中的break不可省略。
//若省略break则系统会一直往下读语句，直至结束或者break，可自行上机作死
</code></pre>
<pre><code class="language-c">return ……;
//从函数中返回语句，一般情况下返回语句也是函数结束的地方
</code></pre>
<pre><code class="language-c">//转向语句
goto a;
  number = 0;
a:
  number = 1;
//结果number为1;  
//声明一处标记为a，使用goto语句使程序转向a处；
</code></pre>
<ol start="2">
<li>
<p><strong>函数调用语句</strong>：右一个函数调用加分号构成。</p>
</li>
<li>
<p><strong>复合语句</strong>：用 <code>{}</code> 括起来的语句，也称语句块。</p>
</li>
<li>
<p><strong>空语句</strong>：只有一个分号。</p>
</li>
<li>
<p><strong>表达式语句</strong>：一个表达式加上一个分号构成。用C语言运算符将运算对象连接起来的式子称为表达式。</p>
</li>
</ol>
<h2 id="3-5-变量的作用范围">3.5 变量的作用范围</h2>
<p>任何一种编程中， <strong>作用域</strong> 是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。</p>
<p>C语言中有三个地方可以声明变量：</p>
<ol>
<li>
<p>在函数或块（由花括号包括起来的称为代码块）内部的局部变量</p>
</li>
<li>
<p>在所有函数外部的全局变量</p>
</li>
<li>
<p>在形式参数的函数参数定义中</p>
</li>
</ol>
<p>变量按作用范围可分为 <strong>局部变量</strong> 、 <strong>全局变量</strong> 、 <strong>形式参数</strong> 。</p>
<ul>
<li><strong>局部变量</strong></li>
</ul>
<p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;
int main()
{
	// 局部变量声明
	int a, b;
	int c;
 
	// 实际初始化 
	a = 10;
	b = 20;
	c = a + b;
 
	printf ("value of a = %d, b = %d and c = %d\n", a, b, c);
	return 0;
}
</code></pre>
<ul>
<li><strong>全局变量</strong></li>
</ul>
<p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。也就是说，全局变量在声明后整个程序中都是可用的。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
// 全局变量声明
int g;
int main ()
{
	// 局部变量声明
	int a, b;
 
	// 实际初始化
	a = 10;
	b = 20;
	g = a + b;
 
	printf ("value of a = %d, b = %d and g = %d\n", a, b, g);
	return 0;
}
</code></pre>
<ul>
<li><strong>形式参数</strong></li>
</ul>
<p>函数的参数就是形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用，同样如果局部变量与全局变量同名时优先使用当前区域的局部变量。</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;
// 全局变量声明
int a = 20;
int main()
{
	// 在主函数中的局部变量声明
	int a = 10;
	int b = 20;
	int c = 0;
	int sum(int, int);
 
	printf ("主函数中的 a = %d\n", a);
	c = sum(a, b);
	printf ("主函数中的 c = %d\n", c);
	return 0;
}
 
// 添加两个整数的函数
int sum(int a, int b)
{
	printf ("sum函数中的 a = %d\n",  a);
	printf ("sum函数中的 b = %d\n",  b);
	return a + b;
}
</code></pre>
<pre><code>输出结果：
主函数中的 a = 10
sum函数中的 a = 10
sum函数中的 b = 20
主函数中的 c = 30
</code></pre>
<ul>
<li><strong>全局变量与局部变量在内存中的区别</strong></li>
</ul>
<ol>
<li>
<p>全局变量保存在内存的全局存储区中，占用静态的存储单元；</p>
</li>
<li>
<p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
</li>
</ol>
<ul>
<li><strong>局部变量和全局变量的初始化</strong></li>
</ul>
<p>当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">初始化默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>\0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pointer</code>（指针）</td>
<td style="text-align:center"><code>NULL</code></td>
</tr>
</tbody>
</table>
<h1>Ⅳ —— 格式化输入输出</h1>
<p>格式化的输入输出函数位于 <code>stdio.h</code> 头文件中。</p>
<h2 id="4-1-格式化的输出">4.1 格式化的输出</h2>
<ul>
<li><code>printf()</code>函数进行格式化的输出，其函数定义如下：</li>
</ul>
<pre><code class="language-c">int printf(const char *fmt, ...);
// fmt：为常量字符串,存储在内存的常量字段，fmt为该字符串首地址；
// ...表示存在可变形参
// 输出正确返回输出的字符总数，输出错误返回负值
</code></pre>
<p>也可以参考这样的格式： <code>printf(格式控制,输出表列)</code></p>
<pre><code class="language-c">// printf.c
#include&lt;stdio.h&gt;
int main()
{
	int a = 1, b = 2, c = 3;
	printf("%d %d %d\n", a, b, c);
	return 0;
}
</code></pre>
<pre><code>输出结果：
1 2 3
</code></pre>
<p><strong>格式控制</strong>，是使用双引号括起来的一个字符串，称为格式控制字符串，包括格式声明和普通字符。</p>
<ol>
<li>
<p><strong>格式声明</strong>，由 <code>%</code>（百分号）和格式字符组成，其作用是将输出的数据转换为指定的格式后输出。格式声明总是由 <code>%</code> 字符开始。</p>
</li>
<li>
<p><strong>普通字符</strong>，即原样输出的字符，包括逗号、空格等。</p>
</li>
</ol>
<p>应当注意的是：</p>
<ol>
<li>
<p>当我们想在显示器输出一个 <code>%</code> 时，我们需要在格式控制字符串中连续使用两个 <code>%</code> 表示一个 <code>%</code> 。</p>
</li>
<li>
<p>当我们想在显示器输出一个 <code>\</code> 时，我们需要在格式控制字符串中连续使用两个 <code>\</code> 表示一个 <code>\</code> 。</p>
</li>
</ol>
<p>对于格式字符，有如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>d</code> 或 <code>i</code></td>
<td style="text-align:center">以带符号的十进制输出整数（正数不带符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>ld</code> 或 <code>lld</code></td>
<td style="text-align:center">数据类型为 <code>long int</code> 或 <code>long long int</code> 的输出</td>
</tr>
<tr>
<td style="text-align:center"><code>o</code></td>
<td style="text-align:center">以无符号的八进制输出整数（不输出前导 <code>0</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>x</code> 或 <code>X</code></td>
<td style="text-align:center">以无符号的十六进制输出整数（不输出前导符 <code>0x</code> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center">以无符号的十进制输出整数</td>
</tr>
<tr>
<td style="text-align:center"><code>c</code></td>
<td style="text-align:center">以字符形式输出一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>s</code></td>
<td style="text-align:center">输出一整个字符串，直至遇到 <code>\0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>f</code></td>
<td style="text-align:center">以小数形式输出单精度数，默认输出6位小数</td>
</tr>
<tr>
<td style="text-align:center"><code>lf</code></td>
<td style="text-align:center">以小数形式输出双精度数，默认输出6位小数</td>
</tr>
<tr>
<td style="text-align:center"><code>e</code> 或 <code>E</code></td>
<td style="text-align:center">以指数形式输出实数</td>
</tr>
<tr>
<td style="text-align:center"><code>g</code> 或 <code>G</code></td>
<td style="text-align:center">选用 <code>%f</code> 或 <code>%e</code> 中宽度较短的格式，不输出无意义 <code>0</code></td>
</tr>
</tbody>
</table>
<ul>
<li>PS：正常来说，一个数字的前面加 <code>0</code> ，表示该数字为八进制。上述中不输出前导 <code>0</code> ，但当格式为 <code>%#o</code> 时，输出前导 <code>0</code> ；一个数字的前面加 <code>0x</code> ，表示该数字为十六进制。上述中不输出前导符，但当格式为 <code>%#x</code> 时，输出前导 <code>0x</code> 。</li>
</ul>
<p>输入下面的代码可以直观感受输出的格式问题：会因为格式字符与输出的数据类型不匹配而导致输出乱码。</p>
<pre><code class="language-c">// test.c

#include&lt;stdio.h&gt;
int main()
{
	int a = 1;
	float b = 3.1415926535; 
	double c = 3.1415926535;
	long int d = 1e9;
	long long int e=1e18;
	printf("%d\t\t%ld\t\t%lld\t\t%f\t%lf\n", a, a, a, a, a);
	printf("%d\t%ld\t%lld\t%.8f\t%.8lf\n", b, b, b, b, b);
	printf("%d\t%ld\t%lld\t%.8f\t%.8lf\n", c, c, c, c, c);
	printf("%d\t%ld\t%lld\t%f\t%lf\n", d, d, d, d, d);
	printf("%d\t%ld\t%lld\t%f\t%lf\n", e, e, e, e, e);
	return 0;
}
</code></pre>
<pre><code>运行结果：
1               1               4294967297              0.000000        0.000000
1610612736      1074340347      4614256656748904448     3.14159274      3.14159274
1413551940      1074340347      4614256656551843652     3.14159265      3.14159265
1000000000      1000000000      4294967297000000000     3.141592        3.141593
-1486618624     232830643       1000000000000000000     0.000000        0.000000
</code></pre>
<p>应该清晰格式字符，不乱用不混用。 <strong>输出表列的数量需与%d（或其他格式声明）的数量一致。</strong></p>
<p><code>%f</code> 默认保留6位小数，而 <code>%m.nf</code> 可以自定义小数位，m指输出宽度，n指保留小数位。如果想用 <code>0</code> 控制宽度，在宽度控制数字前加 <code>0</code> 可以这么使用 <code>%06d</code> 、<code>%07.2f</code> ，但只能补前导 <code>0</code> 。而单独的 <code>%.nf</code> 就可以控制输出的小数位。</p>
<p>当m前面添加 <code>-</code> ，则输出数据向左对齐，再补空格或 <code>0</code> 。当m前面无 <code>-</code> ，则输出数据向右对齐，再补空格或 <code>0</code> ，此时称前导空格或前导 <code>0</code> 。</p>
<p>如 <code>%7.2f</code> ，表示输出数据占7列（小数点也占一列），保留2位小数。运行以下代码可深刻理解：</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	float a = 3.141592;
	printf("|%07.2f|\n", a);
	printf("|%-07.2f|\n", a);
	return 0;
}
</code></pre>
<pre><code>运行结果：
|0003.14|
|3.14   |
</code></pre>
<p>由 <code>%f</code> 拓展， <code>%d</code> 等格式声明都可在 <code>%</code> 和格式字符之间加一个数字（正或负），表示控制整个输出所占宽度，如 <code>%7d</code> 、 <code>%4c</code> 等。</p>
<p>如果事先并不知道保留多少小数位，而是后续输入的情况，可以使用占位符 <code>%.*f</code> 解决。</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	float a = 3.1415926;
	int k;
	scanf("%d", &amp;k); // 根据输入的k决定保留多少位小数
	printf("%.*f", k, a);
	return 0;
}
</code></pre>
<p>另外， <code>printf()</code> 函数在运行时的形参是 <strong>从右到左</strong> 处理，具体效果如下：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt; 
int main() 
{ 
    int a = 5, b = 2;
    printf("%d %d\n", b = a + 1, a += 1);
    return 0;
}
</code></pre>
<pre><code>输出结果:
7 6
</code></pre>
<p>由于是 <strong>从右到左</strong> 的顺序处理，所以先是 <code>a += 1</code> ，a变成6，再接着 <code>b = a + 1</code>，b变成7。</p>
<ul>
<li>putchar()：输出一个字符</li>
</ul>
<p>函数原型： <code>int putchar(int _Character)</code> ，函数定义在 <code>stdio.h</code> 中。</p>
<ul>
<li>puts()：输出一个字符串，并换行</li>
</ul>
<p>函数原型： <code>int puts(const char *s);</code> ，函数定义在 <code>stdio.h</code> 中。</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	char a = 'a';
	putchar('!');
	putchar(a);
	puts("Hello World!");
	return 0;
}
</code></pre>
<pre><code>运行结果：
!aHello World!

</code></pre>
<h2 id="4-2-格式化的输入">4.2 格式化的输入</h2>
<ul>
<li>用 <code>scanf()</code> 函数进行格式化的输出，其函数定义如下：</li>
</ul>
<pre><code class="language-c">int scanf(const char * restrict format,...);
// 第一参数为输入格式字符串，省略号表示存在可变形参
// 输入成功返回成功读入的数据项数，输入数据时遇到了结束则返回EOF（End Of File）。
</code></pre>
<p>也可以参考这样的格式： <code>scanf(格式控制，地址表列)；</code>。格式控制字符串同输入的规则。在使用 <code>scanf()</code> 的时候，我们应当注意， <code>scanf()</code> 函数的地址表列是需要输入的变量地址，而不是变量名，因此，我们要在变量名前加 <code>&amp;</code> 取地址符。如：</p>
<pre><code class="language-c">scanf("%d %d %d", a, b, c);    //此写法错误
scanf("%d %d %d", &amp;a, &amp;b, &amp;c); //此写法正确
</code></pre>
<p>当我们不加取地址符的时候，程序会因为储存内存溢出（输入的内容没有正确的地方存放）而终止程序。因此，当我们的程序莫名中断崩掉时，我们可以优先考虑是否在输入时加取地址符。</p>
<p>从另一个角度理解，对于函数而言，我们希望输入一个值，也就是修改变量里面的值，应当传入其地址，而不是直接传入值。</p>
<p>还需要注意的是， <code>scanf()</code> 的格式控制字符串应与我们输入的格式严格一致，即格式控制字符串中有逗号或空格等的时候，我们输入也需加上逗号或空格等。如：</p>
<pre><code class="language-c">scanf("%d %d %d", &amp;a, &amp;b, &amp;c);//此时应当输入 1 2 3
scanf("%d,%d,%d", &amp;a, &amp;b, &amp;c);//此时应当输入 1,2,3
</code></pre>
<p>如果没有留意到这个问题，那么当我们输入数据的时候，可能会出现数据吞没的情况，因为输入的跟字符串规定的不匹配，不读入。</p>
<p>该函数还有自动处理的地方，如</p>
<ol>
<li>
<p>当我们的输入格式控制为 <code>%d%d%d</code> 时，系统会自动把空格或者换行（回车）作为分隔两个数据的标志。</p>
</li>
<li>
<p>当我们的输入格式控制为 <code>%f%f%f</code> 时，系统会自动把小数点、空格或者换行（回车）作为分隔两个数据的标志。</p>
</li>
</ol>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	float a, b;
	scanf("%f%f", &amp;a, &amp;b);
	printf("%f %f\n", a, b);
	return 0;
}
</code></pre>
<pre><code>运行窗口：
3.142.77                              //输入
3.142000 0.770000                     //输出
</code></pre>
<p>虽然系统会自动把空格作为分隔两个数据的标志而不读入空格，但是总有办法可以使得 <code>scanf()</code> 函数输入带空格，如下代码：</p>
<pre><code class="language-c">// getstring.c
#include &lt;stdio.h&gt;
int main() 
{
	char a[20]; // 存放字符串
	scanf("%[^\n]", a); // 可输入带空格的字符串
	printf("%s\n", a);
	return 0;
}
</code></pre>
<p>实际上， <code>scanf()</code> 函数的注意点与其的键盘缓冲区和输入流有关。该函数会从输入流中选择数据放入键盘缓冲区中。在未输入满前忽略掉空白字符（空格、制表符和新行符），在输入满时把空白字符当作中断的标志。所以要注意反思输入流和键盘缓冲区里面的内容是什么，是否有键盘缓冲区遗留问题导致提前终止输入，是否有数据仍在输入流中没有进入键盘缓冲区而丢弃等。</p>
<ul>
<li><code>getchar()</code>：输入一个字符</li>
</ul>
<p>函数原型： <code>int getchar(void);</code> ，返回值则是输入的字符的ASCII码，若读取失败返回EOF或-1，函数定义在 <code>stdio.h</code> 中。</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	char b;
	b = getchar();
	putchar(b);
	return 0;
}
</code></pre>
<pre><code>运行窗口：
h	// 输入
h	// 输出
</code></pre>
<ul>
<li><code>gets()</code>：输入一个字符串，一般使用 <code>scanf()</code> 输入字符串的时候不能输入含空格的字符串，而使用 <code>gets()</code> 则可以输入含空格的字符串。</li>
</ul>
<p>由于 <code>gets()</code> 函数的不安全性，在C99标准中，已经不再建议使用该函数，而在C11中更是直接抛弃了这个函数。</p>
<p><br><br><br></p>
<h1>Ⅴ —— 条件结构</h1>
<p>实际上，在很多情况下，需要根据某个条件是否满足来决定是否执行指定操作任务，或者从给定的两种或多种操作选择其一。这就是选择结构需要解决的问题。再举个详细的例子，当我们处于岔路时，做出方向的选择；比如数学上的分段函数，条件不同对应函数关系不同。</p>
<p>通过条件结构，可以完成一些简单的语法题，如交换两个数，输出两数最大值和最小值，由键盘输入三个数输出最大值，判断闰年……</p>
<p>条件的真假如果对应到数字上，0为假，非0为真，即正负数都为真。</p>
<h2 id="5-1-if构成的条件结构">5.1 if构成的条件结构</h2>
<p><code>if</code> 语句的结构如下：</p>
<pre><code class="language-c">if( condition is true ) 
{
  sentence1;
  sentence2;
  …………
}
//先简单地翻译一遍以上代码：如果（ 某个条件成立 ），则运行花括号中的内容。
</code></pre>
<p>需要注意， <code>if</code> 语句在没有花括号的情况下，只连带其后的一句语句。即 <code>if(condition)</code> 后只能跟一个语句，其可以是单个简单语句，也可以是由花括号包含起来的复合语句。</p>
<p>再加之 <code>else</code> （另外，否则），可以组成以下三种形式：</p>
<pre><code class="language-c">// 情况一，无else子句部分，只有单个if语句
if( condition )
{
	sentence;
}   
    
// 情况二，有else子句部分
if( condition )
{
	sentence1;
} 
else
{
	sentence2;
}
      
// 情况三，在else部分又嵌套多层if语句
if( condition )
{
	sentence1;
} 
else if( condition1 )
{
	sentence2;
}   
else
{
	sentence3;
}

// 情况三还可以写成下面的形式
if( condition )
{
	sentence1;
} 
else 
{
	if( condition1 )
	{
		sentence2;
	}   
	else
	{
		sentence3;
	}
}
</code></pre>
<p><code>if</code> 语句无论写几行，都是一个整体，属于同一个语句，只是将其分成 <code>if</code> 部分和 <code>else</code> 部分。在 <code>if</code> 语句中要对给定的条件进行检查，判定所给定的条件是否成立。判断的结果是一个逻辑值“是”或“否”。</p>
<p><code>if</code> 语句小括号中的 <code>condition</code> ，应该是由关系运算符与逻辑运算符构成的表达式，运算符号详见运算符。如表达x大于1时写成 <code>x&gt;1</code> ，表达x在10到20之间时写成 <code>x &gt;=10 &amp;&amp; x &lt;= 20</code> ，表达x不等于4时写成 <code>x != 4</code> ，表达x等于4时写成 <code>x == 4</code> 。可以试着巧妙应用 <code>? :</code> 三目运算符转化繁琐的if结构。</p>
<p>下面结合一个例子剖析 <code>if-else</code> 语句，在数学中有阶跃函数（分段函数），当x＞0时，y＝1；当x＝0时，y＝0；当x＜0时，y＝-1。</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt; //声明头文件

int main() 
{
	int x, y; //定义x和y变量
	scanf("%d", &amp;x); //输入x
	if(x &gt; 0) //第一个判断，做x＞0的判断
	{
		y = 1;
	}
	
	else if( x == 0 ) //排除第一个判断后的另外一个判断，做x＝0的判断
	{
		y = 0;
	}
  
	else if( x &lt; 0 ) //排除以上两种情况后的另一种情况，做x＜0的判断
	{
		y = -1;
	}
	
	//其实这种情况下，排除以上两种情况，剩下唯一的可能，可以写成else部分
	//如：
	//  else
	//  {
	//     y = -1;
	//  }
  
	printf("%d", y); //输出y
	return 0;
}
</code></pre>
<p><code>if</code> 语句可以多个嵌套， <code>if</code> 中又带有 <code>if-else</code> 等情况，请注意辨识。应当注意 <code>if</code> 与 <code>else</code> 的配对关系。 <code>else</code> 总是与它上面最近的未配对的 <code>if</code> 配对， <code>else</code> 一般不能单独出现，上面必须先有 <code>if</code> 部分。上面的例子用 <code>if</code> 语句嵌套可如下表示：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt; //声明头文件

int main() 
{
	int x, y; //定义x和y变量
	scanf("%d", &amp;x); //输入x
	if(x &gt;= 0)  //将大于等于零归为一类
	{
		if(x &gt; 0)//再判断大于0的情况
			y = 1;
		else //在x大于等于零的情况下，再排除x大于零，即x等于零
			y = ;  
	}
	else //排除x大于等于零的情况下，即x小于零 
		y = -1;
  
	printf("%d", y); //输出y
	return 0;
}
</code></pre>
<h2 id="5-2-switch构成的条件结构">5.2 switch构成的条件结构</h2>
<p><code>switch</code> 语句的结构如下：</p>
<pre><code class="language-c">switch (object) //对于某个变量或表达式进行switch
{
	case constant1: //对于常量1的情况，进行语句
		//操作部分语句
		break; //注意break必须存在

	case constant2: //对于常量2的情况，进行语句
		//操作部分语句
		break; //注意break必须存在

	default: //对于默认情况，即排除上述情况，进行语句
		//操作部分语句
		break; //注意break不必存在，建议存在
}
</code></pre>
<p>在此强调， <code>switch</code> 语句中 <code>case</code> 情况部分的 <code>break</code> 语句必须存在，此为语法规定。当去掉 <code>break</code> 语句时，系统将逐句往下运行。更具体地说，如果 <code>switch</code> 时 <code>case</code> 情况1的话，你想运行情况1部分的语句，但因为缺少 <code>break</code> 语句，系统还会运行下面 <code>case</code> 情况的语句，造成逻辑表达上的错误。可以对下面的代码中每个 <code>break</code> 试着取消注释，让其运行，观察系统运行语句输出区别。</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt; //声明头文件

int main() 
{
	int object = 1, sum = 0;
	switch(object) 
	{
		case 0 : 
			sum = 0;
			//break;
		case 1 : 
			sum = 1;
			//brea;
		case 2 :
			sum = 2;
			//break;
		default :
			sum = -1;
			//break;
	}
	printf("%d", sum);
	return 0;
}
</code></pre>
<p><code>switch</code> 语句的对象应该是 <strong>整型和字符类型的变量或变量表达式</strong> ，如 <code>int</code> 变量 <code>number</code> 、 <code>char</code> 变量 <code>ch</code>  、 <code>number%10</code> 、 <code>ch+32</code> ……相对于的 <code>case</code> 情况应该是整型常量或者是字符常量。如整数1、2、3……和字符’A’、‘B’、‘c’……</p>
<p>对于 <code>switch</code> 语句，还有以下规则说明。操作部分语句可以不止一个语句，其一直运行到 <code>break</code> 语句为止。可以没有 <code>default</code> 的情况，但此时如果没有与 <code>switch</code> 表达式相匹配的 <code>case</code> 常量时，不执行任何语句。 <code>case</code> 情况出现的次序不影响执行结果，每个 <code>case</code> 情况常量必须互不相同，不能存在一个值有多种执行情况。</p>
<p>这里有一个例子，对于输入分数，输出分数评级，可以辅助理解：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt; //声明头文件

int main() 
{
	int score ; //输入分数score，此处人为规定输入值在0到100之间 
	char grade ; //输出分数评级，由'A'到'E' 
	scanf("%d" , &amp;score ) ; //输入分数 
	switch( score / 10 ) 
	//对分数除以十，即判断十位的情况，如80分到90，除以十为8 
	{
		case 10: 
			grade = 'A' ;
			break ;
		case 9: 
			grade = 'A' ;
			break ;    
		case 8: 
			grade = 'B' ;
			break ;
		case 7: 
			grade = 'C' ;
			break ;
		case 6: 
			grade = 'D' ;
			break ;
		default:
			grade = 'E' ;
			break ;      
	}
	printf("Your grade is %c .\n" , grade ) ;
	return 0;
}
</code></pre>
<p><code>switch</code> 语句也是可以嵌套的，但结构上比较繁琐。</p>
<p><br><br><br></p>
<h1>Ⅵ —— 循环结构</h1>
<p>有时候用条件结构还是不能简便解决问题，还需要使用循环结构，如处理求多个整数的和、处理多个判断。</p>
<p>再如在输入的时候，我希望输入50个数字，我们可以复制粘贴50句 <code>scanf()</code> 来实现这个要求。学了循环之后，至少，不再需要50句语句。</p>
<p>需要注意的是， <strong>循环语句一定要设置终止条件，否则将进入死循环，无法得出结果！！！</strong></p>
<p>通过循环结构，可以完成一些简单的语法题，如判断一个数是否为素数，计算斐波那契数列，计算阶乘……</p>
<h2 id="6-1-while构成的循环结构">6.1 while构成的循环结构</h2>
<p><code>while</code> 语句的一般形式如下：</p>
<pre><code class="language-c">while( condition is true ) 
{
	sentences;
	……………………
	//花括号内的内容总称为循环体
}
</code></pre>
<p>此处 <code>condition</code> 为表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。循环体可以是一条语句，也可以是一个语句块（用花括号包起来）。 <code>while</code> 循环的特点是先判断条件表达式，后执行循环体语句。</p>
<p><code>while</code> 语句的运行顺序是：从上至下，先判断条件表达式是否为真，为真则执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p>这里给出一个例子，求1到100的和，希望通过例子更好理解 <code>while</code> 循环：</p>
<p>分析此问题，将100个数相加，要重复进行100次加法，显然是需要循环结构介入。有兴趣的可以尝试画画流程图（此处不做介绍）。</p>
<pre><code class="language-c">// add-100-number.c
#include &lt;stdio.h&gt; //声明头文件 
int main()
{
	int i = 1; //初始化循环变量，从1开始 
	int sum = 0; //用来存求和的值 
	while(i &lt;= 100) 
	{
		sum += i; //相当于sum=sum+i，求和 
		i ++; //i自增，实现从1到2到3到……100 
	}
	printf("sum = %d\n", sum); //输出求和的值 
	return 0;
}
</code></pre>
<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<h2 id="6-2-do-while构成的循环结构">6.2 do-while构成的循环结构</h2>
<p><code>do-while</code> 语句。其一般形式如下：</p>
<pre><code class="language-c">do 
{
	sentences;
	……………………
	//花括号内的内容总称为循环体
} while(condition is true); //注意这有一个分号
</code></pre>
<p>此处 <code>condition</code> 为表达式，道理同上。 <code>do-while</code> 循环的特点是先无条件执行循环体，然后判断循环条件是否成立。即 <code>do-while</code> 循环至少进行一次循环，注意与 <code>while</code> 语句区分。</p>
<p><code>do-while</code> 语句的运行顺序是：从上至下，先无条件执行一次循环体，再判断条件表达式是否为真，为真则回到循环体开始重新执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p>此处同样解决上面的问题，从1加到100求和。</p>
<pre><code class="language-c">// add-100-number.c
#include &lt;stdio.h&gt; //声明头文件 
int main()
{
	int i = 1; //初始化循环变量，从1开始 
	int sum = 0; //用来存求和的值 
	do
	{
		sum += i; //相当于sum=sum+i，求和 
		i ++; //i自增，实现从1到2到3到……100 
	} while(i &lt;= 100);
	printf("sum = %d\n", sum); //输出求和的值 
	return 0;
}
</code></pre>
<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<h2 id="6-3-for构成的循环结构">6.3 for构成的循环结构</h2>
<p><code>for</code> 语句的一般形式如下：</p>
<pre><code class="language-c">for( sentence1; condition; sentence2 )
{
	sentences3
	…………………………
	//花括号内的内容总称为循环体
}
</code></pre>
<p>此处 <code>sentence1</code> 和 <code>sentence2</code> 为普通表达式， <code>sentence1</code> 只执行一次，而 <code>sentence2</code> 在每次执行完循环体后都会运行一次。 <code>condition</code> 为条件控制表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。</p>
<p><code>for</code> 语句的运行顺序是：先进行一次 <code>sentence1</code> ，接着判断 <code>condition</code> 是否为真，为真则执行循环体。循环体运行完后执行 <code>sentence2</code> 。然后再次判断 <code>condition</code> ，一直循环直至条件为假。</p>
<p>所以延展出常用的 <code>for</code> 语句使用格式：</p>
<pre><code class="language-c">for(循环变量赋值初始化; 循环条件; 循环变量变化)
{
  循环体
}
</code></pre>
<p>做个补充，在老版本的C语言中， <code>sentence1</code> 不支持声明变量并同时初始化，如： <code>for(int i = 1; i &lt;= 100; i ++)</code> 。但是在C99版本后是允许的。</p>
<p>事实上， <code>for</code> 语句中的 <code>sentence1</code> 语句、 <code>sentence2</code> 语句和 <code>condition</code> 语句并非必要。即这三句语句可以省略，省略 <code>condition</code> 语句默认为真，写成 <code>for( ; ; )</code> ，但是两个分号绝不可少。在省略掉这三句语句时，我们仍要思考如何终止循环。例如在 <code>for</code> 语句上面就把变量初始化，在循环体中设置判断 <code>if</code> 什么条件就终止循环，在循环体中处理条件变化……</p>
<h2 id="6-4-循环的终止与继续">6.4 循环的终止与继续</h2>
<ul>
<li>使用 <code>break</code> 语句终止循环。</li>
</ul>
<p>之前使用 <code>break</code> 语句，可能是条件结构中跳出 <code>switch</code> 语句。实际上， <code>break</code> 语句还可以用来跳出循环体，即终止循环。</p>
<p>以求1到100和的例子，假如我希望在和刚好大于等于2500的时候结束，并想知道此时是多少个数的和，那怎么实现呢？</p>
<pre><code class="language-c">// use-break.c
#include &lt;stdio.h&gt; //声明头文件 

int main() 
{
	int i, sum = 0;
	for(i = 1; i &lt;= 100; i ++) 
	{
		sum += i;
		if(sum &gt;= 2500) //当sum大于等于2500 
		break; //终止所在的一层for循环 
	}
	printf("sum = %d, and now i is %d\n", sum, i);
	return 0;
}
</code></pre>
<p>当然也可以这样解决：</p>
<pre><code class="language-c">// use-for.c
#include &lt;stdio.h&gt; //声明头文件 

int main() 
{
	int i, sum = 0;
	for(i = 1; sum &lt; 2500; i ++) 
	{
		sum += i;
	}
	printf("sum = %d, and now i is %d\n", sum, i);
	return 0;
}
</code></pre>
<p>注释中我写到，终止 <code>break</code> 所在的一层 <code>for</code> 循环，因为当有多个循环嵌套时， <code>break</code> 不会终止所有的循环，而是一层循环。（可以自己做实验研究）</p>
<ul>
<li>使用 <code>continue</code> 语句跳过本次循环。</li>
</ul>
<p>有时候不希望终止整个循环，而是想结束这一次循环，还得执行下次循环。这时可以使用 <code>continue</code> 语句。</p>
<p>还是求1到100和的例子，但我希望求1到100中是偶数的和，那么奇数就没必要加进去，此时可以使用 <code>continue</code> 语句跳过本次循环。</p>
<pre><code class="language-c">// Find-the-sum-of-even-numbers-from-1-to-100.c
#include &lt;stdio.h&gt; //声明头文件 
int main() 
{
	int i, sum = 0;
	for(i = 1; i &lt;= 100; i ++) 
	{
		if(i % 2 == 1) //当i为奇数，即除于2余数为1 
			continue; //结束本次循环 
		sum += i; 
	}
	printf("sum = %d\n", sum);
	return 0;
}
</code></pre>
<p>需要注意的是，结束本次循环并不是完全不进入循环，而是不执行 <code>continue</code> 下面的循环体部分。上面的代码，如果 <code>sum += i</code> 在 <code>continue</code> 的上面，结果还是会加上奇数的部分。</p>
<p><br><br><br></p>
<h1>Ⅶ —— 枚举</h1>
<p>枚举是C语言中的一种基本数据类型，用于定义一组具有离散值的常量。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p>
<p>定义一个枚举类型，需要使用 <code>enum</code> 关键字，后面跟着枚举类型的名称，以及用大括号 <code>{}</code> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从0开始递增。</p>
<p>枚举语法定义格式为：</p>
<pre><code class="language-c">enum　枚举名　{枚举元素1,枚举元素2,……};
</code></pre>
<p>举个例子，一周有7天，如果想将星期一映射为数字1，星期天映射为数字7，我们可以使用枚举。</p>
<pre><code class="language-c">enum Day
{
	MON=1, TUE, WED, THU, FRI, SAT, SUN
};
// MON映射到1，后面的会自动递增
// 效果跟#define MON 1 等一样
</code></pre>
<p>如果想让星期三之后特殊一些，星期三映射到8，星期天映射到12，只需在中间添加赋值即可。</p>
<pre><code class="language-c">enum Day
{
	MON=1, TUE, WED=8, THU, FRI, SAT, SUN
};
// MON映射到1，TUE映射到2，WED映射到8，后面的会自动递增
</code></pre>
<p>使用时直接输出即可：</p>
<pre><code class="language-c">printf("%d", MON);
</code></pre>
<p>然而上面是对枚举类型的使用，下面介绍枚举变量的定义和使用。</p>
<p>枚举类型是一种数据类型，可以对标 <code>int</code> 理解；枚举变量是一个变量，可以对标 <code>int number</code> 中的 <code>number</code> 理解。</p>
<p>可以通过三种方式定义枚举变量：</p>
<ol>
<li>先定义枚举类型，再定义枚举变量</li>
</ol>
<pre><code class="language-c">enum DAY
{
	MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
</code></pre>
<ol start="2">
<li>定义枚举类型的同时定义枚举变量</li>
</ol>
<pre><code class="language-c">enum DAY
{
	MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
</code></pre>
<ol start="3">
<li>省略枚举名称，直接定义枚举变量</li>
</ol>
<pre><code class="language-c">enum
{
	MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
</code></pre>
<p>给出使用枚举变量的情形：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main()
{
    enum DAY day;
    day = WED;
    printf("%d", day);
    return 0;
}
</code></pre>
<p>在 <strong>枚举类型值连续</strong> 的情况下还可以进行循环：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
int main()
{
    // 遍历枚举元素
    for (day = MON; day &lt;= SUN; day++) 
    {
        printf("枚举元素：%d \n", day);
    }
    return 0;
}
</code></pre>
<p>如果将将整数转换为现有枚举值，只需强制类型转换：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;

int main()
{
 
    enum day
    {
        saturday, sunday, monday, tuesday, wednesday, thursday, friday
    } workday;
 
    int a = 1;
    enum day weekend;
    weekend = ( enum day ) a;  //类型转换
    //weekend = a; //错误
    printf("%d",weekend);
    return 0;
}
</code></pre>
<pre><code>输出结果：
1
</code></pre>
<p><br><br><br></p>
<h1>Ⅷ —— 数组</h1>
<p>数组是一种可以存储固定大小的相同类型元素的顺序集合。简单来说，数组可以存放一串相同的数据类型。</p>
<h2 id="8-1-数组结构">8.1 数组结构</h2>
<p>数组的结构如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_array.png" alt="数组的结构"></p>
<p>数组的每一个单体称作 <strong>元素</strong> ，每个元素有它的 <strong>索引号</strong> ，用于访问该元素。 <strong>索引号从0开始。</strong></p>
<h2 id="8-2-数组的定义和访问">8.2 数组的定义和访问</h2>
<p>数组的定义十分简单，其定义格式是：</p>
<pre><code class="language-c">type arrayName [arraySize];
</code></pre>
<p>如 <code>int array[5];</code> 就定义了一个大小为5的整型数组，数组名为array，它可以存放5个整型数据，索引号从0到4。</p>
<p>访问数组时直接使用 <code>arrayName[index]</code> 的方式进行，如 <code>array[0]</code> 就是array数组的第一个元素的值。使用循环还可以将数组的内容输出：</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;
int main()
{
	int i;
	int array[5];
	
	// 访问数组并赋值
   	for(i = 0; i &lt; 5; ++ i)
   		array[i] = i + 1;
   	
   	// 访问数组并输出
   	for(i = 0; i &lt; 5; ++ i)
   		printf("%d ", array[i]);
   	return 0;
}

</code></pre>
<p>补充个冷知识，我们比较经常使用 <code>array[0]</code> 访问元素，实际上还能以 <code>0[array]</code> 的方式访问元素。</p>
<h2 id="8-3-数组的初始化">8.3 数组的初始化</h2>
<p>通过上面的例子，我们可以通过循环给数组中的每个元素赋值。但是还可以通过声明时的初始化语句进行相同的操作。</p>
<pre><code class="language-c">int array[5] = {1, 2, 3, 4, 5};
</code></pre>
<p>大括号 <code>{ }</code> 之间的值的数目不能大于我们在数组声明时在方括号 <code>[ ]</code> 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。即等价于：</p>
<pre><code class="language-c">int array[] = {1, 2, 3, 4, 5};
</code></pre>
<h2 id="8-4-多维数组">8.4 多维数组</h2>
<p>C 语言支持多维数组。多维数组声明的一般形式如下：</p>
<pre><code class="language-c">type name[size1][size2]...[sizeN];
</code></pre>
<p>下面以二维数组作为示例。一个二维数组，在本质上，是一个元素为一维数组的数组。定义形式如下：</p>
<pre><code class="language-c">type arrayName [x][y];
</code></pre>
<p>如一个二维数组初始化如下：</p>
<pre><code class="language-c">int array[3][4] = {  
 {1, 2, 3, 4} ,   /*  初始化索引号为 0 的行 */
 {5, 6, 7, 8} ,   /*  初始化索引号为 1 的行 */
 {9, 10, 11, 12}   /*  初始化索引号为 2 的行 */
};
</code></pre>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_array2.png" alt="二维数组"></p>
<p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）访问。</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt; 
int main ()
{
	// 一个带有 5 行 2 列的数组
	int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
	int i, j;
 
	// 输出数组中每个元素的值
	for (i = 0; i &lt; 5; i++)
	{
		for (j = 0; j &lt; 2; j++)
		{
			printf("a[%d][%d] = %d\n", i, j, a[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h2 id="8-5-数组的使用">8.5 数组的使用</h2>
<ul>
<li>求数组长度：使用 <code>sizeof</code> 关键字，将整个数组占的内存大小除以每个元素占的内存大小，得到的就是元素个数。</li>
</ul>
<pre><code class="language-c">int numbers[] = {1, 2, 3, 4, 5};
int length = sizeof(numbers) / sizeof(numbers[0]);
</code></pre>
<ul>
<li>将数组作为函数参数传入</li>
</ul>
<ol>
<li>形式参数是一个已定义大小的数组</li>
</ol>
<pre><code class="language-c">void fun(int param[10])
{
	// ……
}
</code></pre>
<ol start="2">
<li>形式参数是一个未定义大小的数组</li>
</ol>
<pre><code class="language-c">void fun(int param[])
{
	// ……
}
</code></pre>
<p>为了函数的通用性，通常使用未定义大小的数组，再将数组大小作为第二参数传入。</p>
<pre><code class="language-c">double getAverage(int arr[], int size) // 求数组的平均值
{
	int i;
	double avg;
	double sum;
	for (i = 0; i &lt; size; ++ i)
	{
		sum += arr[i];
	}
	avg = sum / size;
	return avg;
}
</code></pre>
<p>需要注意的是，我们传入的是数组，在函数内部中如若有对数组元素的修改，也会同步对外部的数组进行修改。因为此处形式参数是以地址传递的形式传入。</p>
<p>为什么传递数组名字会是以地址传递的形式传入呢？那是因为 <strong>数组名实际上是一个指针</strong> ，它存放数组中首元素的地址。至于什么是指针，可查阅下一节。</p>
<p><br><br><br></p>
<h1>Ⅸ —— 指针</h1>
<p>指针是C语言很重要的一环。</p>
<p>数据都有一个内存空间，内存空间都有一个地址，我们形象地把这个地址称为指针。指针也就是内存地址，指针变量是用来存放内存地址的变量。</p>
<h2 id="9-1-指针变量的定义">9.1 指针变量的定义</h2>
<p>指针变量定义的一般形式为：</p>
<pre><code class="language-c">type *var_name;
</code></pre>
<p><code>type</code> 是指针的基类型，它必须是一个有效的数据类型， <code>var_name</code> 是指针变量的名称。用来声明指针的星号 <code>*</code> 与乘法中使用的星号是相同的，但在此处的意义是标记改变量是指针变量，称为指针运算符。一个指针对应一个 <code>*</code> 。</p>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个 <strong>代表内存地址的长的十六进制数</strong> 。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<p>当我们需要取一个变量的地址时，我们需要加 <code>&amp;</code> （取地址符）；当我们需要取一个指针的数据时，我们需要加 <code>*</code> 。</p>
<pre><code class="language-c">int a = 1;
int *pa = &amp;a;
</code></pre>
<p>之前使用 <code>scanf()</code> 函数时所加的 <code>&amp;</code> ，表明我们是把数据放到某变量名所处的地址，而不是塞到变量名里面。</p>
<p>如果想输出地址的话，可以使用 <code>%p</code> 或 <code>%x</code> 输出：</p>
<pre><code class="language-c">int a = 1;
printf("%p", &amp;a);
</code></pre>
<p>指针使用前必须有初始化值，即定义时必须赋值，若无值则指向NULL。</p>
<pre><code class="language-c">int *p = NULL;
</code></pre>
<p>如果使用前没有初始化值时，该指针会变成 <strong>野指针</strong> ，指针指向了一块随机的空间，不受程序控制。有可能是系统重要软件的地址，贸然使用可能使得系统崩溃。</p>
<h2 id="9-2-指针的运算">9.2 指针的运算</h2>
<ul>
<li>
<p>指针之间不能进行 <code>+</code> 运算，无意义。</p>
</li>
<li>
<p>指针进行 <code>&lt;</code> 运算时，表示实际内存高低位的比较；</p>
</li>
<li>
<p>指针进行 <code>=</code> 运算时，表示把右边的地址赋值给左边；</p>
</li>
<li>
<p>指针进行 <code>-</code> 运算时，表示在两指针之间相隔相同类型元素的个数。</p>
</li>
<li>
<p>指针进行 <code>++</code> 运算时，表示在指针递增，会指向下一个元素的存储单元。指针在递增时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p>
</li>
<li>
<p>指针进行 <code>--</code> 运算时，表示在指针递减，会指向上一个元素的存储单元。指针在递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p>
</li>
</ul>
<h2 id="9-3-指针的使用">9.3 指针的使用</h2>
<ul>
<li>指针间接访问变量</li>
</ul>
<p>通过指针输出：</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int a = 100, b = 10;
	int *pointer1, *pointer2;
	pointer1 = &amp;a;
	pointer2 = &amp;b;
	printf("a=%d,b=%d\n", a, b); 
	printf("pointer1=%d,pointer2=%d\n", pointer1, pointer2); 
	printf("pointer1=%d,pointer2=%d\n", *pointer1, *pointer2);
	return 0;
}
</code></pre>
<pre><code>输出结果：
a=100,b=10
pointer1=6422216,pointer2=6422220
pointer1=100,pointer2=10
</code></pre>
<p>通过指针将两个变量存放的值交换，用地址传递实现存储空间上的交换。</p>
<pre><code class="language-c">// swap-ab.c
#include&lt;stdio.h&gt;
void swap(int *a,int *b)
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}

int main()
{
	int x = 1, y = 2;
	printf("x=%d,y=%d\n", x, y);
	swap(&amp;x, &amp;y);
	printf("x=%d,y=%d\n", x, y);
	return 0;
}
</code></pre>
<pre><code>输出结果：
x=1,y=2
x=2,y=1
</code></pre>
<ul>
<li>指针引用一维数组</li>
</ul>
<p>数组名即是该数组首元素（即序号为0的元素）的地址。所以我们可以直接用指针指向数组名，无需取地址符。</p>
<pre><code class="language-c">int a[10];
int *p;
p = a;
</code></pre>
<p>同时，我们可以对数组首元素进行取地址，即下代码等价：</p>
<pre><code class="language-c">p = a;      //p指向数组首元素的地址，即a[0]的地址；
p = &amp;a[0];  //p指向a[0]的地址
</code></pre>
<p>当我们正确把指针指向一个数组的时候，可以对指针进行以下运算： <code>p++</code> , <code>++p</code> , <code>p--</code> , <code>--p</code> , <code>p = p + 1</code> , <code>p = p - 1</code> 等。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pointer.png" alt="指针访问数组"></p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int a[5] = {101,102,103,104,105};
	int *p;
	p = a;
	printf("%d ", *p);
	printf("%d ", *(p+1));
	printf("%d", *(p+2));
	return 0;      
}
</code></pre>
<pre><code class="language-c">输出结果：
101 102 103
</code></pre>
<p>因为数组名也有地址的属性，所以输出语句还可以改成：</p>
<pre><code class="language-c">printf("%d ", *a);
printf("%d ", *(a+1));
printf("%d", *(a+2));
</code></pre>
<p>但数组名不能进行自增自减，如不能 <code>a++</code> 或 <code>a--</code> 等。</p>
<p>指针还可以引用字符串（字符数组），字符串的本质是一个字符数组。我们可以类似指针引用一维数组那样引用字符串。</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
  char a[] = "computer!";
  char *p;
  p = a;
  printf("%c\n", *p);  //%c，取*时，具体到某个元素，此处是首元素
  printf("%c\n", *(p + 2));
  printf("%s\n", p);  //%s，不取*，从首元素输出所有字符
  printf("%s\n", p + 2);  // 从a[2]开始输出所有字符
  return 0;
}
</code></pre>
<pre><code>输出结果：
输出结果：
c
m
computer!
mputer!
</code></pre>
<pre><code class="language-c">//以上也可用字符指针变量表示，如下所示：
char *p="computer!";//此处可能会出现warning，但无关紧要
//上句等价于char *p; p="computer!";
printf("%s",p);//此处无需*p，注意对比
</code></pre>
<p><code>char *p="computer!"</code> 的意思是将字符指针变量 <code>p</code> 指到"computer!"的首地址即"c"的地址。</p>
<p>之前，我们用字符数组也能实现打印字符串，而使用字符指针的不同是：</p>
<p>①可以对字符指针变量赋值，但不能对数组名赋值，初始化不等于赋值，如不能：</p>
<pre><code class="language-c">char a[10] = {"computer!"}; //此句合法
char a[10]; 
a = "computer!"; //此句不合法
</code></pre>
<p>②储存内容不同，字符数组把每一个元素的值都存放，而字符指针只存放第一个元素的地址。</p>
<ul>
<li>指针指向二维数组</li>
</ul>
<p>二维数组有两个下标，那么一个指针怎么指，我们将指针分为 <strong>行指针</strong> 和 <strong>列指针</strong> 。行指针，即指向某一行元素的指针；列指针，即指向某一列元素的指针。</p>
<p>下有二维数组 <code>a[4][5]</code> ：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pointer2.png" alt="指针指向二维数组"></p>
<ul>
<li>动态数组</li>
</ul>
<p>像 <code>int a[5];</code> 这样的定义数组，我们称之为 <strong>静态数组</strong> 。在程序编译时，静态数组的内存空间就被分配好了，存储在栈上或者全局数据区。静态数组的大小在声明时确定且无法在运行时改变。静态数组的生命周期与其作用域相关。如果在函数内部声明静态数组，其生命周期为整个函数执行期间；如果在函数外部声明静态数组，其生命周期为整个程序的执行期间。</p>
<p><strong>动态数组</strong> 是在运行时通过动态内存分配函数（如 <code>malloc</code> 和 <code>calloc</code> ）手动分配内存的数组。动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 <code>malloc</code> 、 <code>calloc</code>  等函数来申请内存，并使用 <code>free</code> 函数来释放内存。动态数组的大小在运行时可以根据需要进行调整。可以使用 <code>realloc</code> 函数来重新分配内存，并改变数组的大小。动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。</p>
<pre><code class="language-c">int size = 5;
int *dynamicArray = (int *)malloc(size * sizeof(int)); // 动态数组内存分配
// 使用动态数组
free(dynamicArray); // 动态数组内存释放
</code></pre>
<ul>
<li>数组指针</li>
</ul>
<p>数组指针，其本质是指针，指向一个一维数组的指针。所以定义时，由运算符优先级，我们需要带上小括号</p>
<p>定义数组指针： <code>类型名 (*指针变量名)[长度];</code></p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int a[4][5] = {
		1,2,3,4,5,
		6,7,8,9,10,
		11,12,13,14,15,
		16,17,18,19,20};
	int (*p)[5];
	p = a+1; // 指向第2行
	for(int i=0;i&lt;5;i++)  printf("%d ",(*p)[i]);
	return 0;
}
</code></pre>
<pre><code>输出结果：
6 7 8 9 10
</code></pre>
<ul>
<li>指针数组</li>
</ul>
<p>指针数组，其本质是数组，是一个元素均为指针类型的数组。</p>
<p>定义指针数组： <code>类型名 *数组名[长度];</code></p>
<p>举例：（将数字转化为对应的英文月份）</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	char *p[13];
	p[1]="Januray";  p[2]="February";  p[3]="March"; 
	p[4]="April";  p[5]="May";      p[6]="June";
	p[7]="July";  p[8]="August";    p[9]="September";
	p[10]="October";p[11]="November";  p[12]="December";
	//可能会警告，但无关紧要
	int n;
	scanf("%d",&amp;n);
	printf("%s\n",p[n]);
	return 0;
}
</code></pre>
<pre><code>运行结果：
3 	// 输入
March 	// 输出
</code></pre>
<ul>
<li>指向函数的指针</li>
</ul>
<p>函数名也代表函数的起始地址。</p>
<p>此内容直接看以下例子——比较两个数字的大小</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int max(int x,int y)
{
	return (x &gt; y ? x : y);
}

int main()
{
	int a = 50, b = 100;
	printf("max=%d", max(a, b));
	return 0;
}
</code></pre>
<p>上代码等价于：</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int max(int x,int y)
{
	return (x &gt; y ? x : y);
}

int main()
{
	int a = 50, b = 100;
	int (*p)(int,int);
	p = max;
	printf("max=%d", (*p)(a,b));
	return 0;
}
</code></pre>
<p>注意 <code>int (*p)(int,int)</code>；定义指向函数的指针变量： <code>类型名 (* 指针变量名)(函数参数表列);</code></p>
<p>指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数，下附一个使用函数指针的例子；</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
void fun(int x, int y, int (*p)(int,int))
{
	int ans;
	ans = (*p)(x,y);
	printf("%d", ans);
}
int max(int x,int y)
{
	printf("max=");
	return x &gt; y ? x : y;
}
int min(int x,int y)
{
	printf("min=");
	return x &lt; y ? x : y;
}

int main()
{
	int a = 34, b = -21, n;
	printf("请输入你的选择(1-求最大值，2-求最小值)：");
	scanf("%d", &amp;n);
	if(n==1)  fun(a, b, max);
	if(n==2)  fun(a, b, min);
	return 0;
}
</code></pre>
<ul>
<li>返回指针类型的函数</li>
</ul>
<p>定义返回指针值得函数形式为： <code>类型名* 函数名(参数表列);</code></p>
<p>依然是使用一个例子：对若干学生成绩，找出不合格得课程得学生及其学生号，代码如下：</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
float* search(float (*pointer)[4])//定义函数
{
	int i = 0;
	float *pt;
	pt = NULL;
	//切记初始化指针，无则指向NULL

	for(; i &lt; 4; i ++)
	{
		if(*(*pointer+i)&lt;60)  pt = *pointer;
		//如有不及格，使pt指向score[i][0]
	}
	return pt;
}
int main()
{
	float score[][4] = {{60,70,80,90},{56,89,67,88},{34,78,90,66}};
	//定义数组，初始化成绩，有3名学生，每名学生有4门成绩
	float *p;
	int i, j;
	for(i = 0; i &lt; 3; i ++)
	{
		p = search(score + i);
		//调用search函数，如不及格则返回score[i][0]的地址
		//否则返回NULL
		if(p == *(score+i))  //若返回的不是NULL，则输出学生成绩
		{
			printf("No.%d score:",i);
			for(j = 0; j &lt; 4; j ++)
				printf("%5.2f ", *(p+j));
			printf("\n");
		}
	}
	return 0;
}
</code></pre>
<ul>
<li>指向指针数据的指针变量</li>
</ul>
<p>指向指针数据的指针，可以嵌套，如：</p>
<pre><code class="language-c">// test.c
#include&lt;stdio.h&gt;
int main()
{
	int a = 100;
	int *p;
	p = &amp;a;
	int **q;
	q = &amp;p;
	printf("%d ", **q);
	return 0;
}
</code></pre>
<pre><code>输出结果：
100
</code></pre>
<p><br><br><br></p>
<h1>Ⅹ —— 共用体与结构体</h1>
<h2 id="10-1-共用体">10.1 共用体</h2>
<p><strong>共用体（Union）</strong> 是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。</p>
<p>为了定义共用体，必须使用 <code>union</code> 语句。 <code>union</code> 语句定义了一个新的数据类型，带有多个成员。定义格式如下：</p>
<pre><code class="language-c">union [union tag]
{
	成员定义;
	成员定义;
	...
	成员定义;
} 共用体变量;
</code></pre>
<p><code>union tag</code> 是可选的，每个 <code>成员定义</code> 是标准的变量定义，比如 <code>int i;</code> 或者 <code>float f;</code> 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。</p>
<p>下面定义一个名为 <code>Data</code> 的共用体类型，有三个成员 <code>i</code> 、 <code>f</code> 和 <code>str</code> ：</p>
<pre><code class="language-c">union Data
{
	int i;
	float f;
	char  str[10];
};
</code></pre>
<p>也可以像枚举类型定义枚举类型的同时定义枚举变量一样，定义共用体类型的同时定义共用体变量。</p>
<pre><code class="language-c">union Data
{
	int i;
	float f;
	char  str[10];
} data;
</code></pre>
<p><code>Data</code> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>
<p><strong>共用体占用的内存应足够存储共用体中最大的成员。</strong> 例如，在上面的实例中，<code>Data</code> 将占用10个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。</p>
<p>使用共用体时，我们需要先创建共用体类型变量，再根据变量访问成员。</p>
<pre><code class="language-c">union Data data;
</code></pre>
<p>为了访问共用体的成员，使用成员访问运算符 <code>.</code> ，如 <code>data.i</code> 、 <code>data.f</code> 、 <code>data.str</code> ，但是在同一时间只能使用一个成员。</p>
<h2 id="10-2-结构体">10.2 结构体</h2>
<p><strong>结构体</strong> 与共用体类似，不同的是结构体的成员并列存在，可同时使用。</p>
<pre><code class="language-c">struct tag
{
	成员定义;
	成员定义;
	...
	成员定义;
} 结构体变量;
</code></pre>
<p><code>tag</code> 是结构体标签，每个 <code>成员定义</code> 是标准的变量定义，比如 <code>int i;</code> 或者 <code>float f;</code> 或者其他有效的变量定义。在结构体定义的末尾，最后一个分号之前，可以指定一个或多个结构体变量，这是可选的。</p>
<p>如：</p>
<pre><code class="language-c">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
	int a;
	char b;
	double c;
} s1;

//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
	int a;
	char b;
	double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;

//也可以用typedef创建新类型
typedef struct
{
	int a;
	char b;
	double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;
</code></pre>
<p>第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 <code>t3=&amp;s1</code> ，则是非法的。</p>
<p>如果将结构体与基本数据类型做对比的话，举个例子：</p>
<pre><code class="language-c">int a;

struct Tag
{
	double number;
};
struct Tag b；

typedef struct
{
	int number;
} Tag2;
Tag2 c;
</code></pre>
<p>那么 <code>int</code> 、 <code>struct Tag</code> 、 <code>Tag2</code> 是对等的，都是数据类型；而 <code>a</code> 、 <code>b</code> 和 <code>c</code> 是同级的，都是变量。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针。如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<pre><code class="language-c">struct B; &nbsp; &nbsp;//对结构体B进行不完整声明

//结构体A中包含指向结构体B的指针
struct A
{
&nbsp; &nbsp; struct B *partner;
&nbsp; &nbsp; //other members;
};

//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
&nbsp; &nbsp; struct A *partner;
&nbsp; &nbsp; //other members;
};
</code></pre>
<p>为了访问结构的成员，使用成员访问运算符 <code>.</code> 。对于结构体的初始化，可以使用 <code>{}</code> ：</p>
<pre><code class="language-c">//book.c
#include &lt;stdio.h&gt;
struct Books
{
	char &nbsp;title[50];
&nbsp; &nbsp;	char &nbsp;author[50];
&nbsp; &nbsp;	char &nbsp;subject[100];
&nbsp; &nbsp;	int &nbsp; book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};

int main()
{
	printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);
	return 0;
}
</code></pre>
<p>结构体作为函数的参数传入时，传参方式与其他类型的变量或指针类似，如： <code>void printBooks(struct Books b);</code> ，之后在函数里访问成员即可。</p>
<p>可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如：</p>
<pre><code class="language-c">struct Books *struct_pointer;
struct_pointer = &amp;Book1;
struct_pointer-&gt;title; // 指针访问成员时
</code></pre>
<p>需要注意的是，使用指向该结构的指针访问结构的成员时，必须使用 <code>-&gt;</code> 运算符。</p>
<p>使用 <code>sizeof</code> 运算符来计算结构体的大小，这在使用链表时有帮助。</p>
<p><br><br><br></p>
<h1>Ⅺ —— 链表</h1>
<h2 id="11-1-链表及其构成">11.1 链表及其构成</h2>
<p><strong>链表</strong>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。而这些储存单元需要及时开辟，此时需要使用动态储存分配函数。</p>
<p><strong>链表</strong>由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的 <strong>数据域</strong> ，另一个是存储下一个结点地址的 <strong>指针域</strong> 。如：</p>
<pre><code class="language-c">struct test
{
  int num;		// 数据域
  char name[5];		// 数据域
  struct test *next; 	// 指针域
};
</code></pre>
<p>链表还可分为动态链表和静态链表，此处不讨论静态链表，均为动态链表。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_arrayandlist.png" alt="链表与数组"></p>
<h2 id="11-2-内存管理的函数">11.2 内存管理的函数</h2>
<p>关于动态储存分配函数有 <code>calloc()</code> 、 <code>malloc()</code> 、 <code>free()</code> 、 <code>realloc()</code> 。他们都存在于 <code>stdlib.h</code> 头文件中。</p>
<p>有的编译系统要求用 <code>malloc.h</code> 头文件而不是 <code>stdlib.h</code> 头文件，实际上这两个头文件都包含以上的动态储存分配函数。</p>
<p>除 <code>free()</code> 函数，其他函数都会返回一定的地址，需要对地址进行强制类型转换，转换为我们所需的数据类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">函数原型</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>calloc()</code></td>
<td style="text-align:center"><code>void *calloc(unsigned n, unsign size)</code></td>
<td style="text-align:center">分配n个大小为size的内存连续空间</td>
<td style="text-align:center">成功时返回分配内存的起始地址，不成功返回0</td>
</tr>
<tr>
<td style="text-align:center"><code>malloc()</code></td>
<td style="text-align:center"><code>void *calloc(unsigned size)</code></td>
<td style="text-align:center">分配1个大小为size的储存区</td>
<td style="text-align:center">成功时返回分配内存起始地址，内存不足返回0</td>
</tr>
<tr>
<td style="text-align:center"><code>free()</code></td>
<td style="text-align:center"><code>void free(void *p)</code></td>
<td style="text-align:center">释放p所指的内存区</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center"><code>realloc()</code></td>
<td style="text-align:center"><code>void *calloc(viod *p, unsigned isze)</code></td>
<td style="text-align:center">将p所指的已分配内存区大小改为size，size可大于或小于原来大小</td>
<td style="text-align:center">返回指向该内存的指针</td>
</tr>
</tbody>
</table>
<h2 id="11-3-单向链表">11.3 单向链表</h2>
<p><strong>单向链表</strong>，指针指向单向，连接方向单向，优点是简单，缺点是效率略低。</p>
<p>单向链表是由结点构成，所讨论的单向链表结点如下：</p>
<pre><code class="language-c">struct test
{
	int num;
	struct test *next;
};
</code></pre>
<ul>
<li>链表的创建</li>
</ul>
<pre><code class="language-c">//链表创建，返回一个表头head
struct test *creat()  
{
	struct test *head;
	struct test *p1, *p2;
	int n = 0;
	p1 = p2 = (struct test *)malloc(sizeof(struct test));  //开辟一个内存单元
	scanf("%d", &amp;p1-&gt;num);  //输入第一个信息
	head = NULL;  //指针必须初始化，无地址则指向NULL
	while(p1-&gt;num != 0) // 设计当输入0时停止创建链表
	{
		n += 1;
		if(n == 1)  head = p1; // 当链表为空，即创建的是第一个结点，则使头结点指向p1的地址
		else  p2-&gt;next = p1;	// 当链表非空，用next指针连接
		p2 = p1; // p2指向p1所指的地址，p2为当前链表末尾
		p1 = (struct test *)malloc(sizeof(struct test));  //再开辟内存单元，并将起始地址赋值给p1
		scanf("%d", &amp;p1-&gt;num);   //循环输入信息
	}
	free(p1); // 释放最后一个结点，即释放输入为0的结点
	p2-&gt;next = NULL; // 链表的末尾指向NULL
	return head;
}
</code></pre>
<p>根据上述代码，演示过程如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_create.png" alt="链表创建过程"></p>
<ul>
<li>链表的插入</li>
</ul>
<p>链表的插入思路如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_insert.png" alt="链表的插入"></p>
<pre><code class="language-c">// 在某链表中插入一个新的由指针引用的结构体
struct test *add(struct test *head, struct test *insert)
{
	struct test *p0, *p1, *p2;
	p0 = insert;  //将新的由指针引用的结构体赋值给p0
	p1 = head;
	if(head == NULL)//判断是否为空链表
	{
		head = p0;  //是空链表则从头插入，头指针为p0
		p0-&gt;next = NULL;//后面无新的数据
	}
	else    //链表非空，按num排序，找到适合的位置或者到链表末端停下
	{
		while((p0-&gt;num &gt; p1-&gt;num) &amp;&amp; (p1-&gt;next != NULL))
		{
			p2=p1;
			p1=p1-&gt;next;
		}
		
		if(p0-&gt;num &lt;= p1-&gt;num) // 找到合适的位置
		{
			if(head == p1) head = p0;
			else  p2-&gt;next = p0;
			p0-&gt;next = p1;
		}
		else // 找不到合适位置，插入到链表末尾
		{
			p1-&gt;next = p0;
			p0-&gt;next = NULL;
		}		
	}		
	return head; // 返回更新后的链表表头
}
</code></pre>
<ul>
<li>链表的删除</li>
</ul>
<p>链表的删除思路如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_delete.png" alt="链表的删除"></p>
<pre><code class="language-c">// 在某链表中查找num并删除该结构体，返回更新后的表头
struct test *del(struct test *head, int num) 
{
	struct test *p1, *p2;
	if(head == NULL)  // 判断是否为空链表
	{
		printf("这是一个空链表\n");
		return head;
	}  
	
	p1 = head;
	// 链表非空，将创建好的链表头指针head赋值给p1
	// 不能直接对表头进行操作，否则变动完之后找不到表头
	
	// 当没匹配到元素或者已经到链表末端，停止循环
	while(p1-&gt;num != num &amp;&amp; p1-&gt;next != NULL)  
	{
		p2 = p1;		// p2指向的是p1的前一个结点
		p1 = p1-&gt;next;		// p1指针遍历链表
	} // 此处寻找元素
  
	if(p1-&gt;num == num)  // 如果是找到了元素而停止循环的情况
	{
		if(p1 == head)
		{
			head = p1-&gt;next;// 如果删除的是头指针，则将头指针指向下一个，修改表头
			free(p1);
		}  
			
		else
		{
			p2-&gt;next = p1-&gt;next;  // 删除节点，即跳过某结构体直接连向下一个
			free(p1);
		}  
			
	}
	else 
		printf("Not found!");   // 到链表末端而停止循环的情况，也就是没找到

	return head;	// 返回修改后的表头
}
</code></pre>
<ul>
<li>链表的查找</li>
</ul>
<p>思路简单，自行理解代码。</p>
<pre><code class="language-c">// 在链表中查找值为obj的结构体，找到返回该结构体的指针，找不到返回NULL
struct test *find(struct test *head, int obj)
{
	struct test *p, *res = NULL; // res作为返回的结构体
	if(head == NULL)	return NULL; // 链表为空返回空
	
	p = head;
	
	while(p != NULL) // 遍历链表
	{
		if(p-&gt;num == obj) // 找到目标
		{
			res = p;
			break;
		}
		p = p-&gt;next; // 往下顺延
	}
	return res;
}
</code></pre>
<ul>
<li>链表的输出</li>
</ul>
<p>思路简单，自行理解代码。</p>
<pre><code class="language-c">// while循环输出链表
void print(struct test *head)
{
	struct test *p;
	p = head;
	while(p != NULL)
	{
		printf("%d ", p-&gt;num);
		p = p-&gt;next;
	}
}
</code></pre>
<h2 id="11-4-双向链表">11.4 双向链表</h2>
<p><strong>双向链表</strong>，指针指向双向，连接方向双向。</p>
<p>双向链表是由结点构成，所讨论的双向链表结点如下：</p>
<pre><code class="language-c">struct test
{
	int num;
	struct test *next;	// 指向后一个结构体
	struct test *pre;	// 指向前一个结构体
};
</code></pre>
<p>双向链表结构如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_dlist.png" alt="双向链表"></p>
<p>至于双向链表的创建，插入，删除，查找，不详细介绍。多一个方向的指针使得该链表可以往前遍历，提高其方便性。</p>
<h2 id="11-5-循环链表">11.5 循环链表</h2>
<p>循环链表的首位是相接的，构成一个环。所以还可以分成单向循环链表和双向循环链表。</p>
<ul>
<li>循环单向链表</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_clist.png" alt="循环单向链表"></p>
<ul>
<li>循环双向链表</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_cdlist.png" alt="循环双向链表"></p>
<p><br><br><br></p>
<h1>Ⅻ —— 对文件的读写</h1>
<h2 id="12-1-打开文件">12.1 打开文件</h2>
<p>可以使用 <code>fopen()</code> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <code>FILE</code> 的一个对象，类型 <code>FILE</code> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<pre><code class="language-c">FILE *fopen(const char *filename, const char *mode);
</code></pre>
<p>函数的第一参数是打开的文件名，常量字符指针类型，也能看成字符串类型；第二参数是打开文件的模式，有如下模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">打开一个已有的文本文件，允许读取文件</td>
</tr>
<tr>
<td style="text-align:center"><code>r+</code></td>
<td style="text-align:center">打开一个已有的文本文件，允许读写文件</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code></td>
<td style="text-align:center">打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入</td>
</tr>
<tr>
<td style="text-align:center"><code>w+</code></td>
<td style="text-align:center">打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入</td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center">打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则在原有内容上追加写入</td>
</tr>
<tr>
<td style="text-align:center"><code>a+</code></td>
<td style="text-align:center">打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则在原有内容上追加写入</td>
</tr>
</tbody>
</table>
<p>如果是处理二进制文件的情况，则在原来的基础上加上 <code>b</code> ，如： <code>rb</code> ， <code>wb</code> ， <code>ab</code> ， <code>rb+</code> ， <code>r+b</code> ， <code>wb+</code> ， <code>w+b</code> ， <code>ab+</code> ， <code>a+b</code> 。</p>
<p><strong>打开文件处理完成之后记得关闭文件</strong>，使用 <code>fclose()</code> 函数。</p>
<pre><code class="language-c">int fclose(FILE *fp);
</code></pre>
<p>如果成功关闭文件， <code>fclose()</code> 函数返回零，如果关闭文件时发生错误，函数返回  <code>EOF</code> 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。 <code>EOF</code> 是一个定义在头文件 <code>stdio.h</code> 中的常量，上述打开文件函数和关闭文件函数也都在 <code>stdio.h</code> 头文件中。</p>
<pre><code class="language-c">// test.c
#include &lt;stdio.h&gt;
int main()
{
	FILE *fp;	// 文件对象
	fp = fopen("test.txt", "a+"); // 打开文件并把文件指针绑定到该文件
	fclose(fp); // 关闭文件
}
</code></pre>
<h2 id="12-2-写入文件">12.2 写入文件</h2>
<ul>
<li>函数 <code>fputc()</code> ：把参数 <code>c</code> 的字符值写入到 <code>fp</code> 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <code>EOF</code> 。</li>
</ul>
<pre><code class="language-c">int fputc(int c, FILE *fp);
</code></pre>
<ul>
<li>函数 <code>fputs()</code> ：把字符串 <code>s</code> 写入到 <code>fp</code> 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <code>EOF</code> 。</li>
</ul>
<pre><code class="language-c">int fputs(const char *s, FILE *fp);
</code></pre>
<ul>
<li>函数 <code>fprintf</code> ：把一个字符串写入到文件中。该函数形式与 <code>printf</code> 函数类似，参考 <code>printf</code> 函数使用。</li>
</ul>
<pre><code class="language-c">int fprintf(FILE *fp,const char *format, ...) 
</code></pre>
<pre><code class="language-c">// 两函数比较
printf("%d%d", a, b);
fprintf(fp, "%d %d", a, b);
</code></pre>
<h2 id="12-3-读取文件">12.3 读取文件</h2>
<ul>
<li>函数 <code>fgetc()</code> ：从 <code>fp</code> 所指向的输入文件中读取一个字符，返回值是读取的字符，发生错误时返回 <code>EOF</code> 。</li>
</ul>
<pre><code class="language-c">int fgetc(FILE *fp);
</code></pre>
<ul>
<li>函数 <code>fgets()</code> ：从 <code>fp</code> 所指向的输入文件中读取n-1个字符，并把字符串复制到 <code>buf</code> 中，最后追加 <code>NULL</code> 终止字符串。该函数如果在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 <code>EOF</code> ，则只会返回读取到的字符，包括换行符。</li>
</ul>
<pre><code class="language-c">char *fgets(char *buf, int n, FILE *fp );
</code></pre>
<ul>
<li>函数 <code>fscanf()</code> ：从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。该函数形式与 <code>scanf</code> 函数类似，参考 <code>scanf</code> 函数使用，记得添加取地址符 <code>&amp;</code> 。</li>
</ul>
<pre><code class="language-c">int fscanf(FILE *fp, const char *format, ...)
</code></pre>
<pre><code class="language-c">// 两函数比较
scanf("%d%d", &amp;a, &amp;b);
fscanf(fp, "%d%d", &amp;a, &amp;b);
</code></pre>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-07-25</span>
            
                <span>该篇文章被 Fingsinz</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/C/'>
                            C
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            ©2023-2024 Fingsinz&#39;s Space 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>不忘初心，方得始终。</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    
    
    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>


    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


</html>