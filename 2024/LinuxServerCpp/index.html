<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Linux 服务器编程尝试记录 - C++" />
    <meta name="hexo-theme-A4" content="v1.8.9" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Fingsinz&#39;s space | 风信梓</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: white;  
        }
        body {
            color: #000000;
            background: #bed2bb;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #000000;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #000000;
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: white; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: #6b798e;
        }

        .post-md a {
            color: #6b798e;
        }

        .nav li a {
            color: #6b798e;
        }

        .archive-main a:link {
            color: #6b798e;
        }
        .archive-main a:visited {
            color: #6b798e; 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: white;
        }

        .paper {
            background: #bed2bb;
        }

        .index-main {
            background: white;
        }

        .paper-main {
            background: white;
        }

        .wl-panel {
            background: white;
        }

        .archive li:nth-child(odd) {
            background: white;
            ;
        }

        .archive li:nth-child(even) {
            background: white;
        }

        .post-md table tr:nth-child(odd) td {
            background: white;
        }

        .post-md table tr:nth-child(even) td {
            background: white;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #6b798e;
            border-left-color: #6b798e;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Fingsinz&#39;s space</a> 
            <span class="description">我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页🏚️</a></li>
            
        
            
                <li><a href="/list/">文章📄</a></li>
            
        
            
                <li><a href="/categories/">分类📁</a></li>
            
        
            
                <li><a href="/notes/">笔记📔</a></li>
            
        
            
                <li><a href="/funny/">趣事💡</a></li>
            
        
            
                <li><a href="/about/">关于🧑</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Linux 服务器编程尝试记录 - C++
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80-%E4%BB%8Esocket%E5%BC%80%E5%A7%8B"><span class="post-toc-text">一、从socket开始</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="post-toc-text">1.1 服务端干了什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88"><span class="post-toc-text">1.2 客户端如何配合</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-%E8%AF%A5%E8%8A%82%E6%B6%89%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="post-toc-text">1.3 该节涉及函数及源代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8C-%E5%AE%8C%E5%96%84%E4%BB%A3%E7%A0%81-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="post-toc-text">二、完善代码，数据读写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="post-toc-text">2.1 错误检查处理函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="post-toc-text">2.2 数据读写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-%E8%AF%A5%E8%8A%82%E6%B6%89%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="post-toc-text">2.3 该节涉及函数及源代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%89-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8epoll"><span class="post-toc-text">三、高并发使用epoll</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-%E4%BB%8Eselect-poll%E5%88%B0epoll"><span class="post-toc-text">3.1 从select、poll到epoll</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B9%E5%86%99%E6%88%90epoll%E7%89%88%E6%9C%AC"><span class="post-toc-text">3.2 将服务器改写成epoll版本</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9B%9B-%E5%B0%81%E8%A3%85%E6%88%90%E7%B1%BB-%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="post-toc-text">四、封装成类，程序模块化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-%E5%B0%86socket%E5%92%8Cinetaddress%E5%B0%81%E8%A3%85%E6%88%90%E7%B1%BB"><span class="post-toc-text">4.1 将socket和InetAddress封装成类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-%E5%B0%86epoll%E5%B0%81%E8%A3%85%E6%88%90%E7%B1%BB"><span class="post-toc-text">4.2 将epoll封装成类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="post-toc-text">4.3 目录结构及源代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%94-%E5%90%91%E7%9D%80reactor%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8F%98"><span class="post-toc-text">五、向着Reactor模式转变</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-reactor%E5%92%8Cproactor"><span class="post-toc-text">5.1 Reactor和Proactor</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-%E5%8A%A0%E5%85%A5channel%E7%B1%BB"><span class="post-toc-text">5.2 加入Channel类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-%E5%8A%A0%E5%85%A5eventloop%E7%B1%BB"><span class="post-toc-text">5.3 加入EventLoop类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-%E5%8A%A0%E5%85%A5server%E7%B1%BB"><span class="post-toc-text">5.4 加入Server类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%AD-%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%97%E6%8A%BD%E8%B1%A1%E5%8C%96"><span class="post-toc-text">六、把服务器的接受抽象化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-%E6%8A%BD%E8%B1%A1%E5%8C%96%E6%8E%A5%E5%8F%97"><span class="post-toc-text">6.1 抽象化接受</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-acceptor-%E7%B1%BB"><span class="post-toc-text">6.2 Acceptor 类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%83-%E6%8A%8Atcp%E8%BF%9E%E6%8E%A5%E6%8A%BD%E8%B1%A1%E5%8C%96"><span class="post-toc-text">七、把TCP连接抽象化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-%E6%8A%BD%E8%B1%A1%E5%8C%96%E8%BF%9E%E6%8E%A5"><span class="post-toc-text">7.1 抽象化连接</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-connection-%E7%B1%BB"><span class="post-toc-text">7.2 Connection 类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-%E6%94%B9%E5%86%99-server-%E7%B1%BB"><span class="post-toc-text">7.3 改写 Server 类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%AB-%E9%97%B2%E6%9D%A5%E6%97%A0%E4%BA%8B-%E6%95%B4%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="post-toc-text">八、闲来无事，整个缓冲区</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-1-%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="post-toc-text">8.1 引入缓冲区</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-2-buffer%E7%B1%BB"><span class="post-toc-text">8.2 Buffer类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-3-%E5%85%B6%E4%BB%96%E6%96%B9%E9%9D%A2%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="post-toc-text">8.3 其他方面的改进</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B9%9D-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%95%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">九、线程池啊线程池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">9.1 为什么加入线程池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-2-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">9.2 如何设计线程池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86"><span class="post-toc-text">9.3 线程池用到的语法知识</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB"><span class="post-toc-text">9.4 线程池类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8D%81-%E6%9C%89%E4%BA%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8B%E5%90%8E%E7%9A%84%E8%80%83%E8%99%91"><span class="post-toc-text">十、有了线程池之后的考虑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-1-%E5%AE%8C%E5%96%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">10.1 完善线程池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-2-%E5%AE%8C%E5%96%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86"><span class="post-toc-text">10.2 完善线程池用到的语法知识</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-3-%E5%86%8D%E4%BF%AE%E4%BF%AE%E8%A1%A5%E8%A1%A5"><span class="post-toc-text">10.3 再修修补补</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8D%81%E4%B8%80-%E6%94%B9%E5%86%99%E6%88%90%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">十一、改写成主从Reactor多线程模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">11.1 什么是主从Reactor多线程模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-2-%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96"><span class="post-toc-text">11.2 代码上的变化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8D%81%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="post-toc-text">十二、项目工程化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-1-%E8%AE%A4%E8%AF%86cmake"><span class="post-toc-text">12.1 认识Cmake</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-2-%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="post-toc-text">12.2 工程化的实际操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%99%84%E5%BD%95"><span class="post-toc-text">附录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%99%84-1-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="post-toc-text">附 1 - 代码运行环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%99%84-2-cmake%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="post-toc-text">附 2 - CMake的安装和使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%99%84-2-1-%E6%A3%80%E6%9F%A5%E8%BF%9C%E7%A8%8B%E7%9A%84cmake%E7%8E%AF%E5%A2%83%E5%92%8C%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="post-toc-text">附 2.1 检查远程的CMake环境和编译环境</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%99%84-2-2-visual-studio-2022%E4%B8%AD%E4%BD%BF%E7%94%A8cmake%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8Blinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91"><span class="post-toc-text">附 2.2 Visual Studio 2022中使用CMake进行远程Linux服务器开发</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%99%84-2-2-visual-studio-2022%E4%B8%AD%E4%BD%BF%E7%94%A8cmake%E8%BF%9B%E8%A1%8Cwsl%E5%BC%80%E5%8F%91"><span class="post-toc-text">附 2.2 Visual Studio 2022中使用CMake进行WSL开发</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%99%84-2-3-cmake%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="post-toc-text">附 2.3 CMake相关资料</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%99%84-3-%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="post-toc-text">附 3 - 可能出现的问题</span></a></li></ol></li></ol>
            
        
        <div class=".article-gallery"><p>关键词：C++、Linux</p>
<span id="more"></span>
<hr>
<blockquote>
<p><strong>References：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/yuesong-feng/30dayMakeCppServer/">30天自制C++服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/yuesong-feng/pine">配套网络库 pine</a></li>
</ul>
<p><em>Linux下操作。</em></p>
</blockquote>
<h2 id="一-从socket开始">一、从socket开始</h2>
<p>socket，被翻译为套接字，它是计算机之间进行通信的一种约定或一种方式。</p>
<ul>
<li>通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</li>
</ul>
<h3 id="1-1-服务端干了什么">1.1 服务端干了什么</h3>
<p>在服务器端，需要建立一个 socket 套接字，对外提供一个网络通信接口。</p>
<ul>
<li>在 Linux 系统中这个套接字仅仅是一个文件描述符，也就是一个int类型的值。</li>
<li>对套接字的所有操作（包括创建）都是最底层的系统调用。</li>
</ul>
<ol>
<li>创建套接字：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>创建一个 <code>sockaddr_in</code> 结构体并初始化（<code>bzero</code> 函数）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>设置地址族、IP 地址和端口号：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>将 socket 地址与文件描述符绑定：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></tbody></table></figure>
<ol start="5">
<li>使用 <code>listen</code> 函数监听套接字：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd, SOMAXCONN);</span><br></pre></td></tr></tbody></table></figure>
<ol start="6">
<li>服务端想要接受一个客户端连接，需要使用 <code>accept</code> 函数：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line"><span class="type">socklen_t</span> clientAddrLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line"><span class="built_in">bzero</span>(&amp;clientAddr, <span class="built_in">sizeof</span>(clientAddr));</span><br><span class="line"><span class="type">int</span> clientSockfd = <span class="built_in">accept</span>(sockfd, (sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br></pre></td></tr></tbody></table></figure>
<ol start="7">
<li>输出 socket 连接信息：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Client connected: %d!\tIP: %s\tPort: %d\n"</span>, clientSockfd, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), <span class="built_in">ntohs</span>(clientAddr.sin_port));</span><br></pre></td></tr></tbody></table></figure>
<p>至此，客户端已经可以通过 IP 地址和端口号连接到这个 socket 端口了。</p>
<h3 id="1-2-客户端如何配合">1.2 客户端如何配合</h3>
<p>在客户端，也需要建立一个 socket 套接字。</p>
<p>对于客户端，服务器存在的唯一标识是 IP 地址和端口号。此时需要将套接字绑定到一个 IP 地址和端口上。</p>
<ol>
<li>创建套接字：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>创建一个 <code>sockaddr_in</code> 结构体，并绑定 IP 族、IP 地址和端口号：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>使用 <code>connect</code> 函数进行连接：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, (sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></tbody></table></figure>
<p>注意，需要先 <code>./server</code> 运行服务端进行等待，再 <code>./client</code> 运行客户端进行连接请求。</p>
<h3 id="1-3-该节涉及函数及源代码">1.3 该节涉及函数及源代码</h3>
<ul>
<li>相关头文件：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// 创建 socket 所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// socket 地址结构体所需</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建 socket：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span> <span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __domain：IP 地址类型，AF_INET 表示 IPv4，AF_INET6 表示 IPv6。</span></span><br><span class="line"><span class="comment">* __type：数据传输方式，SOCK_STREAM 表示流格式、面向链接，多用于 TCP； SOCK_DGRAM 表示数据报格式、无连接，多用于 UDP。</span></span><br><span class="line"><span class="comment">* __protocol：协议，0 表示根据前面两个参数自动推导协议类型。设置为 IPPROTO_TCP 和 IPPROTO_UDP，分别表示 TCP 和 UDP。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bzero</span> <span class="params">(<span class="type">void</span> *__s, <span class="type">size_t</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __s：指向要清零的内存块的指针。</span></span><br><span class="line"><span class="comment">* __n：要清零的内存块的大小。</span></span><br><span class="line"><span class="comment">* 该函数在头文件 string.h 或 cstring 中。</span></span><br><span class="line"><span class="comment">* Effective C++ - 条款01：视 C++ 为一个语言联邦。写 C 就用 string.h，写 C++ 就用 cstring。</span></span><br><span class="line"><span class="comment">* Effective C++ - 条款04：确定对象被使用前已先被初始化。使用 bzero 进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>绑定函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __addr：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __len：sockaddr 参数的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>listen</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __n：最大监听队列长度，宏定义 SOMAXCONN 为最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>accept</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr, <span class="type">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：服务端的文件描述符。</span></span><br><span class="line"><span class="comment">* __addr`：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __addr_len`：指向 sockaddr 参数大小的指针。因为 accept 需要写入客户端 socket 长度，所以需要地址</span></span><br><span class="line"><span class="comment">* 另外，该函数会阻塞当前程序，直到有一个客户端 socket 被接受后程序才会往下执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>connect</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：客户端的文件描述符。</span></span><br><span class="line"><span class="comment">* __addr：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __len：sockaddr 参数大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day1">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day1">Gitee</a></p>
<h2 id="二-完善代码-数据读写">二、完善代码，数据读写</h2>
<p>上面的代码是基础版的，但要想真正运行使用，需要完善代码，并抓住错误。</p>
<ul>
<li>Effective C++ 中有提到：“别让异常逃离析构函数”（条款08）。</li>
</ul>
<h3 id="2-1-错误检查处理函数">2.1 错误检查处理函数</h3>
<p>对于 Linux 系统调用，常见的错误提示方式是使用返回值和设置错误码。</p>
<ul>
<li>当一个系统调用返回 <code>-1</code>，说明有错误发生。</li>
</ul>
<p>增加一个错误检查处理函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">errorif</span><span class="params">(<span class="type">bool</span> condition, <span class="type">const</span> <span class="type">char</span> *errmsg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (condition)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">perror</span>(errmsg);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第一个参数为判断是否发生错误条件，调用 <code>iostream</code> 中的 <code>perror</code> 打印错误。</li>
<li>第二个参数为错误信息。</li>
<li>然后使用 <code>exit</code> 函数让程序退出并返回一个预定义常量 <code>EXIT_FAILURE</code>。</li>
</ul>
<p>使用就很方便：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">errorif</span>(sockfd == <span class="number">-1</span>, <span class="string">"socket create error"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>对所有函数都进行处理错误：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">errorif</span>(<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">-1</span>, <span class="string">"socket bind error"</span>);</span><br><span class="line"><span class="built_in">errorif</span>(<span class="built_in">listen</span>(sockfd, SOMAXCONN) == <span class="number">-1</span>, <span class="string">"socket listen error"</span>);</span><br><span class="line"><span class="built_in">errorif</span>(clientfd == <span class="number">-1</span>, <span class="string">"socket accept error"</span>);</span><br><span class="line"><span class="built_in">errorif</span>(<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">-1</span>, <span class="string">"socket connect error"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><em>错误的处理是必须的，但处理函数不一定这样写。</em></li>
</ul>
<h3 id="2-2-数据读写">2.2 数据读写</h3>
<p>当建立 socket 连接后，就可以使用 <code>unistd.h</code> 中的 <code>read</code> 和 <code>write</code> 函数进行数据读写。（仅限于 TCP 连接。UDP 连接使用 <code>sendto</code> 和 <code>recvfrom</code> 函数。）</p>
<p>接下来做一个通信情况：客户端向服务端发送一定数据，然后服务端接收后转发回客户端，客户端将接收的转发数据再进行标准输出。</p>
<p>客户端：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">// 持续通信</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];	<span class="comment">// 定义缓冲区</span></span><br><span class="line">	std::cin &gt;&gt; buffer;	<span class="comment">// 从标准输入读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向服务端发送数据</span></span><br><span class="line">	<span class="type">size_t</span> writeLen = <span class="built_in">write</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送失败处理</span></span><br><span class="line">	<span class="keyword">if</span> (writeLen == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Socket already disconnected!\n"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(buffer, <span class="built_in">sizeof</span>(buffer));	<span class="comment">// 清空缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读回数据</span></span><br><span class="line">	<span class="type">size_t</span> readLen = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读数据问题判断</span></span><br><span class="line">	<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; buffer &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Server socket disconnected!\n"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">close</span>(sockfd);</span><br><span class="line">		<span class="built_in">errorif</span>(<span class="literal">true</span>, <span class="string">"socket read error"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>服务端：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 定义并初始化缓冲区</span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">bzero</span>(buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从客户端读取数据</span></span><br><span class="line">	<span class="type">size_t</span> readLen = <span class="built_in">read</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取数据问题判断</span></span><br><span class="line">	<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Message from client:"</span> &lt;&lt; clientfd &lt;&lt; <span class="string">": "</span> &lt;&lt; buffer &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		<span class="built_in">write</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer));	<span class="comment">// 读到后转回客户端</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Client "</span> &lt;&lt; clientfd &lt;&lt; <span class="string">" disconnected\n"</span>;</span><br><span class="line">		<span class="built_in">close</span>(clientfd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">close</span>(clientfd);</span><br><span class="line">		<span class="built_in">errorif</span>(<span class="literal">true</span>, <span class="string">"socket read error"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是：</p>
<ul>
<li>服务端和客户端都可以从对方中读写数据。</li>
<li>使用完一个 <code>fd</code>（文件描述符） 后，记得使用 <code>close</code> 函数进行关闭。</li>
</ul>
<h3 id="2-3-该节涉及函数及源代码">2.3 该节涉及函数及源代码</h3>
<ul>
<li>相关头文件：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>	<span class="comment">// 读写数据等需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"util.h"</span>  	<span class="comment">// 放置错误处理函数</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>write</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __buf：写入缓冲区。</span></span><br><span class="line"><span class="comment">* __n：写入缓冲区大小。</span></span><br><span class="line"><span class="comment">* 返回写入的大小，或-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>read</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __nbytes)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __buf：读取缓冲区。</span></span><br><span class="line"><span class="comment">* __nbytes：读取缓冲区大小。</span></span><br><span class="line"><span class="comment">* 返回读取的大小，-1表示错误，0表示EOF。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>close</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span> <span class="params">(<span class="type">int</span> __fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day2">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day2">Gitee</a></p>
<h2 id="三-高并发使用epoll">三、高并发使用epoll</h2>
<p>之前只写了一个简单的服务器，只能同时处理一个客户端连接。事实上，所有的服务都是高并发的，可以同时为成千上万个客户端提供服务——IO复用。</p>
<ul>
<li>IO 复用和多线程相似，但不是一个概念。
<ul>
<li>IO 复用针对 IO 接口；</li>
<li>多线程针对 CPU。</li>
</ul>
</li>
</ul>
<p>IO 复用的基本思想是事件驱动，服务器同时保持多个客户端 IO 连接。</p>
<ul>
<li>当 IO 上有可读或可写事件发生，表示这个 IO 对应的客户端在请求服务器的服务，服务器应当响应。</li>
<li>Linux 中， IO 复用使用 select、poll 和 epoll 来实现。
<ul>
<li>epoll 相比 select、poll，表现性能更好，更加高效。</li>
</ul>
</li>
</ul>
<h3 id="3-1-从select-poll到epoll">3.1 从select、poll到epoll</h3>
<blockquote>
<p>从实现原理上来说，select 和 poll 采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。epoll_wait 则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插人内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此 epoll_wait 无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。详见《Linux高性能服务器编程-游双，第9章》</p>
</blockquote>
<ul>
<li>当活动连接比较多的时候，epoll_wait 的效率未必比 select 和 poll 高，因为此时回调函数被触发得过于频繁。所以 epoll_wait 适用于连接数量多，但活动连接较少的情况。</li>
</ul>
<p>epoll 是 Linux 特有的 IO 复用函数。</p>
<ul>
<li>使用一组函数完成任务。</li>
<li>把用户关心的文件描述符上的事件放到内核的一个事件表中。
<ul>
<li>而不像 select 和 poll 那样每次调用都重复传入文件描述符或事件集。</li>
</ul>
</li>
<li>需要额外的文件描述符来标识内核中的事件表。</li>
</ul>
<p>创建文件描述符：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* size：内核事件表大小。</span></span><br><span class="line"><span class="comment">* 返回文件描述符，用作其他所有 epoll 系统调用的第一个参数，指定访问的内核事件表。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>操作 epoll 的内核事件表：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* epfd：文件描述符。</span></span><br><span class="line"><span class="comment">* op：操作类型。有 EPOLL_CTL_ADD（往事件表中注册 fd 上的事件）、 </span></span><br><span class="line"><span class="comment">* 				EPOLL_CTL_DEL（修改 fd 上的注册事件）、</span></span><br><span class="line"><span class="comment">* 				EPOLL_CTL_MOD（删除 fd 上的注册事件） 三种。</span></span><br><span class="line"><span class="comment">* fd：文件描述符。</span></span><br><span class="line"><span class="comment">* event：指定事件，是 epoll_event 结构体指针。</span></span><br><span class="line"><span class="comment">* 返回值：成功返回 0，失败返回 -1 并设置错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>而关于 <code>epoll_event</code> 结构体的定义：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">__uint32_t</span> events;	<span class="comment">/*epoll事件*/</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;	<span class="comment">/*用户数据*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *ptr;		<span class="comment">// 指定与fd相关的用户数据</span></span><br><span class="line">	<span class="type">int</span> fd;			<span class="comment">// 指定事件所从属的目标文件描述符</span></span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">} <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>epoll 系列系统调用的主要接口是 <code>epoll_wait</code> 函数，它在一段超时时间内等待一组文件描述符上的事件：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 该函数如果检测到事件，就将所有就绪的事件从内核事件表（epfd指定）中复制到events中。</span></span><br><span class="line"><span class="comment">* epfd：文件描述符。</span></span><br><span class="line"><span class="comment">* events：事件数组。</span></span><br><span class="line"><span class="comment">* maxevents：监听事件数组大小。</span></span><br><span class="line"><span class="comment">* timeout：超时时间，单位为毫秒。</span></span><br><span class="line"><span class="comment">* 返回值：成功返回就绪事件个数，失败返回 -1 并设置错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>epoll 对文件描述符的操作有两种：</p>
<ul>
<li>LT（Level Trigger，电平触发）模式
<ul>
<li>默认的工作模式，相当于效率较高的 poll。</li>
<li>对于采用 LT 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 epoll,_wait 时，epoll_wait 还会再次向应用程序通告此事件，直到该事件被处理。</li>
</ul>
</li>
<li>ET（Edge Trigger，边沿触发）模式
<ul>
<li>对于采用ET工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait 调用将不再向应用程序通知这一事件。可见，ET 模式在很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</li>
<li>ET 模式必须搭配非阻塞式 socket 使用。</li>
</ul>
</li>
</ul>
<p>epoll 的事件有：</p>
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符可读（包括对端 socket 正常关闭）；</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可写；</li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><code>EPOLLET</code>：将 epoll 设为边缘触发模式。</li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完事件后，如果还需要继续监听这个 socket 的情况下，需要再次把这个 socket 加到 epoll 队列里。</li>
</ul>
<h3 id="3-2-将服务器改写成epoll版本">3.2 将服务器改写成epoll版本</h3>
<p>在创建了服务器 socket fd 后，将这个 fd 添加到 epoll。</p>
<ul>
<li>epoll 监听事件的描述符会放在一棵红黑树上，将要监听的 IO 口放入 epoll 红黑树中，就可以监听该 IO 上的事件。</li>
<li>只要这个 fd 上发生可读事件，表示有一个新的客户端连接。</li>
<li>然后 accept 这个客户端并将客户端的 socket fd 添加到 epoll，epoll 会监听客户端 socket fd 是否有事件发生，如果发生则处理事件。</li>
</ul>
<p>所以服务器大概的步骤如下：</p>
<ol>
<li>创建 epoll，同时定义事件数组。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll</span></span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">errorif</span>(epfd == <span class="number">-1</span>, <span class="string">"epoll create error"</span>);</span><br><span class="line"><span class="comment">// 定义事件数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS], ev;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;events, <span class="built_in">sizeof</span>(events));</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>将要监听的 IO 口放入 epoll 中。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ev.data.fd = sockfd;			<span class="comment">// 该 IO 口为服务器 socket fd</span></span><br><span class="line">ev.events = EPOLLIN;			<span class="comment">// 可读</span></span><br><span class="line"><span class="built_in">setnonblocking</span>(sockfd);			<span class="comment">// 设置 sockfd 为非阻塞</span></span><br><span class="line"><span class="comment">// 将服务器 socket fd 注册到 epoll</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>
<p>不断监听 epoll 上的事件并处理。</p>
</li>
<li>
<p>如果监听发生的事件是服务器 socket fd 上的事件，表示有一个新的客户端连接。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (events[i].data.fd == sockfd)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 接收客户端信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新增监听</span></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;ev, <span class="built_in">sizeof</span>(ev));</span><br><span class="line">	ev.data.fd = clientfd;			<span class="comment">// 该 IO 口为客户端 socket fd</span></span><br><span class="line">	ev.events = EPOLLIN | EPOLLET;	<span class="comment">// 客户端连接使用 ET 模式</span></span><br><span class="line">	<span class="built_in">setnonblocking</span>(clientfd);		<span class="comment">// ET 需要搭配非阻塞式 socket 使用</span></span><br><span class="line">	<span class="comment">// 将客户端 socket fd 注册到 epoll</span></span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clientfd, &amp;ev);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="5">
<li>如果监听发生的事件是客户端，并且是可读事件，表示有客户端发送消息：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">// 非阻塞 IO，需要不断读取，直至完毕</span></span><br><span class="line">	{</span><br><span class="line">		<span class="type">ssize_t</span> bytesRead = <span class="built_in">read</span>(events[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正常读取数据</span></span><br><span class="line">		<span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 客户端正常中断，继续读取</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> <span class="keyword">and</span> errno == EINTR)</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 非阻塞 IO，这个条件表示数据全部读取完毕</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> <span class="built_in">and</span> ((errno == EAGAIN) <span class="built_in">or</span> (errno == EWOULDBLOCK)))</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// EOF 事件，一般表示客户端断开连接</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day3">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day3">Gitee</a></p>
<h2 id="四-封装成类-程序模块化">四、封装成类，程序模块化</h2>
<h3 id="4-1-将socket和inetaddress封装成类">4.1 将socket和InetAddress封装成类</h3>
<p>当新建服务器 socket 时，需要完成绑定 IP 地址、监听、接受客户端连接等任务，这些任务都封装成 <code>Socket</code> 类来完成。希望简化成以下操作：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建服务器 socket</span></span><br><span class="line">Socket *serverSocket = <span class="keyword">new</span> <span class="built_in">Socket</span>();</span><br><span class="line"><span class="comment">// 实例化 IP 地址</span></span><br><span class="line">InetAddress *serverAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>(<span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 IP 地址</span></span><br><span class="line">serverSocket-&gt;<span class="built_in">bind</span>(serverAddr);</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">serverSocket-&gt;<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个客户端地址</span></span><br><span class="line">InetAddress *clientAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>();</span><br><span class="line"><span class="comment">// 接受一个客户端连接</span></span><br><span class="line">Socket *clientSocket = <span class="keyword">new</span> <span class="built_in">Socket</span>(serverSocket-&gt;<span class="built_in">accept</span>(clientAddr));</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-2-将epoll封装成类">4.2 将epoll封装成类</h3>
<p>对于 epoll，希望简化操作，封装成类后：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化 epoll</span></span><br><span class="line">Epoll *ep = <span class="keyword">new</span> <span class="built_in">Epoll</span>();</span><br><span class="line"><span class="comment">// 将要监听的 IO 口放入 epoll</span></span><br><span class="line">ep-&gt;<span class="built_in">epoll_add</span>(serverSocket-&gt;<span class="built_in">getFd</span>(), EPOLLIN | EPOLLET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line">	std::vector&lt;epoll_event&gt; events = ep-&gt;<span class="built_in">poll</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ev : events)</span><br><span class="line">		<span class="comment">// 处理事件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-3-目录结构及源代码">4.3 目录结构及源代码</h3>
<p>目录结构如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client.cpp</span><br><span class="line">server.cpp</span><br><span class="line">util.h</span><br><span class="line">util.cpp</span><br><span class="line">Socket.h</span><br><span class="line">Socket.cpp</span><br><span class="line">InetAddress.h</span><br><span class="line">InetAddress.cpp</span><br><span class="line">Epoll.h</span><br><span class="line">Epoll.cpp</span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day4">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day4">Gitee</a></p>
<h2 id="五-向着reactor模式转变">五、向着Reactor模式转变</h2>
<h3 id="5-1-reactor和proactor">5.1 Reactor和Proactor</h3>
<blockquote>
<p>Reactor 翻译过来的意思是「反应堆」，这里的反应指的是「对事件反应」。</p>
<ul>
<li>当来了一个事件，Reactor 就有相对应的反应/响应。</li>
</ul>
<p>事实上，Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 I/O 多路复用监听事件。</p>
<ul>
<li>收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。</li>
</ul>
<p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成。</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ul>
<li>Reactor 的数量可以只有一个，也可以有多个；</li>
<li>处理资源池可以是单个进程 / 线程，也可以是多个进程 / 线程；</li>
</ul>
<p>有 3 个方案都是比较经典的，且都有应用在实际的项目中：</p>
<ul>
<li>单 Reactor 单进程 / 线程；</li>
<li>单 Reactor 多线程 / 进程；</li>
<li>多 Reactor 多进程 / 线程；</li>
</ul>
<p>方案具体使用进程还是线程，要看使用的编程语言以及平台有关：</p>
<ul>
<li>Java 语言一般使用线程，比如 Netty；</li>
<li>C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。</li>
</ul>
<p>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</p>
<p>Proactor 是异步网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p>
<p>因此，Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p>
<p>作者：小林coding<br>
链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26943938/answer/1856426252">https://www.zhihu.com/question/26943938/answer/1856426252</a><br>
来源：知乎著作权归作者所有。</p>
</blockquote>
<p><em>详细请参考游双《Linux高性能服务器编程》第八章第四节、陈硕《Linux多线程服务器编程》第六章第六节。</em></p>
<p>接下来要将服务器向着 Reactor 模式转变：</p>
<ol>
<li>首先将整个服务器抽象成一个 Server 类，这个类中有一个 main-Reactor，里面的核心是一个 EventLoop，这是一个事件循环；</li>
<li>添加需要监听的事务到这个事件循环内，每次有事件发生时就会通知，在程序中返回给 Channel（自封装的类），然后根据不同的描述符、事件类型以回调函数的方式进行处理。</li>
</ol>
<h3 id="5-2-加入channel类">5.2 加入Channel类</h3>
<p>面对服务器许多服务时，不同的连接类型也将决定不同的处理逻辑，仅仅通过一个文件描述符来区分显然会很麻烦。希望得到文件描述符的更多消息。</p>
<ul>
<li>epoll 的 <code>epoll_event</code> 结构体中，<code>data</code> 字段可以放一个 <code>void *</code> 类型的指针，用来保存更多信息。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">} <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> events;		<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;	<span class="comment">/* User data variable */</span></span><br><span class="line">} __EPOLL_PACKED;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>epoll 中的 <code>data</code> 是一个联合类型：
<ul>
<li>可以存储一个指针，指向任何一个地址块的内容；</li>
<li>可以是一个类的对象，就此将一个文件描述符封装成一个 <code>Channel</code> 类，一个 <code>Channel</code> 类始终负责一个文件描述符。对不同的服务、不同的事件类型，都可以在类中进行处理。</li>
</ul>
</li>
</ul>
<p>设计 <code>Channel</code> 类，核心成员如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *loop;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> events;</span><br><span class="line">	<span class="type">uint32_t</span> revents;</span><br><span class="line">	<span class="type">bool</span> isEpoll;</span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>loop</code>：指向与之关联的事件循环的指针。</li>
<li><code>fd</code>：Channel 负责的文件描述符。</li>
<li><code>events</code>：表示希望监听这个文件描述符的哪些事件。</li>
<li><code>revents</code>：表示在 <code>epoll</code> 返回该 <code>Channel</code> 时文件描述符正在发生的事件。</li>
<li><code>isEpoll</code>：表示当前 <code>Channel</code> 是否已经添加到 <code>epoll</code> 红黑树中，区分使用 <code>EPOLL_CTL_ADD</code> 还是 <code>EPOLL_CTL_MOD</code>。</li>
<li><code>callback</code>：发生事件时执行的回调函数。</li>
</ul>
<p>添加 Channel 类可以更加方便简单、多样化地处理 epoll 中发生的事件。同时脱离了底层，将 epoll、文件描述符和事件进行了抽象，形成了事件分发的模型，这也是 Reactor 模式的核心。</p>
<h3 id="5-3-加入eventloop类">5.3 加入EventLoop类</h3>
<p>EventLoop 类的定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Epoll *ep;</span><br><span class="line">    <span class="type">bool</span> quit;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel*)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>ep</code>：指向Epoll类实例的指针；</li>
<li><code>quit</code>：指示程序是否应该退出；</li>
<li><code>loop()</code>：事件循环函数，调用开始事件驱动，即原来调用 <code>epoll_wait</code> 函数的死循环；</li>
<li><code>updateChannel()</code>：更新 Channel。</li>
</ul>
<p>将需要监听的事务加入到事件循环中，每次有事件发生就会通知，返回到 Channel，然后根据不同的描述符、事件类型以回调函数方式进行处理：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (!quit)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 使用epoll实例轮询事件</span></span><br><span class="line">		std::vector&lt;Channel *&gt; channels = ep-&gt;<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理每个Channel的事件</span></span><br><span class="line">		<span class="keyword">for</span> (Channel *channel : channels)</span><br><span class="line">			channel-&gt;<span class="built_in">handleEvent</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-4-加入server类">5.4 加入Server类</h3>
<p>服务器类 <code>Server</code> 的核心成员如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *loop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(EventLoop*);</span><br><span class="line">    ~<span class="built_in">Server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleReadEvent</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(Socket *serv_sock)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>loop</code>：事件循环对象。</li>
<li><code>handleReadEvent()</code>：处理读事件。</li>
<li><code>newConnection()</code>：处理新连接。</li>
</ul>
<p>之后启动服务器的操作抽象为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *loop = <span class="keyword">new</span> <span class="built_in">EventLoop</span>();</span><br><span class="line">Server *server = <span class="keyword">new</span> <span class="built_in">Server</span>(loop);</span><br><span class="line">loop-&gt;<span class="built_in">loop</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>这个版本服务器内只有一个 <code>EventLoop</code>，当其中有可读事件发生时，可以拿到该描述符对应的 <code>Channel</code>。</p>
<p>在新建 Channel 时，根据 Channel 描述符的不同分别绑定了两个回调函数：</p>
<ul>
<li><code>newConnection()</code> 函数被绑定到服务器socket上；
<ul>
<li>如果服务器 socket 有可读事件，Channel 里的 <code>handleEvent()</code> 函数实际上会调用 Server 类的 <code>newConnection()</code> 新建连接。</li>
</ul>
</li>
<li><code>handlrReadEvent()</code> 被绑定到新接受的客户端socket上。
<ul>
<li>如果客户端 socket 有可读事件，Channel 里的 <code>handleEvent()</code> 函数实际上会调用 Server 类的 <code>handleReadEvent()</code> 响应客户端请求。</li>
</ul>
</li>
</ul>
<p>至此，根据抽象出的 <code>EventLoop</code> 和 <code>Channel</code>，构成了事件驱动模型。这两个类和服务器核心 <code>Server</code> 已经没有任何关系，经过完善后可以被任何程序复用，达到了事件驱动的设计思想，现在的服务器也可以看成一个最简易的 Reactor 模式服务器。</p>
<p><em>需要注意的是，目前该服务器的内存管理一塌糊涂。</em></p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day5">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day5">Gitee</a></p>
<h2 id="六-把服务器的接受抽象化">六、把服务器的接受抽象化</h2>
<h3 id="6-1-抽象化接受">6.1 抽象化接受</h3>
<p>服务器中，对于每一个事件，首先都是调用 <code>accept()</code> 函数去接受一个 TCP 连接，然后把 Socket 文件描述符添加到 epoll。当这个 IO 口有事件发生时，对该连接提供相应的服务。</p>
<p>分离接受连接这个功能，添加 <code>Acceptor</code> 类。</p>
<h3 id="6-2-acceptor-类">6.2 Acceptor 类</h3>
<p>Acceptor 类应该有以下特点：</p>
<ul>
<li>类中有一个 Socket fd，就是服务器监听的 Socket fd，每一个<br>
Acceptor 对象都对应一个 Socket fd。</li>
<li>类存在于事件驱动 <code>EventLoop</code> 类中。</li>
<li>类也通过一个 <code>Channel</code> 负责分发到 epoll，该 <code>Channel</code> 的事件处理函数 <code>handleEvent()</code> 会调用 <code>Acceptor</code> 类中的连接函数进行新建一个 TCP 连接。</li>
</ul>
<p>将新建连接的逻辑就在 Acceptor 类中。但逻辑上新 Socket 建立后就和之前的监听的服务器 Socket 没有任何关系了。</p>
<p>新的 TCP 连接应该由 Server 类来创建并管理生命周期，而不是 Acceptor。并且将一部分代码放在 Server 类里也并没有打破服务器的通用性，因为对于所有的服务，都要使用 Acceptor 来建立连接。</p>
<ul>
<li><code>Acceptor</code> 类的新建连接功能是在 <code>Server</code> 类中实现的。</li>
</ul>
<p>可以使用 <code>std::function</code>、<code>std::bind</code>、右值引用、<code>std::move</code> 等实现函数回调。</p>
<p>定义该类：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 用于事件处理的EventLoop指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于处理套接字操作的套接字指针</span></span><br><span class="line">	Socket *sock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于存储地址信息的指针</span></span><br><span class="line">	InetAddress *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于接受连接的 Channel 指针</span></span><br><span class="line">	Channel *acceptChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 定义一个新建连接的回调函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; newConnectionCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Acceptor</span>(EventLoop *_loop);</span><br><span class="line">	~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 接受新连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">acceptConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置新连接的回调函数。</span></span><br><span class="line"><span class="comment">	 * @param _callback 为新连接设置的回调函数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; _callback)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>抽象后，Server类的变化如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器套接字</span></span><br><span class="line">	Socket *serverSock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器地址</span></span><br><span class="line">	InetAddress *serverAddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器通道</span></span><br><span class="line">	Channel *serverChannel;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存客户端的套接字</span></span><br><span class="line">	std::vector&lt;std::pair&lt;Socket *, InetAddress *&gt;&gt; clients;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向Acceptor对象的指针</span></span><br><span class="line">	Acceptor *acceptor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day6">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day6">Gitee</a></p>
<h2 id="七-把tcp连接抽象化">七、把TCP连接抽象化</h2>
<h3 id="7-1-抽象化连接">7.1 抽象化连接</h3>
<p>对于 TCP 协议，在三次握手新建连接后，该连接回一直存在直至四次挥手断开连接。</p>
<p>那么把这个连接也抽象化，抽象成 <code>Connection</code> 类。</p>
<h3 id="7-2-connection-类">7.2 Connection 类</h3>
<p>Connection 类应该有以下特点：</p>
<ul>
<li>类存在于事件驱动类中；</li>
<li>类的 Socket fd 就是客户端的 Socket fd，每一个<br>
Connection 对象都对应一个 Socket fd。</li>
<li>类也通过一个 <code>Channel</code> 负责分发到 epoll，该 <code>Channel</code> 的事件处理函数 <code>handleEvent()</code> 会调用 <code>Connection</code> 类中的事件处理函数进行响应客户端请求。</li>
</ul>
<p><code>Connection</code> 类与 <code>Acceptor</code> 类十分相似，它们都由 <code>Server</code> 管理，由一个 <code>Channel</code> 分发到 epoll，通过回调函数处理响应事件。</p>
<p>一个高并发服务器一般只有一个 <code>Acceptor</code>（可以有多个），但会同时有成千上万个 TCP 连接，也就是 <code>Connection</code> 的实例。</p>
<p>对 <code>Connection</code> 类的定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *loop;</span><br><span class="line">	Socket *sock;</span><br><span class="line">	Channel *channel;</span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; deleteConnectionCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(EventLoop *_loop, Socket *_sock);</span><br><span class="line">	~<span class="built_in">Connection</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 回显sockfd发来的数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 设置删除连接时要调用的回调函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; _callback)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-3-改写-server-类">7.3 改写 Server 类</h3>
<p><code>Server</code> 类的核心变成：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向Acceptor对象的指针</span></span><br><span class="line">	Acceptor *acceptor;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">	std::map&lt;<span class="type">int</span>, Connection *&gt; connections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(EventLoop *_loop);</span><br><span class="line">	~<span class="built_in">Server</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 处理客户端请求，暂时没有</span></span><br><span class="line">	<span class="comment">// void handleReadEvent(int fd);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 处理与所提供套接字的新连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(Socket *_socket)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 断开与提供的套接字关联的连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteConnection</span><span class="params">(Socket *_socket)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>Map</code> 映射将众多连接保存起来，键为该连接客户端的 <code>socket fd</code>，值为指向该连接的指针。</li>
<li>该连接客户端的 <code>socket fd</code> 通过一个 <code>Channel</code> 类分发到 <code>epoll</code>，该 <code>Channel</code> 的事件处理回调函数 <code>handleEvent()</code> 绑定为 <code>Connection</code> 的处理函数，这样每当该连接的 <code>socket fd</code> 上发生事件，就会通过 <code>Channel</code> 调用具体连接类的处理函数。</li>
</ul>
<p>此处将新建连接的功能放回到 <code>Acceptor</code> 类中管理：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::acceptConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 创建一个新的InetAddress对象来存储客户端地址信息</span></span><br><span class="line">	InetAddress *clientAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过使用客户端地址接受来自服务器套接字的连接，创建一个新的Socket对象</span></span><br><span class="line">	Socket *clientSock = <span class="keyword">new</span> <span class="built_in">Socket</span>(sock-&gt;<span class="built_in">accept</span>(clientAddr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印有关新客户端连接的信息</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">"New client "</span> &lt;&lt; clientSock-&gt;<span class="built_in">getFd</span>() &lt;&lt; <span class="string">": "</span> &lt;&lt;</span><br><span class="line">		<span class="built_in">inet_ntoa</span>(clientAddr-&gt;addr.sin_addr) &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="built_in">ntohs</span>(clientAddr-&gt;addr.sin_port) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">	clientSock-&gt;<span class="built_in">setNonBlocking</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">newConnectionCallback</span>(clientSock);</span><br><span class="line">	<span class="keyword">delete</span> clientAddr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>Server</code> 类变得只负责管理 <code>Acceptor</code> 和 <code>Connection</code> 类，其成员函数也集中在管理 <code>Acceptor</code> 和 <code>Connection</code> 类中。改写后的 <code>Server</code> 类代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::newConnection</span><span class="params">(Socket *_socket)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(loop, _socket);</span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; cb = std::<span class="built_in">bind</span>(&amp;Server::deleteConnection, <span class="keyword">this</span>, std::placeholders::_1);</span><br><span class="line">	conn-&gt;<span class="built_in">setDeleteConnectionCallback</span>(cb);</span><br><span class="line">	connections[_socket-&gt;<span class="built_in">getFd</span>()] = conn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::deleteConnection</span><span class="params">(Socket *_socket)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Connection *conn = connections[_socket-&gt;<span class="built_in">getFd</span>()];</span><br><span class="line">	connections.<span class="built_in">erase</span>(_socket-&gt;<span class="built_in">getFd</span>());</span><br><span class="line">	<span class="keyword">delete</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当有新的 TCP 连接时，实例化一个 <code>Connection</code> 对象，设置其删除时的回调函数，并放置在 <code>connections</code> 中管理。
<ul>
<li>目前该服务器的唯一功能——接受客户端的信息并发回，封装成 <code>Connection</code> 类的 <code>echo</code> 函数，在 <code>Connection</code> 构造时绑定给 <code>Channel</code> 类的事件回调函数，由 <code>Channel</code> 实例遇到事件时触发。</li>
</ul>
</li>
<li>当有 TCP 连接断开时，从 <code>connections</code> 中删除该连接，并释放对象。
<ul>
<li>由于 <code>Connection</code> 的生命周期由 <code>Server</code> 进行管理，所以也应该由 <code>Server</code> 来删除连接</li>
</ul>
</li>
</ul>
<p>至此，服务器到了一个比较重要的阶段，服务器最核心的几个模块都已经抽象出来，一个完整的单线程服务器设计基本完成。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day7">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day7">Gitee</a></p>
<h2 id="八-闲来无事-整个缓冲区">八、闲来无事，整个缓冲区</h2>
<h3 id="8-1-引入缓冲区">8.1 引入缓冲区</h3>
<p>此节引入一个最简单、最基本的缓冲区，完善改进之前的服务器。</p>
<p>没有使用缓冲区时，服务器回送信息的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">char</span> buf[READ_BUFFER];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">ssize_t</span> readLen = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			std::cout &lt;&lt; buf &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="built_in">write</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是非阻塞式 socket IO 的读取，缓冲区大小为 1024，表示每次 TCP 缓冲区读取 1024 大小的数据到缓冲区，然后发送到客户端。</li>
<li>只能以 1024 地读，当数据没有 1024，用空值补满。</li>
</ul>
<p>所以，封装一个缓冲区，为每一个 <code>Connection</code> 类分配一个读缓冲区和写缓冲区：</p>
<ul>
<li>从客户端读来的数据存放在都缓冲区。</li>
</ul>
<h3 id="8-2-buffer类">8.2 Buffer类</h3>
<p><code>Buffer</code> 类的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 向当前字符串追加一个字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str, <span class="type">int</span> _size)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 返回当前缓冲区字符串大小</span></span><br><span class="line">	<span class="function"><span class="type">ssize_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief返回指向底层字符串数据的指针</span></span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="type">const</span> *<span class="title">c_str</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 清空当前缓冲区字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 从控制台获取输入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getline</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>使用如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/Connection.cpp */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">ssize_t</span> readLen = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			readBuffer-&gt;<span class="built_in">append</span>(buf, readLen);	<span class="comment">// 缓冲区追加</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span> <span class="keyword">and</span> errno == EINTR)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span> <span class="built_in">and</span> ((errno == EAGAIN) <span class="built_in">or</span> (errno == EWOULDBLOCK)))</span><br><span class="line">		{	<span class="comment">// 从缓冲区中读取数据，同时进行回写</span></span><br><span class="line">			std::cout &lt;&lt; readBuffer-&gt;<span class="built_in">c_str</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="built_in">errorif</span>(<span class="built_in">write</span>(sockfd, readBuffer-&gt;<span class="built_in">c_str</span>(), readBuffer-&gt;<span class="built_in">size</span>()) == <span class="number">-1</span>, <span class="string">"***"</span>);</span><br><span class="line">			readBuffer-&gt;<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">deleteConnectionCallback</span>(sock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>虽然仍有 <code>char buf[1024]</code> 这样的低级缓冲区，用于系统调用 <code>read()</code> 的读取，但这个缓冲区大小无所谓，设置为1到设备TCP缓冲区的大小都可以。</p>
<ul>
<li>太大导致资源浪费，单词读取速度低；</li>
<li>太小导致读取次数增多。</li>
</ul>
<p>以上代码会把 socket IO 上的可读数据全部读取到缓冲区，缓冲区大小就等于客户端发送的数据大小。全部读取完成之后，可以构造一个写缓冲区、填好数据发送给客户端。</p>
<ul>
<li>由于是echo服务器，所以这里使用了相同的缓冲区。</li>
</ul>
<h3 id="8-3-其他方面的改进">8.3 其他方面的改进</h3>
<ul>
<li>
<p>优化 InetAddress 类，将成员私有化，提供访问方法。（—— <code>src/InetAddress.h</code> 和 <code>src/InetAddress.cpp</code>）</p>
</li>
<li>
<p>Socket 类添加 <code>connect</code> 方法，方便 <code>client.cpp</code> 调用。（—— <code>src/Socket.h</code> 和 <code>src/Socket.cpp</code>）</p>
</li>
<li>
<p>结合现有的模块，改进 client 文件。（—— <code>client.cpp</code>）</p>
</li>
<li>
<p>整体改进了了输出信息提示。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-1.jpg" title="服务器端" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-1.jpg" alt="服务器端"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-2.jpg" title="客户端" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-2.jpg" alt="客户端"></a></p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day8">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day8">Gitee</a></p>
<h2 id="九-线程池啊线程池">九、线程池啊线程池</h2>
<h3 id="9-1-为什么加入线程池">9.1 为什么加入线程池</h3>
<p>当前的代码是单线程模式，所有 fd 上的事件都由一个线程（主线程，EventLoop线程）处理。</p>
<ul>
<li>假设响应一个事件需要 1s，那么如果有 1000 个事件，那么主线程就要等待很久。</li>
<li>这不现实。</li>
</ul>
<p>引入多线程，当发现 socket fd 有事件时，应该分发一个工作线程。</p>
<ul>
<li>由这个工作线程处理 fd 上的事件。</li>
</ul>
<p>再者，每一个 Reactor 只应该负责事件分发而不负责事件处理。</p>
<h3 id="9-2-如何设计线程池">9.2 如何设计线程池</h3>
<p>最简单的想法就是，每次遇到一个新的任务，就开一个新线程去执行。</p>
<ul>
<li>这种方式虽然简单，但是太粗暴了。</li>
<li>我们的机器是有上限的，不可能无限开新线程。</li>
</ul>
<p>那么，可以固定一个线程的数量。启动固定数量的工作线程，然后将任务添加到任务队列，工作线程不断取出任务队列的任务执行。</p>
<p>设计线程池还需要注意：</p>
<ol>
<li>多线程环境下任务队列的读写应该考虑互斥锁。</li>
<li>当任务队列为空时，CPU 不应该一直轮询耗费 CPU 资源。</li>
</ol>
<p>此处解决方法如下：</p>
<ol>
<li><code>std::mutex</code> 对任务队列进行加锁解锁。</li>
<li><code>std::condition_variable</code> 使用条件变量。</li>
</ol>
<h3 id="9-3-线程池用到的语法知识">9.3 线程池用到的语法知识</h3>
<p><strong>关于互斥锁：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/mutex">mutex头文件 - cppreference</a></strong></p>
<ul>
<li><code>mutex</code> 类是能用于保护共享数据免受从多个线程同时访问的同步原语。</li>
<li><code>lock()</code>：成员函数，锁定互斥体，若互斥体不可用则阻塞。位于头文件 <code>&lt;mutex&gt;</code>。
<ul>
<li>通常不直接调用 <code>lock()</code>。</li>
<li>用 <code>std::unique_lock</code> 与 <code>std::lock_guard</code> 管理排他性锁定。</li>
<li><code>unique_lock</code> 类是一种通用互斥包装器，允许延迟锁定、有时限的锁定尝试、递归锁定、所有权转移和与条件变量一同使用。</li>
<li>构造函数：<code>explicit unique_lock( mutex_type&amp; m );</code>，通过调用 <code>m.lock()</code> 锁定关联互斥体。</li>
<li>析构函数：若拥有关联互斥体且获得了其所有权，则解锁互斥体。</li>
</ul>
</li>
<li><code>try_lock()</code>：成员函数，尝试锁定互斥体，若互斥体不可用则返回 <code>false</code>。位于头文件 <code>&lt;mutex&gt;</code>。</li>
<li><code>unlock()</code>：成员函数，解锁互斥体。位于头文件 <code>&lt;mutex&gt;</code>。</li>
</ul>
<p><strong>关于线程等待条件：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/condition_variable">condition_variable头文件 - cppreference</a></strong></p>
<ul>
<li><code>std::condition_variable</code>（线程等待条件） 是与 <code>std::mutex</code> 一起使用的同步原语。</li>
<li>它能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 <code>std::condition_variable</code>。</li>
<li>有意修改变量的线程必须：
<ol>
<li>获得 <code>std::mutex</code>（常通过 <code>std::lock_guard</code>）</li>
<li>在保有锁时进行修改</li>
<li>在 <code>std::condition_variable</code> 上执行 <code>notify_one</code> 或 <code>notify_all</code>（可以释放锁后再通知）</li>
</ol>
</li>
<li>任何有意在 <code>std::condition_variable</code> 上等待的线程必须：
<ol>
<li>在用于保护共享变量的互斥体上获得 <code>std::unique_lock&lt;std::mutex&gt;</code>。</li>
<li>执行下列之一：
<ul>
<li>检查条件，是否为已更新且已提醒的情况。</li>
<li>调用 <code>std::condition_variable</code> 的 <code>wait</code>、<code>wait_for</code> 或 <code>wait_until</code>（原子地释放互斥体并暂停线程的执行，直到条件变量被通知，时限过期，或发生虚假唤醒，然后在返回前自动获得互斥体）。</li>
<li>检查条件，并在未满足的情况下继续等待。</li>
</ul>
</li>
</ol>
</li>
<li><code>wait()</code>：成员函数，阻塞当前进程，直至条件变量被唤醒。位于头文件 <code>&lt;condition_variable&gt;</code>。
<ul>
<li>类似还有<code>wait_for</code>、<code>wait_until</code>。不多说，自行查阅。</li>
</ul>
</li>
<li><code>notify_one()</code>：成员函数，通知一个等待的线程。位于头文件 <code>&lt;condition_variable&gt;</code>。</li>
<li><code>notify_all()</code>：成员函数，通知所有等待的线程。位于头文件 <code>&lt;condition_variable&gt;</code>。</li>
</ul>
<h3 id="9-4-线程池类">9.4 线程池类</h3>
<p>线程池类代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 线程池中的线程</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">// 要执行的函数</span></span><br><span class="line">	std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line">	<span class="comment">// 声明互斥锁以同步对任务队列的访问</span></span><br><span class="line">	std::mutex tasksMtx;</span><br><span class="line">	<span class="comment">// 声明在线程之间进行协调的条件变量</span></span><br><span class="line">	std::condition_variable cv;</span><br><span class="line">	<span class="comment">// 指示线程停止的标志</span></span><br><span class="line">	<span class="type">bool</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadPool</span>(<span class="type">int</span> size = <span class="number">10</span>);</span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 加入任务到任务队列中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>线程池的构造函数设计为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> size) : <span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++ i)</span><br><span class="line">	{</span><br><span class="line">		threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">thread</span>([<span class="keyword">this</span>] ()</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">				{</span><br><span class="line">					std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">					{<span class="comment">// 使用作用域生命期解锁 std::mutex，而不调用unlock()</span></span><br><span class="line">						std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(tasksMtx);</span><br><span class="line">						<span class="comment">// 当任务队列不为空或线程池停止时停止等待（阻塞）</span></span><br><span class="line">						cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] (){</span><br><span class="line">								<span class="keyword">return</span> stop <span class="keyword">or</span> !tasks.<span class="built_in">empty</span>();</span><br><span class="line">							});</span><br><span class="line">						<span class="keyword">if</span> (stop <span class="keyword">and</span> tasks.<span class="built_in">empty</span>())	<span class="comment">// 任务队列为空且线程池停止，退出循环</span></span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						task = tasks.<span class="built_in">front</span>();</span><br><span class="line">						tasks.<span class="built_in">pop</span>();</span><br><span class="line">					}</span><br><span class="line">					<span class="built_in">task</span>();	<span class="comment">// 执行任务</span></span><br><span class="line">				}</span><br><span class="line">			}));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>初始线程池大小为 <code>size</code>，创建线程并让每个线程等待将任务添加到任务队列中。</li>
<li>使用 <code>std::unique_lock</code> 锁定任务互斥锁以防止并发访问，并将其置于局部作用域，当离开作用域时，它将自动解锁互斥锁。</li>
<li>当添加任务时，线程从队列中获取任务并执行它。线程将继续执行任务，直到线程池停止。</li>
</ol>
<p>析构函数设计为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">{</span><br><span class="line">	{</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(tasksMtx)</span></span>;</span><br><span class="line">		stop = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	cv.<span class="built_in">notify_all</span>();	<span class="comment">// 通知所有等待的线程线程池正在停止</span></span><br><span class="line">	<span class="keyword">for</span> (std::thread &amp;th : threads)</span><br><span class="line">	{	<span class="comment">// 检查线程是否可接合</span></span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();	<span class="comment">// 阻塞当前线程，直到指定线程完成其执行</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在线程池析构时，需要注意将已经添加的所有任务执行完，最好不采用外部的暴力kill、而是让每个线程从内部自动退出，具体实现参考源代码。</li>
</ul>
<ol>
<li>在上锁的情况下，把线程池的停止状态设置为<code>true</code>，然后通知所有等待的线程线程池正在停止。</li>
<li>然后，等待所有线程完成其执行。</li>
</ol>
<p>加入线程池后，当 <code>Channel</code> 类有事件需要处理时，将这个事件处理添加到线程池，主线程 <code>EventLoop</code> 就可以继续进行事件循环，而不在乎某个 <code>socket fd</code> 上的事件处理。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day9">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day9">Gitee</a></p>
<h2 id="十-有了线程池之后的考虑">十、有了线程池之后的考虑</h2>
<h3 id="10-1-完善线程池">10.1 完善线程池</h3>
<p>上一节添加的线程池是最简单的线程池，还存在许多问题，比如：</p>
<ul>
<li>任务队列的添加、取出都会有不必要的拷贝操作；</li>
<li>线程池只接受 <code>std::function&lt;void&gt;</code> 类型的参数，所有函数参数都要事先使用 <code>std::bind()</code>，并且无法得到返回值。</li>
</ul>
<p>解决方法一一对应：</p>
<ul>
<li>使用右值移动去避免拷贝操作。</li>
<li>改写 <code>add()</code> 函数，希望使用前不需要手动绑定参数，直接传递并且可以得到任务的返回值。</li>
</ul>
<h3 id="10-2-完善线程池用到的语法知识">10.2 完善线程池用到的语法知识</h3>
<p><strong>关于模板编程：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/templates-cpp?view=msvc-170">模板 - MSLearn</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/655902377">理解C++模板 - 知乎</a></strong></p>
<ul>
<li>简单来说，模板编程就是提供了一套模具，对于不同的数据类型都可以适用于这套模具。</li>
<li>函数模板的结构一般如下：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 返回类型 函数名(参数列表){ <span class="comment">/*函数的主体*/</span> }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>类模板结构一般如下：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> 类名 {}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/394184676">变长参数模板</a>：参数个数和类型都可能发生变化的模板。
<ul>
<li>使用模板形参包实现。</li>
<li>模板形参包是可以接受 0 个或者 n 个模板实参的模板形参，至少有一个模板形参包的模板就可以称作变参数模板。</li>
<li>模板形参包有：非类型模板形参包、类型模板形参包、模板模板形参包三种。</li>
<li>此节使用类型模板形参包：表示该可变形参包可以接受无限个不同的实参类型。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span>... Args 或 <span class="keyword">class</span> ... Args</span><br></pre></td></tr></tbody></table></figure>
<p><strong>关于右值和移动 <code>std::move</code>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/reyas/article/details/137735522">C++引用和右值引用 - CSDN</a>、<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2341672">【C++】C++11——左右值|右值引用|移动语义|完美转发</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move - 知乎</a></strong></p>
<ul>
<li>C++11 后增加了移动语义，出现了移动构造、移动赋值等。</li>
<li>简单来说，移动语义的出现，可以把旧对象所拥有的资源交给新对象，而旧对象什么都没有了。</li>
<li>右值引用的出现也是为了移动语义。</li>
</ul>
<p><strong>关于完美转发 <code>std::forward</code>：</strong></p>
<ul>
<li>和 <code>std::move</code> 类似，与 <code>std::move</code>相比，它更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</li>
<li><code>std::forward&lt;T&gt;(u)</code> 有两个参数：<code>T</code> 与 <code>u</code>。
<ul>
<li>当 <code>T</code> 为左值引用类型时，<code>u</code> 将被转换为 <code>T</code> 类型的左值；</li>
<li>否则 <code>u</code> 将被转换为 <code>T</code> 类型右值。</li>
</ul>
</li>
</ul>
<p><strong>关于 <code>std::future</code>：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/future">future - cppreference</a></strong></p>
<ul>
<li>类模板 <code>std::packaged_task</code> 可以包装任何可调用 (Callable) 目标（函数、lambda 表达式、bind 表达式或其他函数对象），使得能异步调用它。其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。
<ul>
<li>成员函数 <code>get_future()</code>，返回与 <code>*this</code> 共享同一共享状态的 <code>future</code>，每个 <code>packaged_task</code> 对象只能调用一次。</li>
</ul>
</li>
<li>类模板 <code>std::future</code>：<code>future</code> 对象提供访问异步操作结果的机制，从异步任务中返回结果。</li>
<li>类模板 <code>std::future</code> 提供访问异步操作结果的机制：
<ul>
<li>（通过 <code>std::async</code>、<code>std::packaged_task</code> 或 <code>std::promise</code> 创建的）异步操作能提供一个 <code>std::future</code> 对象给该异步操作的创建者。</li>
<li>然后，异步操作的创建者可以使用多个方法查询、等待或从 <code>std::future</code> 提取值。若异步操作尚未提供值，则这些方法可能阻塞。</li>
<li>当异步操作准备好发送结果给创建者时，它可以修改与创建者的 <code>std::future</code> 相链接的共享状态（例如 <code>std::promise::set_value</code>）。</li>
</ul>
</li>
</ul>
<h3 id="10-3-再修修补补">10.3 再修修补补</h3>
<p>除了上面线程池的部分有修改，以下部分也有修改：</p>
<p>Channel 部分：</p>
<ul>
<li>新增标记位和是否使用线程池的函数；</li>
<li>对于处理事件区分了读事件和写事件分别的回调函数；</li>
<li>新增可选择性 epoll ET 模式或 epoll LT 模式；</li>
</ul>
<p>Acceptor 部分：因为接受连接处理时间短、报文数据小，也不会有同时到达的新连接，所以</p>
<ul>
<li>Acceptor 的 socket fd （服务器监听 socket）使用阻塞式：</li>
<li>Acceptor 从 epoll ET 模式改为 epoll LT 模式，建立好连接后处理事件 fd 读写用 ET 模式。</li>
<li>Acceptor 的连接建立不适用线程池，建立好连接后处理事件使用线程池。</li>
</ul>
<p>Connection 部分：</p>
<ul>
<li>新增 <code>send()</code> 函数，独立发送数据。</li>
<li>修改 <code>deleteConnectionCallback()</code> 函数，参数类型改为 <code>int</code>。</li>
</ul>
<p>Epoll 部分：</p>
<ul>
<li>新增 <code>deleteChannel()</code> 函数，用于删除 Channel。</li>
</ul>
<p>Server 部分：</p>
<ul>
<li>新增 <code>deleteConnection()</code> 函数。</li>
</ul>
<p>更多细节上的变化（可能有部分错误处理、变量变化）可比较前一天的文件。</p>
<p><em>服务器中还可能有潜在的bug。</em></p>
<p>最后，添加测试连接的程序 <code>test.cpp</code>，使用命令 <code>make t</code> 编译，使用如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test -t 1000 -m 10 -w 100</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-t</code> 表示线程数量，此处为 1000 个线程进行服务器连接；</li>
<li><code>-m</code> 表示每个线程的回显次数，此处为每个线程回显 10 次；</li>
<li><code>-w</code> 表示每个线程的等待时间，可以测试最大连接数，可以不设置。</li>
</ul>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day10">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day10">Gitee</a></p>
<h2 id="十一-改写成主从reactor多线程模式">十一、改写成主从Reactor多线程模式</h2>
<h3 id="11-1-什么是主从reactor多线程模式">11.1 什么是主从Reactor多线程模式</h3>
<p>现在实现的服务器多线程 Reactor 模式，是给每一个 Channel 的任务分配一个线程执行。但目前的线程池对象置于 EventLoop 中，而不是由服务器类 Server 类管理。</p>
<p>主从 Reactor 多线程模式是大多数高性能服务器采用的模式。</p>
<blockquote>
<p>陈硕《Linux多线程服务器编程》书中的 one loop per thread 模式。</p>
</blockquote>
<p>该模式的特点有：</p>
<ul>
<li>服务器一般只有一个 main Reactor，有多个 sub Reactor。</li>
<li>服务器管理一个线程池，每一个 sub Reactor 由一个线程来负责 Connection 上的事件循环，事件执行也在这个线程中完成。</li>
<li>main Reactor 只负责 Acceptor 建立新连接，然后将这个连接分配给一个 sub Reactor。</li>
</ul>
<h3 id="11-2-代码上的变化">11.2 代码上的变化</h3>
<p>根据主从 Reactor 多线程模式的特点，将服务器类重写如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *mainReactor;						<span class="comment">// 只负责接受连接，然后分发给一个subReactor</span></span><br><span class="line">	Acceptor *acceptor;							<span class="comment">// 连接接受器</span></span><br><span class="line">	std::vector&lt;EventLoop *&gt; subReactors;		<span class="comment">// 负责处理事件循环</span></span><br><span class="line">	std::map&lt;<span class="type">int</span>, Connection *&gt; connections;	<span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">	ThreadPool *threadPool;						<span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在有一个新连接到来时，采用随机调度策略分配给一个 subReactor：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> random = _socket-&gt;<span class="built_in">getFd</span>() % subReactors.<span class="built_in">size</span>();</span><br><span class="line">Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(subReactors[random], _socket);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这种调度算法适用于每个socket上的任务处理时间基本相同，可以让每个线程均匀负载。但事实上，不同的业务传输的数据极有可能不一样，也可能受到网络条件等因素的影响，极有可能会造成一些 subReactor 线程十分繁忙，而另一些 subReactor 线程空空如也。此时需要使用更高级的调度算法，如根据繁忙度分配，或支持动态转移连接到另一个空闲 subReactor 等。</li>
</ul>
<p><em>调度问题是个很有趣的问题，会直接影响服务器的效率和性能。</em></p>
<p>代码上，还将原来在 EventLoop 的线程池去掉，Channel 也不再区分是否使用线程池。</p>
<p>现在，服务器以事件驱动为核心，服务器线程只负责 mainReactor 的新建连接任务，同时维护一个线程池，每一个线程是一个事件循环，新连接建立后分发给一个 subReactor 开始事件监听，有事件发生则在当前线程处理。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day11">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day11">Gitee</a></p>
<h2 id="十二-项目工程化">十二、项目工程化</h2>
<p>目前服务器的结构是主从 Reactor 多线程模式，是比较主流的模式。所以大体上的方向已经确定，接下来对细节进行优化，把项目工程化。</p>
<h3 id="12-1-认识cmake">12.1 认识Cmake</h3>
<p>首先，CMake是一个跨平台的编译工具，可以用简单的语句进行编译。</p>
<p>一个项目使用 CMake 维护一个 <code>CMakeLists.txt</code> 配置文件来描述一个项目的编译过程。利用这个文件，就可以搭建起来这个项目。</p>
<p>目前将所有文件都放在一个文件夹，并且没有分类。随着项目越来越复杂、模块越来越多，开发者需要考虑这座屎山的可读性，如将模块拆分到不同文件夹，将头文件统一放在一起等。</p>
<p>对于这样复杂的项目，如果手写复杂的Makefile来编译链接，那么将会相当负责繁琐。我们应当使用 CMake 来管理我们的项目，CMake 的使用非常简单、功能强大，会帮我们自动生成 Makefile 文件，使项目的编译链接更加容易，程序员可以将更多的精力放在写代码上。</p>
<p>这是 <code>CmakeLists.txt</code> 基本结构：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx：本 CMakeLists.txt 的 project 名称</span></span><br><span class="line"><span class="comment"># 会自动创建两个变量，PROJECT_SOURCE_DIR 和 PROJECT_NAME</span></span><br><span class="line"><span class="comment"># ${PROJECT_SOURCE_DIR}：本 CMakeLists.txt 所在的文件夹路径</span></span><br><span class="line"><span class="comment"># ${PROJECT_NAME}：本CMakeLists.txt 的 project 名称</span></span><br><span class="line"><span class="keyword">project</span>(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取路径下所有的.cpp/.c/.cc文件，并赋值给变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(路径 变量)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给文件名/路径名或其他字符串起别名，用${变量}获取变量内容</span></span><br><span class="line"><span class="keyword">set</span>(变量 文件名/路径/...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加编译选项</span></span><br><span class="line"><span class="keyword">add_definitions</span>(编译选项)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印消息</span></span><br><span class="line"><span class="keyword">message</span>(消息)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译子文件夹的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(子文件夹名称)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp/.c/.cc文件生成.a静态库</span></span><br><span class="line"><span class="comment"># 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可</span></span><br><span class="line"><span class="keyword">add_library</span>(库文件名称 STATIC 文件)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp/.c/.cc文件生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名称 文件)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定.h头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定.so/.a库文件路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对add_library或add_executable生成的文件进行链接操作</span></span><br><span class="line"><span class="comment"># 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(库文件名称/可执行文件名称 链接的库文件名称)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="12-2-工程化的实际操作">12.2 工程化的实际操作</h3>
<p>首先规范化目录的意义：</p>
<ul>
<li><code>src</code> 目录（即source），用于存放核心的代码；
<ul>
<li><code>include</code> 目录，用于存放源代码中的头文件；</li>
</ul>
</li>
<li><code>test</code> 目录，用于存放测试的代码；</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">projiect/</span><br><span class="line">├─src/</span><br><span class="line">│ ├─include/</span><br><span class="line">│ │ ├─*.h</span><br><span class="line">│ ├─*.cpp</span><br><span class="line">├─test/</span><br><span class="line">│ ├─*.cpp</span><br></pre></td></tr></tbody></table></figure>
<p>在这一章，我们使用的是一个 CMake 工程，所以 Visual Studio 创建的是 CMake 项目。接下来就是 CMake 的配置工作。（<em>有关 CMake 的安装使用可参考附 2</em>）</p>
<p>构建上述文件目录，将对应的文件分类进去。</p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-1.jpg" title="文件结构" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-1.jpg" alt="文件结构"></a></p>
<p>接着，开始编写项目的根 <code>CMakeLists.txt</code> 文件（即根目录下的 <code>CMakeLists.txt</code> ）：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)    <span class="comment"># CMake运行的最小版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)   <span class="comment"># 启用编译命令的导出，常与代码分析工具配合使用</span></span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)               <span class="comment"># 构建共享（动态）库</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)              <span class="comment"># 设置C++标准为17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)     <span class="comment"># 要求编译器支持C++17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译器</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">"clang"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">"clang++"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Day12           <span class="comment"># 项目名称</span></span><br><span class="line">        LANGUAGES CXX   <span class="comment"># 项目语言</span></span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为源代码和测试添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># set(TEST_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/test/include)</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${SRC_INCLUDE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">${CMAKE_BINARY_DIR}</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">${CMAKE_BINARY_DIR}</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">${CMAKE_BINARY_DIR}</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译和链接选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"${CMAKE_CXX_FLAGS} -fPIC -Wall -Wextra -std=c++17 -pthread"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"${CMAKE_CXX_FLAGS_DEBUG} -O0 -ggdb -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS  <span class="string">"${CMAKE_EXE_LINKER_FLAGS} -fPIC"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">"${CMAKE_SHARED_LINKER_FLAGS} -fPIC"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_STATIC_LINKER_FLAGS <span class="string">"${CMAKE_STATIC_LINKER_FLAGS} -fPIC"</span>)</span><br><span class="line"><span class="keyword">set</span>(GCC_COVERAGE_LINK_FLAGS <span class="string">"-fPIC"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示编译器和链接器标志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_CXX_FLAGS_DEBUG: ${CMAKE_CXX_FLAGS_DEBUG}"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_SHARED_LINKER_FLAGS: ${CMAKE_SHARED_LINKER_FLAGS}"</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第一次接触 CMake 命令可以参考注释理解。</li>
</ul>
<p>接着，尝试把我们关于服务器的设计打包成一个库，即编写 <code>src/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${SRC_INCLUDE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索/src目录中的所有.cpp文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE day12_sources <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置共享库链接选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">"${CMAKE_SHARED_LINKER_FLAGS}  -fPIC -pthread"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用源文件创建一个名为day12_shared的共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(day12_shared SHARED <span class="variable">${day12_sources}</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>然后，把测试文件的 <code>CMakeLists.txt</code>（即 <code>test/CMakeLists.txt</code>）也编写一下，用于管理测试文件的编译：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${SRC_INCLUDE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置变量TEST_SOURCES，将所有.cpp文件存储在测试目录中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB TEST_SOURCES <span class="string">"${PROJECT_SOURCE_DIR}/test/*.cpp"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为“build-tests”的自定义目标以仅显示测试</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(build-tests <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_CTEST_COMMAND}</span> --show-only)</span><br><span class="line"><span class="comment"># 创建名为“check-tests”的自定义目标以在详细模式下运行测试</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(check-tests <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_CTEST_COMMAND}</span> --verbose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历TEST_SOURCES中的每个测试源文件</span></span><br><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">${TEST_SOURCES}</span>)</span><br><span class="line">    <span class="comment"># 组合为可读的名称，使得每个Cpp都可以make</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(test_filename <span class="variable">${test_source}</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">".cpp"</span> <span class="string">""</span> test_name <span class="variable">${test_filename}</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为测试添加可执行目标，默认情况下将其从所有生成中排除</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">${test_name}</span> EXCLUDE_FROM_ALL <span class="variable">${test_source}</span>)</span><br><span class="line">    <span class="comment"># 添加对生成测试和检查测试的依赖项</span></span><br><span class="line">    <span class="keyword">add_dependencies</span>(build-tests <span class="variable">${test_name}</span>)</span><br><span class="line">    <span class="keyword">add_dependencies</span>(check-tests <span class="variable">${test_name}</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将“day12_shared”库链接到可执行测试文件</span></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">${test_name}</span> day12_shared)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置测试目标的属性，指定输出目录和运行测试的命令</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(<span class="variable">${test_name}</span></span><br><span class="line">        PROPERTIES</span><br><span class="line">        RUNTIME_OUTPUT_DIRECTORY <span class="string">"${CMAKE_BINARY_DIR}/bin"</span></span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${test_name}</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endforeach</span>(test_source <span class="variable">${TEST_SOURCES}</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>当然，这章在代码上也有些许修改，比如函数参数做了 <code>const &amp;</code>，类也禁止了拷贝和移动操作。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day12">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day12">Gitee</a></p>
<p>接着只需要把项目部署到远程 Linux 服务器，使用以下命令编译即可：</p>
<ul>
<li><code>make server</code>：编译服务端代码</li>
<li><code>make SingleClient</code>：编译单个客户端连接代码</li>
<li><code>make MultipleClients</code>：编译多个客户端连接代码</li>
<li><code>make clean</code>：清理生成</li>
</ul>
<p>运行只需要：</p>
<ul>
<li><code>./bin/server</code>：启动服务端</li>
<li><code>./bin/SingleClient</code>：启动单个客户端连接</li>
<li><code>./bin/MultipleClients -t 线程数 -m 回显消息数 -w 延时发送信息</code>：启动多个客户端连接</li>
</ul>
<blockquote>
<p>原作者还进行了代码静态分析和代码格式化，详见地址：<a target="_blank" rel="noopener" href="https://github.com/yuesong-feng/30dayMakeCppServer/blob/main/day13-C%2B%2B%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md">Github</a></p>
</blockquote>
<hr>
<h2 id="附录">附录</h2>
<h3 id="附-1-代码运行环境">附 1 - 代码运行环境</h3>
<ul>
<li>代码编写：Windows 下 Visual Studio 2022</li>
<li>代码编译及执行：阿里云 ECS，Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-169-generic x86_64)</li>
</ul>
<p>在 Visual Studio 2022 中编写代码，接着连接远程服务器，将代码部署到服务器上。</p>
<ul>
<li>前期在服务器使用 <code>make</code> 编译代码。<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/798104">Ubuntu之make：make命令行工具的简介、安装、使用方法之详细攻略</a>
<ul>
<li>编译命令见每个 Day 中的 Makefile 文件。
<ul>
<li><code>make</code> 命令为：<code>make build</code> 或 <code>make</code>。</li>
<li>清理编译结果命令为：<code>make clean</code>。</li>
</ul>
</li>
<li>若没有 <code>make</code>，可以手动输入（Makefile中的） <code>g++</code> 命令编译。</li>
</ul>
</li>
<li>后期考虑使用 CMake 将项目工程化，详情看附录 2。</li>
</ul>
<h3 id="附-2-cmake的安装和使用">附 2 - CMake的安装和使用</h3>
<p>此处的环境是：<strong>Visual Studio 2022 远程连接 Ubuntu 20.04.6 LTS</strong></p>
<ul>
<li><em>当然 Windows 也有 CMake，此处主要是在 Linux 下的使用。</em></li>
</ul>
<h4 id="附-2-1-检查远程的cmake环境和编译环境">附 2.1 检查远程的CMake环境和编译环境</h4>
<p><em>可能需要先 <code>apt-get update</code> 更新一下 apt。</em></p>
<ol>
<li>安装 CMake 工具</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install cmake</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>可选择安装使用 clang 编译器</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install clang</span><br></pre></td></tr></tbody></table></figure>
<h4 id="附-2-2-visual-studio-2022中使用cmake进行远程linux服务器开发">附 2.2 Visual Studio 2022中使用CMake进行远程Linux服务器开发</h4>
<ol>
<li>创建选择 CMake 项目，我此处构建演示项目 <code>CMakeTestProject</code>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-2.jpg" title="选择CMake项目" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-2.jpg" alt="选择CMake项目"></a></p>
<ol start="2">
<li>选择远程的 Linux 计算机，管理配置，新建一个配置。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-3.jpg" title="管理配置" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-3.jpg" alt="管理配置"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-4.jpg" title="新建配置" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-4.jpg" alt="新建配置"></a></p>
<ol start="3">
<li>编辑配置，具体看下图，主要修改部分已经框选。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-5.jpg" title="编辑配置" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-5.jpg" alt="编辑配置"></a></p>
<ol start="4">
<li>
<p>正常编写代码，此处我用 Day12（第十二章）的代码作为演示。编写代码后，可以点进去根目录的 <code>CMakeLists.txt</code> 文件，保存一下（<code>ctrl + s</code>），就会自动复制到远程。</p>
</li>
<li>
<p>进行项目生成和编译，项目生成有两种方式：</p>
</li>
</ol>
<ul>
<li>可以选择右键项目名，选择以 CMake 视图查看。再进行生成或清理，最后使用编译命令进行编译。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-6.jpg" title="选择CMake视图" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-6.jpg" alt="选择CMake视图"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-7.jpg" title="生成和清理" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-7.jpg" alt="生成和清理"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-8.jpg" title="生成成功1" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-8.jpg" alt="生成成功1"></a></p>
<ul>
<li>可以在 Linux 的终端上执行以下命令：</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake ../src/ &amp;&amp; make</span><br></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-9.jpg" title="生成成功2" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-9.jpg" alt="生成成功2"></a></p>
<p><em>可以在 CMakeLists.txt 中的项目信息之前设置编译器为Clang。</em></p>
<ol start="6">
<li>生成成功后就可以在 <code>CMakeLists.txt</code> 中指定的输出文件夹中找到可执行文件或其他。</li>
</ol>
<h4 id="附-2-2-visual-studio-2022中使用cmake进行wsl开发">附 2.2 Visual Studio 2022中使用CMake进行WSL开发</h4>
<p><em>有的人可能没有Linux服务器，但是WSL可以有的。如何安装WSL可以查看<a target="_blank" rel="noopener" href="https://www.fingsinz.space/2024/20/">这里</a></em></p>
<p>基本步骤同上，但在新建配置和编辑时，需要做一些修改：</p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-10.jpg" title="新建关于WSL的配置" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-10.jpg" alt="新建关于WSL的配置"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-11.jpg" title="编辑关于WSL的配置" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-11.jpg" alt="编辑关于WSL的配置"></a></p>
<h4 id="附-2-3-cmake相关资料">附 2.3 CMake相关资料</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/</a></li>
</ul>
<h3 id="附-3-可能出现的问题">附 3 - 可能出现的问题</h3>
<ul>
<li>
<p>在 Ubuntu 中安装 <code>make</code> 时，出现 <font color="red">“dpkg: error processing package ***”</font> 的问题，可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/dou3516/article/details/105120221">CSDN</a>。</p>
</li>
<li>
<p>在线程池部分中，直接使用 <code>g++</code> 命令会出现 <font color="red">“对‘pthread_create’未定义的引用”</font> 的问题，需要加上 <code>-lpthread</code> 参数，详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Dontla/article/details/122637407">CSDN</a> 或 <code>Makefile</code> 中的做法。</p>
</li>
</ul>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-03-22</span>
            
                <span>该篇文章被 Fingsinz</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/C/'>
                            C++
                        </a>
                    
                        <a href='/tags/Linux/'>
                            Linux
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            ©2023-2024 

            
                

            
                
                    / <a href="/"> Fingsinz&#39;s Space </a>
                

            
                
                    / <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/fingsinz"> 知乎 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


</html>