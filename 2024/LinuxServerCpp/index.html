
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.0" theme-name="Stellar" theme-version="1.33.0">
  
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>Linux 服务器编程入门尝试 - C++ - Fingsinz</title>

  
  <meta name="description" content="关键词：C++、Linux">
  
  <meta name="keywords" content="CPP,Linux">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.0">


  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Fingsinz","sameAs":[],"image":"/images/avatar.jpg"},"dateCreated":"2024-03-22T15:10:57+08:00","dateModified":"2024-08-07T14:15:40+08:00","datePublished":"2024-03-22T15:10:57+08:00","description":"关键词：C++、Linux","headline":"Linux 服务器编程入门尝试 - C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://fingsinz.space/2024/LinuxServerCpp/"},"publisher":{"@type":"Organization","name":"Fingsinz","sameAs":[],"image":"/images/avatar.jpg","logo":{"@type":"ImageObject","url":"/images/avatar.jpg"}},"url":"https://fingsinz.space/2024/LinuxServerCpp/","keywords":"CPP, Linux","image":[]}</script>
  

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">Fingsinz</div><div class="sub cap">Fingsinz's space</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#c7c6b6"><span>博客</span></a><a class="nav-item" title="笔记" href="/notebooks/" style="color:#9a6655"><span>笔记</span></a><a class="nav-item" title="文档" href="/wiki/" style="color:#a72126"><span>文档</span></a><a class="nav-item" title="探索" href="/explore/" style="color:#12264f"><span>探索</span></a></nav>
</div>
<div class="widgets"></div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-03-22T07:10:57.000Z">2024-03-22</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-08-07T06:15:40.319Z">2024-08-07</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Linux 服务器编程入门尝试 - C++</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>关键词：C++、Linux</p>
<span id="more"></span>
<hr>
<blockquote>
<p><strong>References：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/yuesong-feng/30dayMakeCppServer/">30天自制C++服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/yuesong-feng/pine">配套网络库 pine</a></li>
</ul>
<p><em>Linux下操作。</em></p>
</blockquote>
<h2 id="零-前言">零、前言</h2>
<p>这个项目原作者暂未更新，单凭我自己的话，还没能力续写下去。我的想法是有时间再重新组织一下语言，细化一下每一章的描述。这个项目作为一个 Linux 网络编程的入门项目还是相当不错的，能够了解到 Socket、线程池以及一系列抽象编程思想。如果想继续深入学习网络编程，那路还有很长很长……</p>
<p><em>——Fingsinz，2024.06.06留</em></p>
<p>碰巧看到一位大牛在原仓库的基础上专注于功能的实现，并进行了自我改造，我将根据这位大牛的思想继续完善这个 Linux 高性能服务器。</p>
<p>Reference：<a target="_blank" rel="noopener" href="https://github.com/Wlgls/30daysCppWebServer">https://github.com/Wlgls/30daysCppWebServer</a></p>
<p><em>——Fingsinz，2024.07.11留</em></p>
<h2 id="一-从socket开始">一、从socket开始</h2>
<p>socket，被翻译为套接字，它是计算机之间进行通信的一种约定或一种方式。套接字是双方通过网络进行通信的通道。Socket 连接的一边是客户端，另一边是服务器端。一个正常的服务器端能服务多个客户端。</p>
<ul>
<li>通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</li>
</ul>
<h3 id="1-1-服务端干了什么">1.1 服务端干了什么</h3>
<p>在服务器端，需要建立一个 socket 套接字，对外提供一个网络通信接口。</p>
<ul>
<li>在 Linux 系统中这个套接字仅仅是一个文件描述符，也就是一个int类型的值。</li>
<li>对套接字的所有操作（包括创建）都是最底层的系统调用。</li>
</ul>
<ol>
<li>创建套接字：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>创建一个 <code>sockaddr_in</code> 结构体并初始化（<code>bzero</code> 函数）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>设置地址族、IP 地址和端口号：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>将 socket 地址与文件描述符绑定：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></tbody></table></figure>
<ol start="5">
<li>使用 <code>listen</code> 函数监听套接字：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd, SOMAXCONN);</span><br></pre></td></tr></tbody></table></figure>
<ol start="6">
<li>服务端想要接受一个客户端连接，需要使用 <code>accept</code> 函数：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line"><span class="type">socklen_t</span> clientAddrLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line"><span class="built_in">bzero</span>(&amp;clientAddr, <span class="built_in">sizeof</span>(clientAddr));</span><br><span class="line"><span class="type">int</span> clientSockfd = <span class="built_in">accept</span>(sockfd, (sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br></pre></td></tr></tbody></table></figure>
<ol start="7">
<li>输出 socket 连接信息：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Client connected: %d!\tIP: %s\tPort: %d\n"</span>, clientSockfd, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), <span class="built_in">ntohs</span>(clientAddr.sin_port));</span><br></pre></td></tr></tbody></table></figure>
<p>至此，客户端已经可以通过 IP 地址和端口号连接到这个 socket 端口了。</p>
<h3 id="1-2-客户端如何配合">1.2 客户端如何配合</h3>
<p>在客户端，也需要建立一个 socket 套接字。</p>
<p>对于客户端，服务器存在的唯一标识是 IP 地址和端口号。此时需要将套接字绑定到一个 IP 地址和端口上。</p>
<ol>
<li>创建套接字：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>创建一个 <code>sockaddr_in</code> 结构体，并绑定 IP 族、IP 地址和端口号：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>使用 <code>connect</code> 函数进行连接：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, (sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></tbody></table></figure>
<p>注意，需要先 <code>./server</code> 运行服务端进行等待，再 <code>./client</code> 运行客户端进行连接请求。</p>
<h3 id="1-3-该节涉及函数及源代码">1.3 该节涉及函数及源代码</h3>
<ul>
<li>相关头文件：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// 创建 socket 所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// socket 地址结构体所需</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建 socket：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span> <span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __domain：IP 地址类型，AF_INET 表示 IPv4，AF_INET6 表示 IPv6。</span></span><br><span class="line"><span class="comment">* __type：数据传输方式，SOCK_STREAM 表示流格式、面向链接，多用于 TCP； SOCK_DGRAM 表示数据报格式、无连接，多用于 UDP。</span></span><br><span class="line"><span class="comment">* __protocol：协议，0 表示根据前面两个参数自动推导协议类型。设置为 IPPROTO_TCP 和 IPPROTO_UDP，分别表示 TCP 和 UDP。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bzero</span> <span class="params">(<span class="type">void</span> *__s, <span class="type">size_t</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __s：指向要清零的内存块的指针。</span></span><br><span class="line"><span class="comment">* __n：要清零的内存块的大小。</span></span><br><span class="line"><span class="comment">* 该函数在头文件 string.h 或 cstring 中。</span></span><br><span class="line"><span class="comment">* Effective C++ - 条款01：视 C++ 为一个语言联邦。写 C 就用 string.h，写 C++ 就用 cstring。</span></span><br><span class="line"><span class="comment">* Effective C++ - 条款04：确定对象被使用前已先被初始化。使用 bzero 进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>绑定函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __addr：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __len：sockaddr 参数的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>listen</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __n：最大监听队列长度，宏定义 SOMAXCONN 为最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>accept</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr, <span class="type">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：服务端的文件描述符。</span></span><br><span class="line"><span class="comment">* __addr`：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __addr_len`：指向 sockaddr 参数大小的指针。因为 accept 需要写入客户端 socket 长度，所以需要地址</span></span><br><span class="line"><span class="comment">* 另外，该函数会阻塞当前程序，直到有一个客户端 socket 被接受后程序才会往下执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>connect</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：客户端的文件描述符。</span></span><br><span class="line"><span class="comment">* __addr：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __len：sockaddr 参数大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>关于 Socket 的有些地址结构需要清楚：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 通用的套接字地址类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>   sa_family;     <span class="comment">// AF_INET 或 AF_INET6</span></span><br><span class="line">    <span class="type">char</span>             sa_data[<span class="number">14</span>];   <span class="comment">// 无关紧要</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际使用的套接字地址类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">short</span>           sin_family;     <span class="comment">// AF_INET</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  sin_port;       <span class="comment">// 端口号，大端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;       <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span>            sin_zero[<span class="number">8</span>];    <span class="comment">// 无关紧要</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class="line">    <span class="type">uint16_t</span>        sin6_family;    <span class="comment">// AF_INET6</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin6_port;      <span class="comment">// 端口号，大端</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;      <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> {</span><br><span class="line">    <span class="type">sa_family_t</span>     ss_family;      <span class="comment">// AF_INET 或 AF_INET6</span></span><br><span class="line">    <span class="comment">// 为IPv4和IPv6提供足够的空间</span></span><br><span class="line">    <span class="type">char</span>    __ss_pad1[_SS_PAD1SIZE];</span><br><span class="line">    <span class="type">int64_t</span> __ss_align;</span><br><span class="line">    <span class="type">char</span>    __ss_pad2[_SS_PAD2SIZE];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p><code>struct sockaddr_storage</code> 对于IPv4和IPv6都足够大，可以在实际中使用它。</p>
</li>
<li>
<p><code>struct sockaddr_in</code> 和 <code>struct sockaddr_in6</code> 是IPv4和IPv6的具体结构。</p>
</li>
</ul>
<p><code>struct sockaddr *</code> 是 socket API 使用的类型，结构本身是无用的。程序员不应操作 <code>sockaddr</code>，<code>sockaddr</code> 是给操作系统用的。应使用 <code>sockaddr_in</code> 来表示地址，<code>sockaddr_in</code> 区分了地址和端口，将 <code>struct sockaddr_storage</code> 引用（指针）转换为 <code>struct sockaddr_in</code> 或 <code>struct sockaddr_in6</code> 以初始化/读取结构。</p>
<p>当在 Linux 上调用任何系统调用时，实际上是在调用 libc 中的一个瘦包装器，即一个稳定的 Linux 系统调用接口的包装器。在 Windows 上，套接字 API 遵循相同的 BSD API，但有许多不同的细节。接口来自 OS DLL 而不是系统调用。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day01">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day01">Gitee</a></p>
<h2 id="二-完善代码-数据读写">二、完善代码，数据读写</h2>
<p>上面的代码是基础版的，但要想真正运行使用，需要完善代码，并抓住错误。</p>
<ul>
<li>Effective C++ 中有提到：“别让异常逃离析构函数”（条款08）。</li>
</ul>
<h3 id="2-1-错误检查处理函数">2.1 错误检查处理函数</h3>
<p>对于 Linux 系统调用，常见的错误提示方式是使用返回值和设置错误码。</p>
<ul>
<li>当一个系统调用返回 <code>-1</code>，说明有错误发生。</li>
</ul>
<p>增加一个错误检查处理函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">errorif</span><span class="params">(<span class="type">bool</span> condition, <span class="type">const</span> <span class="type">char</span> *errmsg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (condition)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">perror</span>(errmsg);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第一个参数为判断是否发生错误条件，调用 <code>iostream</code> 中的 <code>perror</code> 打印错误。</li>
<li>第二个参数为错误信息。</li>
<li>然后使用 <code>exit</code> 函数让程序退出并返回一个预定义常量 <code>EXIT_FAILURE</code>。</li>
</ul>
<p>使用就很方便：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">errorif</span>(sockfd == <span class="number">-1</span>, <span class="string">"socket create error"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>对所有函数都进行处理错误：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">errorif</span>(<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">-1</span>, <span class="string">"socket bind error"</span>);</span><br><span class="line"><span class="built_in">errorif</span>(<span class="built_in">listen</span>(sockfd, SOMAXCONN) == <span class="number">-1</span>, <span class="string">"socket listen error"</span>);</span><br><span class="line"><span class="built_in">errorif</span>(clientfd == <span class="number">-1</span>, <span class="string">"socket accept error"</span>);</span><br><span class="line"><span class="built_in">errorif</span>(<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">-1</span>, <span class="string">"socket connect error"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><em>错误的处理是必须的，但处理函数不一定这样写。</em></li>
</ul>
<h3 id="2-2-数据读写">2.2 数据读写</h3>
<p>当建立 socket 连接后，就可以使用 <code>unistd.h</code> 中的 <code>read</code> 和 <code>write</code> 函数进行数据读写。（仅限于 TCP 连接。UDP 连接使用 <code>sendto</code> 和 <code>recvfrom</code> 函数。）</p>
<p>接下来做一个通信情况：客户端向服务端发送一定数据，然后服务端接收后转发回客户端，客户端将接收的转发数据再进行标准输出。</p>
<p>客户端：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">// 持续通信</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];	<span class="comment">// 定义缓冲区</span></span><br><span class="line">	std::cin &gt;&gt; buffer;	<span class="comment">// 从标准输入读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向服务端发送数据</span></span><br><span class="line">	<span class="type">size_t</span> writeLen = <span class="built_in">write</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送失败处理</span></span><br><span class="line">	<span class="keyword">if</span> (writeLen == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Socket already disconnected!\n"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(buffer, <span class="built_in">sizeof</span>(buffer));	<span class="comment">// 清空缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读回数据</span></span><br><span class="line">	<span class="type">size_t</span> readLen = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读数据问题判断</span></span><br><span class="line">	<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; buffer &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Server socket disconnected!\n"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">close</span>(sockfd);</span><br><span class="line">		<span class="built_in">errorif</span>(<span class="literal">true</span>, <span class="string">"socket read error"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>服务端：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 定义并初始化缓冲区</span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">bzero</span>(buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从客户端读取数据</span></span><br><span class="line">	<span class="type">size_t</span> readLen = <span class="built_in">read</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取数据问题判断</span></span><br><span class="line">	<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Message from client:"</span> &lt;&lt; clientfd &lt;&lt; <span class="string">": "</span> &lt;&lt; buffer &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		<span class="built_in">write</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer));	<span class="comment">// 读到后转回客户端</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Client "</span> &lt;&lt; clientfd &lt;&lt; <span class="string">" disconnected\n"</span>;</span><br><span class="line">		<span class="built_in">close</span>(clientfd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">close</span>(clientfd);</span><br><span class="line">		<span class="built_in">errorif</span>(<span class="literal">true</span>, <span class="string">"socket read error"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是：</p>
<ul>
<li>服务端和客户端都可以从对方中读写数据。</li>
<li>使用完一个 <code>fd</code>（文件描述符） 后，记得使用 <code>close</code> 函数进行关闭。</li>
</ul>
<h3 id="2-3-该节涉及函数及源代码">2.3 该节涉及函数及源代码</h3>
<ul>
<li>相关头文件：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>	<span class="comment">// 读写数据等需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"util.h"</span>  	<span class="comment">// 放置错误处理函数</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>write</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __buf：写入缓冲区。</span></span><br><span class="line"><span class="comment">* __n：写入缓冲区大小。</span></span><br><span class="line"><span class="comment">* 返回写入的大小，或-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>read</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __nbytes)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __buf：读取缓冲区。</span></span><br><span class="line"><span class="comment">* __nbytes：读取缓冲区大小。</span></span><br><span class="line"><span class="comment">* 返回读取的大小，-1表示错误，0表示EOF。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>close</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span> <span class="params">(<span class="type">int</span> __fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day02">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day02">Gitee</a></p>
<h2 id="三-高并发使用epoll">三、高并发使用epoll</h2>
<p>之前只写了一个简单的服务器，只能同时处理一个客户端连接。事实上，所有的服务都是高并发的，可以同时为成千上万个客户端提供服务——IO复用。</p>
<ul>
<li>IO 复用和多线程相似，但不是一个概念。
<ul>
<li>IO 复用针对 IO 接口；</li>
<li>多线程针对 CPU。</li>
</ul>
</li>
</ul>
<p>IO 复用的基本思想是事件驱动，服务器同时保持多个客户端 IO 连接。</p>
<ul>
<li>当 IO 上有可读或可写事件发生，表示这个 IO 对应的客户端在请求服务器的服务，服务器应当响应。</li>
<li>Linux 中， IO 复用使用 select、poll 和 epoll 来实现。
<ul>
<li>epoll 相比 select、poll，表现性能更好，更加高效。</li>
</ul>
</li>
</ul>
<h3 id="3-1-从select-poll到epoll">3.1 从select、poll到epoll</h3>
<blockquote>
<p>从实现原理上来说，select 和 poll 采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。epoll_wait 则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插人内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此 epoll_wait 无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。详见《Linux高性能服务器编程-游双，第9章》</p>
</blockquote>
<ul>
<li>当活动连接比较多的时候，epoll_wait 的效率未必比 select 和 poll 高，因为此时回调函数被触发得过于频繁。所以 epoll_wait 适用于连接数量多，但活动连接较少的情况。</li>
</ul>
<p>epoll 是 Linux 特有的 IO 复用函数。</p>
<ul>
<li>使用一组函数完成任务。</li>
<li>把用户关心的文件描述符上的事件放到内核的一个事件表中。
<ul>
<li>而不像 select 和 poll 那样每次调用都重复传入文件描述符或事件集。</li>
</ul>
</li>
<li>需要额外的文件描述符来标识内核中的事件表。</li>
</ul>
<p>创建文件描述符：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* size：内核事件表大小。</span></span><br><span class="line"><span class="comment">* 返回文件描述符，用作其他所有 epoll 系统调用的第一个参数，指定访问的内核事件表。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>操作 epoll 的内核事件表：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* epfd：文件描述符。</span></span><br><span class="line"><span class="comment">* op：操作类型。有 EPOLL_CTL_ADD（往事件表中注册 fd 上的事件）、 </span></span><br><span class="line"><span class="comment">* 				EPOLL_CTL_DEL（修改 fd 上的注册事件）、</span></span><br><span class="line"><span class="comment">* 				EPOLL_CTL_MOD（删除 fd 上的注册事件） 三种。</span></span><br><span class="line"><span class="comment">* fd：文件描述符。</span></span><br><span class="line"><span class="comment">* event：指定事件，是 epoll_event 结构体指针。</span></span><br><span class="line"><span class="comment">* 返回值：成功返回 0，失败返回 -1 并设置错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>而关于 <code>epoll_event</code> 结构体的定义：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">__uint32_t</span> events;	<span class="comment">/*epoll事件*/</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;	<span class="comment">/*用户数据*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *ptr;		<span class="comment">// 指定与fd相关的用户数据</span></span><br><span class="line">	<span class="type">int</span> fd;			<span class="comment">// 指定事件所从属的目标文件描述符</span></span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">} <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>epoll 系列系统调用的主要接口是 <code>epoll_wait</code> 函数，它在一段超时时间内等待一组文件描述符上的事件：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 该函数如果检测到事件，就将所有就绪的事件从内核事件表（epfd指定）中复制到events中。</span></span><br><span class="line"><span class="comment">* epfd：文件描述符。</span></span><br><span class="line"><span class="comment">* events：事件数组。</span></span><br><span class="line"><span class="comment">* maxevents：监听事件数组大小。</span></span><br><span class="line"><span class="comment">* timeout：超时时间，单位为毫秒。</span></span><br><span class="line"><span class="comment">* 返回值：成功返回就绪事件个数，失败返回 -1 并设置错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>epoll 对文件描述符的操作有两种：</p>
<ul>
<li>LT（Level Trigger，电平触发）模式
<ul>
<li>默认的工作模式，相当于效率较高的 poll。</li>
<li>对于采用 LT 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 epoll,_wait 时，epoll_wait 还会再次向应用程序通告此事件，直到该事件被处理。</li>
</ul>
</li>
<li>ET（Edge Trigger，边沿触发）模式
<ul>
<li>对于采用ET工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait 调用将不再向应用程序通知这一事件。可见，ET 模式在很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</li>
<li>ET 模式必须搭配非阻塞式 socket 使用。</li>
</ul>
</li>
</ul>
<p>epoll 的事件有：</p>
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符可读（包括对端 socket 正常关闭）；</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可写；</li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><code>EPOLLET</code>：将 epoll 设为边缘触发模式。</li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完事件后，如果还需要继续监听这个 socket 的情况下，需要再次把这个 socket 加到 epoll 队列里。</li>
</ul>
<h3 id="3-2-将服务器改写成epoll版本">3.2 将服务器改写成epoll版本</h3>
<p>在创建了服务器 socket fd 后，将这个 fd 添加到 epoll。</p>
<ul>
<li>epoll 监听事件的描述符会放在一棵红黑树上，将要监听的 IO 口放入 epoll 红黑树中，就可以监听该 IO 上的事件。</li>
<li>只要这个 fd 上发生可读事件，表示有一个新的客户端连接。</li>
<li>然后 accept 这个客户端并将客户端的 socket fd 添加到 epoll，epoll 会监听客户端 socket fd 是否有事件发生，如果发生则处理事件。</li>
</ul>
<p>所以服务器大概的步骤如下：</p>
<ol>
<li>创建 epoll，同时定义事件数组。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll</span></span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">errorif</span>(epfd == <span class="number">-1</span>, <span class="string">"epoll create error"</span>);</span><br><span class="line"><span class="comment">// 定义事件数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS], ev;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;events, <span class="built_in">sizeof</span>(events));</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>将要监听的 IO 口放入 epoll 中。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ev.data.fd = sockfd;			<span class="comment">// 该 IO 口为服务器 socket fd</span></span><br><span class="line">ev.events = EPOLLIN;			<span class="comment">// 可读</span></span><br><span class="line"><span class="built_in">setnonblocking</span>(sockfd);			<span class="comment">// 设置 sockfd 为非阻塞</span></span><br><span class="line"><span class="comment">// 将服务器 socket fd 注册到 epoll</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>
<p>不断监听 epoll 上的事件并处理。</p>
</li>
<li>
<p>如果监听发生的事件是服务器 socket fd 上的事件，表示有一个新的客户端连接。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (events[i].data.fd == sockfd)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 接收客户端信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新增监听</span></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;ev, <span class="built_in">sizeof</span>(ev));</span><br><span class="line">	ev.data.fd = clientfd;			<span class="comment">// 该 IO 口为客户端 socket fd</span></span><br><span class="line">	ev.events = EPOLLIN | EPOLLET;	<span class="comment">// 客户端连接使用 ET 模式</span></span><br><span class="line">	<span class="built_in">setnonblocking</span>(clientfd);		<span class="comment">// ET 需要搭配非阻塞式 socket 使用</span></span><br><span class="line">	<span class="comment">// 将客户端 socket fd 注册到 epoll</span></span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clientfd, &amp;ev);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="5">
<li>如果监听发生的事件是客户端，并且是可读事件，表示有客户端发送消息：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">// 非阻塞 IO，需要不断读取，直至完毕</span></span><br><span class="line">	{</span><br><span class="line">		<span class="type">ssize_t</span> bytesRead = <span class="built_in">read</span>(events[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正常读取数据</span></span><br><span class="line">		<span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 客户端正常中断，继续读取</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> <span class="keyword">and</span> errno == EINTR)</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 非阻塞 IO，这个条件表示数据全部读取完毕</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> <span class="built_in">and</span> ((errno == EAGAIN) <span class="built_in">or</span> (errno == EWOULDBLOCK)))</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// EOF 事件，一般表示客户端断开连接</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day03">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day03">Gitee</a></p>
<h2 id="四-封装成类-程序模块化">四、封装成类，程序模块化</h2>
<h3 id="4-1-将socket和inetaddress封装成类">4.1 将socket和InetAddress封装成类</h3>
<p>当新建服务器 socket 时，需要完成绑定 IP 地址、监听、接受客户端连接等任务，这些任务都封装成 <code>Socket</code> 类来完成。希望简化成以下操作：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建服务器 socket</span></span><br><span class="line">Socket *serverSocket = <span class="keyword">new</span> <span class="built_in">Socket</span>();</span><br><span class="line"><span class="comment">// 实例化 IP 地址</span></span><br><span class="line">InetAddress *serverAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>(<span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 IP 地址</span></span><br><span class="line">serverSocket-&gt;<span class="built_in">bind</span>(serverAddr);</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">serverSocket-&gt;<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个客户端地址</span></span><br><span class="line">InetAddress *clientAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>();</span><br><span class="line"><span class="comment">// 接受一个客户端连接</span></span><br><span class="line">Socket *clientSocket = <span class="keyword">new</span> <span class="built_in">Socket</span>(serverSocket-&gt;<span class="built_in">accept</span>(clientAddr));</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-2-将epoll封装成类">4.2 将epoll封装成类</h3>
<p>对于 epoll，希望简化操作，封装成类后：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化 epoll</span></span><br><span class="line">Epoll *ep = <span class="keyword">new</span> <span class="built_in">Epoll</span>();</span><br><span class="line"><span class="comment">// 将要监听的 IO 口放入 epoll</span></span><br><span class="line">ep-&gt;<span class="built_in">epoll_add</span>(serverSocket-&gt;<span class="built_in">getFd</span>(), EPOLLIN | EPOLLET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line">	std::vector&lt;epoll_event&gt; events = ep-&gt;<span class="built_in">poll</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ev : events)</span><br><span class="line">		<span class="comment">// 处理事件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-3-目录结构及源代码">4.3 目录结构及源代码</h3>
<p>目录结构如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client.cpp</span><br><span class="line">server.cpp</span><br><span class="line">util.h</span><br><span class="line">util.cpp</span><br><span class="line">Socket.h</span><br><span class="line">Socket.cpp</span><br><span class="line">InetAddress.h</span><br><span class="line">InetAddress.cpp</span><br><span class="line">Epoll.h</span><br><span class="line">Epoll.cpp</span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day04">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day04">Gitee</a></p>
<h2 id="五-向着reactor模式转变">五、向着Reactor模式转变</h2>
<h3 id="5-1-reactor和proactor">5.1 Reactor和Proactor</h3>
<blockquote>
<p>Reactor 翻译过来的意思是「反应堆」，这里的反应指的是「对事件反应」。</p>
<ul>
<li>当来了一个事件，Reactor 就有相对应的反应/响应。</li>
</ul>
<p>事实上，Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 I/O 多路复用监听事件。</p>
<ul>
<li>收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。</li>
</ul>
<p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成。</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ul>
<li>Reactor 的数量可以只有一个，也可以有多个；</li>
<li>处理资源池可以是单个进程 / 线程，也可以是多个进程 / 线程；</li>
</ul>
<p>有 3 个方案都是比较经典的，且都有应用在实际的项目中：</p>
<ul>
<li>单 Reactor 单进程 / 线程；</li>
<li>单 Reactor 多线程 / 进程；</li>
<li>多 Reactor 多进程 / 线程；</li>
</ul>
<p>方案具体使用进程还是线程，要看使用的编程语言以及平台有关：</p>
<ul>
<li>Java 语言一般使用线程，比如 Netty；</li>
<li>C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。</li>
</ul>
<p>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</p>
<p>Proactor 是异步网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p>
<p>因此，Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p>
<p>作者：小林coding<br>
链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26943938/answer/1856426252">https://www.zhihu.com/question/26943938/answer/1856426252</a><br>
来源：知乎著作权归作者所有。</p>
</blockquote>
<p><em>详细请参考游双《Linux高性能服务器编程》第八章第四节、陈硕《Linux多线程服务器编程》第六章第六节。</em></p>
<p>接下来要将服务器向着 Reactor 模式转变：</p>
<ol>
<li>首先将整个服务器抽象成一个 Server 类，这个类中有一个 main-Reactor，里面的核心是一个 EventLoop，这是一个事件循环；</li>
<li>添加需要监听的事务到这个事件循环内，每次有事件发生时就会通知，在程序中返回给 Channel（自封装的类），然后根据不同的描述符、事件类型以回调函数的方式进行处理。</li>
</ol>
<h3 id="5-2-加入channel类">5.2 加入Channel类</h3>
<p>面对服务器许多服务时，不同的连接类型也将决定不同的处理逻辑，仅仅通过一个文件描述符来区分显然会很麻烦。希望得到文件描述符的更多消息。</p>
<ul>
<li>epoll 的 <code>epoll_event</code> 结构体中，<code>data</code> 字段可以放一个 <code>void *</code> 类型的指针，用来保存更多信息。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">} <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> events;		<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;	<span class="comment">/* User data variable */</span></span><br><span class="line">} __EPOLL_PACKED;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>epoll 中的 <code>data</code> 是一个联合类型：
<ul>
<li>可以存储一个指针，指向任何一个地址块的内容；</li>
<li>可以是一个类的对象，就此将一个文件描述符封装成一个 <code>Channel</code> 类，一个 <code>Channel</code> 类始终负责一个文件描述符。对不同的服务、不同的事件类型，都可以在类中进行处理。</li>
</ul>
</li>
</ul>
<p>设计 <code>Channel</code> 类，核心成员如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *loop;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> events;</span><br><span class="line">	<span class="type">uint32_t</span> revents;</span><br><span class="line">	<span class="type">bool</span> isEpoll;</span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>loop</code>：指向与之关联的事件循环的指针。</li>
<li><code>fd</code>：Channel 负责的文件描述符。</li>
<li><code>events</code>：表示希望监听这个文件描述符的哪些事件。</li>
<li><code>revents</code>：表示在 <code>epoll</code> 返回该 <code>Channel</code> 时文件描述符正在发生的事件。</li>
<li><code>isEpoll</code>：表示当前 <code>Channel</code> 是否已经添加到 <code>epoll</code> 红黑树中，区分使用 <code>EPOLL_CTL_ADD</code> 还是 <code>EPOLL_CTL_MOD</code>。</li>
<li><code>callback</code>：发生事件时执行的回调函数。</li>
</ul>
<p>添加 Channel 类可以更加方便简单、多样化地处理 epoll 中发生的事件。同时脱离了底层，将 epoll、文件描述符和事件进行了抽象，形成了事件分发的模型，这也是 Reactor 模式的核心。</p>
<h3 id="5-3-加入eventloop类">5.3 加入EventLoop类</h3>
<p>EventLoop 类的定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Epoll *ep;</span><br><span class="line">    <span class="type">bool</span> quit;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel*)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>ep</code>：指向Epoll类实例的指针；</li>
<li><code>quit</code>：指示程序是否应该退出；</li>
<li><code>loop()</code>：事件循环函数，调用开始事件驱动，即原来调用 <code>epoll_wait</code> 函数的死循环；</li>
<li><code>updateChannel()</code>：更新 Channel。</li>
</ul>
<p>将需要监听的事务加入到事件循环中，每次有事件发生就会通知，返回到 Channel，然后根据不同的描述符、事件类型以回调函数方式进行处理：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (!quit)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 使用epoll实例轮询事件</span></span><br><span class="line">		std::vector&lt;Channel *&gt; channels = ep-&gt;<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理每个Channel的事件</span></span><br><span class="line">		<span class="keyword">for</span> (Channel *channel : channels)</span><br><span class="line">			channel-&gt;<span class="built_in">handleEvent</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-4-加入server类">5.4 加入Server类</h3>
<p>服务器类 <code>Server</code> 的核心成员如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *loop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(EventLoop*);</span><br><span class="line">    ~<span class="built_in">Server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleReadEvent</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(Socket *serv_sock)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>loop</code>：事件循环对象。</li>
<li><code>handleReadEvent()</code>：处理读事件。</li>
<li><code>newConnection()</code>：处理新连接。</li>
</ul>
<p>之后启动服务器的操作抽象为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *loop = <span class="keyword">new</span> <span class="built_in">EventLoop</span>();</span><br><span class="line">Server *server = <span class="keyword">new</span> <span class="built_in">Server</span>(loop);</span><br><span class="line">loop-&gt;<span class="built_in">loop</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>这个版本服务器内只有一个 <code>EventLoop</code>，当其中有可读事件发生时，可以拿到该描述符对应的 <code>Channel</code>。</p>
<p>在新建 Channel 时，根据 Channel 描述符的不同分别绑定了两个回调函数：</p>
<ul>
<li><code>newConnection()</code> 函数被绑定到服务器socket上；
<ul>
<li>如果服务器 socket 有可读事件，Channel 里的 <code>handleEvent()</code> 函数实际上会调用 Server 类的 <code>newConnection()</code> 新建连接。</li>
</ul>
</li>
<li><code>handlrReadEvent()</code> 被绑定到新接受的客户端socket上。
<ul>
<li>如果客户端 socket 有可读事件，Channel 里的 <code>handleEvent()</code> 函数实际上会调用 Server 类的 <code>handleReadEvent()</code> 响应客户端请求。</li>
</ul>
</li>
</ul>
<p>至此，根据抽象出的 <code>EventLoop</code> 和 <code>Channel</code>，构成了事件驱动模型。这两个类和服务器核心 <code>Server</code> 已经没有任何关系，经过完善后可以被任何程序复用，达到了事件驱动的设计思想，现在的服务器也可以看成一个最简易的 Reactor 模式服务器。</p>
<p><em>需要注意的是，目前该服务器的内存管理一塌糊涂。</em></p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day05">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day05">Gitee</a></p>
<h2 id="六-把服务器的接受抽象化">六、把服务器的接受抽象化</h2>
<h3 id="6-1-抽象化接受">6.1 抽象化接受</h3>
<p>服务器中，对于每一个事件，首先都是调用 <code>accept()</code> 函数去接受一个 TCP 连接，然后把 Socket 文件描述符添加到 epoll。当这个 IO 口有事件发生时，对该连接提供相应的服务。</p>
<p>分离接受连接这个功能，添加 <code>Acceptor</code> 类。</p>
<h3 id="6-2-acceptor-类">6.2 Acceptor 类</h3>
<p>Acceptor 类应该有以下特点：</p>
<ul>
<li>类中有一个 Socket fd，就是服务器监听的 Socket fd，每一个<br>
Acceptor 对象都对应一个 Socket fd。</li>
<li>类存在于事件驱动 <code>EventLoop</code> 类中。</li>
<li>类也通过一个 <code>Channel</code> 负责分发到 epoll，该 <code>Channel</code> 的事件处理函数 <code>handleEvent()</code> 会调用 <code>Acceptor</code> 类中的连接函数进行新建一个 TCP 连接。</li>
</ul>
<p>将新建连接的逻辑就在 Acceptor 类中。但逻辑上新 Socket 建立后就和之前的监听的服务器 Socket 没有任何关系了。</p>
<p>新的 TCP 连接应该由 Server 类来创建并管理生命周期，而不是 Acceptor。并且将一部分代码放在 Server 类里也并没有打破服务器的通用性，因为对于所有的服务，都要使用 Acceptor 来建立连接。</p>
<ul>
<li><code>Acceptor</code> 类的新建连接功能是在 <code>Server</code> 类中实现的。</li>
</ul>
<p>可以使用 <code>std::function</code>、<code>std::bind</code>、右值引用、<code>std::move</code> 等实现函数回调。</p>
<p>定义该类：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 用于事件处理的EventLoop指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于处理套接字操作的套接字指针</span></span><br><span class="line">	Socket *sock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于存储地址信息的指针</span></span><br><span class="line">	InetAddress *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于接受连接的 Channel 指针</span></span><br><span class="line">	Channel *acceptChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 定义一个新建连接的回调函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; newConnectionCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Acceptor</span>(EventLoop *_loop);</span><br><span class="line">	~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 接受新连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">acceptConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置新连接的回调函数。</span></span><br><span class="line"><span class="comment">	 * @param _callback 为新连接设置的回调函数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; _callback)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>抽象后，Server类的变化如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器套接字</span></span><br><span class="line">	Socket *serverSock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器地址</span></span><br><span class="line">	InetAddress *serverAddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器通道</span></span><br><span class="line">	Channel *serverChannel;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存客户端的套接字</span></span><br><span class="line">	std::vector&lt;std::pair&lt;Socket *, InetAddress *&gt;&gt; clients;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向Acceptor对象的指针</span></span><br><span class="line">	Acceptor *acceptor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day06">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day06">Gitee</a></p>
<h2 id="七-把tcp连接抽象化">七、把TCP连接抽象化</h2>
<h3 id="7-1-抽象化连接">7.1 抽象化连接</h3>
<p>对于 TCP 协议，在三次握手新建连接后，该连接会一直存在直至四次挥手断开连接。</p>
<p>那么把这个连接也抽象化，抽象成 <code>Connection</code> 类。</p>
<h3 id="7-2-connection-类">7.2 Connection 类</h3>
<p>Connection 类应该有以下特点：</p>
<ul>
<li>类存在于事件驱动类中；</li>
<li>类的 Socket fd 就是客户端的 Socket fd，每一个<br>
Connection 对象都对应一个 Socket fd。</li>
<li>类也通过一个 <code>Channel</code> 负责分发到 epoll，该 <code>Channel</code> 的事件处理函数 <code>handleEvent()</code> 会调用 <code>Connection</code> 类中的事件处理函数进行响应客户端请求。</li>
</ul>
<p><code>Connection</code> 类与 <code>Acceptor</code> 类十分相似，它们都由 <code>Server</code> 管理，由一个 <code>Channel</code> 分发到 epoll，通过回调函数处理响应事件。</p>
<p>一个高并发服务器一般只有一个 <code>Acceptor</code>（可以有多个），但会同时有成千上万个 TCP 连接，也就是 <code>Connection</code> 的实例。</p>
<p>对 <code>Connection</code> 类的定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *loop;</span><br><span class="line">	Socket *sock;</span><br><span class="line">	Channel *channel;</span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; deleteConnectionCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(EventLoop *_loop, Socket *_sock);</span><br><span class="line">	~<span class="built_in">Connection</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 回显sockfd发来的数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 设置删除连接时要调用的回调函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; _callback)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-3-改写-server-类">7.3 改写 Server 类</h3>
<p><code>Server</code> 类的核心变成：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向Acceptor对象的指针</span></span><br><span class="line">	Acceptor *acceptor;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">	std::map&lt;<span class="type">int</span>, Connection *&gt; connections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(EventLoop *_loop);</span><br><span class="line">	~<span class="built_in">Server</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 处理客户端请求，暂时没有</span></span><br><span class="line">	<span class="comment">// void handleReadEvent(int fd);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 处理与所提供套接字的新连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(Socket *_socket)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 断开与提供的套接字关联的连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteConnection</span><span class="params">(Socket *_socket)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>Map</code> 映射将众多连接保存起来，键为该连接客户端的 <code>socket fd</code>，值为指向该连接的指针。</li>
<li>该连接客户端的 <code>socket fd</code> 通过一个 <code>Channel</code> 类分发到 <code>epoll</code>，该 <code>Channel</code> 的事件处理回调函数 <code>handleEvent()</code> 绑定为 <code>Connection</code> 的处理函数，这样每当该连接的 <code>socket fd</code> 上发生事件，就会通过 <code>Channel</code> 调用具体连接类的处理函数。</li>
</ul>
<p>此处将新建连接的功能放回到 <code>Acceptor</code> 类中管理：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::acceptConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 创建一个新的InetAddress对象来存储客户端地址信息</span></span><br><span class="line">	InetAddress *clientAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过使用客户端地址接受来自服务器套接字的连接，创建一个新的Socket对象</span></span><br><span class="line">	Socket *clientSock = <span class="keyword">new</span> <span class="built_in">Socket</span>(sock-&gt;<span class="built_in">accept</span>(clientAddr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印有关新客户端连接的信息</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">"New client "</span> &lt;&lt; clientSock-&gt;<span class="built_in">getFd</span>() &lt;&lt; <span class="string">": "</span> &lt;&lt;</span><br><span class="line">		<span class="built_in">inet_ntoa</span>(clientAddr-&gt;addr.sin_addr) &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="built_in">ntohs</span>(clientAddr-&gt;addr.sin_port) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">	clientSock-&gt;<span class="built_in">setNonBlocking</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">newConnectionCallback</span>(clientSock);</span><br><span class="line">	<span class="keyword">delete</span> clientAddr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>Server</code> 类变得只负责管理 <code>Acceptor</code> 和 <code>Connection</code> 类，其成员函数也集中在管理 <code>Acceptor</code> 和 <code>Connection</code> 类中。改写后的 <code>Server</code> 类代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::newConnection</span><span class="params">(Socket *_socket)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(loop, _socket);</span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; cb = std::<span class="built_in">bind</span>(&amp;Server::deleteConnection, <span class="keyword">this</span>, std::placeholders::_1);</span><br><span class="line">	conn-&gt;<span class="built_in">setDeleteConnectionCallback</span>(cb);</span><br><span class="line">	connections[_socket-&gt;<span class="built_in">getFd</span>()] = conn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::deleteConnection</span><span class="params">(Socket *_socket)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Connection *conn = connections[_socket-&gt;<span class="built_in">getFd</span>()];</span><br><span class="line">	connections.<span class="built_in">erase</span>(_socket-&gt;<span class="built_in">getFd</span>());</span><br><span class="line">	<span class="keyword">delete</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当有新的 TCP 连接时，实例化一个 <code>Connection</code> 对象，设置其删除时的回调函数，并放置在 <code>connections</code> 中管理。
<ul>
<li>目前该服务器的唯一功能——接受客户端的信息并发回，封装成 <code>Connection</code> 类的 <code>echo</code> 函数，在 <code>Connection</code> 构造时绑定给 <code>Channel</code> 类的事件回调函数，由 <code>Channel</code> 实例遇到事件时触发。</li>
</ul>
</li>
<li>当有 TCP 连接断开时，从 <code>connections</code> 中删除该连接，并释放对象。
<ul>
<li>由于 <code>Connection</code> 的生命周期由 <code>Server</code> 进行管理，所以也应该由 <code>Server</code> 来删除连接</li>
</ul>
</li>
</ul>
<p>至此，服务器到了一个比较重要的阶段，服务器最核心的几个模块都已经抽象出来，一个完整的单线程服务器设计基本完成。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day07">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day07">Gitee</a></p>
<h2 id="八-闲来无事-整个缓冲区">八、闲来无事，整个缓冲区</h2>
<h3 id="8-1-引入缓冲区">8.1 引入缓冲区</h3>
<p>此节引入一个最简单、最基本的缓冲区，完善改进之前的服务器。</p>
<p>没有使用缓冲区时，服务器回送信息的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">char</span> buf[READ_BUFFER];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">ssize_t</span> readLen = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			std::cout &lt;&lt; buf &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="built_in">write</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是非阻塞式 socket IO 的读取，缓冲区大小为 1024，表示每次 TCP 缓冲区读取 1024 大小的数据到缓冲区，然后发送到客户端。</li>
<li>只能以 1024 地读，当数据没有 1024，用空值补满。</li>
</ul>
<p>所以，封装一个缓冲区，为每一个 <code>Connection</code> 类分配一个读缓冲区和写缓冲区：</p>
<ul>
<li>从客户端读来的数据存放在都缓冲区。</li>
</ul>
<h3 id="8-2-buffer类">8.2 Buffer类</h3>
<p><code>Buffer</code> 类的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 向当前字符串追加一个字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str, <span class="type">int</span> _size)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 返回当前缓冲区字符串大小</span></span><br><span class="line">	<span class="function"><span class="type">ssize_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief返回指向底层字符串数据的指针</span></span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="type">const</span> *<span class="title">c_str</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 清空当前缓冲区字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 从控制台获取输入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getline</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>使用如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/Connection.cpp */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">ssize_t</span> readLen = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			readBuffer-&gt;<span class="built_in">append</span>(buf, readLen);	<span class="comment">// 缓冲区追加</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span> <span class="keyword">and</span> errno == EINTR)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span> <span class="built_in">and</span> ((errno == EAGAIN) <span class="built_in">or</span> (errno == EWOULDBLOCK)))</span><br><span class="line">		{	<span class="comment">// 从缓冲区中读取数据，同时进行回写</span></span><br><span class="line">			std::cout &lt;&lt; readBuffer-&gt;<span class="built_in">c_str</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="built_in">errorif</span>(<span class="built_in">write</span>(sockfd, readBuffer-&gt;<span class="built_in">c_str</span>(), readBuffer-&gt;<span class="built_in">size</span>()) == <span class="number">-1</span>, <span class="string">"***"</span>);</span><br><span class="line">			readBuffer-&gt;<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">deleteConnectionCallback</span>(sock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>虽然仍有 <code>char buf[1024]</code> 这样的低级缓冲区，用于系统调用 <code>read()</code> 的读取，但这个缓冲区大小无所谓，设置为1到设备TCP缓冲区的大小都可以。</p>
<ul>
<li>太大导致资源浪费，单词读取速度低；</li>
<li>太小导致读取次数增多。</li>
</ul>
<p>以上代码会把 socket IO 上的可读数据全部读取到缓冲区，缓冲区大小就等于客户端发送的数据大小。全部读取完成之后，可以构造一个写缓冲区、填好数据发送给客户端。</p>
<ul>
<li>由于是echo服务器，所以这里使用了相同的缓冲区。</li>
</ul>
<h3 id="8-3-其他方面的改进">8.3 其他方面的改进</h3>
<ul>
<li>
<p>优化 InetAddress 类，将成员私有化，提供访问方法。（—— <code>src/InetAddress.h</code> 和 <code>src/InetAddress.cpp</code>）</p>
</li>
<li>
<p>Socket 类添加 <code>connect</code> 方法，方便 <code>client.cpp</code> 调用。（—— <code>src/Socket.h</code> 和 <code>src/Socket.cpp</code>）</p>
</li>
<li>
<p>结合现有的模块，改进 client 文件。（—— <code>client.cpp</code>）</p>
</li>
<li>
<p>整体改进了了输出信息提示。</p>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-1.jpg" alt="服务器端"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-2.jpg" alt="客户端"></p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day08">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day08">Gitee</a></p>
<h2 id="九-线程池啊线程池">九、线程池啊线程池</h2>
<h3 id="9-1-为什么加入线程池">9.1 为什么加入线程池</h3>
<p>当前的代码是单线程模式，所有 fd 上的事件都由一个线程（主线程，EventLoop线程）处理。</p>
<ul>
<li>假设响应一个事件需要 1s，那么如果有 1000 个事件，那么主线程就要等待很久。</li>
<li>这不现实。</li>
</ul>
<p>引入多线程，当发现 socket fd 有事件时，应该分发一个工作线程。</p>
<ul>
<li>由这个工作线程处理 fd 上的事件。</li>
</ul>
<p>再者，每一个 Reactor 只应该负责事件分发而不负责事件处理。</p>
<h3 id="9-2-如何设计线程池">9.2 如何设计线程池</h3>
<p>最简单的想法就是，每次遇到一个新的任务，就开一个新线程去执行。</p>
<ul>
<li>这种方式虽然简单，但是太粗暴了。</li>
<li>我们的机器是有上限的，不可能无限开新线程。</li>
</ul>
<p>那么，可以固定一个线程的数量。启动固定数量的工作线程，然后将任务添加到任务队列，工作线程不断取出任务队列的任务执行。</p>
<p>设计线程池还需要注意：</p>
<ol>
<li>多线程环境下任务队列的读写应该考虑互斥锁。</li>
<li>当任务队列为空时，CPU 不应该一直轮询耗费 CPU 资源。</li>
</ol>
<p>此处解决方法如下：</p>
<ol>
<li><code>std::mutex</code> 对任务队列进行加锁解锁。</li>
<li><code>std::condition_variable</code> 使用条件变量。</li>
</ol>
<h3 id="9-3-线程池用到的语法知识">9.3 线程池用到的语法知识</h3>
<p><strong>关于互斥锁：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/mutex">mutex头文件 - cppreference</a></strong></p>
<ul>
<li><code>mutex</code> 类是能用于保护共享数据免受从多个线程同时访问的同步原语。</li>
<li><code>lock()</code>：成员函数，锁定互斥体，若互斥体不可用则阻塞。位于头文件 <code>&lt;mutex&gt;</code>。
<ul>
<li>通常不直接调用 <code>lock()</code>。</li>
<li>用 <code>std::unique_lock</code> 与 <code>std::lock_guard</code> 管理排他性锁定。</li>
<li><code>unique_lock</code> 类是一种通用互斥包装器，允许延迟锁定、有时限的锁定尝试、递归锁定、所有权转移和与条件变量一同使用。</li>
<li>构造函数：<code>explicit unique_lock( mutex_type&amp; m );</code>，通过调用 <code>m.lock()</code> 锁定关联互斥体。</li>
<li>析构函数：若拥有关联互斥体且获得了其所有权，则解锁互斥体。</li>
</ul>
</li>
<li><code>try_lock()</code>：成员函数，尝试锁定互斥体，若互斥体不可用则返回 <code>false</code>。位于头文件 <code>&lt;mutex&gt;</code>。</li>
<li><code>unlock()</code>：成员函数，解锁互斥体。位于头文件 <code>&lt;mutex&gt;</code>。</li>
</ul>
<p><strong>关于线程等待条件：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/condition_variable">condition_variable头文件 - cppreference</a></strong></p>
<ul>
<li><code>std::condition_variable</code>（线程等待条件） 是与 <code>std::mutex</code> 一起使用的同步原语。</li>
<li>它能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 <code>std::condition_variable</code>。</li>
<li>有意修改变量的线程必须：
<ol>
<li>获得 <code>std::mutex</code>（常通过 <code>std::lock_guard</code>）</li>
<li>在保有锁时进行修改</li>
<li>在 <code>std::condition_variable</code> 上执行 <code>notify_one</code> 或 <code>notify_all</code>（可以释放锁后再通知）</li>
</ol>
</li>
<li>任何有意在 <code>std::condition_variable</code> 上等待的线程必须：
<ol>
<li>在用于保护共享变量的互斥体上获得 <code>std::unique_lock&lt;std::mutex&gt;</code>。</li>
<li>执行下列之一：
<ul>
<li>检查条件，是否为已更新且已提醒的情况。</li>
<li>调用 <code>std::condition_variable</code> 的 <code>wait</code>、<code>wait_for</code> 或 <code>wait_until</code>（原子地释放互斥体并暂停线程的执行，直到条件变量被通知，时限过期，或发生虚假唤醒，然后在返回前自动获得互斥体）。</li>
<li>检查条件，并在未满足的情况下继续等待。</li>
</ul>
</li>
</ol>
</li>
<li><code>wait()</code>：成员函数，阻塞当前进程，直至条件变量被唤醒。位于头文件 <code>&lt;condition_variable&gt;</code>。
<ul>
<li>类似还有<code>wait_for</code>、<code>wait_until</code>。不多说，自行查阅。</li>
</ul>
</li>
<li><code>notify_one()</code>：成员函数，通知一个等待的线程。位于头文件 <code>&lt;condition_variable&gt;</code>。</li>
<li><code>notify_all()</code>：成员函数，通知所有等待的线程。位于头文件 <code>&lt;condition_variable&gt;</code>。</li>
</ul>
<h3 id="9-4-线程池类">9.4 线程池类</h3>
<p>线程池类代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 线程池中的线程</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">// 要执行的函数</span></span><br><span class="line">	std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line">	<span class="comment">// 声明互斥锁以同步对任务队列的访问</span></span><br><span class="line">	std::mutex tasksMtx;</span><br><span class="line">	<span class="comment">// 声明在线程之间进行协调的条件变量</span></span><br><span class="line">	std::condition_variable cv;</span><br><span class="line">	<span class="comment">// 指示线程停止的标志</span></span><br><span class="line">	<span class="type">bool</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadPool</span>(<span class="type">int</span> size = <span class="number">10</span>);</span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 加入任务到任务队列中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>线程池的构造函数设计为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> size) : <span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++ i)</span><br><span class="line">	{</span><br><span class="line">		threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">thread</span>([<span class="keyword">this</span>] ()</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">				{</span><br><span class="line">					std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">					{<span class="comment">// 使用作用域生命期解锁 std::mutex，而不调用unlock()</span></span><br><span class="line">						std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(tasksMtx);</span><br><span class="line">						<span class="comment">// 当任务队列不为空或线程池停止时停止等待（阻塞）</span></span><br><span class="line">						cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] (){</span><br><span class="line">								<span class="keyword">return</span> stop <span class="keyword">or</span> !tasks.<span class="built_in">empty</span>();</span><br><span class="line">							});</span><br><span class="line">						<span class="keyword">if</span> (stop <span class="keyword">and</span> tasks.<span class="built_in">empty</span>())	<span class="comment">// 任务队列为空且线程池停止，退出循环</span></span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						task = tasks.<span class="built_in">front</span>();</span><br><span class="line">						tasks.<span class="built_in">pop</span>();</span><br><span class="line">					}</span><br><span class="line">					<span class="built_in">task</span>();	<span class="comment">// 执行任务</span></span><br><span class="line">				}</span><br><span class="line">			}));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>初始线程池大小为 <code>size</code>，创建线程并让每个线程等待将任务添加到任务队列中。</li>
<li>使用 <code>std::unique_lock</code> 锁定任务互斥锁以防止并发访问，并将其置于局部作用域，当离开作用域时，它将自动解锁互斥锁。</li>
<li>当添加任务时，线程从队列中获取任务并执行它。线程将继续执行任务，直到线程池停止。</li>
</ol>
<p>析构函数设计为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">{</span><br><span class="line">	{</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(tasksMtx)</span></span>;</span><br><span class="line">		stop = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	cv.<span class="built_in">notify_all</span>();	<span class="comment">// 通知所有等待的线程线程池正在停止</span></span><br><span class="line">	<span class="keyword">for</span> (std::thread &amp;th : threads)</span><br><span class="line">	{	<span class="comment">// 检查线程是否可接合</span></span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();	<span class="comment">// 阻塞当前线程，直到指定线程完成其执行</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在线程池析构时，需要注意将已经添加的所有任务执行完，最好不采用外部的暴力kill、而是让每个线程从内部自动退出，具体实现参考源代码。</li>
</ul>
<ol>
<li>在上锁的情况下，把线程池的停止状态设置为<code>true</code>，然后通知所有等待的线程线程池正在停止。</li>
<li>然后，等待所有线程完成其执行。</li>
</ol>
<p>加入线程池后，当 <code>Channel</code> 类有事件需要处理时，将这个事件处理添加到线程池，主线程 <code>EventLoop</code> 就可以继续进行事件循环，而不在乎某个 <code>socket fd</code> 上的事件处理。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day09">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day09">Gitee</a></p>
<h2 id="十-有了线程池之后的考虑">十、有了线程池之后的考虑</h2>
<h3 id="10-1-完善线程池">10.1 完善线程池</h3>
<p>上一节添加的线程池是最简单的线程池，还存在许多问题，比如：</p>
<ul>
<li>任务队列的添加、取出都会有不必要的拷贝操作；</li>
<li>线程池只接受 <code>std::function&lt;void&gt;</code> 类型的参数，所有函数参数都要事先使用 <code>std::bind()</code>，并且无法得到返回值。</li>
</ul>
<p>解决方法一一对应：</p>
<ul>
<li>使用右值移动去避免拷贝操作。</li>
<li>改写 <code>add()</code> 函数，希望使用前不需要手动绑定参数，直接传递并且可以得到任务的返回值。</li>
</ul>
<h3 id="10-2-完善线程池用到的语法知识">10.2 完善线程池用到的语法知识</h3>
<p><strong>关于模板编程：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/templates-cpp?view=msvc-170">模板 - MSLearn</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/655902377">理解C++模板 - 知乎</a></strong></p>
<ul>
<li>简单来说，模板编程就是提供了一套模具，对于不同的数据类型都可以适用于这套模具。</li>
<li>函数模板的结构一般如下：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 返回类型 函数名(参数列表){ <span class="comment">/*函数的主体*/</span> }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>类模板结构一般如下：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> 类名 {}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/394184676">变长参数模板</a>：参数个数和类型都可能发生变化的模板。
<ul>
<li>使用模板形参包实现。</li>
<li>模板形参包是可以接受 0 个或者 n 个模板实参的模板形参，至少有一个模板形参包的模板就可以称作变参数模板。</li>
<li>模板形参包有：非类型模板形参包、类型模板形参包、模板模板形参包三种。</li>
<li>此节使用类型模板形参包：表示该可变形参包可以接受无限个不同的实参类型。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span>... Args 或 <span class="keyword">class</span> ... Args</span><br></pre></td></tr></tbody></table></figure>
<p><strong>关于右值和移动 <code>std::move</code>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/reyas/article/details/137735522">C++引用和右值引用 - CSDN</a>、<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2341672">【C++】C++11——左右值|右值引用|移动语义|完美转发</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move - 知乎</a></strong></p>
<ul>
<li>C++11 后增加了移动语义，出现了移动构造、移动赋值等。</li>
<li>简单来说，移动语义的出现，可以把旧对象所拥有的资源交给新对象，而旧对象什么都没有了。</li>
<li>右值引用的出现也是为了移动语义。</li>
</ul>
<p><strong>关于完美转发 <code>std::forward</code>：</strong></p>
<ul>
<li>和 <code>std::move</code> 类似，与 <code>std::move</code>相比，它更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</li>
<li><code>std::forward&lt;T&gt;(u)</code> 有两个参数：<code>T</code> 与 <code>u</code>。
<ul>
<li>当 <code>T</code> 为左值引用类型时，<code>u</code> 将被转换为 <code>T</code> 类型的左值；</li>
<li>否则 <code>u</code> 将被转换为 <code>T</code> 类型右值。</li>
</ul>
</li>
</ul>
<p><strong>关于 <code>std::future</code>：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/future">future - cppreference</a></strong></p>
<ul>
<li>类模板 <code>std::packaged_task</code> 可以包装任何可调用 (Callable) 目标（函数、lambda 表达式、bind 表达式或其他函数对象），使得能异步调用它。其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。
<ul>
<li>成员函数 <code>get_future()</code>，返回与 <code>*this</code> 共享同一共享状态的 <code>future</code>，每个 <code>packaged_task</code> 对象只能调用一次。</li>
</ul>
</li>
<li>类模板 <code>std::future</code>：<code>future</code> 对象提供访问异步操作结果的机制，从异步任务中返回结果。</li>
<li>类模板 <code>std::future</code> 提供访问异步操作结果的机制：
<ul>
<li>（通过 <code>std::async</code>、<code>std::packaged_task</code> 或 <code>std::promise</code> 创建的）异步操作能提供一个 <code>std::future</code> 对象给该异步操作的创建者。</li>
<li>然后，异步操作的创建者可以使用多个方法查询、等待或从 <code>std::future</code> 提取值。若异步操作尚未提供值，则这些方法可能阻塞。</li>
<li>当异步操作准备好发送结果给创建者时，它可以修改与创建者的 <code>std::future</code> 相链接的共享状态（例如 <code>std::promise::set_value</code>）。</li>
</ul>
</li>
</ul>
<h3 id="10-3-再修修补补">10.3 再修修补补</h3>
<p>除了上面线程池的部分有修改，以下部分也有修改：</p>
<p>Channel 部分：</p>
<ul>
<li>新增标记位和是否使用线程池的函数；</li>
<li>对于处理事件区分了读事件和写事件分别的回调函数；</li>
<li>新增可选择性 epoll ET 模式或 epoll LT 模式；</li>
</ul>
<p>Acceptor 部分：因为接受连接处理时间短、报文数据小，也不会有同时到达的新连接，所以</p>
<ul>
<li>Acceptor 的 socket fd （服务器监听 socket）使用阻塞式：</li>
<li>Acceptor 从 epoll ET 模式改为 epoll LT 模式，建立好连接后处理事件 fd 读写用 ET 模式。</li>
<li>Acceptor 的连接建立不适用线程池，建立好连接后处理事件使用线程池。</li>
</ul>
<p>Connection 部分：</p>
<ul>
<li>新增 <code>send()</code> 函数，独立发送数据。</li>
<li>修改 <code>deleteConnectionCallback()</code> 函数，参数类型改为 <code>int</code>。</li>
</ul>
<p>Epoll 部分：</p>
<ul>
<li>新增 <code>deleteChannel()</code> 函数，用于删除 Channel。</li>
</ul>
<p>Server 部分：</p>
<ul>
<li>新增 <code>deleteConnection()</code> 函数。</li>
</ul>
<p>更多细节上的变化（可能有部分错误处理、变量变化）可比较前一天的文件。</p>
<p><em>服务器中还可能有潜在的bug。</em></p>
<p>最后，添加测试连接的程序 <code>test.cpp</code>，使用命令 <code>make t</code> 编译，使用如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test -t 1000 -m 10 -w 100</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-t</code> 表示线程数量，此处为 1000 个线程进行服务器连接；</li>
<li><code>-m</code> 表示每个线程的回显次数，此处为每个线程回显 10 次；</li>
<li><code>-w</code> 表示每个线程的等待时间，可以测试最大连接数，可以不设置。</li>
</ul>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day10">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day10">Gitee</a></p>
<h2 id="十一-改写成主从reactor多线程模式">十一、改写成主从Reactor多线程模式</h2>
<h3 id="11-1-什么是主从reactor多线程模式">11.1 什么是主从Reactor多线程模式</h3>
<p>现在实现的服务器多线程 Reactor 模式，是给每一个 Channel 的任务分配一个线程执行。但目前的线程池对象置于 EventLoop 中，而不是由服务器类 Server 类管理。</p>
<p>主从 Reactor 多线程模式是大多数高性能服务器采用的模式。</p>
<blockquote>
<p>陈硕《Linux多线程服务器编程》书中的 one loop per thread 模式。</p>
</blockquote>
<p>该模式的特点有：</p>
<ul>
<li>服务器一般只有一个 main Reactor，有多个 sub Reactor。</li>
<li>服务器管理一个线程池，每一个 sub Reactor 由一个线程来负责 Connection 上的事件循环，事件执行也在这个线程中完成。</li>
<li>main Reactor 只负责 Acceptor 建立新连接，然后将这个连接分配给一个 sub Reactor。</li>
</ul>
<h3 id="11-2-代码上的变化">11.2 代码上的变化</h3>
<p>根据主从 Reactor 多线程模式的特点，将服务器类重写如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *mainReactor;						<span class="comment">// 只负责接受连接，然后分发给一个subReactor</span></span><br><span class="line">	Acceptor *acceptor;							<span class="comment">// 连接接受器</span></span><br><span class="line">	std::vector&lt;EventLoop *&gt; subReactors;		<span class="comment">// 负责处理事件循环</span></span><br><span class="line">	std::map&lt;<span class="type">int</span>, Connection *&gt; connections;	<span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">	ThreadPool *threadPool;						<span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在有一个新连接到来时，采用随机调度策略分配给一个 subReactor：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> random = _socket-&gt;<span class="built_in">getFd</span>() % subReactors.<span class="built_in">size</span>();</span><br><span class="line">Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(subReactors[random], _socket);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这种调度算法适用于每个socket上的任务处理时间基本相同，可以让每个线程均匀负载。但事实上，不同的业务传输的数据极有可能不一样，也可能受到网络条件等因素的影响，极有可能会造成一些 subReactor 线程十分繁忙，而另一些 subReactor 线程空空如也。此时需要使用更高级的调度算法，如根据繁忙度分配，或支持动态转移连接到另一个空闲 subReactor 等。</li>
</ul>
<p><em>调度问题是个很有趣的问题，会直接影响服务器的效率和性能。</em></p>
<p>代码上，还将原来在 EventLoop 的线程池去掉，Channel 也不再区分是否使用线程池。</p>
<p>现在，服务器以事件驱动为核心，服务器线程只负责 mainReactor 的新建连接任务，同时维护一个线程池，每一个线程是一个事件循环，新连接建立后分发给一个 subReactor 开始事件监听，有事件发生则在当前线程处理。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day11">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day11">Gitee</a></p>
<h2 id="十二-项目工程化">十二、项目工程化</h2>
<p>目前服务器的结构是主从 Reactor 多线程模式，是比较主流的模式。所以大体上的方向已经确定，接下来对细节进行优化，把项目工程化。</p>
<h3 id="12-1-认识cmake">12.1 认识Cmake</h3>
<p>首先，CMake是一个跨平台的编译工具，可以用简单的语句进行编译。</p>
<p>一个项目使用 CMake 维护一个 <code>CMakeLists.txt</code> 配置文件来描述一个项目的编译过程。利用这个文件，就可以搭建起来这个项目。</p>
<p>目前将所有文件都放在一个文件夹，并且没有分类。随着项目越来越复杂、模块越来越多，开发者需要考虑这座屎山的可读性，如将模块拆分到不同文件夹，将头文件统一放在一起等。</p>
<p>对于这样复杂的项目，如果手写复杂的Makefile来编译链接，那么将会相当负责繁琐。我们应当使用 CMake 来管理我们的项目，CMake 的使用非常简单、功能强大，会帮我们自动生成 Makefile 文件，使项目的编译链接更加容易，程序员可以将更多的精力放在写代码上。</p>
<p>这是 <code>CmakeLists.txt</code> 基本结构：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx：本 CMakeLists.txt 的 project 名称</span></span><br><span class="line"><span class="comment"># 会自动创建两个变量，PROJECT_SOURCE_DIR 和 PROJECT_NAME</span></span><br><span class="line"><span class="comment"># ${PROJECT_SOURCE_DIR}：本 CMakeLists.txt 所在的文件夹路径</span></span><br><span class="line"><span class="comment"># ${PROJECT_NAME}：本CMakeLists.txt 的 project 名称</span></span><br><span class="line"><span class="keyword">project</span>(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取路径下所有的.cpp/.c/.cc文件，并赋值给变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(路径 变量)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给文件名/路径名或其他字符串起别名，用${变量}获取变量内容</span></span><br><span class="line"><span class="keyword">set</span>(变量 文件名/路径/...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加编译选项</span></span><br><span class="line"><span class="keyword">add_definitions</span>(编译选项)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印消息</span></span><br><span class="line"><span class="keyword">message</span>(消息)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译子文件夹的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(子文件夹名称)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp/.c/.cc文件生成.a静态库</span></span><br><span class="line"><span class="comment"># 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可</span></span><br><span class="line"><span class="keyword">add_library</span>(库文件名称 STATIC 文件)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp/.c/.cc文件生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名称 文件)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定.h头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定.so/.a库文件路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对add_library或add_executable生成的文件进行链接操作</span></span><br><span class="line"><span class="comment"># 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(库文件名称/可执行文件名称 链接的库文件名称)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="12-2-工程化的实际操作">12.2 工程化的实际操作</h3>
<p>首先规范化目录的意义：</p>
<ul>
<li><code>src</code> 目录（即source），用于存放核心的代码；
<ul>
<li><code>include</code> 目录，用于存放源代码中的头文件；</li>
</ul>
</li>
<li><code>test</code> 目录，用于存放测试的代码；</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">projiect/</span><br><span class="line">├─src/</span><br><span class="line">│ ├─include/</span><br><span class="line">│ │ ├─*.h</span><br><span class="line">│ ├─*.cpp</span><br><span class="line">├─test/</span><br><span class="line">│ ├─*.cpp</span><br></pre></td></tr></tbody></table></figure>
<p>在这一章，我们使用的是一个 CMake 工程，所以 Visual Studio 创建的是 CMake 项目。接下来就是 CMake 的配置工作。（<em>有关 CMake 的安装使用可参考附 2</em>）</p>
<p>构建上述文件目录，将对应的文件分类进去。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-1.jpg" alt="文件结构"></p>
<p>接着，开始编写项目的根 <code>CMakeLists.txt</code> 文件（即根目录下的 <code>CMakeLists.txt</code> ）：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)    <span class="comment"># CMake运行的最小版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)   <span class="comment"># 启用编译命令的导出，常与代码分析工具配合使用</span></span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)               <span class="comment"># 构建共享（动态）库</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)              <span class="comment"># 设置C++标准为17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)     <span class="comment"># 要求编译器支持C++17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译器</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">"clang"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">"clang++"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Day12           <span class="comment"># 项目名称</span></span><br><span class="line">        LANGUAGES CXX   <span class="comment"># 项目语言</span></span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为源代码和测试添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># set(TEST_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/test/include)</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${SRC_INCLUDE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">${CMAKE_BINARY_DIR}</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">${CMAKE_BINARY_DIR}</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">${CMAKE_BINARY_DIR}</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译和链接选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"${CMAKE_CXX_FLAGS} -fPIC -Wall -Wextra -std=c++17 -pthread"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"${CMAKE_CXX_FLAGS_DEBUG} -O0 -ggdb -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS  <span class="string">"${CMAKE_EXE_LINKER_FLAGS} -fPIC"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">"${CMAKE_SHARED_LINKER_FLAGS} -fPIC"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_STATIC_LINKER_FLAGS <span class="string">"${CMAKE_STATIC_LINKER_FLAGS} -fPIC"</span>)</span><br><span class="line"><span class="keyword">set</span>(GCC_COVERAGE_LINK_FLAGS <span class="string">"-fPIC"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示编译器和链接器标志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_CXX_FLAGS_DEBUG: ${CMAKE_CXX_FLAGS_DEBUG}"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMAKE_SHARED_LINKER_FLAGS: ${CMAKE_SHARED_LINKER_FLAGS}"</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第一次接触 CMake 命令可以参考注释理解。</li>
</ul>
<p>接着，尝试把我们关于服务器的设计打包成一个库，即编写 <code>src/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${SRC_INCLUDE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索/src目录中的所有.cpp文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE day12_sources <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置共享库链接选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">"${CMAKE_SHARED_LINKER_FLAGS}  -fPIC -pthread"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用源文件创建一个名为day12_shared的共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(day12_shared SHARED <span class="variable">${day12_sources}</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>然后，把测试文件的 <code>CMakeLists.txt</code>（即 <code>test/CMakeLists.txt</code>）也编写一下，用于管理测试文件的编译：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${SRC_INCLUDE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置变量TEST_SOURCES，将所有.cpp文件存储在测试目录中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB TEST_SOURCES <span class="string">"${PROJECT_SOURCE_DIR}/test/*.cpp"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为“build-tests”的自定义目标以仅显示测试</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(build-tests <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_CTEST_COMMAND}</span> --show-only)</span><br><span class="line"><span class="comment"># 创建名为“check-tests”的自定义目标以在详细模式下运行测试</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(check-tests <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_CTEST_COMMAND}</span> --verbose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历TEST_SOURCES中的每个测试源文件</span></span><br><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">${TEST_SOURCES}</span>)</span><br><span class="line">    <span class="comment"># 组合为可读的名称，使得每个Cpp都可以make</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(test_filename <span class="variable">${test_source}</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">".cpp"</span> <span class="string">""</span> test_name <span class="variable">${test_filename}</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为测试添加可执行目标，默认情况下将其从所有生成中排除</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">${test_name}</span> EXCLUDE_FROM_ALL <span class="variable">${test_source}</span>)</span><br><span class="line">    <span class="comment"># 添加对生成测试和检查测试的依赖项</span></span><br><span class="line">    <span class="keyword">add_dependencies</span>(build-tests <span class="variable">${test_name}</span>)</span><br><span class="line">    <span class="keyword">add_dependencies</span>(check-tests <span class="variable">${test_name}</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将“day12_shared”库链接到可执行测试文件</span></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">${test_name}</span> day12_shared)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置测试目标的属性，指定输出目录和运行测试的命令</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(<span class="variable">${test_name}</span></span><br><span class="line">        PROPERTIES</span><br><span class="line">        RUNTIME_OUTPUT_DIRECTORY <span class="string">"${CMAKE_BINARY_DIR}/bin"</span></span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${test_name}</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endforeach</span>(test_source <span class="variable">${TEST_SOURCES}</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>当然，这章在代码上也有些许修改，比如函数参数做了 <code>const &amp;</code>，类也禁止了拷贝和移动操作。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day12">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day12">Gitee</a></p>
<p>接着只需要把项目部署到远程 Linux 服务器，使用以下命令编译即可：</p>
<ul>
<li><code>make server</code>：编译服务端代码</li>
<li><code>make SingleClient</code>：编译单个客户端连接代码</li>
<li><code>make MultipleClients</code>：编译多个客户端连接代码</li>
<li><code>make clean</code>：清理生成</li>
</ul>
<p>运行只需要：</p>
<ul>
<li><code>./bin/server</code>：启动服务端</li>
<li><code>./bin/SingleClient</code>：启动单个客户端连接</li>
<li><code>./bin/MultipleClients -t 线程数 -m 回显消息数 -w 延时发送信息</code>：启动多个客户端连接</li>
</ul>
<blockquote>
<p>原作者还进行了代码静态分析和代码格式化，详见地址：<a target="_blank" rel="noopener" href="https://github.com/yuesong-feng/30dayMakeCppServer/blob/main/day13-C%2B%2B%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md">Github</a></p>
</blockquote>
<h2 id="十三-业务逻辑自定义化">十三、业务逻辑自定义化</h2>
<h3 id="13-1-业务逻辑思想">13.1 业务逻辑思想</h3>
<p>首先回顾之前的思想，我们目前服务器只有一个功能，就是进行回声（Echo）：把客户端发来的消息再发送回去。而这个功能，或者说业务逻辑，就固定在 <code>Connection</code> 类。</p>
<p>而通过第十二章的设计，我们把网络方面的代码整合为一个链接库。很明显，作为一个库，并不能就这样把业务逻辑固定了，应该支持业务逻辑自定义。</p>
<p>业务逻辑由用户自定义，然后使用网络库进行服务器与客户端间的交互。</p>
<blockquote>
<p>怎样事件触发、读取数据、异常处理等流程应该是网络库提供的基本功能，用户只应当关注怎样处理业务即可，所以业务逻辑的进入点应该是服务器读取完客户端的所有数据之后。这时，客户端传来的请求在 <code>Connection</code> 类的读缓冲区里，只需要根据请求来分发、处理业务即可。</p>
</blockquote>
<p>总体上，服务器端提出这样的设计：</p>
<ul>
<li>具有一个 <code>Server</code> 类和一个事件循环类。</li>
<li>通过回调函数的方式编写业务逻辑，传给 <code>Server</code> 类的实例。
<ul>
<li>只需关心服务器的处理方法，比如一个 Echo 服务器只需要把对方发来的信息发回去。通过设置 <code>onMessage</code> 回调函数来自定义自己的业务逻辑，在服务器完全接收到客户端的数据之后，该函数触发。</li>
<li>可以设置连接时的业务逻辑和整个服务端的业务逻辑。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Server *server = <span class="keyword">new</span> <span class="built_in">Server</span>(loop);</span><br><span class="line"></span><br><span class="line">server-&gt;<span class="built_in">newConnect</span>([] (Connection *conn) </span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 服务器对有新连接时的操作函数</span></span><br><span class="line">	});</span><br><span class="line"></span><br><span class="line">server-&gt;<span class="built_in">onMessage</span>([] (Connection *conn)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 服务器对客户端消息的操作函数</span></span><br><span class="line">	});</span><br></pre></td></tr></tbody></table></figure>
<p>另外，希望客户端的代码也可以通过我们的网络库进行实现：将 <code>Connection</code> 类进行完善，使得其满足服务端（Server → Client）和客户端（Client → Server）的使用：</p>
<ul>
<li>服务端和客户端的传输数据方向是相反的：对于服务端，它从客户端中读取数据，或者写入数据到客户端；对于客户端，它从服务端中读取数据，或者写入数据到服务端。</li>
<li>在发回数据时，应该考虑对方是否已经关闭了链接。所以还需要设计 <code>Connection</code> 的状态。</li>
</ul>
<p>总体上，客户端要使用 Connection 类，提出这样的设计：</p>
<ul>
<li>提供 <code>write()</code> 和 <code>read()</code> 函数。
<ul>
<li><code>write()</code> 函数表示将写缓冲区里的内容发送到该 <code>Connection</code> 的 socket，发送后会清空写缓冲区；</li>
<li><code>read()</code> 函数表示清空读缓冲区，然后将 TCP 缓冲区内的数据读取到读缓冲区。</li>
</ul>
</li>
<li>考虑 <code>Connection</code> 的状态 <code>State</code>。</li>
</ul>
<h3 id="13-2-操刀动代码">13.2 操刀动代码</h3>
<p>根据上面的分析，<code>Server</code> 进行改动如下：</p>
<ol>
<li>将 <code>Server</code> 类进行改写：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Connection *)&gt; onConnectionCallback;	<span class="comment">// 连接的业务逻辑</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Connection *)&gt; onMessageCallback;	<span class="comment">// 消息的业务逻辑</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Connection *)&gt; newConnectCallback;	<span class="comment">// 新连接的业务逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置服务器的业务逻辑</span></span><br><span class="line"><span class="comment">	 * @param fn 业务逻辑函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">onConnect</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置接收消息时调用的回调函数</span></span><br><span class="line"><span class="comment">	 * @param fn 回调函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置在建立新连接时调用的回调函数。</span></span><br><span class="line"><span class="comment">	 * @param fn 回调函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">newConnect</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是我们不能急，修改 <code>Server</code> 必须还得对 <code>Connection</code> 类的完善。因为服务器的一些操作是通过连接类完成，改动如下：</p>
<ol>
<li>添加连接状态（此处其实只关注是否连接建立即可）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span></span><br><span class="line">{</span><br><span class="line">	Invalid = <span class="number">1</span>, <span class="comment">// 初始无效状态</span></span><br><span class="line">	Handshaking, <span class="comment">// 握手过程中的状态</span></span><br><span class="line">	Connected,   <span class="comment">// 连接建立</span></span><br><span class="line">	Closed,      <span class="comment">// 连接关闭</span></span><br><span class="line">	Failed,      <span class="comment">// 连接失败</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>提供读写函数（详细见章末 Gitee 或 Github 链接）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 判断连接状态</span></span><br><span class="line">	<span class="comment">// 清空读缓冲区</span></span><br><span class="line">	<span class="comment">// 读操作</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 判断连接状态</span></span><br><span class="line">	<span class="comment">// 写操作</span></span><br><span class="line">	<span class="comment">// 清空写缓冲区</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于服务器程序回发消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string msg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><em>读操作和写操作区分是否阻塞：对于客户端，使用阻塞读写；对于服务端，使用非阻塞读写。在判断 Socket 是否阻塞时，需要添加个函数（之前没有）。</em></p>
<ol start="3">
<li>
<p>将原来成员属性 <code>int fd</code> 变成 <code>Socket *mSocket</code>。</p>
</li>
<li>
<p>添加上对应的回调函数及其 <code>Set</code> 函数：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(Socket *)&gt; mDeleteConnectionCallback;	<span class="comment">// 删除连接的回调函数</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(Connection *)&gt; mOnConnectCallback;		<span class="comment">// 连接建立时的回调函数</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(Connection *)&gt; mOnMessageCallback;		<span class="comment">// 业务逻辑回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置连接时的业务逻辑回调函数</span></span><br><span class="line"><span class="comment"> * @param callback 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOnConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将回调函数设置为在收到消息时调用</span></span><br><span class="line"><span class="comment"> * @param callback 接收到消息时调用的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOnMessageCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置删除连接时要调用的回调函数</span></span><br><span class="line"><span class="comment"> * @param _callback 删除连接时要调用的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ol start="5">
<li>编写业务函数。在构建服务器时指定对客户端消息的响应，然后通过对 <code>Server</code> 类的设置，传递到 <code>Connection</code> 类，最后传递到 <code>Channel</code> 类的 <code>handleEvent()</code> 进行调用。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该函数表示业务逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">business</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 大概操作有：</span></span><br><span class="line">	<span class="comment">// - 接受客户端信息</span></span><br><span class="line">	<span class="comment">// - 做出响应，即 mOnMessageCallback()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在也差不多了，但是可以完善（重构）一下 <code>Channel</code> 类，让其意义更明确，更规范一些：</p>
<ol>
<li>规范私有成员变量：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *mLoop;					<span class="comment">// 指向与之关联的事件循环</span></span><br><span class="line">	Socket *mSocket;					<span class="comment">// 与之关联的Socket</span></span><br><span class="line">	<span class="type">uint32_t</span> mListenEvents{ <span class="number">0</span> };		<span class="comment">// 监听的事件</span></span><br><span class="line">	<span class="type">uint32_t</span> mReadyEvents{ <span class="number">0</span> };			<span class="comment">// 就绪事件</span></span><br><span class="line">	<span class="type">bool</span> exist{ <span class="literal">false</span> };				<span class="comment">// 指示该Channel是否存在有效</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; readCallback;	<span class="comment">// 读回调</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; writeCallback;<span class="comment">// 写回调</span></span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>编写相关成员函数（函数名修改后记得在对应调用处修改）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开启读操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableRead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开启写操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableWrite</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 使用ET</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useET</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取Socket</span></span><br><span class="line"><span class="function">Socket *<span class="title">getSocket</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取监听事件</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">getListenEvents</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取就绪事件</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">getReadyEvents</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置就绪事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadyEvents</span><span class="params">(<span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"><span class="comment">// 检查有效性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getExist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置有效性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setExist</span><span class="params">(<span class="type">bool</span> _exist)</span></span>;</span><br><span class="line"><span class="comment">// 设置回调函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>修改 <code>Channel</code> 类的析构函数，其析构为 <code>loop</code> 调用 <code>deleteChannel()</code>（需要添加函数）（实际上还是相关联的 <code>Epoll</code> 封装类去 <code>deleteChannel()</code>）：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Channel::~<span class="built_in">Channel</span>()</span><br><span class="line">{</span><br><span class="line">	mLoop-&gt;<span class="built_in">deleteChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::deleteChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ep-&gt;<span class="built_in">deleteChannel</span>(channel);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在修改了 Channel 类后，其相关联的 <code>Epoll</code> 封装类也需要修改：</p>
<ol>
<li>修改 <code>Epoll::deleteChannel(Channel *channel)</code>，需要把当前的 <code>Channel</code> 对象从 epoll 中删除，然后设置有效性为 <code>false</code>：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Epoll::deleteChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> fd = channel-&gt;<span class="built_in">getSocket</span>()-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">	<span class="built_in">errorif</span>(<span class="built_in">epoll_ctl</span>(mEpFd, EPOLL_CTL_DEL, fd, <span class="literal">nullptr</span>) == <span class="number">-1</span>, <span class="string">"epoll delete error"</span>);</span><br><span class="line">	channel-&gt;<span class="built_in">setExist</span>(<span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>完善 <code>Epoll::updateChannel(Channel *channel)</code>：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Epoll::updateChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 更新事件event，读写事件区分开</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!channel-&gt;<span class="built_in">getExist</span>())	<span class="comment">// 如果不存在，则添加</span></span><br><span class="line">		<span class="comment">// 添加到epoll</span></span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">// 存在，只需要修改</span></span><br><span class="line">		<span class="comment">// 修改epoll</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>完善 <code>Epoll::poll(int timeout)</code>：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Channel *&gt; <span class="title">Epoll::poll</span><span class="params">(<span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// epoll_wait</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 遍历事件 events</span></span><br><span class="line">		<span class="keyword">if</span>(events &amp; EPOLLIN)</span><br><span class="line">			<span class="comment">// 读</span></span><br><span class="line">		<span class="keyword">if</span> (events &amp; EPOLLOUT)</span><br><span class="line">			<span class="comment">// 写</span></span><br><span class="line">		<span class="keyword">if</span>(events &amp; EPOLLET)</span><br><span class="line">			<span class="comment">// ET 模式</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 返回事件（Channel数组）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>最后检查各个文件无报错后，根据需要修改 CMakeLists.txt 文件。</em></p>
<p><em>之后，如果想创建不一样功能的服务器，可以通用我们这样的一个网络库。</em></p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day13">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day13">Gitee</a></p>
<h2 id="十四-再次重构-告一段落">十四、再次重构，告一段落</h2>
<h3 id="14-1-重构思想">14.1 重构思想</h3>
<ol>
<li>
<p>使用智能指针进行内存管理。在之前的开发中，使用的都是原始的指针，但是原始的指针对内存管理而言是困难的，极易产生内存泄漏、悬垂引用、野指针等问题。从 C++11 标准后，可以使用智能指针来管理内存，让程序员无需过多考虑内存资源的使用。</p>
<ul>
<li><code>std::unique_ptr</code></li>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>
</li>
<li>
<p>避免资源的复制操作，尽量使用移动语义来进行所有权的转移，这对提升程序的性能有十分显著的帮助。</p>
</li>
<li>
<p>对错误、异常的处理。在项目上线后，我们不能因为某些错误就直接让程序崩溃或者终止。而且，绝大部分错误都是可恢复的：</p>
<ul>
<li>如创建 socket 失败可能是文件描述符超过操作系统限制，稍后再次尝试即可。</li>
<li>监听 socket 失败可能是端口被占用，切换端口或提示并等待用户处理即可。</li>
<li>打开文件失败可能是文件不存在或没有权限，此时只需创建文件或赋予权限即可。</li>
<li>所以在底层的编码上，对于部分错误需要进行可恢复处理，避免一个模块或资源发生的小错误影响整个服务器的运行。</li>
</ul>
</li>
</ol>
<h3 id="14-2-加入-clang-fromat">14.2 加入.clang-fromat</h3>
<p>Clang 本身是一个 C++ 的编译器。而 Clang-Format 是其中的一个格式化工具，可用于格式化（排版）多种不同语言的代码。在 Linux 中安装一下 <code>clang-format</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y clang-format</span><br></pre></td></tr></tbody></table></figure>
<p>如果使用 VSCode 进行编程的话，需要安装插件 Clang-Format，格式化快捷键：<code>shift + alt + f</code>。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://www.fingsinz.space/2024/22/">使用clang-format给你代码格式化</a></p>
<p><em>纯靠手动控制格式太麻烦了，还是使用工具吧</em></p>
<h3 id="14-3-设计宏定义-common-h">14.3 设计宏定义（Common.h）</h3>
<p>显式将拷贝和移动函数删除，避免拷贝和移动操作：</p>
<figure class="highlight h"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY(className) \</span></span><br><span class="line"><span class="meta">	className(const className &amp;) = delete; \</span></span><br><span class="line"><span class="meta">	className &amp;operator = (const className &amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_MOVE(className) \</span></span><br><span class="line"><span class="meta">	className(className &amp;&amp;) = delete; \</span></span><br><span class="line"><span class="meta">	className &amp;operator = (className &amp;&amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_MOVE(className) \</span></span><br><span class="line"><span class="meta">	DISALLOW_COPY(className);             \</span></span><br><span class="line"><span class="meta">	DISALLOW_MOVE(className);</span></span><br></pre></td></tr></tbody></table></figure>
<p>新增 <code>FLAG</code> 标记，统一标记函数的返回：</p>
<figure class="highlight h"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FLAG</span> {</span></span><br><span class="line">	FL_UNDIFINED,</span><br><span class="line">	FL_SUCCESS,</span><br><span class="line">	FL_SOCKET_ERROR,</span><br><span class="line">	FL_EPOLL_ERROR,</span><br><span class="line">	FL_CONNECTION_ERROR,</span><br><span class="line">	FL_ACCEPTOR_ERROR,</span><br><span class="line">	FL_UNIMPLEMENTED</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><em>记得修改包含的头文件。</em></p>
<h3 id="14-4-重构socket类">14.4 重构Socket类</h3>
<p><code>Socket</code> 类主要是对 socket 操作进行了封装，并主要应用在 <code>Acceptor</code> 类中和 <code>Connection</code> 类中。对 <code>Socket</code> 类的函数进行重构，同时删去 InetAddress 类：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Socket);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Socket</span>();</span><br><span class="line">    ~<span class="built_in">Socket</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getAddr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketCreate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketBind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketListen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketAccept</span><span class="params">(<span class="type">int</span> &amp;clientFd)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">setNonBlocking</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNonBlocking</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">recvBufSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mFd{<span class="number">-1</span>}; <span class="comment">// socket 文件描述符</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>对于 <code>Socket</code>的创建、绑定、监听、接受等操作进行错误、异常的处理，在函数中大概如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLAG <span class="title">xxx</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">	<span class="comment">// 断言 fd 是否合法</span></span><br><span class="line">	<span class="comment">// 进行创建、绑定、监听、接受等操作</span></span><br><span class="line">	<span class="comment">// 判断上述操作是否出现异常</span></span><br><span class="line">	<span class="comment">// 出现异常则输出并返回错误标记，无异常则返回成功标记</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于 Socket 的连接操作，是将 Socket 连接到某个 IP 地址，在函数中如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLAG <span class="title">Socket::socketConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> <span class="type">const</span> </span>{</span><br><span class="line">	<span class="comment">// 构建地址结构体</span></span><br><span class="line">	<span class="comment">// 连接</span></span><br><span class="line">	<span class="comment">// 判断上述操作是否出现异常</span></span><br><span class="line">	<span class="comment">// 出现异常则输出并返回错误标记，无异常则返回成功标记</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有其他的 Get、Set 函数可详见代码。</p>
<h3 id="14-4-小改channel类和epoll类">14.4 小改Channel类和Epoll类</h3>
<p>修改完 <code>Socket</code> 类后，比较底层的还有 <code>Channel</code> 类。<code>Channel</code> 类是网络库的核心组建之一，其对 <code>socket</code> 进行了更深度的封装，保存了需要对 <code>socket</code> 监听的事件和当前 <code>socket</code> 已经准备好的事件，并进行处理。此外，为了更新和获取在 <code>epoll</code> 中的状态，需要使用<code>EventLoop</code>进行管理。</p>
<p>对于 Channel 类的改动并不多，类声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Channel);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(EventLoop *loop, <span class="type">int</span> fd)</span></span>;</span><br><span class="line">    ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableRead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useET</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getListenEvents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getReadyEvents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadyEvents</span><span class="params">(<span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getExist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setExist</span><span class="params">(<span class="type">bool</span> _exist = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *mLoop;                    <span class="comment">// 指向与之关联的事件循环</span></span><br><span class="line">    <span class="type">int</span> mFd;                             <span class="comment">// 与之关联的Socket fd</span></span><br><span class="line">    <span class="type">uint32_t</span> mListenEvents{<span class="number">0</span>};           <span class="comment">// 监听的事件</span></span><br><span class="line">    <span class="type">uint32_t</span> mReadyEvents{<span class="number">0</span>};            <span class="comment">// 就绪事件</span></span><br><span class="line">    <span class="type">bool</span> exist{<span class="literal">false</span>};                   <span class="comment">// 指示该Channel是否存在有效</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; readCallback;  <span class="comment">// 读回调</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; writeCallback; <span class="comment">// 写回调</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>大部分代码没什么特别的，可以见代码。但是需要注意的是，设置回调函数时，使用 <code>std::move()</code> ：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setxxxCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	xxxCallback = std::<span class="built_in">move</span>(callback);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>Epoll</code> 类主要是进行 IO 多路复用，保证高并发。在 <code>Epoll</code> 类主要是对 epoll 中 channel 的监听与处理。声明改为如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Epoll</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 禁用拷贝和移动</span></span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Epoll);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Epoll</span>();</span><br><span class="line">    ~<span class="built_in">Epoll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">deleteChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Channel *&gt; <span class="title">poll</span><span class="params">(<span class="type">int</span> timeout = <span class="number">-1</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mEpFd{<span class="number">-1</span>};                        <span class="comment">// epoll文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *mEvents{<span class="literal">nullptr</span>}; <span class="comment">// epoll事件</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>函数方面也是小改。</p>
<h3 id="14-5-小改eventloop类">14.5 小改EventLoop类</h3>
<p><code>EventLoop</code> 类用于对事件的轮询和处理。每一个 <code>EventLoop</code> 不断地调用 <code>epoll_wait</code> 来获取激活的事件，并处理。原本的 <code>EventLoop</code> 类中有一个普通的指针 <code>Epoll*</code>，现改为 <code>std::unique_ptr</code>。顺便再把函数声明为 <code>const</code>，使其更安全。</p>
<p>EventLoop 类声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(EventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Epoll&gt; ep; <span class="comment">// 指向Epoll类实例的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>由于使用了智能指针，所以其构造函数和析构函数也简化了不少。</p>
<h3 id="14-6-小改acceptor类">14.6 小改Acceptor类</h3>
<p><code>Acceptor</code> 主要用于服务器接受连接，并在接受连接之后进行相应的处理。这个类需要独属于自己的 <code>Channel</code>，因此采用了智能指针管理。</p>
<p>Acceptor 类的重构类似。</p>
<ul>
<li>将一些指针变成智能指针；</li>
<li>使用之前定义的 <code>FLAG</code> 标记。</li>
</ul>
<p>Acceptor 类声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Acceptor);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Acceptor</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line">    ~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">acceptConnection</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Socket&gt; mSocket;   <span class="comment">// 用于处理套接字操作的套接字指针</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; mChannel; <span class="comment">// 用于接受连接的 Channel 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个新建连接的回调函数</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; mNewConnectionCallback;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="14-7-小改connection类">14.7 小改Connection类</h3>
<p>对于每个 TCP 连接，都可以使用一个类进行管理，在这个类中，将注意力转移到对客户端 socket 的读写上，除此之外，他还需要绑定几个回调函数，例如当接收到信息时，或者需要关闭时进行的操作。</p>
<p>对于 <code>Connection</code> 类中的指针改用智能指针，同时按需求简化了部分函数，声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> {</span><br><span class="line">        Invalid = <span class="number">0</span>, <span class="comment">// 初始无效状态</span></span><br><span class="line">        Handshaking, <span class="comment">// 握手过程中的状态</span></span><br><span class="line">        Connected,   <span class="comment">// 连接建立</span></span><br><span class="line">        Closed,      <span class="comment">// 连接关闭</span></span><br><span class="line">        Failed,      <span class="comment">// 连接失败</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Connection</span><span class="params">(EventLoop *loop, <span class="type">int</span> fd)</span></span>;</span><br><span class="line">    ~<span class="built_in">Connection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Connection);</span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">send</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setOnMessageCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">business</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">State <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSentBuffer</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str)</span></span>;</span><br><span class="line">    <span class="function">Buffer *<span class="title">getReadBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Buffer *<span class="title">getSendBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Socket *<span class="title">getSocket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// EventLoop *mLoop;							// EventLoop指针</span></span><br><span class="line">    std::unique_ptr&lt;Socket&gt; mSocket;              <span class="comment">// Socket指针</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; mChannel{<span class="literal">nullptr</span>};   <span class="comment">// Channel指针</span></span><br><span class="line">    std::unique_ptr&lt;Buffer&gt; mReadBuffer{<span class="literal">nullptr</span>}; <span class="comment">// 读缓冲区</span></span><br><span class="line">    std::unique_ptr&lt;Buffer&gt; mSendBuffer{<span class="literal">nullptr</span>}; <span class="comment">// 写缓冲区</span></span><br><span class="line"></span><br><span class="line">    State mState{Invalid};                                <span class="comment">// 连接状态</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; mDeleteConnectionCallback;   <span class="comment">// 删除连接的回调函数</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Connection *)&gt; mOnMessageCallback; <span class="comment">// 业务逻辑回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">readNonBlocking</span><span class="params">()</span></span>;  <span class="comment">// 非阻塞读</span></span><br><span class="line">    <span class="function">FLAG <span class="title">writeNonBlocking</span><span class="params">()</span></span>; <span class="comment">// 非阻塞写</span></span><br><span class="line">    <span class="function">FLAG <span class="title">readBlocking</span><span class="params">()</span></span>;     <span class="comment">// 阻塞读</span></span><br><span class="line">    <span class="function">FLAG <span class="title">writeBlocking</span><span class="params">()</span></span>;    <span class="comment">// 阻塞写</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="14-8-重头戏server类">14.8 重头戏Server类</h3>
<p><code>Server</code> 类是对整个服务器的管理，他通过创建 <code>acceptor</code> 来接收连接。并管理 <code>Connection</code> 的添加。</p>
<p>对 Server 类的众多指针都改为智能指针，声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>();</span><br><span class="line">    ~<span class="built_in">Server</span>();</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Server);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnect</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">newConnection</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">deleteConnection</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;EventLoop&gt; mainReactor;              <span class="comment">// 只负责接受连接，然后分发给一个subReactor</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EventLoop&gt;&gt; subReactors; <span class="comment">// 处理事件循环</span></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor;                  <span class="comment">// 连接接受器</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Connection&gt;&gt; connections; <span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">    std::unique_ptr&lt;ThreadPool&gt; threadPool;                           <span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Connection *)&gt; onConnectionCallback; <span class="comment">// 连接的业务逻辑</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Connection *)&gt; onMessageCallback;    <span class="comment">// 接收消息后的业务逻辑</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>修改完这么多类后，记得查看代码修改一下测试的 <code>server.cpp</code>、<code>SingleClient.cpp</code>、<code>MultipleClients.cpp</code> 等文件，然后编译即可。</p>
<p>该节代码：<a target="_blank" rel="noopener" href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day14">Github</a>，<a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day14">Gitee</a></p>
<hr>
<h2 id="附录">附录</h2>
<h3 id="附-1-代码运行环境">附 1 - 代码运行环境</h3>
<p>前十四章：</p>
<ul>
<li>代码编写：Windows 下 Visual Studio 2022</li>
<li>代码编译及执行：阿里云 ECS，Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-169-generic x86_64)</li>
</ul>
<p>在 Visual Studio 2022 中编写代码，接着连接远程服务器，将代码部署到服务器上。</p>
<ul>
<li>前期在服务器使用 <code>make</code> 编译代码。<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/798104">Ubuntu之make：make命令行工具的简介、安装、使用方法之详细攻略</a>
<ul>
<li>编译命令见每个 Day 中的 Makefile 文件。
<ul>
<li><code>make</code> 命令为：<code>make build</code> 或 <code>make</code>。</li>
<li>清理编译结果命令为：<code>make clean</code>。</li>
</ul>
</li>
<li>若没有 <code>make</code>，可以手动输入（Makefile中的） <code>g++</code> 命令编译。</li>
</ul>
</li>
<li>后期考虑使用 CMake 将项目工程化，详情看附录 2。</li>
</ul>
<p>剩下章节：</p>
<ul>
<li>代码编写：Windows 下 Visual Studio Code</li>
<li>代码编译及执行：WSL2 - Ubuntu 18.04</li>
</ul>
<p>用 Visual Studio Code 远程连接 WSL 进行编写代码，使用 cmake 进行项目管理。</p>
<h3 id="附-2-cmake的安装和使用">附 2 - CMake的安装和使用</h3>
<p>此处的环境是：<strong>Visual Studio 2022 远程连接 Ubuntu 20.04.6 LTS</strong></p>
<ul>
<li><em>当然 Windows 也有 CMake，此处主要是在 Linux 下的使用。</em></li>
</ul>
<h4 id="附-2-1-检查远程的cmake环境和编译环境">附 2.1 检查远程的CMake环境和编译环境</h4>
<p><em>可能需要先 <code>apt-get update</code> 更新一下 apt。</em></p>
<ol>
<li>安装 CMake 工具</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install cmake</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>可选择安装使用 clang 编译器</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install clang</span><br></pre></td></tr></tbody></table></figure>
<h4 id="附-2-2-visual-studio-2022中使用cmake进行远程linux服务器开发">附 2.2 Visual Studio 2022中使用CMake进行远程Linux服务器开发</h4>
<ol>
<li>创建选择 CMake 项目，我此处构建演示项目 <code>CMakeTestProject</code>。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-2.jpg" alt="选择CMake项目"></p>
<ol start="2">
<li>选择远程的 Linux 计算机，管理配置，新建一个配置。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-3.jpg" alt="管理配置"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-4.jpg" alt="新建配置"></p>
<ol start="3">
<li>编辑配置，具体看下图，主要修改部分已经框选。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-5.jpg" alt="编辑配置"></p>
<ol start="4">
<li>
<p>正常编写代码，此处我用 Day12（第十二章）的代码作为演示。编写代码后，可以点进去根目录的 <code>CMakeLists.txt</code> 文件，保存一下（<code>ctrl + s</code>），就会自动复制到远程。</p>
</li>
<li>
<p>进行项目生成和编译，项目生成有两种方式：</p>
</li>
</ol>
<ul>
<li>可以选择右键项目名，选择以 CMake 视图查看。再进行生成或清理，最后使用编译命令进行编译。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-6.jpg" alt="选择CMake视图"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-7.jpg" alt="生成和清理"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-8.jpg" alt="生成成功1"></p>
<ul>
<li>可以在 Linux 的终端上执行以下命令：</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake ../src/ &amp;&amp; make</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-9.jpg" alt="生成成功2"></p>
<p><em>可以在 CMakeLists.txt 中的项目信息之前设置编译器为Clang。</em></p>
<ol start="6">
<li>生成成功后就可以在 <code>CMakeLists.txt</code> 中指定的输出文件夹中找到可执行文件或其他。</li>
</ol>
<h4 id="附-2-2-visual-studio-2022中使用cmake进行wsl开发">附 2.2 Visual Studio 2022中使用CMake进行WSL开发</h4>
<p><em>有的人可能没有Linux服务器，但是WSL可以有的。如何安装WSL可以查看<a target="_blank" rel="noopener" href="https://www.fingsinz.space/2024/20/">这里</a></em></p>
<p>基本步骤同上，但在新建配置和编辑时，需要做一些修改：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-10.jpg" alt="新建关于WSL的配置"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-11.jpg" alt="编辑关于WSL的配置"></p>
<h4 id="附-2-3-cmake相关资料">附 2.3 CMake相关资料</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/</a></li>
</ul>
<h3 id="附-3-可能出现的问题">附 3 - 可能出现的问题</h3>
<ul>
<li>
<p>在 Ubuntu 中安装 <code>make</code> 时，出现 <font color="red">“dpkg: error processing package ***”</font> 的问题，可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/dou3516/article/details/105120221">CSDN</a>。</p>
</li>
<li>
<p>在线程池部分中，直接使用 <code>g++</code> 命令会出现 <font color="red">“对‘pthread_create’未定义的引用”</font> 的问题，需要加上 <code>-lpthread</code> 参数，详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Dontla/article/details/122637407">CSDN</a> 或 <code>Makefile</code> 中的做法。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/cpp-patterns/">设计模式 - C++</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/19/">Windows 下 vcpkg 的配置与使用</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap" style="column-count:2;"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期发布</a><a href="/blog/categories/">分类</a><a href="/blog/tags/">标签</a><a href="/blog/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">关于</span><a href="/about/me/">关于我</a><a href="/about/site/">关于博客</a></div></div><div class="text"><p>本站由 <a href="/">Fingsinz</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.0">Stellar 1.33.0</a> 主题创建。<br>
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="true"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6-%E5%89%8D%E8%A8%80"><span class="toc-text">零、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BB%8Esocket%E5%BC%80%E5%A7%8B"><span class="toc-text">一、从socket开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">1.1 服务端干了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88"><span class="toc-text">1.2 客户端如何配合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%AF%A5%E8%8A%82%E6%B6%89%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3 该节涉及函数及源代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%8C%E5%96%84%E4%BB%A3%E7%A0%81-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-text">二、完善代码，数据读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">2.1 错误检查处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-text">2.2 数据读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AF%A5%E8%8A%82%E6%B6%89%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">2.3 该节涉及函数及源代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8epoll"><span class="toc-text">三、高并发使用epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%8Eselect-poll%E5%88%B0epoll"><span class="toc-text">3.1 从select、poll到epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B9%E5%86%99%E6%88%90epoll%E7%89%88%E6%9C%AC"><span class="toc-text">3.2 将服务器改写成epoll版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%B0%81%E8%A3%85%E6%88%90%E7%B1%BB-%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">四、封装成类，程序模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B0%86socket%E5%92%8Cinetaddress%E5%B0%81%E8%A3%85%E6%88%90%E7%B1%BB"><span class="toc-text">4.1 将socket和InetAddress封装成类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B0%86epoll%E5%B0%81%E8%A3%85%E6%88%90%E7%B1%BB"><span class="toc-text">4.2 将epoll封装成类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">4.3 目录结构及源代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%90%91%E7%9D%80reactor%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8F%98"><span class="toc-text">五、向着Reactor模式转变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-reactor%E5%92%8Cproactor"><span class="toc-text">5.1 Reactor和Proactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%8A%A0%E5%85%A5channel%E7%B1%BB"><span class="toc-text">5.2 加入Channel类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%8A%A0%E5%85%A5eventloop%E7%B1%BB"><span class="toc-text">5.3 加入EventLoop类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%8A%A0%E5%85%A5server%E7%B1%BB"><span class="toc-text">5.4 加入Server类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%97%E6%8A%BD%E8%B1%A1%E5%8C%96"><span class="toc-text">六、把服务器的接受抽象化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%8A%BD%E8%B1%A1%E5%8C%96%E6%8E%A5%E5%8F%97"><span class="toc-text">6.1 抽象化接受</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-acceptor-%E7%B1%BB"><span class="toc-text">6.2 Acceptor 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%8A%8Atcp%E8%BF%9E%E6%8E%A5%E6%8A%BD%E8%B1%A1%E5%8C%96"><span class="toc-text">七、把TCP连接抽象化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%8A%BD%E8%B1%A1%E5%8C%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">7.1 抽象化连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-connection-%E7%B1%BB"><span class="toc-text">7.2 Connection 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%94%B9%E5%86%99-server-%E7%B1%BB"><span class="toc-text">7.3 改写 Server 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E9%97%B2%E6%9D%A5%E6%97%A0%E4%BA%8B-%E6%95%B4%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">八、闲来无事，整个缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">8.1 引入缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-buffer%E7%B1%BB"><span class="toc-text">8.2 Buffer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%85%B6%E4%BB%96%E6%96%B9%E9%9D%A2%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">8.3 其他方面的改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%95%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">九、线程池啊线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">9.1 为什么加入线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">9.2 如何设计线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86"><span class="toc-text">9.3 线程池用到的语法知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB"><span class="toc-text">9.4 线程池类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E6%9C%89%E4%BA%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8B%E5%90%8E%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-text">十、有了线程池之后的考虑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%AE%8C%E5%96%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">10.1 完善线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%AE%8C%E5%96%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86"><span class="toc-text">10.2 完善线程池用到的语法知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%86%8D%E4%BF%AE%E4%BF%AE%E8%A1%A5%E8%A1%A5"><span class="toc-text">10.3 再修修补补</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E6%94%B9%E5%86%99%E6%88%90%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">十一、改写成主从Reactor多线程模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">11.1 什么是主从Reactor多线程模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">11.2 代码上的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">十二、项目工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E8%AE%A4%E8%AF%86cmake"><span class="toc-text">12.1 认识Cmake</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="toc-text">12.2 工程化的实际操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%96"><span class="toc-text">十三、业务逻辑自定义化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3"><span class="toc-text">13.1 业务逻辑思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E6%93%8D%E5%88%80%E5%8A%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">13.2 操刀动代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E5%86%8D%E6%AC%A1%E9%87%8D%E6%9E%84-%E5%91%8A%E4%B8%80%E6%AE%B5%E8%90%BD"><span class="toc-text">十四、再次重构，告一段落</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E9%87%8D%E6%9E%84%E6%80%9D%E6%83%B3"><span class="toc-text">14.1 重构思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E5%8A%A0%E5%85%A5-clang-fromat"><span class="toc-text">14.2 加入.clang-fromat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E8%AE%BE%E8%AE%A1%E5%AE%8F%E5%AE%9A%E4%B9%89-common-h"><span class="toc-text">14.3 设计宏定义（Common.h）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E9%87%8D%E6%9E%84socket%E7%B1%BB"><span class="toc-text">14.4 重构Socket类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E5%B0%8F%E6%94%B9channel%E7%B1%BB%E5%92%8Cepoll%E7%B1%BB"><span class="toc-text">14.4 小改Channel类和Epoll类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E5%B0%8F%E6%94%B9eventloop%E7%B1%BB"><span class="toc-text">14.5 小改EventLoop类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E5%B0%8F%E6%94%B9acceptor%E7%B1%BB"><span class="toc-text">14.6 小改Acceptor类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E5%B0%8F%E6%94%B9connection%E7%B1%BB"><span class="toc-text">14.7 小改Connection类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-%E9%87%8D%E5%A4%B4%E6%88%8Fserver%E7%B1%BB"><span class="toc-text">14.8 重头戏Server类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84-1-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-text">附 1 - 代码运行环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84-2-cmake%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">附 2 - CMake的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84-2-1-%E6%A3%80%E6%9F%A5%E8%BF%9C%E7%A8%8B%E7%9A%84cmake%E7%8E%AF%E5%A2%83%E5%92%8C%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-text">附 2.1 检查远程的CMake环境和编译环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84-2-2-visual-studio-2022%E4%B8%AD%E4%BD%BF%E7%94%A8cmake%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8Blinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91"><span class="toc-text">附 2.2 Visual Studio 2022中使用CMake进行远程Linux服务器开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84-2-2-visual-studio-2022%E4%B8%AD%E4%BD%BF%E7%94%A8cmake%E8%BF%9B%E8%A1%8Cwsl%E5%BC%80%E5%8F%91"><span class="toc-text">附 2.2 Visual Studio 2022中使用CMake进行WSL开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84-2-3-cmake%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="toc-text">附 2.3 CMake相关资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84-3-%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">附 3 - 可能出现的问题</span></a></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
