<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="OpenGL图形学编程基础学习记录" />
    <meta name="hexo-theme-A4" content="v1.8.3" />
    <link rel="alternate icon" type="image/webp" href="/images/icon1.webp">
    <title>Fingsinz&#39;s space | 风信梓的博客</title>

    
        
<link rel="stylesheet" href="/css/a11y-dark.min.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    
    

<meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: white;  
        }
        body {
            color: #000000;
            background: #bed2bb;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: white; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: #6b798e;
        }

        .post-md a {
            color: #6b798e;
        }

        .nav li a {
            color: #6b798e;
        }

        .archive-main a:link {
            color: #6b798e;
        }
        .archive-main a:visited {
            color: #6b798e; 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: white;
        }

        .paper {
            background: #bed2bb;
        }

        .index-main {
            background: white;
        }

        .paper-main {
            background: white;
        }

        .wl-panel {
            background: white;
        }

        .archive li:nth-child(odd) {
            background: white;
            ;
        }

        .archive li:nth-child(even) {
            background: white;
        }

        .post-md>table tr:nth-child(odd) td {
            background: white;
        }

        .post-md>table tr:nth-child(even) td {
            background: white;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #6b798e;
            border-left-color: #6b798e;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Fingsinz&#39;s space</a> 
            <span class="description">不忘初心，方得始终</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            OpenGL图形学编程基础学习记录
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80-opengl%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="post-toc-text">一、OpenGL安装与使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-%E8%AE%A4%E8%AF%86opengl"><span class="post-toc-text">1.1 认识OpenGL</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEopengl"><span class="post-toc-text">1.2 安装和配置OpenGL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-1-%E5%87%86%E5%A4%87opengl-glsl"><span class="post-toc-text">1.2.1 准备OpenGL&#x2F;GLSL</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-2-%E5%87%86%E5%A4%87glfw"><span class="post-toc-text">1.2.2 准备GLFW</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-3-%E5%87%86%E5%A4%87glew"><span class="post-toc-text">1.2.3 准备GLEW</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-4-%E5%87%86%E5%A4%87glm"><span class="post-toc-text">1.2.4 准备GLM</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-5-%E5%87%86%E5%A4%87soil2"><span class="post-toc-text">1.2.5 准备SOIL2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-6-%E5%87%86%E5%A4%87%E5%85%B1%E4%BA%AB%E7%9A%84lib%E5%92%8Cinclude"><span class="post-toc-text">1.2.6 准备共享的lib和include</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-%E5%9C%A8vs%E4%B8%AD%E9%85%8D%E7%BD%AEopengl%E9%A1%B9%E7%9B%AE"><span class="post-toc-text">1.3 在VS中配置OpenGL项目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3"><span class="post-toc-text">1.4 创建一个窗口</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8C-opengl%E5%9B%BE%E5%83%8F%E7%AE%A1%E7%BA%BF"><span class="post-toc-text">二、OpenGL图像管线</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-%E7%AE%A1%E7%BA%BF"><span class="post-toc-text">2.1 管线</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-1-%E7%AC%AC%E4%B8%80%E4%B8%AAc-opengl%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="post-toc-text">2.1.1 第一个C++&#x2F;OpenGL应用程序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8"><span class="post-toc-text">2.2 顶点着色器和片段着色器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-glsl%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5"><span class="post-toc-text">2.3 GLSL代码检查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-%E8%AE%A9%E5%9B%BE%E5%83%8F%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="post-toc-text">2.4 让图像动起来</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%89-opengl%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="post-toc-text">三、OpenGL数学基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="post-toc-text">3.1 坐标系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-%E7%82%B9"><span class="post-toc-text">3.2 点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-%E5%90%91%E9%87%8F"><span class="post-toc-text">3.3 向量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-1-%E7%82%B9%E7%A7%AF%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-text">3.3.1 点积的应用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-2-%E5%8F%89%E7%A7%AF%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-text">3.3.2 叉积的应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.4 矩阵</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.5 变换矩阵</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-1-%E5%B9%B3%E7%A7%BB%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.5.1 平移矩阵</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-2-%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.5.2 缩放矩阵</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-3-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.5.3 旋转矩阵</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-6-%E8%A7%86%E8%A7%89%E7%A9%BA%E9%97%B4%E5%92%8C%E5%90%88%E6%88%90%E7%9B%B8%E6%9C%BA"><span class="post-toc-text">3.6 视觉空间和合成相机</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-7-%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.7 投影矩阵</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-7-1-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.7.1 透视投影矩阵</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-7-2-%E6%AD%A3%E5%B0%84%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.7.2 正射投影矩阵</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-8-lookat%E7%9F%A9%E9%98%B5"><span class="post-toc-text">3.8 LookAt矩阵</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9B%9B-opengl%E7%AE%A1%E7%90%863d%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE"><span class="post-toc-text">四、OpenGL管理3D图形数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="post-toc-text">4.1 缓冲区和顶点属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F"><span class="post-toc-text">4.2 统一变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E6%8F%92%E5%80%BC"><span class="post-toc-text">4.3 顶点属性插值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-4-mv-%E7%9F%A9%E9%98%B5%E5%92%8C%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5"><span class="post-toc-text">4.4 MV 矩阵和透视矩阵</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-5-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA-3d-%E7%AB%8B%E6%96%B9%E4%BD%93"><span class="post-toc-text">4.5 构建一个 3D 立方体</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-6-%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%89%AF%E6%9C%AC"><span class="post-toc-text">4.6 渲染一个对象的多个副本</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-7-%E5%90%8C%E4%B8%80%E5%9C%BA%E6%99%AF%E6%B8%B2%E6%9F%93%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">4.7 同一场景渲染多个对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-8-%E7%9F%A9%E9%98%B5%E6%A0%88"><span class="post-toc-text">4.8 矩阵栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-9-%E5%BA%94%E5%AF%B9-z%E5%86%B2%E7%AA%81-%E4%BC%AA%E5%BD%B1"><span class="post-toc-text">4.9 应对“Z冲突”伪影</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-10-%E5%85%B6%E4%BB%96%E5%9B%BE%E5%85%83"><span class="post-toc-text">4.10 其他图元</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-10-1-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%9B%BE%E5%85%83"><span class="post-toc-text">4.10.1 三角形图元</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-10-2-%E7%BA%BF%E5%9B%BE%E5%85%83"><span class="post-toc-text">4.10.2 线图元</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-10-3-%E7%82%B9%E5%9B%BE%E5%85%83"><span class="post-toc-text">4.10.3 点图元</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A1%A5%E4%B8%81%E5%9B%BE%E5%85%83"><span class="post-toc-text">补丁图元</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-11-%E6%80%A7%E8%83%BD%E4%BC%98%E5%85%88%E7%BC%96%E7%A8%8B"><span class="post-toc-text">4.11 性能优先编程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%94-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">五、纹理贴图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-%E5%8A%A0%E8%BD%BD%E7%BA%B9%E7%90%86%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6"><span class="post-toc-text">5.1 加载纹理图像文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="post-toc-text">5.2 纹理坐标</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%BA%B9%E7%90%86%E7%9A%84%E5%9B%9B%E6%A3%B1%E9%94%A5"><span class="post-toc-text">5.3 构建一个带纹理的四棱锥</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">5.4 多级渐远纹理贴图</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-5-%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4"><span class="post-toc-text">5.5 各向异性过滤</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-6-%E7%8E%AF%E7%BB%95%E5%92%8C%E5%B9%B3%E9%93%BA"><span class="post-toc-text">5.6 环绕和平铺</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-7-%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2"><span class="post-toc-text">5.7 透视变形</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-8-%E6%9D%90%E8%B4%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82"><span class="post-toc-text">5.8 材质的更多细节</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%AD-3d%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">六、3D模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">6.1 程序构建模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-1-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%90%83%E4%BD%93"><span class="post-toc-text">6.1.1 构建一个球体</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-2-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%8E%AF%E9%9D%A2"><span class="post-toc-text">6.1.2 构建一个环面</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E6%9E%84%E5%BB%BA%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">6.2 加载外部构建的模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%83-%E5%85%89%E7%85%A7"><span class="post-toc-text">七、光照</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">7.1 光照模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-%E5%85%89%E6%BA%90"><span class="post-toc-text">7.2 光源</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-%E6%9D%90%E8%B4%A8"><span class="post-toc-text">7.3 材质</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-4-ads%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="post-toc-text">7.4 ADS光照计算</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-5-%E5%AE%9E%E7%8E%B0ads%E5%85%89%E7%85%A7"><span class="post-toc-text">7.5 实现ADS光照</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-5-1-gouraud-%E7%9D%80%E8%89%B2"><span class="post-toc-text">7.5.1 Gouraud 着色</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-5-2-phong-%E7%9D%80%E8%89%B2"><span class="post-toc-text">7.5.2 Phong 着色</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-6-%E7%BB%93%E5%90%88%E5%85%89%E7%85%A7%E5%92%8C%E7%BA%B9%E7%90%86"><span class="post-toc-text">7.6 结合光照和纹理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%AB-%E9%98%B4%E5%BD%B1"><span class="post-toc-text">八、阴影</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-1-%E6%8A%95%E5%BD%B1%E9%98%B4%E5%BD%B1"><span class="post-toc-text">8.1 投影阴影</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-2-%E9%98%B4%E5%BD%B1%E4%BD%93"><span class="post-toc-text">8.2 阴影体</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-3-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">8.3 阴影贴图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-1-%E7%AC%AC%E4%B8%80%E8%BD%AE-%E4%BB%8E%E5%85%89%E6%BA%90%E4%BD%8D%E7%BD%AE%E7%BB%98%E5%88%B6"><span class="post-toc-text">8.3.1 第一轮——从光源位置绘制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-2-%E5%B0%86%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%8D%E5%88%B6%E5%88%B0%E7%BA%B9%E7%90%86"><span class="post-toc-text">8.3.2 将深度缓冲区复制到纹理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-3-%E7%AC%AC%E4%BA%8C%E8%BD%AE-%E4%BB%8E%E7%9B%B8%E6%9C%BA%E4%BD%8D%E7%BD%AE%E7%BB%98%E5%88%B6"><span class="post-toc-text">8.3.3 第二轮——从相机位置绘制</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-4-%E6%9F%94%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="post-toc-text">8.4 柔和阴影</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B9%9D-%E5%A4%A9%E7%A9%BA%E5%92%8C%E8%83%8C%E6%99%AF"><span class="post-toc-text">九、天空和背景</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-1-%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="post-toc-text">9.1 天空盒</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-2-%E7%A9%B9%E9%A1%B6"><span class="post-toc-text">9.2 穹顶</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-3-%E5%AE%9E%E7%8E%B0%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="post-toc-text">9.3 实现天空盒</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-3-1-%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="post-toc-text">9.3.1 从头开始构建天空盒</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-3-2-%E4%BD%BF%E7%94%A8opengl%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">9.3.2 使用OpenGL立方体贴图</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-4-%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">9.4 环境贴图</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8D%81-%E5%A2%9E%E5%BC%BA%E8%A1%A8%E9%9D%A2%E7%BB%86%E8%8A%82"><span class="post-toc-text">十、增强表面细节</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-1-%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">10.1 凹凸贴图</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-2-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">10.2 法线贴图</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-3-%E9%AB%98%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="post-toc-text">10.3 高度贴图</span></a></li></ol></li></ol>
            
        
        <p>关键词：C++、OpenGL</p>
<span id="more"></span>
<hr>
<h2 id="一-opengl安装与使用">一、OpenGL安装与使用</h2>
<p><em>Reference：计算机图形学编程（使用OpenGL和C++）（第2版）</em></p>
<h3 id="1-1-认识opengl">1.1 认识OpenGL</h3>
<p>在 C++中使用 OpenGL 需要配置多个库。此处，使用到：</p>
<ul>
<li>
<p>C++开发环境；</p>
</li>
<li>
<p>OpenGL / GLSL：2004 年，2.0 版本中引入了 OpenGL 着色语言 GLSL，使得“着色器程序”可以被直接安装到图形管线的各个阶段并执行；</p>
</li>
<li>
<p>窗口管理库：OpenGL会将图像渲染到一个帧缓冲区，然后由计算机将帧缓冲区的内容绘制到屏幕的窗口中，GLFW 库是最流行的选择之一。</p>
</li>
<li>
<p>扩展库：常用如 GLEW 库；</p>
</li>
<li>
<p>数学库：3D 图形编程会大量使用向量和矩阵代数，可使用 OpenGL Mathematics（GLM）库、 Eigen 库或 vmath 库；</p>
</li>
<li>
<p>纹理图像加载库：比如 FreeImage、DevIL、GLI、Glraw 和 SOIL。</p>
</li>
</ul>
<h3 id="1-2-安装和配置opengl">1.2 安装和配置OpenGL</h3>
<p><em>基于Visual Studio 2022进行</em></p>
<h4 id="1-2-1-准备opengl-glsl">1.2.1 准备OpenGL/GLSL</h4>
<ul>
<li>了解计算机支持什么版本的OpenGL，可使用 <a target="_blank" rel="noopener" href="https://www.realtech-vr.com/home/?page_id=1402">GLView</a> 查看。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_OpenGLversion.jpg" alt="OpenGL版本"></p>
<h4 id="1-2-2-准备glfw">1.2.2 准备GLFW</h4>
<ol>
<li>下载 GLFW 源代码，<a target="_blank" rel="noopener" href="https://www.glfw.org/">下载地址</a></li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glfwfiles.jpg" alt="GLFW文件"></p>
<ol start="2">
<li>使用 CMake 进行编译源码</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glfwbuild.jpg" alt="编译GLFW"></p>
<p>接着找到 GLFW.sln，使用VS打开并编译为64位应用程序。</p>
<ol start="3">
<li>构建完成后得到下面两个内容：lib静态库文件和include文件夹</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs%2Fopengl_glfwlib.jpg" alt="静态库"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs%2Fopengl_glfwinclude.jpg" alt="include"></p>
<h4 id="1-2-3-准备glew">1.2.3 准备GLEW</h4>
<p>下载 GLEW 的二进制文件，<a target="_blank" rel="noopener" href="https://glew.sourceforge.net/">下载地址</a>。解压后内有库文件和头文件等。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glew.jpg" alt="GLEW文件夹"></p>
<h4 id="1-2-4-准备glm">1.2.4 准备GLM</h4>
<p>下载 GLM 压缩包，<a target="_blank" rel="noopener" href="https://github.com/g-truc/glm/releases">下载地址</a>，解压后即可。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glm.jpg" alt="GLM"></p>
<h4 id="1-2-5-准备soil2">1.2.5 准备SOIL2</h4>
<ol>
<li>
<p>下载并解压 <a target="_blank" rel="noopener" href="https://premake.github.io/">premake</a>，包含 premake5.exe。</p>
</li>
<li>
<p>下载 SOIL2 的源码，<a target="_blank" rel="noopener" href="https://github.com/SpartanJ/SOIL2/tags">下载地址</a>，解压。</p>
</li>
<li>
<p>将 premake5.exe 复制到 soil2 目录下。</p>
</li>
<li>
<p>在 soil2 目录下使用cmd，运行命令：</p>
</li>
</ol>
<pre><code class="language-cmd">premake5 vs2022
</code></pre>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_premake.jpg" alt="运行命令"></p>
<ol start="5">
<li>打开 make/windows 文件夹的 SOIL2.sln 文件，右键 soil2-static-lib 在 x64 下选择进行生成。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_soil2.jpg" alt="生成文件"></p>
<h4 id="1-2-6-准备共享的lib和include">1.2.6 准备共享的lib和include</h4>
<p>选择合适的位置创建文件夹，并设置 lib 和 include 子文件夹。</p>
<ul>
<li>
<p>在 lib 文件夹中放入 glew32.lib、glfw3.lib 和 soil2-debug.lib。</p>
</li>
<li>
<p>在 include 文件夹中放入 GLEW 的 GL 文件夹、GLFW 文件夹、glm 文件夹 和 SOIL2-1.3.0/src 的 SOIL2 文件夹。</p>
</li>
<li>
<p>在当前文件夹放入 glew32.dll</p>
</li>
</ul>
<p>文件结构如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_openglstructure.jpg" alt="共享文件夹结构"></p>
<h3 id="1-3-在vs中配置opengl项目">1.3 在VS中配置OpenGL项目</h3>
<p><em>创建 VS 自定义项目模板</em></p>
<ol>
<li>
<p>启动 VS， 创建空白项目，选择 x64。</p>
</li>
<li>
<p>在 Debug 模式下，进入“项目属性”，在“VC++”目录下的包含目录添加上共享文件夹的 include 文件夹；在“链接器”下，“常规-&gt;附加库目录”（或“VC+±&gt;库目录”）添加上共享文件夹的 lib 文件夹，“输入-&gt;附加依赖项”添加以下文件名： <code>glfw3.lib</code>、<code>glew32.lib</code>、<code>soil2-debug.lib</code> 和 <code>opengl32.lib</code>。</p>
</li>
<li>
<p>在 Release 模式下，重复上述步骤。</p>
</li>
<li>
<p>“项目-&gt;导出模板”，选择项目模板，命名自定义，此处为“OpenGL project”。</p>
</li>
</ol>
<p>创建 OpenGL C++ 项目时，启动 VS 时，点击“新建项目”，在左上方选择 OpenGL 模板即可使用。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_template.jpg" alt="使用模板创建项目"></p>
<p>需要注意的是，在新建OpenGL C++项目时，需要把 <code>glew32.dll</code> 放到项目目录下。</p>
<h3 id="1-4-创建一个窗口">1.4 创建一个窗口</h3>
<p>这部分可以用来测试上面的配置是否成功。下面给出一个 OpenGL C++ 创建窗口的代码：</p>
<details><summary>展开代码</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

GLFWwindow *window;
using namespace glm;

int main()
&#123;
    // 初始化 GLFW
    if (!glfwInit())
    &#123;
        return -1;
    &#125;

    glfwWindowHint(GLFW_SAMPLES, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // MacOS 不需要
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // 打开一个窗口并创建它的OpenGL上下文
    window = glfwCreateWindow(1024, 768, &quot;New Window&quot;, NULL, NULL);
    if (window == NULL)
    &#123;
        glfwTerminate();
        return -1;
    &#125;
    glfwMakeContextCurrent(window);

    // 初始化 GLEW
    if (glewInit() != GLEW_OK)
    &#123;
        glfwTerminate();
        return -1;
    &#125;

    // 确保我们可以捕捉到下面按下的转义键
    glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

    // 蓝色背景
    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);

    do
    &#123;
        // 清除屏幕
        glClear(GL_COLOR_BUFFER_BIT);

        // 交换缓冲区
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0); // 检查是否按下了ESC键或窗口已关闭

    // 关闭OpenGL窗口并终止GLFW
    glfwTerminate();
    return 0;
&#125;
</code></pre>
</details>
<p>运行结果：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_newwindow.jpg" alt="运行结果"></p>
<h2 id="二-opengl图像管线">二、OpenGL图像管线</h2>
<p>C++/OpenGL 应用程序的一个重要任务是让程序员的 GLSL 代码运行于 GPU 上。</p>
<p>OpenGL 提供了一个多级图形管线，可以使用 GLSL 语言进行部分编程。GLSL 是一种着色器语言。着色器语言主要运行于 GPU 上，在图形管线上下文中。</p>
<h3 id="2-1-管线">2.1 管线</h3>
<p>OpenGL 图像管线是 OpenGL 的核心，它是一个图像处理的管线。图像管线的工作原理是将图像数据从原始的纹理中渲染到屏幕上。</p>
<p>3D 图形编程会使用管线的概念，在管线中，将 3D 场景转换成  2D 图形的过程被分割成许多步骤。</p>
<p>C++/OpenGL 应用程序发送图形数据到顶点着色器，随着管线处理，最终生成在显示器上显示的像素点。</p>
<h4 id="2-1-1-第一个c-opengl应用程序">2.1.1 第一个C++/OpenGL应用程序</h4>
<p><em>即详细解释之前的创建窗口代码</em></p>
<p>该程序将会使用一些扩展库：GLEW、GLM、SOIL2 和 GLFW。</p>
<ul>
<li>GLFW 库提供了 GLFWwindow 类，可在其上进行3D场景绘制。</li>
</ul>
<p>该程序的大概操作有：</p>
<ol>
<li>初始化 GLFW</li>
</ol>
<pre><code class="language-cpp">// 初始化 GLFW
if (!glfwInit())
&#123;
    return -1;
&#125;
</code></pre>
<ol start="2">
<li>创建窗口的设置</li>
</ol>
<pre><code class="language-cpp">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
// WindowHint 指定了计算机必须与 OpenGL 版本 4.6 兼容（主版本号为 4，次版本号为 6）。
</code></pre>
<ol start="3">
<li>创建一个 GLFWwindow 实例并创建窗口</li>
</ol>
<pre><code class="language-cpp">GLFWwindow *window = glfwCreateWindow(1024, 768, &quot;New Window&quot;, NULL, NULL);
if (window == NULL)
&#123;
    glfwTerminate();
    return -1;
&#125;
// glfwCreateWindow 命令的参数指定了窗口的宽、高（以像素为单位）以及窗口顶部的标题，后两个NULL分别用来控制全屏显示和资源共享）
// 创建一个新窗口，大小为1024×768，窗口名为“New Window”

glfwMakeContextCurrent(window);
// 创建 GLFW 窗口并不会自动将它与当前 OpenGL 上下文关联起来，因此需要调用 glfwMakeContextCurrent()。
</code></pre>
<ol start="4">
<li>设置窗口属性</li>
</ol>
<pre><code class="language-cpp">// 确保我们可以捕捉到下面按下的转义键
glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

// 设置绿色背景，四个参数分别为RGBA。
// glClearColor()能够指定颜色缓冲区清除后填充的值
glClearColor(0.0f, 1.0f, 0.0f, 0.0f);
</code></pre>
<ol start="5">
<li>初始化 GLEW 库</li>
</ol>
<pre><code class="language-cpp">// 初始化 GLEW
if (glewInit() != GLEW_OK)
&#123;
    glfwTerminate();
    return -1;
&#125;
</code></pre>
<ol start="6">
<li>循环显示窗口</li>
</ol>
<pre><code class="language-cpp">do
&#123;
    // 清除屏幕，重置缓冲区时填充的颜色
    glClear(GL_COLOR_BUFFER_BIT);

    // 交换缓冲区，绘制屏幕
    glfwSwapBuffers(window);
    // 处理窗口相关事件（如按键事件）
    glfwPollEvents();
&#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0); // 检查是否按下了ESC键或窗口已关闭
</code></pre>
<ol start="7">
<li>退出程序</li>
</ol>
<pre><code class="language-cpp">// 关闭OpenGL窗口并终止GLFW
glfwDestroyWindow(window);
glfwTerminate();
</code></pre>
<details><summary>完整程序</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

using namespace glm;

int main()
&#123;
    // 初始化 GLFW
    if (!glfwInit())
    &#123;
        return -1;
    &#125;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);

    // 打开一个窗口并创建它的OpenGL上下文
    GLFWwindow *window = glfwCreateWindow(1024, 768, &quot;New Window&quot;, NULL, NULL);
    if (window == NULL)
    &#123;
        glfwTerminate();
        return -1;
    &#125;

    glfwMakeContextCurrent(window);

    // 确保我们可以捕捉到下面按下的转义键
    glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

    // 绿色背景
    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);

    // 初始化 GLEW
    if (glewInit() != GLEW_OK)
    &#123;
        glfwTerminate();
        return -1;
    &#125;

    do
    &#123;
        // 清除屏幕
        glClear(GL_COLOR_BUFFER_BIT);

        // 交换缓冲区
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0); // 检查是否按下了ESC键或窗口已关闭

    // 关闭OpenGL窗口并终止GLFW
    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
&#125;
</code></pre>
</details>
<h3 id="2-2-顶点着色器和片段着色器">2.2 顶点着色器和片段着色器</h3>
<p>多数 3D 模型通常由多个三角形图元构成。如点、线、三角形这些简单的图形称作图元。</p>
<p>图元由顶点组成。</p>
<p>在加载顶点之前，C++/OpenGL 应用程序必须编译并链接合适的 GLSL 顶点着色器和片段着色器程序，之后将它们载入管线。</p>
<p>比如绘画三角形时，可以通过该函数实现：</p>
<pre><code class="language-cpp">glDrawArrays(GLenum mode, Glint first, Glsizei count);
</code></pre>
<ul>
<li>
<p>mode：表示图元的类型；</p>
</li>
<li>
<p>first：表示从哪个顶点开始绘制；</p>
</li>
<li>
<p>count：表示绘制的顶点数。</p>
</li>
</ul>
<p>以绘画三角形为例子，步骤如下：</p>
<p><em>注： <code>GLuint</code> 是 OpenGL 提供的 <code>unsigned int</code></em></p>
<ol>
<li>
<p>初始化阶段，对 GLFW 和 GLEW 库进行初始化，同时创建窗口；</p>
</li>
<li>
<p>创建顶点数组对象VAO和缓存区；</p>
</li>
</ol>
<pre><code class="language-cpp">// 创建一个顶点数组对象，并将它设为当前对象
GLuint VertexArrayID;
glGenVertexArrays(1, &amp;VertexArrayID);
glBindVertexArray(VertexArrayID);

// 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)
static const GLfloat g_vertex_buffer_data[] = &#123;
    -1.0f, -1.0f, 0.0f,
     1.0f, -1.0f, 0.0f,
     0.0f,  1.0f, 0.0f &#125;;

// 创建缓存区
GLuint vertexbuffer; // 顶点缓冲区标识
glGenBuffers(1, &amp;vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲
glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);
glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL
</code></pre>
<ol start="3">
<li>循环中绘画三角形</li>
</ol>
<pre><code class="language-cpp">do
&#123;
    glClear(GL_COLOR_BUFFER_BIT);

    glEnableVertexAttribArray(0);    // 启用顶点数组
    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);

    glDrawArrays(GL_TRIANGLES, 0, 3);    // 绘制三角形

    glDisableVertexAttribArray(0);    // 禁用顶点数组

    glfwSwapBuffers(window);    // 交换缓冲区，更新屏幕
    glfwPollEvents();            // 监听事件
&#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0);
</code></pre>
<ol start="4">
<li>后处理，删除申请的资源</li>
</ol>
<pre><code class="language-cpp">// 后处理，删除资源
glDeleteBuffers(1, &amp;vertexbuffer);
glDeleteVertexArrays(1, &amp;VertexArrayID);
glfwTerminate();
</code></pre>
<details><summary>完整代码</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

int main()
&#123;
    // 初始化 GLFW
    if (!glfwInit())
    &#123;
        return -1;
    &#125;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);

    // 打开一个窗口并创建它的OpenGL上下文
    GLFWwindow *window = glfwCreateWindow(1024, 768, &quot;triangle&quot;, NULL, NULL);
    if (window == NULL)
    &#123;
        glfwTerminate();
        return -1;
    &#125;
    glfwMakeContextCurrent(window);

    // 确保我们可以捕捉到下面按下的转义键
    glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

    // 绿色背景
    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);

    // 初始化 GLEW
    if (glewInit() != GLEW_OK)
    &#123;
        glfwTerminate();
        return -1;
    &#125;

    // 创建一个顶点数组对象，并将它设为当前对象
    GLuint VertexArrayID; // 顶点数组标识
    glGenVertexArrays(1, &amp;VertexArrayID);
    glBindVertexArray(VertexArrayID);

    // 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)
    static const GLfloat g_vertex_buffer_data[] = &#123;
        -1.0f, -1.0f, 0.0f,
         1.0f, -1.0f, 0.0f,
         0.0f,  1.0f, 0.0f &#125;;

    // 创建缓存区
    GLuint vertexbuffer; // 顶点缓冲区标识
    glGenBuffers(1, &amp;vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲
    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
    glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL

    do
    &#123;
        glClear(GL_COLOR_BUFFER_BIT);

        glEnableVertexAttribArray(0);    // 启用顶点数组属性
        glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);

        glDrawArrays(GL_TRIANGLES, 0, 3);    // 绘制三角形

        glDisableVertexAttribArray(0);    // 禁用顶点数组属性

        glfwSwapBuffers(window);    // 交换缓冲区，更新屏幕
        glfwPollEvents();            // 监听事件
    &#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0);

    // 后处理，删除资源
    glDeleteBuffers(1, &amp;vertexbuffer);
    glDeleteVertexArrays(1, &amp;VertexArrayID);

    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_triangle.jpg" alt="绘画三角形"></p>
<p>这个三角形是白色的，因为其并没有进行任何着色。</p>
<p>使用顶点着色器和片段着色器可以进行着色。</p>
<details><summary>完整代码</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

GLuint createShadeProgram()
&#123;
    // 顶点着色器
    const char *vshaderSource =
        &quot;#version 460 core\n&quot;
        &quot;layout(location = 0) in vec3 vertexPosition_modelspace;\n&quot;
        &quot;void main()\n&quot;
        &quot;&#123; gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0; &#125;&quot;;

    // 片段着色器
    const char *fshaderSource =
        &quot;#version 460 core\n&quot;
        &quot;out vec3 color;\n&quot;
        &quot;void main()\n&quot;
        &quot;&#123; color = vec3(0, 0, 0.3); &#125;&quot;;

    // OpenGL 创建每个着色器对象（初始值为空）的时候，会返回一个整数 ID 作为后面引用它的序号
    // 分别存入 vShader 和 fShader 变量
    GLuint vShader = glCreateShader(GL_VERTEX_SHADER); // 创建了类型为GL_VERTEX_SHADER 的着色器，即顶点着色器
    GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 创建了类型为GL_FRAGMENT_SHADER 的着色器，即片段着色器

    // 将 GLSL 代码从字符串载入空着色器对象中
    glShaderSource(vShader, 1, &amp;vshaderSource, NULL);
    glShaderSource(fShader, 1, &amp;fshaderSource, NULL);

    // 编译着色器
    glCompileShader(vShader);
    glCompileShader(fShader);

    // 创建了一个叫作 vfProgram 的程序对象并记录其ID
    GLuint vProgram = glCreateProgram();
    // 将着色器加入程序对象
    glAttachShader(vProgram, vShader);
    glAttachShader(vProgram, fShader);
    // 请求 GLSL 编译器，以确保它们的兼容性
    glLinkProgram(vProgram);

    return vProgram; // 返回着色器程序ID
&#125;

int main()
&#123;
    // 初始化 GLFW
    if (!glfwInit())
    &#123;
        return -1;
    &#125;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);

    // 打开一个窗口并创建它的OpenGL上下文
    GLFWwindow *window = glfwCreateWindow(1024, 768, &quot;triangle&quot;, NULL, NULL);
    if (window == NULL)
    &#123;
        glfwTerminate();
        return -1;
    &#125;
    glfwMakeContextCurrent(window);

    // 确保我们可以捕捉到下面按下的转义键
    glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

    // 绿色背景
    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);

    // 初始化 GLEW
    if (glewInit() != GLEW_OK)
    &#123;
        glfwTerminate();
        return -1;
    &#125;

    // 创建一个顶点数组对象，并将它设为当前对象
    GLuint VertexArrayID; // 顶点数组标识
    glGenVertexArrays(1, &amp;VertexArrayID);
    glBindVertexArray(VertexArrayID);

    // 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)
    static const GLfloat g_vertex_buffer_data[] = &#123;
        -1.0f, -1.0f, 0.0f,
         1.0f, -1.0f, 0.0f,
         0.0f,  1.0f, 0.0f &#125;;

    // 创建缓存区
    GLuint vertexbuffer; // 顶点缓冲区标识
    glGenBuffers(1, &amp;vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲
    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
    glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL

    GLuint programID = createShadeProgram(); // 创建着色器

    do
    &#123;
        glClear(GL_COLOR_BUFFER_BIT);

        glUseProgram(programID);    // 使用着色器

        glEnableVertexAttribArray(0);    // 启用顶点数组属性
        glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);

        glDrawArrays(GL_TRIANGLES, 0, 3);    // 绘制三角形

        glDisableVertexAttribArray(0);    // 禁用顶点数组属性

        glfwSwapBuffers(window);    // 交换缓冲区，更新屏幕
        glfwPollEvents();            // 监听事件
    &#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0);

    // 后处理，删除资源
    glDeleteBuffers(1, &amp;vertexbuffer);
    glDeleteVertexArrays(1, &amp;VertexArrayID);
    glDeleteProgram(programID);

    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_triangle1.jpg" alt="着色后的三角形"></p>
<p>观察着色器部分的代码：</p>
<p>顶点着色器：所有顶点着色器的主要目标都是将顶点发送给管线。</p>
<pre><code class="language-cpp">&quot;#version 460 core\n&quot;
&quot;layout(location = 0) in vec3 vertexPosition_modelspace;\n&quot;
&quot;void main()\n&quot;
&quot;&#123; gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0; &#125;&quot;
</code></pre>
<ol>
<li>
<p>第一行表示OpenGL版本，同时也使用该版本的语法，我这里是4.6.0；</p>
</li>
<li>
<p>第二行</p>
<ul>
<li><code>layout(location = 0)</code> 指用来赋给 <code>vertexPosition_modelspace</code> 这个属性的缓冲区。每个顶点能有多种属性：位置，一种或多种颜色，一个或多个纹理坐标，等等；通过将 <code>glvertexAttribPointer</code> 函数的第一个参数值赋给layout，就完成了这一点。参数值“0”并不重要，它可以是12（但是不大于 <code>glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;v)</code> ）；重要的是两边参数值保持一致</li>
<li><code>in</code> 表示表明变量是输入变量；</li>
<li><code>vec3</code> 在GLSL中是一个三维向量；</li>
<li><code>vertexPosition_modelspace</code> 是变量名，将包含每个顶点着色器运行所需的顶点位置值。</li>
</ul>
</li>
<li>
<p>第三行表示主函数，与C++语法相似；</p>
</li>
<li>
<p>第四行内置变量 gl_Position 用来设置顶点在 3D 空间中的坐标位置，并将其发送至下一个管线阶段。</p>
</li>
</ol>
<p>片段着色器：所有片段着色器的目的都是给为要展示的像素赋予颜色。</p>
<pre><code class="language-cpp">&quot;#version 460 core\n&quot; 
&quot;out vec3 color;\n&quot;
&quot;void main()\n&quot;
&quot;&#123; color = vec3(0, 0, 0.3); &#125;&quot;
</code></pre>
<ol>
<li>
<p>第一行表示OpenGL版本，同时也使用该版本的语法，我这里是4.6.0；</p>
</li>
<li>
<p>第二行 out 标签表明 color 变量是输出变量；</p>
</li>
<li>
<p>第三行表示主函数，与C++语法相似；</p>
</li>
<li>
<p>第四行表示设置颜色RGB值。</p>
</li>
</ol>
<p>解释 <code>glvertexAttribPointer</code> 函数，函数使用如下：</p>
<pre><code class="language-cpp">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);
</code></pre>
<ol>
<li>
<p>第一参数：指定要配置的顶点属性。在顶点着色器中使用 <code>layout(location = 0)</code> 定义了顶点属性的位置值，它可以把顶点属性的位置值设置为0，所以这里传入0；</p>
</li>
<li>
<p>第二参数：指定顶点属性的大小；</p>
</li>
<li>
<p>第三参数：指定数据的类型；</p>
</li>
<li>
<p>第四参数：是否希望数据被标准化（Normalize）；</p>
</li>
<li>
<p>第五参数：步长，告诉在连续的顶点属性组之间的间隔；</p>
</li>
<li>
<p>第六参数：数组缓冲区偏移量。</p>
</li>
</ol>
<p>此示例中着色器代码较短，可以直接编写到程序中。但当着色器代码较为复杂时，希望能文件分开，从文件中读入着色器代码。</p>
<pre><code class="language-cpp">// 读代码函数
std::string readShaderSource(const char *filePath)
&#123;
    std::string content = &quot;&quot;;
    std::ifstream fileStream(filePath, std::ios::in);
    std::string line = &quot;&quot;;
    while (!fileStream.eof())
    &#123;
        getline(fileStream, line);
        content.append(line + &quot;\n&quot;);
    &#125;
    fileStream.close();
    return content;
&#125;
</code></pre>
<p>相应地 <code>createShadeProgram()</code> 改成：</p>
<pre><code class="language-cpp">std::string vs = readShaderSource(&quot;vertex.glsl&quot;);
std::string fs = readShaderSource(&quot;fragment.glsl&quot;);
const char *vshaderSource = vs.c_str();
const char *fshaderSource = fs.c_str();
</code></pre>
<h3 id="2-3-glsl代码检查">2.3 GLSL代码检查</h3>
<p>编译和运行 GLSL 代码的过程与普通代码的不同，GLSL 的编译发生在 C++运行时。另外一个复杂的点是 GLSL 代码并没有运行在 CPU 中（它运行在 GPU 中），因此操作系统并不总能捕获 OpenGL 运行时的错误。着色器运行时错误的常见结果是输出屏幕上完全空白，根本没有输出。</p>
<p>但是 GLSL 函数 <code>glGetShaderiv()</code> 和 <code>glGetProgramiv()</code> 可提供有关编译过的 GLSL 着色器和程序的信息。</p>
<p>设计三个函数：</p>
<ul>
<li>
<p><code>checkOpenGLError()</code>：既用于检测 GLSL 代码编译错误，又用于检测 OpenGL 运行时的错误。</p>
</li>
<li>
<p><code>printShaderLog()</code>：当 GLSL 代码编译失败时，显示 OpenGL 日志内容。</p>
</li>
<li>
<p><code>printProgramLog()</code>：当 GLSL 链接失败时，显示 OpenGL 日志内容。</p>
</li>
</ul>
<details><summary>详细代码</summary>
<pre><code class="language-cpp">/*
* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容
* @param shader 着色器标识
*/
void printShaderLog(GLuint shader)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetShaderInfoLog(shader, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Shader Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 当 GLSL 链接失败时，显示 OpenGL 日志内容
* @param program 着色器程序标识
*/
void printProgramLog(GLuint program)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetProgramInfoLog(program, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Program Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误
*/
bool checkOpenGLerror()
&#123;
    bool err = false;
    int glErr = glGetError();
    while (glErr != GL_NO_ERROR)
    &#123;
        std::cout &lt;&lt; &quot;glError: &quot; &lt;&lt; glErr &lt;&lt; &quot;\n&quot;;
        err = true;
        glErr = glGetError();
    &#125;
    return err;
&#125;
</code></pre>
</details>
<p>加入错误检查，创建着色器程序代码更改为：</p>
<details><summary>展开代码</summary>
<pre><code class="language-cpp">GLuint createShadeProgram()
&#123;
    // 记录错误信息
    GLint vertCompiled, fragCompiled, linked;

    // 顶点着色器
    std::string vs = readShaderSource(&quot;vertex.glsl&quot;);
    // 片段着色器
    std::string fs = readShaderSource(&quot;fragment.glsl&quot;);
    const char *vshaderSource = vs.c_str();
    const char *fshaderSource = fs.c_str();

    // OpenGL 创建每个着色器对象（初始值为空）的时候，会返回一个整数 ID 作为后面引用它的序号
    // 分别存入 vShader 和 fShader 变量
    GLuint vShader = glCreateShader(GL_VERTEX_SHADER); // 创建了类型为GL_VERTEX_SHADER 的着色器，即顶点着色器
    GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 创建了类型为GL_FRAGMENT_SHADER 的着色器，即片段着色器

    // 将 GLSL 代码从字符串载入空着色器对象中
    glShaderSource(vShader, 1, &amp;vshaderSource, NULL);
    glShaderSource(fShader, 1, &amp;fshaderSource, NULL);

    // 编译顶点着色器
    glCompileShader(vShader);
    checkOpenGLerror();
    glGetShaderiv(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);
    if (vertCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;vertex compilation failed\n&quot;;
        printShaderLog(vShader);
    &#125;
    // 编译片段着色器
    glCompileShader(fShader);
    checkOpenGLerror();
    glGetShaderiv(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);
    if (fragCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;fragment compilation failed\n&quot;;
        printShaderLog(fShader);
    &#125;

    // 创建了一个叫作 vfProgram 的程序对象并记录其ID
    GLuint vProgram = glCreateProgram();
    // 将着色器加入程序对象
    glAttachShader(vProgram, vShader);
    glAttachShader(vProgram, fShader);
    // 请求 GLSL 编译器，以确保它们的兼容性
    glLinkProgram(vProgram);
    checkOpenGLerror();
    glGetProgramiv(vProgram, GL_LINK_STATUS, &amp;linked);
    if (linked == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;linking failed\n&quot;;
        printProgramLog(vProgram);
    &#125;

    return vProgram; // 返回着色器程序ID
&#125;
</code></pre>
</details>
<h3 id="2-4-让图像动起来">2.4 让图像动起来</h3>
<p>实际上，在主函数的循环中，每一次循环都会刷新一次显示。但由于显示内容相同，故看起来是静态的。</p>
<p>对于上面的三角形，添加上些许偏移量，则会自由移动。</p>
<p>效果如下：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_movingtriangle.gif" alt="移动的三角形"></p>
<details><summary>主函数代码</summary>
<pre><code class="language-cpp">int main()
&#123;
    // 初始化 GLFW
    if (!glfwInit())
    &#123;
        return -1;
    &#125;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);

    // 打开一个窗口并创建它的OpenGL上下文
    GLFWwindow *window = glfwCreateWindow(1024, 768, &quot;triangle&quot;, NULL, NULL);
    if (window == NULL)
    &#123;
        glfwTerminate();
        return -1;
    &#125;
    glfwMakeContextCurrent(window);

    // 确保我们可以捕捉到下面按下的转义键
    glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);

    // 绿色背景
    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);

    // 初始化 GLEW
    if (glewInit() != GLEW_OK)
    &#123;
        glfwTerminate();
        return -1;
    &#125;

    // 创建一个顶点数组对象，并将它设为当前对象
    GLuint VertexArrayID; // 顶点数组标识
    glGenVertexArrays(1, &amp;VertexArrayID);
    glBindVertexArray(VertexArrayID);

    // 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)
    static const GLfloat g_vertex_buffer_data[] = &#123;
        -1.0f, -1.0f, 0.0f,
         1.0f, -1.0f, 0.0f,
         0.0f,  1.0f, 0.0f &#125;;

    // 创建缓存区
    GLuint vertexbuffer; // 顶点缓冲区标识
    glGenBuffers(1, &amp;vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲
    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
    glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL

    GLuint programID = createShadeProgram(); // 创建着色器

    float x = 0.0f, inc = 0.001f;

    do
    &#123;
        glClear(GL_COLOR_BUFFER_BIT);

        glUseProgram(programID);    // 使用着色器

        x += inc;    // 移动
        if (x &gt; 1.0f) inc = -0.001f;
        if (x &lt; -1.0f) inc = 0.001f;
        // 获取指向 offset 变量的指针
        GLuint offsetLoc = glGetUniformLocation(programID, &quot;offset&quot;);
        // 将 x 的值复制给 offset
        glProgramUniform1f(programID, offsetLoc, x);

        glEnableVertexAttribArray(0);    // 启用顶点数组
        glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);

        glDrawArrays(GL_TRIANGLES, 0, 3);    // 绘制三角形

        glDisableVertexAttribArray(0);    // 禁用顶点数组

        glfwSwapBuffers(window);    // 交换缓冲区，更新屏幕
        glfwPollEvents();            // 监听事件
    &#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0);

    // 后处理，删除资源
    glDeleteBuffers(1, &amp;vertexbuffer);
    glDeleteVertexArrays(1, &amp;VertexArrayID);
    glDeleteProgram(programID);

    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<p>而顶点着色器也需要根据偏移量作修改：</p>
<pre><code class="language-glsl">#version 460 core

uniform float offset;

layout(location = 0) in vec3 vertexPosition_modelspace;

void main()
&#123;
    gl_Position = vec4(vertexPosition_modelspace.x + offset, vertexPosition_modelspace.y, vertexPosition_modelspace.z, 1.0);
&#125;
</code></pre>
<p>其中 <code>uniform</code> 表示统一变量。</p>
<h2 id="三-opengl数学基础">三、OpenGL数学基础</h2>
<h3 id="3-1-坐标系">3.1 坐标系</h3>
<p>3D 空间中常常使用三个坐标轴组成的坐标系，如左手坐标系和右手坐标系。</p>
<ul>
<li>
<p>左手坐标系：伸出左手，使得拇指、食指和中指两两垂直，则拇指指向为 x 方向，中指指向为 z 方向，食指指向为 y 方向。</p>
</li>
<li>
<p>右手坐标系：伸出右手，使得拇指、食指和中指两两垂直，则拇指指向为 x 方向，中指指向为 z 方向，食指指向为 y 方向。</p>
</li>
</ul>
<p><em>此学习记录使用右手坐标系</em></p>
<h3 id="3-2-点">3.2 点</h3>
<p>齐次坐标：具有四个值，分别是 x 坐标、y 坐标、z 坐标、w 坐标。其中 w 总是非零值。</p>
<p>OpenGL 中可用 <code>vec3</code> 或 <code>vec4</code> 类表示点数据。</p>
<h3 id="3-3-向量">3.3 向量</h3>
<p>向量表示大小和方向。它们没有特定位置。在 3D 图形学中，向量一般用空间中的单个点表示，向量的大小是原点到该点的距离，方向则是原点到该点的方向。</p>
<p>GLSL 和 GLM 所提供的 <code>vec3</code> 和 <code>vec4</code> 类型既能用来存储点，又能用来存储向量。</p>
<p>设有向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 和 向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(u,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>：</p>
<ul>
<li>
<p>向量的加法：对应位置相加</p>
</li>
<li>
<p>向量归一化：将长度变为1。GLM 库提供了函数 <code>glm::normalize(vec3)</code></p>
</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>^</mo></mover><mo>=</mo><mfrac><mi>A</mi><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>=</mo><mfrac><mi>A</mi><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\hat{A}=\frac A{\vert A\vert}=\frac A{\sqrt{x^2+y^2+z^2}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9467699999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.11110999999999999em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">A</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.49033em;vertical-align:-1.13em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.1521660000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578340000000001em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.917834em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2821659999999999em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">A</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.13em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p>向量点积： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi><mo>=</mo><mi>x</mi><mi>u</mi><mo>+</mo><mi>y</mi><mi>v</mi><mo>+</mo><mi>z</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">A\cdot B = xu+yv+zw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>。GLM 库提供了函数 <code>glm::dot(vec3,vec3)</code></p>
</li>
<li>
<p>向量叉积： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mi>w</mi><mo>−</mo><mi>v</mi><mi>z</mi><mo separator="true">,</mo><mi>u</mi><mi>z</mi><mo>−</mo><mi>x</mi><mi>w</mi><mo separator="true">,</mo><mi>x</mi><mi>v</mi><mo>−</mo><mi>u</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A\times B=(yw-vz, uz-xw, xv-uy)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。GLM 库提供了函数 <code>glm::cross(vec3,vec3)</code></p>
</li>
</ul>
<h4 id="3-3-1-点积的应用">3.3.1 点积的应用</h4>
<ol>
<li>点积的基本应用是求两向量夹角。</li>
</ol>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><mfrac><mrow><mi>V</mi><mo>⋅</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>W</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\cos\theta=\frac{V\cdot W}{\vert V\vert\vert W\vert}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ol start="2">
<li>
<p>求向量的大小： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mi>V</mi><mo>⋅</mo><mi>V</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{V\cdot V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>判断向量是否正交，若正交，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>⋅</mo><mi>W</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">V\cdot W=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
</li>
<li>
<p>判断向量是否平行，若平行，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>⋅</mo><mi>W</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>W</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">V\cdot W=\vert V\vert\vert W\vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">∣</span></span></span></span></p>
</li>
</ol>
<h4 id="3-3-2-叉积的应用">3.3.2 叉积的应用</h4>
<ul>
<li>
<p>两向量叉积的一个重要特性是，它会生成一个新的向量（法向量），新的向量正交（垂直）于之前两个向量所定义的平面。所得法向量的方向遵循右手定则，即将右手手指从 V 向 W 卷曲会使得大拇指指向法向量 R 的方向。</p>
</li>
<li>
<p>叉积的计算与向量顺序有关。</p>
</li>
</ul>
<h3 id="3-4-矩阵">3.4 矩阵</h3>
<p>矩阵式矩形的值的阵列，跟很多领域上的矩阵概念相似。</p>
<p>GLSL中的 <code>mat4</code> 数据类型便是用来存储 4 x 4 矩阵。同样 GLM 中的 <code>mat4</code> 类也是用来实例化并表示 4 x 4 矩阵。</p>
<p>比如单位矩阵是对角线值全为1，其余值都为0的矩阵。在 GLM 中，调用构造函数 <code>glm::mat4 m(1.0f)</code> 可以在变量 m 中生成单位矩阵。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(单位矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
\tag{单位矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>矩阵转置：矩阵的列与行交换。GLM 库和 GLSL 库都有转置函数，分别是 <code>glm::transpose(mat4)</code> 和 <code>transpose(mat4)</code>。</p>
<p>矩阵加法：两个矩阵对应值相加。在GLSL中，<code>+</code> 作了重载，支持矩阵加法。</p>
<p>矩阵乘法：与线性代数中的矩阵乘法一致。</p>
<ul>
<li>在 3D 图形学中，点与矩阵相乘通常将点视作列向量，并从右向左计算，得到点。</li>
<li>矩阵相乘也叫作合并。
<ul>
<li>矩阵乘法结合律</li>
</ul>
</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>e</mi><mi>w</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>=</mo><msub><mi>M</mi><mn>1</mn></msub><mo>×</mo><mo stretchy="false">[</mo><msub><mi>M</mi><mn>2</mn></msub><mo>×</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mn>3</mn></msub><mo>×</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo>×</mo><msub><mi>M</mi><mn>2</mn></msub><mo>×</mo><msub><mi>M</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">NewPoint = M_1\times[M_2\times(M_3\times Point)]=(M_1\times M_2\times M_3)\times Point
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<ul>
<li>GLSL 和 GLM 都支持 vec4 与矩阵相乘，并使用 <code>*</code> 操作符表示。</li>
</ul>
<p>逆矩阵： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>M</mi><mo>=</mo><mtext>单位矩阵</mtext></mrow><annotation encoding="application/x-tex">MM^{-1}=M^{-1}M=单位矩阵</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span></span></span>，GLSL 和 GLM 都提供了 <code>mat4.inverse()</code> 函数。</p>
<h3 id="3-5-变换矩阵">3.5 变换矩阵</h3>
<p>变换矩阵基于 4x4 矩阵，使用齐次坐标系，包括平移矩阵、缩放矩阵、旋转矩阵、投影矩阵和 LookAt 矩阵。</p>
<h4 id="3-5-1-平移矩阵">3.5.1 平移矩阵</h4>
<p>平移矩阵 A 用于将物体从一个位置移至另一位置。</p>
<p>在单位矩阵的基础上，将 x、y、z 的移动量记录在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>03</mn></msub></mrow><annotation encoding="application/x-tex">A_{03}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>13</mn></msub></mrow><annotation encoding="application/x-tex">A_{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>23</mn></msub></mrow><annotation encoding="application/x-tex">A_{23}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 位置。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mo>+</mo><msub><mi>T</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mo>+</mo><msub><mi>T</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Z</mi><mo>+</mo><msub><mi>T</mi><mi>z</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(
\begin{matrix}
X+T_x\\
Y+T_y\\
Z+T_z\\
1
\end{matrix}
\right)
=
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; T_x\\
0 &amp; 1 &amp; 0 &amp; T_y\\
0 &amp; 0 &amp; 1 &amp; T_z\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
\left(
\begin{matrix}
X\\
Y\\
Z\\
1
\end{matrix}
\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>结果就是点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X,Y,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> 平移到位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><msub><mi>T</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>Y</mi><mo>+</mo><msub><mi>T</mi><mi>y</mi></msub><mo separator="true">,</mo><mi>Z</mi><mo>+</mo><msub><mi>T</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X+T_x,Y+T_y,Z+T_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>平移矩阵的构建可以使用 GLM 中 <code>glm::translate(x,y,z)</code> 函数。接着矩阵与点相乘。</p>
<h4 id="3-5-2-缩放矩阵">3.5.2 缩放矩阵</h4>
<p>缩放矩阵用于改变物体的大小或者将点沿朝向或远离原点的方向移动。</p>
<p>缩放矩阵 A 在单位矩阵的基础上，将位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>00</mn></msub></mrow><annotation encoding="application/x-tex">A_{00}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">A_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>22</mn></msub></mrow><annotation encoding="application/x-tex">A_{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值替换为 x、y、z 缩放因子。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mtext> </mtext><msub><mi>S</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mtext> </mtext><msub><mi>S</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Z</mi><mtext> </mtext><msub><mi>S</mi><mi>z</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>S</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>S</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>S</mi><mi>z</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(
\begin{matrix}
X\ S_x\\
Y\ S_y\\
Z\ S_z\\
1
\end{matrix}
\right)
=
\left[
\begin{matrix}
S_x &amp; 0 &amp; 0 &amp; 0\\
0 &amp; S_y &amp; 0 &amp; 0\\
0 &amp; 0 &amp; S_z &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
\left(
\begin{matrix}
X\\
Y\\
Z\\
1
\end{matrix}
\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>GLM 的 <code>glm::scale(x,y,z)</code> 函数用于构建依照 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 缩放的矩阵，接着矩阵与点相乘。</p>
<p>缩放还可以用来切换坐标系，比如在右手坐标系下确定左手坐标系的坐标，只需把 z 坐标反转即可。切换坐标系的缩放矩阵：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -1&amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="3-5-3-旋转矩阵">3.5.3 旋转矩阵</h4>
<p>3D 空间中旋转物体需要指定旋转轴和旋转角（以度或弧度为单位）。</p>
<p>数学上可证明：围绕任何轴的旋转都可以表示为绕 x 轴、y<br>
轴、z 轴旋转的组合。围绕这 3 个轴的旋转角度被称为欧拉角。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(绕x轴旋转)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left(\begin{matrix}X \\ Y&#x27;\\ Z&#x27;\\ 1\end{matrix}\right)=\left[\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; \cos\theta &amp; -\sin\theta &amp; 0\\ 0 &amp; \sin\theta &amp; \cos\theta &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left(\begin{matrix}X\\ Y\\ Z\\ 1\end{matrix}\right)\tag{绕x轴旋转}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">绕</span><span class="mord">x</span><span class="mord cjk_fallback">轴</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(绕y轴旋转)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left(\begin{matrix}X&#x27; \\ Y\\ Z&#x27;\\ 1\end{matrix}\right)=\left[\begin{matrix}\cos\theta &amp; 0 &amp; \sin\theta &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ -\sin\theta &amp; 0 &amp; \cos\theta &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left(\begin{matrix}X\\ Y\\ Z\\ 1\end{matrix}\right)\tag{绕y轴旋转}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">绕</span><span class="mord">y</span><span class="mord cjk_fallback">轴</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(绕z轴旋转)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left(\begin{matrix}X&#x27; \\ Y&#x27;\\ Z\\ 1\end{matrix}\right)=\left[\begin{matrix}\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0\\ \sin\theta &amp; \cos\theta &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left(\begin{matrix}X\\ Y\\ Z\\ 1\end{matrix}\right)\tag{绕z轴旋转}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">绕</span><span class="mord">z</span><span class="mord cjk_fallback">轴</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>旋转变换有 3 种，分别是绕 x 轴、y 轴、z 轴旋转。GLM 提供了函数 <code>glm::rotate(mat4,θ,x,y,z)</code> 构建绕 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 旋转 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 度的矩阵，接着矩阵与点相乘。</p>
<p>通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>−</mtext><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\cos(−θ) = \cos(θ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>−</mtext><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>−</mtext><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(−θ) = −\sin(θ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 即可验证反向旋转的矩阵恰等于其转置矩阵。</p>
<p>当在 3D 空间中旋转轴不穿过原点时，物体使用欧拉角进行旋转需要几个额外的步骤。一般有：</p>
<ol>
<li>平移旋转轴以使它经过原点；</li>
<li>绕 x 轴、y 轴、z 轴旋转适当的欧拉角；</li>
<li>复原步骤 1 中的平移。</li>
</ol>
<h3 id="3-6-视觉空间和合成相机">3.6 视觉空间和合成相机</h3>
<p>3D 空间中，需要找到一点并确立观察方向，这个点叫作视图或视觉空间或合成相机。</p>
<p>观察 3D 世界需要以下步骤</p>
<ol>
<li>确定相机的位置；</li>
<li>调整相机的角度，通常需要一套它自己的直角坐标轴u、v、n；</li>
<li>定义一个视体。视体是从相机的位置出发，沿着相机的视线朝向的可视范围。</li>
<li>将视体内的对象投影到投影平面上。</li>
</ol>
<p>OpenGL 具有一个固定在原点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 且朝向 z 轴负方向的相机。所以当使用这个相机时，由于相机自身不能移动，所以需要将对象移动到适合的位置并调整合适的方向。</p>
<p>假设有世界空间（类似于全局的空间）中某点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>W</mi></msub></mrow><annotation encoding="application/x-tex">P_W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，需要对该点进行变换转换成相机空间中适合的点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">P_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。构建一个单一变换矩阵以完成旋转和平移，这个矩阵叫作视图变换矩阵，记作 V（V合并了平移矩阵和旋转矩阵）。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub><mo>=</mo><mi>V</mi><mo>×</mo><msub><mi>P</mi><mi>W</mi></msub></mrow><annotation encoding="application/x-tex">P_C=V\times P_W
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>将 V 矩阵与模型矩阵 M 的积定义为 <strong>模型-视图(Model-View, MV)</strong> 矩阵，记作MV，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>V</mi><mo>=</mo><mi>V</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">MV=VM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>。</p>
<ul>
<li><em>模型矩阵 M 是世界空间中对象定位及定向的矩阵</em></li>
</ul>
<p>之后，对于某点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">P_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就可以从自己的模型空间直接转换到相机空间：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub><mo>=</mo><mi>M</mi><mi>V</mi><msub><mi>P</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">P_C=MVP_M
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="3-7-投影矩阵">3.7 投影矩阵</h3>
<p>透视投影矩阵和正射投影矩阵</p>
<h4 id="3-7-1-透视投影矩阵">3.7.1 透视投影矩阵</h4>
<p>透视投影通过使用透视概念模仿我们看真实世界的方<br>
式，尝试让 2D 图像看起来像是 3D 的。</p>
<p>使用叫作 <strong>透视矩阵</strong> 或者 <strong>透视变换</strong> 的变换矩阵将平行线变为恰当的不平行线来实现这个效果。定义 4 个参数来构建视体：</p>
<ul>
<li>纵横比：远近剪裁平面的宽度与高度之比；</li>
<li>视场：可视空间的纵向角度；</li>
<li>近剪裁平面（也称投影平面）</li>
<li>远剪裁平面。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_View.jpg" alt="透视视体或视锥，图源计算机图形学编程（第2版）"></p>
<p>透视矩阵：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>q</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>B</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>C</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(透视矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
A &amp; 0 &amp; 0 &amp; 0\\
0 &amp; q &amp; 0 &amp; 0\\
0 &amp; 0 &amp; B &amp; C\\
0 &amp; 0 &amp;-1 &amp; 0
\end{matrix}
\right]
\tag{透视矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">透</span><span class="mord cjk_fallback">视</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>其中：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mi>tan</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mtext>视场</mtext><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">q = \frac{1}{\tan{(\frac{视场}{2})}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.428771em;vertical-align:-1.1073309999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2376690000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">tan</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">视</span><span class="mord cjk_fallback mtight">场</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1073309999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mi>q</mi><mtext>纵横比</mtext></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{q}{纵横比}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">纵</span><span class="mord cjk_fallback">横</span><span class="mord cjk_fallback">比</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mfrac><mrow><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>+</mo><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><mrow><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub><mo>−</mo><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">B = \frac{Z_{near}+Z_{far}}{Z_{nead}-Z_{far}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.332438em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><mrow><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>−</mo><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac><mrow></mrow></mrow><annotation encoding="application/x-tex">C = \frac{2Z_{near}Z_{far}}{Z_{near}-Z_{far}}{}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.332438em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"></span></span></span></span></span></p>
<p>GLM 库提供了构建透视矩阵函数 <code>glm::perspective()</code>。</p>
<h4 id="3-7-2-正射投影矩阵">3.7.2 正射投影矩阵</h4>
<p>在正射投影中，平行线仍然是平行的。</p>
<p>构建正射矩阵需要以下参数：</p>
<ol>
<li>从相机到投影平面的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{near}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>从相机到远剪裁平面的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{far}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>投影平面左边界 x 坐标 L， 投影平面右边界 x 坐标 R，投影平面上边界 y 坐标 T， 投影平面下边界 y 坐标 B</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_zhengshe.jpg" alt="正射投影，图源计算机图形学编程（第2版）"></p>
<p>正射矩阵：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>R</mi><mo>−</mo><mi>L</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>R</mi><mo>+</mo><mi>L</mi></mrow><mrow><mi>R</mi><mo>−</mo><mi>L</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>T</mi><mo>−</mo><mi>B</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>T</mi><mo>+</mo><mi>B</mi></mrow><mrow><mi>T</mi><mo>−</mo><mi>B</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>−</mo><mn>2</mn></mrow><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>+</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(正射矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
\frac{2}{R-L} &amp; 0 &amp; 0 &amp; -\frac{R+L}{R-L}\\
0 &amp; \frac{2}{T-B} &amp; 0 &amp; -\frac{T+B}{T-B}\\
0 &amp; 0 &amp; \frac{-2}{z_{far}-z_{near}} &amp; -\frac{z_{far}+z_{near}}{z_{far}-z_{near}}\\
0 &amp; 0 &amp;0 &amp; 1
\end{matrix}
\right]
\tag{正射矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.220815em;vertical-align:-2.3604075em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">L</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5480799999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">L</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.921411em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.51308em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5480799999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:5.220815em;vertical-align:-2.3604075em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">射</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<h3 id="3-8-lookat矩阵">3.8 LookAt矩阵</h3>
<p>当把相机放在某处并看向一个特定的位置时，就需要用到 LookAt 矩阵。LookAt 变换依然由相机旋转决定。</p>
<p>通过指定大致旋转朝向的向量（如世界空间 y 轴）。可以通过一系列叉积获得一组向量，代表相机的正面（向量 fwd）、侧面（向量 side），以及上面（向量 up）。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_lookat.jpg" alt="LookAt元素，图源计算机图形学编程（第2版）"></p>
<p>由相机位置（点eye）、目标位置（点target）、初始向上向量 Y 构建 LookAt 矩阵：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>i</mi><mi>d</mi><msub><mi>e</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>i</mi><mi>d</mi><msub><mi>e</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>⋅</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><msub><mi>p</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><msub><mi>p</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><msub><mi>p</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>u</mi><mi>p</mi><mo>⋅</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>f</mi><mi>w</mi><msub><mi>d</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>f</mi><mi>w</mi><msub><mi>d</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>f</mi><mi>w</mi><msub><mi>d</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mi>w</mi><mi>d</mi><mo>⋅</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(LookAt矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
side_x &amp; side_y &amp; size_z &amp; -(side\cdot eye)\\
up_x &amp; up_y &amp; up_z &amp; -(up\cdot eye)\\
-fwd_x &amp; -fwd_y &amp; -fwd_z &amp; -(-fwd\cdot eye)\\
0 &amp; 0 &amp;0 &amp; 1
\end{matrix}
\right]
\tag{LookAt矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">L</span><span class="mord">o</span><span class="mord">o</span><span class="mord">k</span><span class="mord">A</span><span class="mord">t</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>其中：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>w</mi><mi>d</mi><mo>=</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fwd = normalize(eye-target)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>=</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mi>w</mi><mi>d</mi><mo>×</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">side = normalize(-fwd \times Y)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mo>=</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>×</mo><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mi>w</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">up = normalize(side \times (-fwd))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="四-opengl管理3d图形数据">四、OpenGL管理3D图形数据</h2>
<p>使用 OpenGL 渲染一个 3D 图形 需要将若干数据发送给 OpenGL 着色器管线。</p>
<p>比如一个立方体，需要发送：</p>
<ul>
<li>立方体模型的顶点；</li>
<li>控制立方体在3D空间中朝向的变换矩阵。</li>
</ul>
<p>然而，发送数据到 OpenGL 管线的方式有：</p>
<ul>
<li>通过顶点属性的 <strong>缓冲区</strong>；</li>
<li>直接发送给 <strong>统一变量</strong>。</li>
</ul>
<h3 id="4-1-缓冲区和顶点属性">4.1 缓冲区和顶点属性</h3>
<p>绘制对象时，它的顶点数据需要发送给顶点着色器。通常：</p>
<ol>
<li>顶点数据被发送到一个缓冲区中；</li>
<li>把缓冲区和着色器中声明的顶点属性相关联。</li>
</ol>
<p>完成这件事，有一系列的步骤，有的步骤只需要做一次，有的步骤每帧都需做一次：</p>
<ul>
<li>只做一次的步骤：
<ol>
<li>创建缓冲区</li>
<li>将顶点数据复制到缓冲区</li>
</ol>
</li>
<li>每帧刷新需要的步骤：
<ol>
<li>启用包含顶点数据的缓冲区</li>
<li>将缓冲区和一个顶点属性相关联</li>
<li>启用这个顶点属性</li>
<li>使用 <code>glDrawArrays()</code> 绘制对象</li>
</ol>
</li>
</ul>
<p>在 OpenGL 中，缓冲区被包含在顶点缓冲对象（Vertex Buffer Object，VBO）中，VBO 在 C++/OpenGL 应用程序中被声明和实例化。一个场景可能需要很多 VBO，所以常常会在一个地方中生成并填充若干个 VBO，以备程序需要时直接使用。</p>
<p>缓冲区使用特定的方式和顶点属性交互。当 <code>glDrawArrays()</code> 执行时，缓冲区中的数据开始流动，从缓冲区的开头开始，按顺序流过顶点着色器，顶点着色器对每个顶点执行一次。</p>
<p>OpenGL 中还有一种相关的结构，叫作顶点数组对象（Vertex Array Object，VAO）。OpenGL的 3.0 版本引入了 VAO，作为一种组织缓冲区的方法，让缓冲区在复杂场景中更容易操控。OpenGL 要求至少创建一个 VAO。</p>
<p>举个例子，假设想显示两个对象，那么声明一个 VAO 和两个相关的 VBO：</p>
<pre><code class="language-cpp">GLuint vao[1];
GLuint vbo[2];
// ……
glGenVertexArrays(1, vao);
glBindVertexArray(vao[0]);
glGenBuffers(2, vbo);
</code></pre>
<ul>
<li><code>glGenVertexArrays()</code>：生成一个 VAO，返回 VAO 的整型 ID 并将存到vao
<ul>
<li>第一参数表示创建 ID 个数</li>
<li>第二参数表示保存返回 ID 的数组</li>
</ul>
</li>
<li><code>glBindVertexArray()</code>：将 vao[0] 设为当前对象，这样生成的缓冲区就会和这个 VAO 相关联</li>
<li><code>glGenBuffers()</code>：生成两个 VBO，返回 VBO 的整型 ID 并将它们存到vbo
<ul>
<li>第一参数表示创建 ID 个数</li>
<li>第二参数表示保存返回 ID 的数组</li>
</ul>
</li>
</ul>
<p>缓冲区大概完成之后，顶点着色器需要有相应地顶点属性变量。如：</p>
<pre><code class="language-cpp">layout (location = 0) in vec3 position;
</code></pre>
<ul>
<li><code>layout (location = 0)</code>：layout修饰符，顶点属性和特定缓冲区关联的方法，这里表示顶点属性的识别号是0</li>
<li><code>in</code>：表示顶点属性将会从缓冲区中接收数值</li>
<li><code>vec3</code>：表示顶点属性的类型是三维向量</li>
<li><code>position</code>：顶点属性的名字</li>
</ul>
<p>继续假设绘制一个立方体，假定立方体的顶点数据在代码中用数组直接指定，还需要进行以下步骤：</p>
<ol>
<li>将顶点数据值复制到之前生成的两个缓冲区之一。使用 OpenGL 的函数 <code>glBindBuffer()</code> 将缓冲区标为活跃（使用）</li>
<li>使用 <code>glBufferData()</code> 函数将包含顶点数据的数组复制进活跃缓冲区</li>
</ol>
<pre><code class="language-cpp">glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
</code></pre>
<p>上述是初始化时执行一次的步骤，接下来对于每一帧刷新，需要进行：</p>
<ol>
<li>使用 <code>glBindBuffer()</code> 函数标记缓冲区为活跃</li>
<li>将活跃缓冲区与着色器中的顶点属性相关联</li>
<li>启用顶点属性</li>
</ol>
<pre><code class="language-cpp">// 标记第0个缓冲区为活跃
glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
// 将第0个属性关联到缓冲区
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);
// 启用第0个顶点属性
glEnableVertexAttribArray(0);
</code></pre>
<h3 id="4-2-统一变量">4.2 统一变量</h3>
<p>使用关键字 <code>uniform</code> 在着色器中声明统一变量。</p>
<p>将数据从 C++/OpenGL 应用程序发送到统一变量需要以下步骤：</p>
<ol>
<li>获取统一变量的引用</li>
<li>将指向所需数值的指针与获取的统一变量引用相关联</li>
</ol>
<p>比如在上面绘制立方体的例子，假设链接的渲染程序保存在名为 <code>rendering</code> 的变量中，则以下代码会把 MV 和投影矩阵发送到两个统一变量中：</p>
<pre><code class="language-cpp">// 获取着色器程序中的统一变量位置
mvLoc = glGetUniformLocation(rendering, &quot;mv_m&quot;);
projLoc = glGetUniformLocation(rendering, &quot;proj_m&quot;);
// 将矩阵数据发送到统一变量中
glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mv));
glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(proj));
// mv 是模型视图矩阵，proj 是投影矩阵
</code></pre>
<p><em><code>value_ptr()</code> 返回对矩阵数据的引用， <code>glUniformMatrix4fv()</code> 将矩阵数据传递给统一变量</em></p>
<h3 id="4-3-顶点属性插值">4.3 顶点属性插值</h3>
<p>在片段着色器栅格化之前，由顶点定义的图元被转换为片段。</p>
<ul>
<li>栅格化：将 3D 空间信息表达在 2D 屏幕的栅格（像素阵列）中。</li>
<li>栅格化过程会线性插值顶点属性值，以便显示的像素能无缝连接建模后的曲面。</li>
<li>比如栅格化一个三角形时，将三角形顶点传入，首先沿着连接顶点的线开始插值，其精度级别和像素显示密度相关。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_rasterized.png" alt="三角形栅格化"></p>
<p>而统一变量在每次顶点着色器调用时保持不变，本身不是插值的，无论顶点数量有多少，变量都包含相同的值。</p>
<p>顶点着色器中，顶点属性被声明为 <code>in</code>，表示从缓冲区接收，也可以被声明为 <code>out</code>，表示值发送到管线的下一阶段。</p>
<p>OpenGL 内置一个 <code>vec4</code> 变量 <code>gl_Position</code>，在顶点着色器中，将矩阵变换后的顶点赋值给它：</p>
<pre><code class="language-cpp">gl_Position = proj_matrix * mv_matrix * position;
</code></pre>
<h3 id="4-4-mv-矩阵和透视矩阵">4.4 MV 矩阵和透视矩阵</h3>
<p>渲染 3D 对象的一个基础步骤是创建适当的变换矩阵并将它们发送到统一变量。</p>
<ul>
<li>模型矩阵：在世界空间中表示对象的位置和朝向。</li>
<li>视图矩阵：移动并旋转世界中的模型，以模拟相机看到的效果。</li>
<li>透视矩阵：根据所需的视锥提供 3D 效果。</li>
</ul>
<p>假设模型是变动的，相机是可移动的，那么：</p>
<ul>
<li>需要每帧为每个模型创建模型矩阵；</li>
<li>需要每帧创建视图矩阵，对于这一帧所渲染的所有对象都是一致的；</li>
<li>需要创建一次透视矩阵，确定视锥。</li>
</ul>
<h3 id="4-5-构建一个-3d-立方体">4.5 构建一个 3D 立方体</h3>
<p>由于 OpenGL 代码繁多，需要处理多文件，给出文件结构：</p>
<pre><code>OpenGL项目
├─ main.cpp        // 主程序
├─ fragment.glsl   // 片段着色器
├─ vertex.glsl     // 顶点着色器
├─ Util.h          // 常用函数的声明
└─ Util.cpp        // 常用函数的实现
</code></pre>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_greenCube.jpg" alt="绿色的立方体"></p>
<details><summary>源代码main.cpp</summary>
<pre><code class="language-cpp">// main.cpp

#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 1;
GLuint vao[numVAO], vbo[numVBO];

double cameraX, cameraY, cameraZ;
double cubeLocX, cubeLocY, cubeLocZ;
float aspect;

GLuint mvLoc, projLoc;
int width, height;
glm::mat4 pMat, vMat, mMat, mvMat;

void makeVertexArray()
&#123;
    float vertexs[108] = &#123;
        -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
    &#125;;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联

    glGenBuffers(numVBO, vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // 将缓冲区标为活跃（使用）
    // 将包含顶点数据的数组复制进活跃缓冲区
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 8.0f;
    cubeLocX = 0.0f, cubeLocY = -2.0f, cubeLocZ = 0.0f;    // 沿 y 轴下移展示透视
    makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glUseProgram(renderProgram);

    // 获取 MV 矩阵 和投影矩阵的统一变量
    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    // 构建透视矩阵
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 100.0f);
    // 参数为：视角，宽高比，近裁剪面，远裁剪面

    // 构建视图矩阵、模型矩阵和 MV 矩阵
    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ));
    mvMat = vMat * mMat;

    // 将矩阵复制给相应的统一变量
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

    // 将 VBO 关联给顶点着色器中相应的顶点属性
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    // 调整 OpenGL 设置，绘制模型
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, 36);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Cube&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
<p>解释 <code>main.cpp</code>：</p>
<ul>
<li>函数 <code>makeVertexArray()</code>
<ul>
<li>创建顶点数组，使用三角形绘制立方体，每个面需要两个三角形，共需要12个三角形，有36个顶点，合36×3=108个坐标（值）。</li>
<li>立方体定义在自己的坐标系上，中心为(0,0,0)。</li>
<li>建立一个 VAO 和 VBO，并把立方体顶点加载到VBO中。</li>
</ul>
</li>
<li>函数 <code>init()</code>
<ul>
<li>读取着色器代码并构建渲染程序。</li>
<li>将立方体通过函数 <code>makeVertexArray()</code> 加载到 VBO 中。</li>
<li>定义立方体和相机在世界中的位置：(0,0,8)和(0,-2,0)。</li>
</ul>
</li>
<li>函数 <code>display()</code>
<ul>
<li>不断重绘帧。</li>
<li>调用 <code>glClear(GL_DEPTH_BUFFER_BIT)</code> 清除深度缓冲区。</li>
<li>调用 <code>glUseProgram()</code> 启用着色器，在 GPU 上加载 GLSL 代码，但不会运行着色器程序。</li>
<li>获取统一变量位置，构建透视、视图矩阵和模型矩阵，并合成 MV 矩阵。
<ul>
<li>使用 <code>glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));</code> 构建视图矩阵。为了模拟以某种方式移动的相机的表现，需要向相反的方向移动物体本身。</li>
<li>使用 <code>glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ));</code> 构建模型矩阵。</li>
</ul>
</li>
<li>将透视矩阵和 MV 矩阵赋给相应的统一变量。</li>
<li>启用立方体顶点数据的缓冲区，并将其附加到第0个顶点属性。</li>
<li>调用 <code>glDrawArrays()</code> 绘制模型。</li>
</ul>
</li>
</ul>
</details>
<details><summary>Util.h</summary>
<pre><code class="language-cpp">// Util.h

#pragma once

#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;SOIL2/soil2.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

class Util
&#123;
public:
    static std::string readShaderSource(const std::string &amp;path);
    static void printShaderLog(GLuint shader);
    static void printProgramLog(GLuint program);
    static bool checkOpenGLerror();

    static GLuint createShadeProgram(const std::string vpath, const std::string fpath);
&#125;;
</code></pre>
</details>
<details><summary>Util.cpp</summary>
<pre><code class="language-cpp">// Util.cpp

#include &quot;Util.h&quot;

/*
* 从文件中读取 GLSL 代码
* @param path 文件路径
*/
std::string Util::readShaderSource(const std::string &amp;path)
&#123;
    std::string content = &quot;&quot;;
    std::ifstream fileStream(path, std::ios::in);
    std::string line = &quot;&quot;;
    while (!fileStream.eof())
    &#123;
        getline(fileStream, line);
        content.append(line + &quot;\n&quot;);
    &#125;
    fileStream.close();
    return content;
&#125;

/*
* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容
* @param shader 着色器标识
*/
void Util::printShaderLog(GLuint shader)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetShaderInfoLog(shader, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Shader Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 当 GLSL 链接失败时，显示 OpenGL 日志内容
* @param program 着色器程序标识
*/
void Util::printProgramLog(GLuint program)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetProgramInfoLog(program, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Program Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误
*/
bool Util::checkOpenGLerror()
&#123;
    bool err = false;
    int glErr = glGetError();
    while (glErr != GL_NO_ERROR)
    &#123;
        std::cout &lt;&lt; &quot;glError: &quot; &lt;&lt; glErr &lt;&lt; &quot;\n&quot;;
        err = true;
        glErr = glGetError();
    &#125;
    return err;
&#125;

/*
* 创建着色器程序
* @param vpath 顶点着色器路径
* @param fpath 片段着色器路径
*/
GLuint Util::createShadeProgram(const std::string vpath, const std::string fpath)
&#123;
    // 记录错误信息
    GLint vertCompiled, fragCompiled, linked;

    // 顶点着色器
    std::string vs = readShaderSource(vpath);
    // 片段着色器
    std::string fs = readShaderSource(fpath);
    const char *vshaderSource = vs.c_str();
    const char *fshaderSource = fs.c_str();

    // 分别存入 vShader 和 fShader 变量
    GLuint vShader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER);

    // 将 GLSL 代码从字符串载入空着色器对象中
    glShaderSource(vShader, 1, &amp;vshaderSource, NULL);
    glShaderSource(fShader, 1, &amp;fshaderSource, NULL);

    // 编译顶点着色器
    glCompileShader(vShader);
    checkOpenGLerror();
    glGetShaderiv(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);
    if (vertCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;vertex compilation failed\n&quot;;
        printShaderLog(vShader);
    &#125;
    // 编译片段着色器
    glCompileShader(fShader);
    checkOpenGLerror();
    glGetShaderiv(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);
    if (fragCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;fragment compilation failed\n&quot;;
        printShaderLog(fShader);
    &#125;

    GLuint vProgram = glCreateProgram();
    glAttachShader(vProgram, vShader);
    glAttachShader(vProgram, fShader);
    glLinkProgram(vProgram);
    checkOpenGLerror();
    glGetProgramiv(vProgram, GL_LINK_STATUS, &amp;linked);
    if (linked == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;linking failed\n&quot;;
        printProgramLog(vProgram);
    &#125;

    return vProgram; // 返回着色器程序ID
&#125;
</code></pre>
</details>
<details><summary>vertex.glsl 和 fragment.glsl</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 position;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

void main()
&#123;
    gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
&#125;
</code></pre>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

out vec4 color;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

void main()
&#123;
    color = vec4(0, 0.6, 0, 1.0);
&#125;
</code></pre>
<p>关于着色器方面</p>
<ul>
<li>着色器中传入的顶点属性的 <code>position</code> 变量上存在。<code>layout</code> 修饰符，位置指定为“0”，因此 <code>display()</code> 函数可以简单地通过在 <code>glVertexAttribPointer()</code> 函数调用中（第一个参数）和在 <code>glEnableVertexAttribArray()</code> 函数调用中使用 0 来引用此变量。</li>
<li><code>position</code> 顶点属性被声明为 <code>vec3</code> 类型，需要将其转换为 <code>vec4</code> 类型，由 <code>vec4(position,1.0)</code> 完成。</li>
<li>顶点着色器中的乘法将矩阵变换应用于顶点，将其转换为相机空间，接着被放入内置的 OpenGL 输出变量 <code>gl_Position</code> 中，然后继续通过管线，并由光栅着色器进行插值。</li>
<li>插值后的像素位置（称为片段）被发送到片段着色器。
<ul>
<li>片段着色器中也有两个统一变量，但在该着色器中尚未使用。</li>
</ul>
</li>
</ul>
</details>
<details><summary>通过修改着色器，实现彩色立方体</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 position;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

out vec4 changingColor;

void main()
&#123;
    gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
    changingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);
&#125;
</code></pre>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

in vec4 changingColor;

out vec4 color;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

void main()
&#123;
    color = changingColor;
&#125;
</code></pre>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_coloredCube.jpg" alt="彩色立方体"></p>
<p>同样地，也可以让立方体动起来，只需要在刷新的每一帧加上平移变换和旋转变换：</p>
<details><summary>展开代码</summary>
<pre><code class="language-cpp">// ……

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    // 获取 MV 矩阵 和投影矩阵的统一变量
    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    // 构建透视矩阵
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 100.0f);
    // 参数为：视角，宽高比，近裁剪面，远裁剪面

    // 一系列旋转变换矩阵
    glm::mat tMat = glm::translate(glm::mat4(1.0f), glm::vec3(sin(0.35f * currentTime) * 2.0f, cos(0.52f * currentTime) * 2.0f, sin(0.7f * currentTime) * 2.0f));
    glm::mat rMat = glm::rotate(glm::mat4(1.0f), 1.75f * static_cast&lt;float&gt;(currentTime), glm::vec3(0.0f, 1.0f, 0.0f));
    rMat = glm::rotate(rMat, 1.75f * static_cast&lt;float&gt;(currentTime), glm::vec3(1.0f, 0.0f, 0.0f));
    rMat = glm::rotate(rMat, 1.75f * static_cast&lt;float&gt;(currentTime), glm::vec3(0.0f, 0.0f, 1.0f));

    // 构建视图矩阵、模型矩阵和 MV 矩阵
    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    //mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ));
    mMat = rMat * tMat;
    mvMat = vMat * mMat;

    // 将矩阵复制给相应的统一变量
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

    // 将 VBO 关联给顶点着色器中相应的顶点属性
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    // 调整 OpenGL 设置，绘制模型
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, 36);
&#125;

// ……
</code></pre>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_coloredCube1.gif" alt="旋转的立方体"></p>
<h3 id="4-6-渲染一个对象的多个副本">4.6 渲染一个对象的多个副本</h3>
<p>上面实现了一个翻滚的立方体，接着可以考虑实现多个翻滚的立方体。</p>
<p>可以将 <code>display()</code> 函数中用于构建 MV 矩阵并绘制立方体的代码移动到一个执行 24 次的循环中来完成此操作。</p>
<details><summary>展开代码</summary>
<pre><code class="language-cpp">void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 32.0f;
    makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    // 获取 MV 矩阵 和投影矩阵的统一变量
    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    // 视图矩阵
    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));

    // 构建透视矩阵
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 100.0f);
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    // 参数为：视角，宽高比，近裁剪面，远裁剪面

    float tf;
    glm::mat4 tMat, rMat;
    for (int i = 0; i &lt; 24; i ++)
    &#123;
        tf = currentTime + i;
        tMat = glm::translate(glm::mat4(1.0f), glm::vec3(sin(0.35f * tf) * 8.0f, cos(0.52f * tf) * 8.0f, sin(0.7f * tf) * 8.0f));
        rMat = glm::rotate(glm::mat4(1.0f), 1.75f * tf, glm::vec3(0.0f, 1.0f, 0.0f));
        rMat = glm::rotate(rMat, 1.75f * tf, glm::vec3(1.0f, 0.0f, 0.0f));
        rMat = glm::rotate(rMat, 1.75f * tf, glm::vec3(0.0f, 0.0f, 1.0f));
        // 构建模型矩阵和 MV 矩阵
        mMat = rMat * tMat;
        mvMat = vMat * mMat;

        // 将矩阵复制给相应的统一变量
        glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

        // 将 VBO 关联给顶点着色器中相应的顶点属性
        glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
        glEnableVertexAttribArray(0);

        // 调整 OpenGL 设置，绘制模型
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LEQUAL);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    &#125;
&#125;
</code></pre>
</details>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_mcoloredCube.gif" alt="效果展示"></p>
<p>OpenGL 的实例化提供了一种机制，可以只用一个调用就渲染一个对象的多个副本。</p>
<ul>
<li>带来显著的性能优势</li>
</ul>
<p>把原来调用的 <code>glDrawArrays()</code> 改为 <code>glDrawArraysInstanced()</code>。</p>
<p>同时实例化时，顶点着色器可以访问内置变量 <code>gl_InstanceID</code> 来获取当前正在处理对象的实例序号。</p>
<p>实例化的程序：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 1;
GLuint vao[numVAO], vbo[numVBO];

double cameraX, cameraY, cameraZ;
float aspect, timeFactor;

GLuint mLoc, vLoc, projLoc, tfLoc;
int width, height;
glm::mat4 pMat, vMat, mMat;

void makeVertexArray()
&#123;
    float vertexs[108] = &#123;
        -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
    &#125;;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联

    glGenBuffers(numVBO, vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // 将缓冲区标为活跃（使用）
    // 将包含顶点数据的数组复制进活跃缓冲区
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);
&#125;

void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 32.0f;
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
    makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    // 获取视图矩阵和投影矩阵的统一变量
    vLoc = glGetUniformLocation(renderProgram, &quot;v_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    glUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(vMat));
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

    // 获取时间因子的统一变量
    timeFactor = static_cast&lt;float&gt;(currentTime);
    tfLoc = glGetUniformLocation(renderProgram, &quot;tf&quot;);
    glUniform1f(tfLoc, timeFactor);

    // 将 VBO 关联给顶点着色器中相应的顶点属性
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    // 实例化
    glDrawArraysInstanced(GL_TRIANGLES, 0, 36, 24);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Cube&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
<p>从之前的循环多个模型矩阵展示 改为了 在顶点着色器中构建模型矩阵。</p>
<ul>
<li>将时间因子通过统一变量传递给顶点着色器，还需要将视图矩阵传递到单独的统一变量中</li>
<li>旋转计算被移动到了顶点着色器中</li>
</ul>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 position;

uniform mat4 v_matrix;
uniform mat4 proj_matrix;
uniform float tf;

out vec4 changingColor;

mat4 buildRotateX(float rad)
&#123;
    mat4 xrot = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, cos(rad), -sin(rad), 0.0,
        0.0, sin(rad), cos(rad), 0.0,
        0.0, 0.0, 0.0, 1.0);
    return xrot;
&#125;

mat4 buildRotateY(float rad)
&#123;
    mat4 yrot = mat4(
        cos(rad), 0.0, sin(rad), 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sin(rad), 0.0, cos(rad), 0.0,
        0.0, 0.0, 0.0, 1.0);
    return yrot;
&#125;

mat4 buildRotateZ(float rad)
&#123;
    mat4 zrot = mat4(
        cos(rad), -sin(rad), 0.0, 0.0,
        sin(rad), cos(rad), 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0);
    return zrot;
&#125;

mat4 buildTranslate(float x, float y, float z)
&#123;
    mat4 trans = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        x, y, z, 1.0);
    return trans;
&#125;

void main()
&#123;
    float i = gl_InstanceID + tf;

    float a = sin(0.35 * i) * 8.0;
    float b = cos(0.52 * i) * 8.0;
    float c = sin(0.70 * i) * 8.0;

    mat4 localRotx = buildRotateX(1.75 * i);
    mat4 localRoty = buildRotateY(1.75 * i);
    mat4 localRotz = buildRotateZ(1.75 * i);
    mat4 localTrans = buildTranslate(a, b, c);

    mat4 newM_matrix = localTrans * localRotx * localRoty * localRotz;
    mat4 mv_matrix = v_matrix * newM_matrix;

    gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
    changingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);
&#125;
</code></pre>
<p>由于着色器内部无法调用 GLM 的函数，故需要编写矩阵变换的相关函数。</p>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

in vec4 changingColor;

out vec4 color;

uniform mat4 proj_matrix;

void main()
&#123;
    color = changingColor;
&#125;
</code></pre>
<p>片段着色器无需做改变。</p>
</details>
<p>如果渲染的立方体很多时，实例化极大的方便了程序的编写，只需要修改视野相关的常量：</p>
<p>比如想渲染 100000 个彩色立方体，只需修改：</p>
<pre><code class="language-cpp">// main.cpp
// 实例化个数
glDrawArraysInstanced(GL_TRIANGLES, 0, 36, 100000);
</code></pre>
<pre><code class="language-cpp">// main.cpp
// 镜头位置，镜头拉远
cameraX = 0.0f, cameraY = 0.0f, cameraZ = 402.0f;
</code></pre>
<pre><code class="language-cpp">// vertex.glsl
// 位移变大
float a = sin(203.0 * i / 8000.0) * 403.0;
float b = cos(301.0 * i / 4001.0) * 401.0;
float c = sin(400.0 * i / 6003.0) * 405.0;
</code></pre>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_100kcubes.jpg" alt="效果截图(静态图)"></p>
<h3 id="4-7-同一场景渲染多个对象">4.7 同一场景渲染多个对象</h3>
<p>要在单个场景中渲染多个模型，简单的做法：</p>
<ol>
<li>为每个模型使用单独的缓冲区；</li>
<li>每个模型都需要自己的模型矩阵，为渲染的每个模型生成一个新的 MV 矩阵；</li>
<li>为每个模型单独调用 <code>glDrawArrays()</code>。</li>
</ol>
<p>假如在场景中渲染立方体和四棱锥，且不考虑复杂的情况，复用着色器，效果如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_2objects.gif" alt="渲染立方体和四棱锥"></p>
<p>代码如下（自主研究，不过多解释）：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 2;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
float cubeLocx, cubeLocy, cubeLocz;
float pyramidLocx, pyramidLocy, pyramidLocz;

GLuint mvLoc, projLoc;

glm::mat4 pMat, vMat, mMat, mvMat;

void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
    float vertexs[108] = &#123;
        -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
    &#125;;

    float pyramids[54] = &#123;
        -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  0.0f,  1.0f, 0.0f,
         1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  0.0f,  1.0f, 0.0f,
         1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  0.0f,  1.0f, 0.0f,
        -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  0.0f,  1.0f, 0.0f,
        -1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f, -1.0f, -1.0f, 1.0f,
         1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f
    &#125;;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联

    glGenBuffers(numVBO, vbo);
    // 立方体与缓冲区0绑定
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);
    // 四棱锥与缓冲区1绑定
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(pyramids), pyramids, GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 8.0f;
    cubeLocx = 0.0f, cubeLocy = -2.0f, cubeLocz = 0.0f;
    pyramidLocx = 0.0f, pyramidLocy = 1.0f, pyramidLocz = 0.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    // 获取视图矩阵和投影矩阵的统一变量
    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));

    // 绘画立方体
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocx, cubeLocy, cubeLocz));
    mMat *= glm::rotate(glm::mat4(1.0f), static_cast&lt;float&gt;(currentTime), glm::vec3(0.25f, 1.0f, 0.0f));
    mvMat = vMat * mMat;
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);
    glEnable(GL_DEPTH_TEST);
    glDrawArrays(GL_TRIANGLES, 0, 36);

    // 绘画四棱锥
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(pyramidLocx, pyramidLocy, pyramidLocz));
    mMat *= glm::rotate(glm::mat4(1.0f), static_cast&lt;float&gt;(currentTime), glm::vec3(0.25f, 1.0f, 0.0f));
    mvMat = vMat * mMat;
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);
    glEnable(GL_DEPTH_TEST);
    glDrawArrays(GL_TRIANGLES, 0, 18);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Cube&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-cpp">// 顶点着色器
#version 460 core

layout(location = 0) in vec3 position;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

out vec4 changingColor;

void main()
&#123;
    gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
    changingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);
&#125;
</code></pre>
<pre><code class="language-cpp">// 片段着色器
#version 460 core

in vec4 changingColor;

out vec4 color;

uniform mat4 proj_matrix;

void main()
&#123;
    color = changingColor;
&#125;
</code></pre>
</details>
<h3 id="4-8-矩阵栈">4.8 矩阵栈</h3>
<p>前面渲染的模型都是由一组顶点构成，而实际上希望通过组装许多简单地模型来构建复杂的模型。以这种方式构建的对象称为分层模型。</p>
<ul>
<li>构建分层模型的棘手部分是跟踪所有 MV 矩阵并保证矩阵完美协调。</li>
</ul>
<p>矩阵栈：变换矩阵的栈。</p>
<ul>
<li>使得创建和管理复杂分层对象和场景变得容易</li>
<li>使得变换可以构建在其他变换之上</li>
<li>通过 STL 的 <code>stack</code> 类构建 <code>mat4</code> 的栈。</li>
</ul>
<p>对于 <code>std::stack&lt;glm::mat4&gt;</code> 的实例 <code>s</code>：</p>
<ul>
<li><code>s.push(mat4)</code>：将栈顶的矩阵复制一份，并作变换后把新的矩阵压入栈。</li>
<li><code>s.pop()</code>：弹出栈顶的矩阵。</li>
<li><code>s.top()</code>：返回栈顶的矩阵的引用。</li>
<li><code>s.top() *= rotate(args)</code>：直接对栈顶矩阵作旋转变换。</li>
<li><code>s.top() *= translate(args)</code>：直接对栈顶矩阵作平移变换。</li>
<li><code>s.top() *= scale(args)</code>：直接对栈顶矩阵作缩放变换。</li>
</ul>
<p>在此之后，不再通过创建 <code>mat4</code> 的实例来构建变换，而是使用 <code>push()</code> 命令在栈顶部创建新的矩阵，然后根据需要将期望的变换应用于栈顶部的新创建的矩阵。</p>
<ul>
<li>压入栈的第一个矩阵通常是视图矩阵。它上面的矩阵是复杂程度越来越高的 MV 矩阵，也就是说，它们应用了越来越多的模型变换。这些变换既可以直接应用，也可以先结合其他矩阵再应用。</li>
</ul>
<p>假设一个例子，实现一个地球围绕太阳旋转和月球围绕地球旋转的场景：</p>
<ol>
<li>首先压入视图矩阵 V；</li>
<li>压入太阳的 MV 矩阵；</li>
<li>压入地球的 MV 矩阵，由太阳的 MV 矩阵的副本和应用于其之上的地球模型矩阵变换组成；</li>
<li>压入月球的 MV 矩阵，由地球的 MV 矩阵的副本和应用于其之上的月球模型矩阵变换组成。</li>
</ol>
<p>接着，渲染月球并把月球矩阵弹出，后面的地球和太阳只需要重复即可。步骤如下：</p>
<ol>
<li>声明矩阵栈；</li>
<li>当相对于父对象创建新对象时，调用 <code>s.push(s.top())</code>；</li>
<li>应用新对象所需的变换；</li>
<li>完成对象或子对象的绘制后，弹出栈顶，移除对应的 MV 矩阵。</li>
</ol>
<p>在这个例子中，需要注意：</p>
<ul>
<li>太阳的自转在它自己的局部坐标空间中进行，不应影响地球和月球。因此，太阳的旋转变换矩阵被推到栈上，但是在绘制太阳之后，它必须被从栈中弹出。</li>
<li>地球的公转将影响月球的运动，因此地球的平移变换矩阵被压入栈并保持到绘制月球。</li>
<li>地球的自转是局部的，不会影响月球，因此在绘制月球之前地球的旋转变换矩阵需要从栈中弹出。</li>
</ul>
<p>效果如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_sunearthmoon.gif" alt="太阳-地球-月球场景"></p>
<p>顶点着色器与片段着色器无需改变，同上面渲染两个目标的程序。</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;

GLuint renderProgram;

const int numVAO = 1, numVBO = 2;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;

GLuint mvLoc, projLoc;

glm::mat4 pMat, vMat, mMat, mvMat;

std::stack&lt;glm::mat4&gt; matrixStack;

void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
    float vertexs[108] = &#123;
        -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
         1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
    &#125;;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联

    glGenBuffers(numVBO, vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 4.0f, cameraZ = 20.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    matrixStack.push(vMat);

    // 绘制太阳
    matrixStack.push(matrixStack.top());
    matrixStack.top() *= glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f)); // 太阳位置
    matrixStack.push(matrixStack.top());
    matrixStack.top() *= glm::rotate(glm::mat4(1.0f), static_cast&lt;float&gt;(currentTime), glm::vec3(1.0f, 0.0f, 0.0f)); // 太阳自转
    matrixStack.top() *= glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(matrixStack.top()));
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    matrixStack.pop();

    // 绘制地球
    matrixStack.push(matrixStack.top());
    matrixStack.top() *= glm::translate(glm::mat4(1.0f), glm::vec3(sin(static_cast&lt;float&gt;(currentTime)) * 8.0, 0.0, cos(static_cast&lt;float&gt;(currentTime)) * 8.0)); // 平移矩阵变换
    matrixStack.push(matrixStack.top());
    matrixStack.top() *= glm::rotate(glm::mat4(1.0f), static_cast&lt;float&gt;(currentTime) * 2.0f, glm::vec3(0.0f, 2.0f, 0.0f)); // 旋转矩阵变换
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(matrixStack.top()));
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    matrixStack.pop();

    // 绘制月球
    matrixStack.push(matrixStack.top());
    matrixStack.top() *= glm::translate(glm::mat4(1.0f), glm::vec3(0.0, sin(static_cast&lt;float&gt;(currentTime)) * 2.0, cos(static_cast&lt;float&gt;(currentTime)) * 2.0)); // 平移矩阵变换
    matrixStack.top() *= glm::rotate(glm::mat4(1.0f), static_cast&lt;float&gt;(currentTime), glm::vec3(0.0f, 0.0f, 1.0f)); // 旋转矩阵变换
    matrixStack.top() *= glm::scale(glm::mat4(1.0f), glm::vec3(0.25f, 0.25f, 0.25f));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(matrixStack.top()));
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    matrixStack.pop(); matrixStack.pop(); matrixStack.pop();
    matrixStack.pop();
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;sun-earth-moon&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
<p>注意的点：</p>
<ul>
<li>加入缩放矩阵调节各个模型的大小</li>
<li>使用三角函数实现自转和公转</li>
<li>在 <code>glUniformMatrix4fv()</code> 命令中调用的  <code>glm::value_ptr(mvStack.top())</code> 函数，获取栈顶部矩阵中的值</li>
</ul>
</details>
<h3 id="4-9-应对-z冲突-伪影">4.9 应对“Z冲突”伪影</h3>
<p>在渲染多个对象时，OpenGL 使用 Z-buffer 算法来进行隐藏面消除。通常情况下，通过选择最接近相机的相应片段的颜色作为像素的颜色，这种方法可决定哪些物体的曲面可见并呈现到屏幕，而位于其他物体后面的曲面不应该被渲染。</p>
<p><em>Z-buffer 算法思想：先将 Z 缓冲器中各单元的初始置设置为最小值。当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值（保存在该像素所对应的Z 缓冲器的单元中）。如果大于原来的 Z 值，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色。</em></p>
<p>然而，有时候场景中的两个物体表面重叠并位于重合的平面中，这使得深度缓冲区算法难以确定应该渲染两个表面中的哪一个。</p>
<p>发生这种情况时，浮点舍入误差可能会导致渲染表面的某些部分使用其中一个对象的颜色，而其他部分则使用另一个对象的颜色。这种不自然的伪影称为 Z 冲突（Z-fighting）或深度冲突（depth-fighting）。</p>
<ul>
<li>是渲染的片段在深度缓冲区中相互对应的像素条目上“斗争”的结果。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_zfighting.jpg" alt="Z冲突例子，图源计算机图形学编程（第2版）"></p>
<p>部分应对方法：</p>
<ul>
<li>可以选择适当的近、远剪裁平面值来最小化两个平面之间的距离，同时仍然确保场景必需的所有对象都位于视锥内</li>
<li>建议避免选择太靠近相机的近剪裁平面</li>
</ul>
<h3 id="4-10-其他图元">4.10 其他图元</h3>
<p>目前一直使用三角形进行绘制，其实 OpenGL 还有其他选择。</p>
<h4 id="4-10-1-三角形图元">4.10.1 三角形图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_TRIANGLES</code></td>
<td style="text-align:center">管线中传递的每3个顶点数据组成一个三角形</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gltriangle.jpg"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLE_STRIP</code></td>
<td style="text-align:center">管线中传递的每个顶点和之前的两个顶点组成一个三角形</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gltrianglestrip.png"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLE_FAN</code></td>
<td style="text-align:center">管线中传递的每对顶点和最开始的顶点组成一个三角形</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gltrianglefan.png"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLES_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，允许着色器访问当前三角形的顶点，以及额外的相邻顶点</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLE_STRIP_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，类似于 <code>GL_TRIANGLES_ADJACENCY</code>，但三角形顶点像在 <code>GL_TRIANGLE_STRIP</code> 中一样重叠</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="4-10-2-线图元">4.10.2 线图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_LINES</code></td>
<td style="text-align:center">管线中传递的每两个顶点组成一条线</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_glline.png"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_STRIP</code></td>
<td style="text-align:center">管线中每个顶点和前一个顶点组成一条线</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gllinestrip.png"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_LOOP</code></td>
<td style="text-align:center">类似于 <code>GL_LINE_STRIP</code>，但最后的顶点和第一个顶点之间会形成一条线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，允许着色器访问当前线的顶点，以及额外的相邻顶点</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_STRIP_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，类似于 <code>GL_LINE_ADJACENCY</code>，但线顶点像在 <code>GL_LINE_STRIP</code> 中一样重叠</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="4-10-3-点图元">4.10.3 点图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_POINTS</code></td>
<td style="text-align:center">管线中传递的每个顶点组成一个点</td>
</tr>
</tbody>
</table>
<h4 id="补丁图元">补丁图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_PATCHES</code></td>
<td style="text-align:center">仅用于细分着色器，指示一组顶点从顶点着色器传递到细分控制着色器，在这里它们通常用于将曲面细分网格塑造成曲面</td>
</tr>
</tbody>
</table>
<h3 id="4-11-性能优先编程">4.11 性能优先编程</h3>
<p>随着 3D 场景逐渐复杂，性能方面不得不关心。</p>
<ol>
<li>尽量减少动态内存空间分配
<ul>
<li>关键部分 <code>display()</code> 函数会被重复调用
<ul>
<li>避免重复实例化对象</li>
<li>避免重复声明变量</li>
</ul>
</li>
<li>C++ 栈类，每次入栈可能会导致动态内存分配</li>
<li>将数据从一种类型转换为另一种类型的函数调用在某些情况下可能会实例化并返回新转换的数据</li>
<li>GLM 库函数优化有限，可能引起动态内存分配</li>
</ul>
</li>
<li>预先计算透视矩阵
<ul>
<li>将透视矩阵的计算移动到 <code>init()</code> 函数中</li>
<li>一般情况下不需要重新计算透视矩阵，但窗口大小变化时需要重新计算，可以将计算透视矩阵添加到回调函数中。</li>
</ul>
</li>
<li>背面剔除
<ul>
<li>利用 OpenGL 的背面剔除能力：当 3D 模型完全闭合时，其内部永远不可见时，那么这些部分不需要被栅格化或渲染。</li>
<li>默认背面剔除时关闭的</li>
<li>使用函数 <code>glEnable(GL_CULL_FACE)</code> 开启</li>
<li>启用背面剔除时，默认情况下，三角形只有朝前时才会被渲染。此外，默认情况下，从 OpenGL相机的角度看，如果三角形的 3 个顶点是以逆时针顺序排列的（基于它们在缓冲区中定义的顺序），则三角形被视为朝前；顶点沿顺时针方向排列的三角形是朝后的，不会被渲染
<ul>
<li><strong>定义“前向”的顶点顺序有时被称为缠绕顺序</strong></li>
<li>使用 <code>glFrontFace(GL_CW)</code> 设置顺时针为正向，使用 <code>glFrontFace(GL_CCW)</code> 设置逆时针为正向</li>
<li>默认下，<code>glCullFace(GL_BACK)</code> 设置背向的三角形被剔除，但参数还有 <code>GL_FRONT</code> 和 <code>GL_FRONT_AND_BACK</code>，分别设置前向或全部三角形被剔除</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="五-纹理贴图">五、纹理贴图</h2>
<p>纹理贴图是在栅格化的模型表面上覆盖图像的技术。</p>
<p>纹理图像可以是任何图像。</p>
<h3 id="5-1-加载纹理图像文件">5.1 加载纹理图像文件</h3>
<p>OpenGL/GLSL 中完成纹理贴图需要协调不同的数据集和机制：</p>
<ul>
<li>保存纹理图像的纹理对象</li>
<li>特殊的统一采样器变量，用于顶点着色器访问纹理</li>
<li>保存纹理坐标的缓冲区</li>
<li>将纹理坐标传递给管线的顶点属性</li>
<li>显卡上的纹理单元</li>
</ul>
<p>此处将用 SOIL2 库进行加载图像文件用于贴图：</p>
<ol>
<li>使用 SOIL2 实例化 OpenGL 纹理对象并从图像文件中读入数据；</li>
<li>调用 <code>glBindTexture()</code> 使得新创建的纹理对象处于激活状态；</li>
<li>使用 <code>glTexParameteri()</code> 调整纹理设置；</li>
</ol>
<ul>
<li>最终得到的结果是可用的 OpenGL 纹理对象的整型 ID。</li>
</ul>
<p>加载纹理的代码（加入在 Util 类中）如下：</p>
<pre><code class="language-cpp">GLuint Util::loadTexture(const std::string &amp;imgPath)
&#123;
    GLuint textureID;
    textureID = SOIL_load_OGL_texture(imgPath.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    if (textureID == 0)
        std::cout &lt;&lt; &quot;Failed to load texture: &quot; &lt;&lt; imgPath &lt;&lt; &quot;\n&quot;;
    return textureID;
&#125;
</code></pre>
<p>代码先声明了一个 <code>GLuint</code> 类型的变量用于记录 OpenGL 纹理对象的 ID，接着调用 <code>SOIL_load_OGL_texture()</code> 函数生成纹理对象。</p>
<ul>
<li>函数参数及返回值
<ul>
<li>第一个参数为文件名；</li>
<li>第二个说明符，<code>SOIL_LOAD_AUTO</code> 表示使用磁盘载入的；</li>
<li>第三个表示让SOIL为我们创建一个ID；</li>
<li>第四个参数 <code>SOIL_FLAG_INVERT_Y</code> 允许做是翻转Y轴</li>
<li>返回值，0表示失败，其他表示 OpenGL 上下文句柄</li>
</ul>
</li>
</ul>
<h3 id="5-2-纹理坐标">5.2 纹理坐标</h3>
<p>通过为模型中的每个顶点指定纹理坐标来完成纹理贴图。</p>
<p>纹理坐标是对纹理图像（2D 图像文件）中像素的引用，用于将 3D 模型上的点映射到纹理中的位置。</p>
<ul>
<li>模型除了 3D 空间中的定位坐标 (x, y, z) 外，表面上每个点还具有纹理坐标 (s, t)，用来指定纹理图像中哪个像素为它提供颜色。</li>
</ul>
<p><strong>必须为要添加纹理的对象中每个顶点提供纹理坐标。</strong></p>
<p>设置两个缓冲区，一个用于顶点坐标，另一个用于纹理坐标。每次调用顶点着色器会接收到两组坐标。</p>
<p>2D 纹理图像被设定为矩形，左下角坐标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，右上角坐标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，故纹理坐标取值区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</p>
<p>由于之前渲染的立方体模型都是由三角形构成，每个面需要两个三角形。</p>
<p><em>对于立方体或四棱锥这样的简单模型，选择纹理坐标相对容易。但对于具有大量三角形的更复杂的弯曲模型，手动确定它们是不切实际的。在弯曲的几何形状（例如球形或环面）的情况下，可以通过算法或数学方式计算纹理坐标。使用 Maya 或 Blender 等建模工具构建模型时，可以使用“UV 映射”功能，使得确定纹理坐标的任务更容易完成</em></p>
<h3 id="5-3-构建一个带纹理的四棱锥">5.3 构建一个带纹理的四棱锥</h3>
<ol>
<li>首先创建纹理对象：</li>
</ol>
<pre><code class="language-cpp">GLuint textureID = Util::loadTexture(&quot;texture.jpg&quot;);
</code></pre>
<ol start="2">
<li>接着构建纹理坐标：
<ul>
<li>四棱锥具有五个面，由6个三角形组成，每个三角形有3个顶点，共18个顶点</li>
<li>使图像的顶部中心对应四棱锥的顶（简单地贴上去）。</li>
</ul>
</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_texture.jpg" alt="纹理贴图"></p>
<pre><code class="language-cpp">float textures[36] = &#123;
    0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
    0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
    0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
    0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f
&#125;;
</code></pre>
<ol start="3">
<li>然后将纹理载入缓冲区：载入缓冲区1。</li>
</ol>
<pre><code class="language-cpp">glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
glBufferData(GL_ARRAY_BUFFER, sizeof(textures), textures, GL_STATIC_DRAW);
</code></pre>
<ol start="4">
<li>在着色器中使用纹理：采样器变量和纹理单元。为了提高性能，在硬件中执行纹理处理。则需要通过统一采样器变量实现。
<ul>
<li>统一采样器变量：指示显卡上的纹理单元，从加载的纹理对象中提取或采样纹理图像中的像素。</li>
</ul>
</li>
</ol>
<pre><code class="language-cpp">layout(binding = 0) uniform sampler2D samp;
</code></pre>
<ul>
<li>
<p><code>layout(binding = 0)</code> 表示采样器变量 <code>samp</code> 的绑定第0个纹理单元。</p>
</li>
<li>
<p>可用纹理单元的数量取决于显卡提供的数量。</p>
</li>
</ul>
<ol start="5">
<li>
<p>在 <code>display()</code> 函数中，调用 <code>glActiveTexture()</code> 函数激活纹理单元并调用 <code>glBindTexture()</code> 函数将纹理单元绑定到特定的纹理对象。</p>
<ul>
<li>代码中使用 <code>GL_TEXTURE0</code> 让第0个纹理单元处于激活状态。</li>
</ul>
</li>
<li>
<p>片段着色器中使用顶点着色器接收的插值纹理坐标来对纹理对象进行采样：</p>
</li>
</ol>
<pre><code class="language-cpp">in vec2 tc;
……
color = texture(samp, tc);
</code></pre>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_pyramidwithtexture.jpg" alt="带纹理的四棱锥"></p>
<p>完整代码：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;

GLuint renderProgram;

const int numVAO = 1, numVBO = 2;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint textureID[2];
GLuint mvLoc, projLoc;

glm::mat4 pMat, vMat, mMat, mvMat;

std::stack&lt;glm::mat4&gt; matrixStack;

void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
    float pyramidVertexs[54] = &#123;
        -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  0.0f,  1.0f,  0.0f,
         1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  0.0f,  1.0f,  0.0f,
         1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  0.0f,  1.0f,  0.0f,
        -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  0.0f,  1.0f,  0.0f,
        -1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,
         1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f
    &#125;;

    float textures[36] = &#123;
        0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
        0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
        0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
        0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f,
        0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,
        1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f
    &#125;;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]);

    glGenBuffers(numVBO, vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(pyramidVertexs), pyramidVertexs, GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(textures), textures, GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 1.5f, cameraY = 0.0f, cameraZ = 5.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
    textureID[0] = Util::loadTexture(&quot;brick1.jpg&quot;);
    textureID[1] = Util::loadTexture(&quot;ice.jpg&quot;);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    for (int i = 0; i &lt; 2; i ++)
    &#123;
        vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
        mMat = glm::translate(glm::mat4(1.0f), glm::vec3(i * 3.0f, 0.0f, 0.0f));
        // 旋转展示各个面
        mMat = glm::rotate(mMat, -0.45f, glm::vec3(1.0f, 0.0f, 0.0f));
        mMat = glm::rotate(mMat, 0.61f, glm::vec3(0.0f, 1.0f, 0.0f));
        mMat = glm::rotate(mMat, 0.00f, glm::vec3(0.0f, 0.0f, 1.0f));

        mvMat = vMat * mMat;

        glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
        glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

        glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
        glEnableVertexAttribArray(0);

        glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
        glEnableVertexAttribArray(1);

        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, textureID[i]);

        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LEQUAL);
        glDrawArrays(GL_TRIANGLES, 0, 18);
    &#125;
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Pyramid with texture&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<details><summary>Util.h</summary>
<pre><code class="language-cpp">#pragma once

#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;SOIL2/soil2.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

class Util
&#123;
public:
    static std::string readShaderSource(const std::string &amp;path);
    static void printShaderLog(GLuint shader);
    static void printProgramLog(GLuint program);
    static bool checkOpenGLerror();

    static GLuint createShadeProgram(const std::string vpath, const std::string fpath);
    static GLuint loadTexture(const std::string &amp;imgPath);
&#125;;
</code></pre>
</details>
<details><summary>Util.cpp</summary>
<pre><code class="language-cpp">#include &quot;Util.h&quot;

/*
* 从文件中读取 GLSL 代码
* @param path 文件路径
*/
std::string Util::readShaderSource(const std::string &amp;path)
&#123;
    std::string content = &quot;&quot;;
    std::ifstream fileStream(path, std::ios::in);
    std::string line = &quot;&quot;;
    while (!fileStream.eof())
    &#123;
        getline(fileStream, line);
        content.append(line + &quot;\n&quot;);
    &#125;
    fileStream.close();
    return content;
&#125;

/*
* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容
* @param shader 着色器标识
*/
void Util::printShaderLog(GLuint shader)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetShaderInfoLog(shader, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Shader Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 当 GLSL 链接失败时，显示 OpenGL 日志内容
* @param program 着色器程序标识
*/
void Util::printProgramLog(GLuint program)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetProgramInfoLog(program, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Program Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误
*/
bool Util::checkOpenGLerror()
&#123;
    bool err = false;
    int glErr = glGetError();
    while (glErr != GL_NO_ERROR)
    &#123;
        std::cout &lt;&lt; &quot;glError: &quot; &lt;&lt; glErr &lt;&lt; &quot;\n&quot;;
        err = true;
        glErr = glGetError();
    &#125;
    return err;
&#125;

/*
* 创建着色器程序
* @param vpath 顶点着色器路径
* @param fpath 片段着色器路径
*/
GLuint Util::createShadeProgram(const std::string vpath, const std::string fpath)
&#123;
    // 记录错误信息
    GLint vertCompiled, fragCompiled, linked;

    // 顶点着色器
    std::string vs = readShaderSource(vpath);
    // 片段着色器
    std::string fs = readShaderSource(fpath);
    const char *vshaderSource = vs.c_str();
    const char *fshaderSource = fs.c_str();

    // 分别存入 vShader 和 fShader 变量
    GLuint vShader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER);

    // 将 GLSL 代码从字符串载入空着色器对象中
    glShaderSource(vShader, 1, &amp;vshaderSource, NULL);
    glShaderSource(fShader, 1, &amp;fshaderSource, NULL);

    // 编译顶点着色器
    glCompileShader(vShader);
    checkOpenGLerror();
    glGetShaderiv(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);
    if (vertCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;vertex compilation failed\n&quot;;
        printShaderLog(vShader);
    &#125;
    // 编译片段着色器
    glCompileShader(fShader);
    checkOpenGLerror();
    glGetShaderiv(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);
    if (fragCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;fragment compilation failed\n&quot;;
        printShaderLog(fShader);
    &#125;

    GLuint vProgram = glCreateProgram();
    glAttachShader(vProgram, vShader);
    glAttachShader(vProgram, fShader);
    glLinkProgram(vProgram);
    checkOpenGLerror();
    glGetProgramiv(vProgram, GL_LINK_STATUS, &amp;linked);
    if (linked == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;linking failed\n&quot;;
        printProgramLog(vProgram);
    &#125;

    return vProgram; // 返回着色器程序ID
&#125;

/*
* 从文件中读取纹理图像并返回纹理 ID
* @param imgPath 图像文件路径
*/
GLuint Util::loadTexture(const std::string &amp;imgPath)
&#123;
    GLuint textureID;
    textureID = SOIL_load_OGL_texture(imgPath.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    if (textureID == 0)
        std::cout &lt;&lt; &quot;Failed to load texture: &quot; &lt;&lt; imgPath &lt;&lt; &quot;\n&quot;;
    return textureID;
&#125;
</code></pre>
</details>
<details><summary>vertex.glsl</summary>
<pre><code class="language-cpp">#version 460 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec2 texCoord;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
layout(binding = 0) uniform sampler2D samp;

out vec2 tc;

void main()
&#123;
    gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
    tc = texCoord;
&#125;
</code></pre>
</details>
<details><summary>fragment.glsl</summary>
<pre><code class="language-cpp">#version 460 core

in vec2 tc;
out vec4 color;

layout(binding = 0) uniform sampler2D samp;

void main()
&#123;
    color = texture(samp, tc);
&#125;
</code></pre>
</details>
<h3 id="5-4-多级渐远纹理贴图">5.4 多级渐远纹理贴图</h3>
<p>纹理贴图经常会在渲染图像中导致各种不利的伪影。</p>
<ul>
<li>这是因为纹理图像的分辨率或长宽比很少与被纹理贴图的场景中区域的分辨率或长宽比匹配。</li>
</ul>
<ol>
<li>
<p>当图像分辨率小于所绘制区域的分辨率时，会出现一种很常见的伪影。在这种情况下，需要拉伸图像以覆盖整个区域，这样图像就会变得模糊（并且可能变形）。</p>
<ul>
<li>根据纹理的性质，有时可以通过改变纹理坐标分配方式来应对这种情况，使得纹理需要较少的拉伸。</li>
<li>另一种解决方案是使用更高分辨率的纹理图像。</li>
</ul>
</li>
<li>
<p>相反的情况是图像纹理的分辨率大于被绘制区域的分辨率。</p>
<ul>
<li>在这种情况下，可能会出现明显的叠影，从而产生奇怪的错误图案，或移动物体中的“闪烁”效果。</li>
<li>叠影是由采样错误引起的。</li>
</ul>
</li>
</ol>
<p>使用多级渐远纹理贴图可以很大程度上矫正采样误差伪影。</p>
<ul>
<li>使用各种分辨率创建纹理图像的不同版本。</li>
<li>被贴图的区域使用最适合的分辨率的纹理图像。</li>
</ul>
<p>多级渐远纹理贴图的机制：</p>
<ul>
<li>它在纹理图像中存储相同图像的连续的一系列较低分辨率的副本。</li>
<li>所用的纹理图像比原始图像大 1/3，其中图像的 RGB 值分别存储在纹理图像空间的 3 个 1/4 区域中来实现的。</li>
<li>剩余的 1/4 区域中迭代地将图像分辨率设置为原来的 1/4，直到剩余区域太小而不包含任何有用的图像数据。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_Multileveltexture.jpg" alt="多级渐远纹理贴图示例，图源计算机图形学编程（第二版）"></p>
<p>使用代码进行构建多级渐远纹理：</p>
<pre><code class="language-cpp">// ……
glBindTexture(GL_TEXTURE_2D, textureID);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glGenerateMipmap(GL_TEXTURE_2D);
// ……
</code></pre>
<p>对于函数 <code>glTexparameteri()</code> 其第三个参数设置为所需的缩小方法来选择多级渐远纹理的采样方法，方法如下：</p>
<ul>
<li><code>GL_NEAREST_MIPMAP_NEAREST</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的多级渐远纹理，获取所需纹理坐标的最近的纹理图像像素。</li>
<li><code>GL_LINEAR_MIPMAP_NEAREST</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的多级渐远纹理，获取最接近纹理坐标的4个纹理图像像素的插值。</li>
<li><code>GL_NEAREST_MIPMAP_LINEAR</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的2个多级渐远纹理，从每个多级渐远纹理获取纹理坐标的最近的纹理图像像素进行插值。</li>
<li><code>GL_LINEAR_MIPMAP_LINEAR</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的2多个渐远纹理，从每多个渐远纹理获取最接近纹理坐标的4个纹理图像像素进行插值，又称为“三线性过滤”。</li>
</ul>
<p>通常选择三线性过滤。</p>
<p><em>对于特殊的应用场景，可以使用任何图像编辑软件自行构建多级渐远纹理，然后通过为每个多级渐远纹理级别重复调用 OpenGL 的 <code>glTexImage2D()</code> 函数来创建纹理对象，并将它们添加为多级渐远纹理级别</em></p>
<h3 id="5-5-各向异性过滤">5.5 各向异性过滤</h3>
<p>多级渐远纹理贴图有时看起来比非多级渐远纹理贴图更模糊。</p>
<ul>
<li>这种细节的丢失是因为当物体倾斜时，其图元看起来在一个轴（即沿宽或高）上的尺寸比在另一个轴上更小。</li>
<li>当 OpenGL 为图元贴图时，它选择适合两个轴中尺寸较小的轴的多级渐远纹理）。</li>
</ul>
<p>可以通过各向异性过滤恢复一些丢失的细节。</p>
<ul>
<li>各向异性过滤比标准多级渐远纹理贴图的计算代价更高，并且不是 OpenGL 的必需部分。</li>
</ul>
<p>只需添加以下代码：</p>
<pre><code class="language-cpp">if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;))
&#123;
    GLfloat anisoSetting = 0.0f;
    glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);
&#125;
</code></pre>
<ul>
<li><code>if</code> 判断测试显卡是否支持各向异性过滤。如果支持，则设置为支持的最大采样程度，由 <code>glGetFloatv()</code> 函数获取。</li>
<li>使用 <code>glTexParameterf()</code> 函数激活并设置纹理的各向异性采样值。</li>
</ul>
<h3 id="5-6-环绕和平铺">5.6 环绕和平铺</h3>
<p>当纹理坐标超出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 时，可以使用 <code>glTexParameteri()</code> 函数设置：</p>
<ul>
<li><code>GL_REPEAT</code>：重复纹理图像，忽略纹理坐标的整数部分，生成重复或平铺的图案，这是默认选项。</li>
<li><code>GL_MIRRORED_REPEAT</code>：重复纹理图像，忽略纹理坐标的整数部分，但是当整数部分为奇数时反转坐标，重复的图案在原图案和其镜像图案之间交替。</li>
<li><code>GL_CLAMP_TO_EDGE</code>：将纹理坐标限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 之间，小于0的坐标设置为0，大于1的坐标设置为1。</li>
<li><code>GL_CLAMP_TO_BORDER</code>：将纹理坐标限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 之间，区间以外设置为指定的边框颜色。</li>
</ul>
<p>代码上：</p>
<pre><code class="language-cpp">// 设置为重复
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</code></pre>
<p>修改为 <code>GL_CLAMP_TO_BORDER</code>：</p>
<pre><code class="language-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
float redColor[4] = &#123; 1.0f, 0.0f, 0.0f, 1.0f &#125;;
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, redColor);
</code></pre>
<h3 id="5-7-透视变形">5.7 透视变形</h3>
<p>在纹理坐标的情况下，线性插值可能导致在具有透视投影的 3D 场景中出现明显的失真。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_distortion.jpg" alt="失真（左），纠正（右），图源计算机图形学编程（第二版）"></p>
<p>默认情况下，OpenGL 在栅格化期间会应用透视校正算法。</p>
<ul>
<li>可以在顶点属性中添加关键字 <code>noperspective</code> 来禁用透视校正。</li>
<li>顶点着色器：<code>noperspective out vec2 texCoord;</code></li>
<li>片段着色器：<code>noperspective in vec2 texCoord;</code></li>
</ul>
<h3 id="5-8-材质的更多细节">5.8 材质的更多细节</h3>
<p>可以使用 C++ 和 OpenGL 函数直接将纹理图像文件数据加载到 OpenGL 中（不适用 SOIL2 库）：</p>
<ol>
<li>使用 C++ 工具读取图像文件数据。
<ul>
<li>C++ 函数 <code>fopen()</code>、<code>fread()</code>。</li>
</ul>
</li>
<li>生成 OpenGL 纹理对象。
<ul>
<li>使用 <code>glGenTextures()</code> 函数生成纹理对象。</li>
<li><code>glGenTextures(1, &amp;textureID);</code></li>
</ul>
</li>
<li>将图像文件数据复制到纹理对象中。
<ul>
<li>
<p>使用 <code>glTexImage2D()</code> 函数将图像文件数据复制到纹理对象中。</p>
</li>
<li>
<p><code>data</code> 为图像文件数据，数据类型为 <code>unsigned char</code>。</p>
<pre><code class="language-cpp">GLuint textureID;
glGenTextures(1, &amp;textureID);
glBindTexture(GL_TEXTURE_2D, textureID);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="六-3d模型">六、3D模型</h2>
<p>对于四棱锥和立方体，可以通过在OpenGL中使用顶点数组来创建。但是大部分 3D 场景对象都比较复杂，无法手动构建顶点数组。</p>
<p>对于更为复杂的模型，此处关注：</p>
<ul>
<li>通过程序来构建模型</li>
<li>加载外部创建的模型</li>
</ul>
<h3 id="6-1-程序构建模型">6.1 程序构建模型</h3>
<h4 id="6-1-1-构建一个球体">6.1.1 构建一个球体</h4>
<p>像圆、球体等具有数学定义，其顶点数组可以通过数学计算而生成。</p>
<p>建立一个球体模型：</p>
<ol>
<li>选择模型精度：一个表示将球体分成相应份数的圆形部分的数字，体现为切片数。</li>
<li>将每个圆形切片的圆周细分若干个点，此处每个切片具有相同数量的点。</li>
<li>将顶点分组为三角形：逐步遍历顶点，在每一步构建两个三角形。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_group.jpg" alt="将顶点组合成三角形"></p>
<ol start="4">
<li>根据纹理图像的性质选择纹理坐标。对于球体，想象让纹理图像围绕球体包裹，可以根据图像中像素的最终对应位置为每个顶点指定纹理坐标。</li>
<li>对于每个顶点，还应该生成法向量，用于光照。</li>
</ol>
<p>在第3点中，存在顶点出现在多个三角形中，导致每个顶点被多次指定，这对程序不利。仅存储每个顶点一次，然后为三角形的每个角指定索引，引用所需的顶点。</p>
<ul>
<li>需要存储每个顶点的位置、纹理坐标和法向量。
<ul>
<li>顶点存储在一维数组中，从最下面的水平切片开始。</li>
<li>索引数组包含相应三角形的每个角，将值设为顶点数组中的下标。</li>
</ul>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_index.png" alt="顶点数组和索引数组"></p>
<p>然后，从球体底部开始，围绕每个水平切片以圆形方式遍历顶点。访问每个顶点时，构建两个三角形，在其右上方形成一个方形区域。</p>
<pre><code class="language-cpp">// slices 为切片数，也是精度
// vertexs 为每个水平切片的顶点数
for (int i = 0; i &lt; slices; i++) 
&#123;
    for(int j = 0; j &lt; vertexs; j++)
    &#123;
        // 计算顶点j的指向右边相邻顶点、上方顶点
        // 以及右上方顶点的两个三角形的索引
    &#125;
&#125;
</code></pre>
<p>索引数组也加载到 VBO 中，指定 VBO 的类型为 <code>GL_ELEMENT_ARRAY_BUFFER</code>（这会告诉 OpenGL 这个 VBO 包含索引）。</p>
<ul>
<li>在 <code>display()</code> 中：
<ul>
<li>将 <code>glDrawArrays()</code> 调用替换为  <code>glDrawElements()</code> 调用，它会告诉 OpenGL利用索引 VBO 来查找要绘制的顶点。</li>
<li>还需要使用 <code>glBindBuffer()</code> 启用包含索引的 VBO，指定哪个 VBO 包含索引并且为 <code>GL_ELEMENT_ARRAY_BUFFER</code> 类型。</li>
</ul>
</li>
</ul>
<p>编写类 <code>Sphere</code>，用于创建球体模型，球体中心位于原点。</p>
<ul>
<li>
<p>顶点存储在 <code>GLM</code> 中的 <code>vec2</code> 和 <code>vec3</code> 示例的 <code>std::vector</code> 中。</p>
</li>
<li>
<p>因为纹理贴图完全包裹在球体周围，所以在纹理贴图的左右边缘相交的每个点处需要一个额外的顶点来使贴图两侧重合。</p>
<ul>
<li>顶点的总数是 <code>(prec+1)*(prec+1)</code>。由于每个顶点生成 6 个三角形索引，因此索引的总数是 <code>prec*prec*6</code>。</li>
<li><code>prec</code> 为精度，体现在切片数。</li>
</ul>
</li>
</ul>
<p>效果截图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_sphere.jpg" alt="球体"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint textureID;
GLuint mvLoc, projLoc;

glm::mat4 pMat, vMat, mMat, mvMat;

Sphere sphere(48);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
    std::vector&lt;int&gt; ind = sphere.getIndices();
    std::vector&lt;glm::vec3&gt; vert = sphere.getVertices();
    std::vector&lt;glm::vec2&gt; tex = sphere.getTexCoords();
    std::vector&lt;glm::vec3&gt; norm = sphere.getNormals();

    std::vector&lt;float&gt; pvalues;    // 顶点位置
    std::vector&lt;float&gt; tvalues;    // 纹理坐标
    std::vector&lt;float&gt; nvalues;    // 法向量

    int numIndices = sphere.getNumIndices();

    for (int i = 0; i &lt; numIndices; ++ i)
    &#123;
        pvalues.push_back(vert[i].x);
        pvalues.push_back(vert[i].y);
        pvalues.push_back(vert[i].z);
        tvalues.push_back(tex[i].s);
        tvalues.push_back(tex[i].t);
        nvalues.push_back(norm[i].x);
        nvalues.push_back(norm[i].y);
        nvalues.push_back(norm[i].z);
    &#125;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]);

    glGenBuffers(numVBO, vbo);
    // 顶点坐标放入缓冲区0
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
    // 纹理坐标放入缓冲区1
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
    // 法向量放入缓冲区2
    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
    // 索引放入缓冲区3
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 5.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
    textureID = Util::loadTexture(&quot;ice.jpg&quot;);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -1.0f));
    mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f));
    mvMat = vMat * mMat;

    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(1);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glGenerateMipmap(GL_TEXTURE_2D);
    if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;))
    &#123;
        GLfloat anisoSetting = 0.0f;
        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);
    &#125;

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    // 利用索引 vbo3 来查找要绘制的顶点
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    glDrawElements(GL_TRIANGLES, sphere.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Sphere&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<details><summary>球体类</summary>
<pre><code class="language-cpp">// Sphere.h
#pragma once

#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;glm/glm.hpp&gt;

class Sphere
&#123;
private:
    int numVertices;    // 顶点数组大小
    int numIndices;        // 索引数组大小
    std::vector&lt;glm::vec3&gt; vertices;    // 顶点数组
    std::vector&lt;int&gt; indices;            // 索引数组
    std::vector&lt;glm::vec3&gt; normals;        // 法向量数组
    std::vector&lt;glm::vec2&gt; texCoords;    // 纹理坐标数组

    void init(int);
    float toRadians(float degrees);

public:
    Sphere(int prec = 48);
    int getNumVertices();
    int getNumIndices();
    std::vector&lt;glm::vec3&gt; getVertices();
    std::vector&lt;int&gt; getIndices();
    std::vector&lt;glm::vec3&gt; getNormals();
    std::vector&lt;glm::vec2&gt; getTexCoords();
&#125;;
</code></pre>
<pre><code class="language-cpp">// Sphere.cpp
#include &quot;Sphere.h&quot;

Sphere::Sphere(int prec)
&#123;
    init(prec);
&#125;

void Sphere::init(int _prec)
&#123;
    numVertices = (_prec + 1) * (_prec + 1);
    numIndices = _prec * _prec * 6;
    for (int i = 0; i &lt; numVertices; ++ i)
        vertices.push_back(glm::vec3());
    for (int i = 0; i &lt; numVertices; ++ i)
        texCoords.push_back(glm::vec2());
    for (int i = 0; i &lt; numVertices; ++ i)
        normals.push_back(glm::vec3());
    for (int i = 0; i &lt; numIndices; ++ i)
        indices.push_back(0);

    // 计算三角形顶点
    for (int i = 0; i &lt;= _prec; ++ i)
        for (int j = 0; j &lt;= _prec; ++ j)
        &#123;
            float y = static_cast&lt;float&gt;(cos(toRadians(180.0f - i * 180.0f / _prec)));
            float x = - static_cast&lt;float&gt;(cos(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y))));
            float z = static_cast&lt;float&gt;(sin(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y))));
            vertices[i * (_prec + 1) + j] = glm::vec3(x, y, z);
            texCoords[i * (_prec + 1) + j] = glm::vec2(j * 1.0f / _prec, i * 1.0f / _prec);
            normals[i * (_prec + 1) + j] = glm::vec3(x, y, z);
        &#125;

    // 计算三角形索引
    for (int i = 0; i &lt; _prec; ++ i)
        for (int j = 0; j &lt; _prec; ++ j)
        &#123;
            indices[6 * (i * _prec + j) + 0] = i * (_prec + 1) + j;
            indices[6 * (i * _prec + j) + 1] = i * (_prec + 1) + j + 1;
            indices[6 * (i * _prec + j) + 2] = (i + 1) * (_prec + 1) + j;
            indices[6 * (i * _prec + j) + 3] = i * (_prec + 1) + j + 1;
            indices[6 * (i * _prec + j) + 4] = (i + 1) * (_prec + 1) + j + 1;
            indices[6 * (i * _prec + j) + 5] = (i + 1) * (_prec + 1) + j;
        &#125;
&#125;

float Sphere::toRadians(float degrees)
&#123;
    return degrees * 2.0f * 3.14159f / 360.0f;
&#125;

int Sphere::getNumVertices()
&#123;
    return numVertices;
&#125;

int Sphere::getNumIndices()
&#123;
    return numIndices;
&#125;

std::vector&lt;glm::vec3&gt; Sphere::getVertices()
&#123;
    return vertices;
&#125;

std::vector&lt;int&gt; Sphere::getIndices()
&#123;
    return indices;
&#125;

std::vector&lt;glm::vec3&gt; Sphere::getNormals()
&#123;
    return normals;
&#125;

std::vector&lt;glm::vec2&gt; Sphere::getTexCoords()
&#123;
    return texCoords;
&#125;
</code></pre>
</details>
<details><summary>着色器</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec2 texCoord;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
layout(binding = 0) uniform sampler2D samp;

out vec2 tc;

void main()
&#123;
    gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
    tc = texCoord;
&#125;
</code></pre>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

in vec2 tc;
out vec4 color;

layout(binding = 0) uniform sampler2D samp;

void main()
&#123;
    color = texture(samp, tc);
&#125;
</code></pre>
</details>
<h4 id="6-1-2-构建一个环面">6.1.2 构建一个环面</h4>
<p>产生环面需要一定的算法。</p>
<p>构建一个环面如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_totorus.jpg" alt="图源计算机图形学编程（第二版）"></p>
<p>将一个顶点定位到原点的右侧，然后在 xOy 平面上的圆中让这个顶点围绕 z 轴旋转，以形成“环”，最后将这个环“向外”移动“内径”的距离。</p>
<p>在构建这些顶点时，会为每个顶点计算纹理坐标和法向量，还会额外为每个顶点生成与环面表面相切的向量（称为切向量）。在顶点创建之后，逐环遍历所有顶点，并在每个顶点上生成两个三角形。两个三角形的 6 个索引表的生成方式和之前的球体类似。</p>
<p>效果截图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_torus.jpg" alt="环面"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
//#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint textureID;
GLuint mvLoc, projLoc;

glm::mat4 pMat, vMat, mMat, mvMat;

//Sphere sphere(48);
Torus torus(48, 0.5f, 0.2f);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
    std::vector&lt;int&gt; ind = torus.getIndices();
    std::vector&lt;glm::vec3&gt; vert = torus.getVertices();
    std::vector&lt;glm::vec2&gt; tex = torus.getTexCoords();
    std::vector&lt;glm::vec3&gt; norm = torus.getNormals();

    std::vector&lt;float&gt; pvalues;    // 顶点位置
    std::vector&lt;float&gt; tvalues;    // 纹理坐标
    std::vector&lt;float&gt; nvalues;    // 法向量

    int numIndices = torus.getNumIndices();

    for (int i = 0; i &lt; numIndices; ++ i)
    &#123;
        pvalues.push_back(vert[i].x);
        pvalues.push_back(vert[i].y);
        pvalues.push_back(vert[i].z);
        tvalues.push_back(tex[i].s);
        tvalues.push_back(tex[i].t);
        nvalues.push_back(norm[i].x);
        nvalues.push_back(norm[i].y);
        nvalues.push_back(norm[i].z);
    &#125;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]);

    glGenBuffers(numVBO, vbo);
    // 顶点坐标放入缓冲区0
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
    // 纹理坐标放入缓冲区1
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
    // 法向量放入缓冲区2
    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
    // 索引放入缓冲区3
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 5.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
    textureID = Util::loadTexture(&quot;ice.jpg&quot;);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -0.5f));
    mMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));
    mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f));
    mvMat = vMat * mMat;

    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(1);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glGenerateMipmap(GL_TEXTURE_2D);
    if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;))
    &#123;
        GLfloat anisoSetting = 0.0f;
        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);
    &#125;

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    // 利用索引 vbo3 来查找要绘制的顶点
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    glDrawElements(GL_TRIANGLES, torus.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Torus&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<details><summary>环面类</summary>
<pre><code class="language-cpp">// Torus.h
#pragma once

#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;

class Torus
&#123;
private:
    int numVertices;
    int numIndices;
    int prec;
    float inner, outer;
    std::vector&lt;int&gt; indices;
    std::vector&lt;glm::vec3&gt; vertices;
    std::vector&lt;glm::vec2&gt; texCoords;
    std::vector&lt;glm::vec3&gt; normals;
    std::vector&lt;glm::vec3&gt; sTangents;
    std::vector&lt;glm::vec3&gt; tTangents;
    void init();
    float toRadians(float degrees);

public:
    Torus(int _prec = 48, float _inner = 0.5, float _outer = 0.2);
    int getNumVertices();
    int getNumIndices();
    std::vector&lt;int&gt; getIndices();
    std::vector&lt;glm::vec3&gt; getVertices();
    std::vector&lt;glm::vec2&gt; getTexCoords();
    std::vector&lt;glm::vec3&gt; getNormals();
    std::vector&lt;glm::vec3&gt; getStangents();
    std::vector&lt;glm::vec3&gt; getTtangents();
&#125;;
</code></pre>
<pre><code class="language-cpp">// Torus.cpp
#include &quot;Torus.h&quot;

Torus::Torus(int _prec, float _inner, float _outer)
&#123;
    prec = _prec;
    inner = _inner;
    outer = _outer;
    init();
&#125;

void Torus::init()
&#123;
    numVertices = (prec + 1) * (prec + 1);
    numIndices = prec * prec * 6;
    for (int i = 0; i &lt; numVertices; ++ i)
        vertices.push_back(glm::vec3());
    for (int i = 0; i &lt; numVertices; ++ i)
        texCoords.push_back(glm::vec2());
    for (int i = 0; i &lt; numVertices; ++ i)
        normals.push_back(glm::vec3());
    for (int i = 0; i &lt; numIndices; ++ i)
        indices.push_back(0);
    for (int i = 0; i &lt; numVertices; ++ i)
        sTangents.push_back(glm::vec3());
    for (int i = 0; i &lt; numVertices; ++ i)
        tTangents.push_back(glm::vec3());

    // 计算第一个环
    for (int i = 0; i &lt; prec + 1; ++ i)
    &#123;
        float amt = toRadians(i * 360.0f / prec);
        glm::mat4 rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 0.0f, 1.0f));
        glm::vec3 initPos(rMat * glm::vec4(0.0f, outer, 0.0f, 1.0f));

        vertices[i] = glm::vec3(initPos + glm::vec3(inner, 0.0f, 0.0f));
        texCoords[i] = glm::vec2(0.0f, static_cast&lt;float&gt;(i) / prec);

        rMat = glm::rotate(glm::mat4(1.0f), amt + (3.14159f / 2.0f), glm::vec3(0.0f, 0.0f, 1.0f));
        tTangents[i] = glm::vec3(rMat * glm::vec4(0.0f, -1.0f, 0.0f, 1.0f));
        sTangents[i] = glm::vec3(glm::vec3(0.0f, 0.0f, -1.0f));

        normals[i] = glm::cross(tTangents[i], sTangents[i]);
    &#125;

    // 将第一个环绕Y轴旋转，得到其他环
    for (int ring = 1; ring &lt; prec + 1; ++ ring)
        for (int i = 0; i &lt; prec + 1; ++ i)
        &#123;
            float amt = toRadians(ring * 360.0f / prec);

            glm::mat4 rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));
            vertices[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(vertices[i], 1.0f));

            texCoords[ring * (prec + 1) + i] = glm::vec2(ring * 2.0f / prec, texCoords[i].t);

            rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));
            sTangents[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(sTangents[i], 1.0f));

            rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));
            tTangents[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(tTangents[i], 1.0f));

            rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));
            normals[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(normals[i], 1.0f));
        &#125;

    // 计算三角形索引
    for (int ring = 0; ring &lt; prec; ++ ring)
        for (int i = 0; i &lt; prec; ++ i)
        &#123;
            indices[((ring * prec + i) * 2) * 3 + 0] = ring * (prec + 1) + i;
            indices[((ring * prec + i) * 2) * 3 + 1] = (ring + 1) * (prec + 1) + i;
            indices[((ring * prec + i) * 2) * 3 + 2] = ring * (prec + 1) + i + 1;
            indices[((ring * prec + i) * 2 + 1) * 3 + 0] = ring * (prec + 1) + i + 1;
            indices[((ring * prec + i) * 2 + 1) * 3 + 1] = (ring + 1) * (prec + 1) + i;
            indices[((ring * prec + i) * 2 + 1) * 3 + 2] = (ring + 1) * (prec + 1) + i + 1;
        &#125;
&#125;

float Torus::toRadians(float degrees)
&#123;
    return degrees * 2.0f * 3.14159f / 360.0f;
&#125;

int Torus::getNumVertices()
&#123;
    return numVertices;
&#125;

int Torus::getNumIndices()
&#123;
    return numIndices;
&#125;

std::vector&lt;int&gt; Torus::getIndices()
&#123;
    return indices;
&#125;

std::vector&lt;glm::vec3&gt; Torus::getVertices()
&#123;
    return vertices;
&#125;

std::vector&lt;glm::vec2&gt; Torus::getTexCoords()
&#123;
    return texCoords;
&#125;

std::vector&lt;glm::vec3&gt; Torus::getNormals()
&#123;
    return normals;
&#125;

std::vector&lt;glm::vec3&gt; Torus::getStangents()
&#123;
    return sTangents;
&#125;

std::vector&lt;glm::vec3&gt; Torus::getTtangents()
&#123;
    return tTangents;
&#125;
</code></pre>
<ul>
<li>当绕 y 轴旋转生成环时，指定一个从 1 开始并增加到指定精度的变量 <code>ring</code>。然后将纹理坐标值设置为 <code>ring*2.0/prec</code>，使其取值范围为 0.0～2.0，再前面描述的，将纹理的平铺模式设为 <code>GL_REPEAT</code>。运用这种方法的目的是避免纹理图像在水平方向上过度“拉伸”。反之，如果确实希望纹理完全围绕环面拉伸，只需从纹理坐标计算代码中删除 <code>*2.0</code>。</li>
</ul>
</details>
<h3 id="6-2-加载外部构建的模型">6.2 加载外部构建的模型</h3>
<p>通过一些建模工具也可以构建模型，如：Maya、Blender、Cinema4D等，而一般模型导出也有许多格式。此处使用 OBJ 格式进行处理。</p>
<p>OBJ 文件中的行以字符标签开头，表明该行的数据类型，常见的标签如下：</p>
<ul>
<li>v：几何数据（顶点位置）</li>
<li>vt：纹理坐标</li>
<li>vn：顶点法向量</li>
<li>f：面（通常是三角形中的顶点）<br>
可能还有标签存储对象名称、使用的材质、曲线、阴影和许多其他细节。</li>
</ul>
<p>使用 Blender 绘制一个四棱锥，并导出为 OBJ文件：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_blender.jpg" alt="Blender导出设置"></p>
<p>使用记事本打开一个 OBJ 文件，其内容如下：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_Pyramidobj.jpg" alt="立方体的OBJ文件"></p>
<ul>
<li>以 <code>#</code> 开头的是 Blender 添加的注释，可以忽略。</li>
<li>以 <code>o</code> 开头的是对象的名称，导入时也可以忽略。</li>
<li>以 <code>s</code> 开头表明不应该平滑处理，此处同样忽略。</li>
<li>以 <code>v</code> 开头的是顶点位置，顶点位置的顺序是 <code>x y z</code>。此处有8个顶点，原点在中心。</li>
<li>以 <code>vt</code> 开头的是各种纹理坐标，纹理坐标列表比顶点列表长的原因是一些顶点参与了多个三角形的构建，并且在这些情况下可能使用不同的纹理坐标。</li>
<li>以 <code>vn</code> 开头的是各种法向量，通常也是比顶点列表长，原因同上。</li>
<li>以 <code>f</code> 开头的行指定面（三角形）。每个面（三角形）具有三个元素，由 <code>/</code> 分隔。每个元素的值分别是顶点列表、纹理坐标和法向量的索引，如第三个面是：<code>3/4/3 5/2/3 4/5/3</code>，表明顶点列表第3个、第5个、第4个组成一个面，相应的纹理坐标是第4项、第2项、第5项，法向量相同都是第3项。</li>
</ul>
<p>OBJ 格式的模型并不要求具有法向量，甚至纹理坐标。</p>
<ul>
<li>如果模型没有纹理坐标和法向量，则面的数值将仅指定顶点索引：
<ul>
<li><code>3 5 4</code></li>
</ul>
</li>
<li>如果模型有纹理坐标，没有法向量，则格式为：
<ul>
<li><code>3/4 5/2 4/5</code></li>
</ul>
</li>
<li>如果模型没有纹理坐标，有法向量，则格式为：
<ul>
<li><code>3//3 5//3 4//3</code></li>
</ul>
</li>
</ul>
<p>在互联网上可以获得各种能导入 OBJ 模型的程序，但此处手动编写程序进行简单地导入 OBJ 文件，局限如下：</p>
<ul>
<li>仅支持包含 3 个面属性字段，即以 <code>f #/#/# #/#/# #/#/#</code> 的形式存在。</li>
<li>材质标签将被忽略。</li>
<li>仅支持由单个三角形网格组成的 OBJ 模型。</li>
<li>假设每行上的元素都只用一个空格分隔。</li>
<li>没有使用上索引机制。</li>
</ul>
<p>定义两个类（置于同一个文件）：</p>
<ul>
<li><code>ModelImporter</code> 类用于从 OBJ 文件中导入模型数据。</li>
<li><code>ImportedModel</code> 类用于保存并构建一个模型，类似于上面的球体类、环面类。</li>
</ul>
<p>对于四棱锥，加载 OBJ 与先前手动构建的模型差不多。通过 Windows 自带的 3D 查看器，可以获取一些模型（格式为 <code>.glb</code> ，将其放入 Blender 中，再导出为 OBJ 文件）。获取模型后在 OpenGL 程序中加载，如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_unicorn.jpg" alt="独角兽模型"></p>
<p>导入模型后，对模型的大小和位置进行修改，移动适合的相机位置并加入材质，最后如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_iceUnicorn.jpg" alt="冰独角兽"></p>
<p>更多可以自己摸索。</p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint textureID;
GLuint mvLoc, projLoc;

glm::mat4 pMat, vMat, mMat, mvMat;

//Sphere sphere(48);
//Torus torus(48, 0.5f, 0.2f);
ImportedModel model(&quot; Pyramid.obj&quot;);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
    //std::vector&lt;int&gt; ind = model.getIndices(); 不使用索引数组
    std::vector&lt;glm::vec3&gt; vert = model.getVertices();
    std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
    std::vector&lt;glm::vec3&gt; norm = model.getNormals();

    std::vector&lt;float&gt; pvalues;    // 顶点位置
    std::vector&lt;float&gt; tvalues;    // 纹理坐标
    std::vector&lt;float&gt; nvalues;    // 法向量

    int numObjVertices = model.getNumVertices();

    for (int i = 0; i &lt; numObjVertices; ++ i)
    &#123;
        pvalues.push_back(vert[i].x);
        pvalues.push_back(vert[i].y);
        pvalues.push_back(vert[i].z);
        tvalues.push_back(tex[i].s);
        tvalues.push_back(tex[i].t);
        nvalues.push_back(norm[i].x);
        nvalues.push_back(norm[i].y);
        nvalues.push_back(norm[i].z);
    &#125;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]);

    glGenBuffers(numVBO, vbo);
    // 顶点坐标放入缓冲区0
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
    // 纹理坐标放入缓冲区1
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
    // 法向量放入缓冲区2
    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
    textureID = Util::loadTexture(&quot;ice.jpg&quot;);
    glBindTexture(GL_TEXTURE_2D, textureID);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
    mMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f));
    mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(1.0f, 1.0f, 1.0f));
    mvMat = vMat * mMat;

    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(1);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glGenerateMipmap(GL_TEXTURE_2D);
    if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;))
    &#123;
        GLfloat anisoSetting = 0.0f;
        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);
    &#125;

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());
    // 利用索引 vbo3 来查找要绘制的顶点
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    // glDrawElements(GL_TRIANGLES, torus.getVertices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Pyramid&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<details><summary>导入模型类</summary>
<pre><code class="language-cpp">// ImportedModel.h
#pragma once

#include &lt;glm/glm.hpp&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;

class ImportedModel
&#123;
private:
    int numVertices;
    std::vector&lt;glm::vec3&gt; vertices;
    std::vector&lt;glm::vec2&gt; texCoords;
    std::vector&lt;glm::vec3&gt; normals;

public:
    ImportedModel();
    ImportedModel(const std::string &amp;filePath);
    int getNumVertices();
    std::vector&lt;glm::vec3&gt; getVertices();
    std::vector&lt;glm::vec2&gt; getTexCoords();
    std::vector&lt;glm::vec3&gt; getNormals();
&#125;;

class ModelImporter
&#123;
private:
    // OBJ 读取
    std::vector&lt;float&gt; vertVals;
    std::vector&lt;float&gt; stVals;
    std::vector&lt;float&gt; normalVals;

    // 保存为顶点属性以供后续使用的数值
    std::vector&lt;float&gt; triangleVerts;
    std::vector&lt;float&gt; texCoords;
    std::vector&lt;float&gt; normals;

public:
    ModelImporter();
    void parseOBJ(const std::string &amp;filePath);
    int getNumVertices();
    std::vector&lt;float&gt; getVertices();
    std::vector&lt;float&gt; getTexCoords();
    std::vector&lt;float&gt; getNormals();
&#125;;
</code></pre>
<pre><code class="language-cpp">// ImportedModel.cpp
#include &quot;ImportedModel.h&quot;

ImportedModel::ImportedModel()
&#123;&#125;

ImportedModel::ImportedModel(const std::string &amp;filePath)
&#123;
    ModelImporter modelImporter = ModelImporter();
    modelImporter.parseOBJ(filePath);
    numVertices = modelImporter.getNumVertices();
    std::vector&lt;float&gt; verts = modelImporter.getVertices();
    std::vector&lt;float&gt; tcs = modelImporter.getTexCoords();
    std::vector&lt;float&gt; nms = modelImporter.getNormals();

    for (int i = 0; i &lt; numVertices; ++ i)
    &#123;
        vertices.push_back(glm::vec3(verts[i * 3], verts[i * 3 + 1], verts[i * 3 + 2]));
        texCoords.push_back(glm::vec2(tcs[i * 2], tcs[i * 2 + 1]));
        normals.push_back(glm::vec3(nms[i * 3], nms[i * 3 + 1], nms[i * 3 + 2]));
    &#125;
&#125;

int ImportedModel::getNumVertices()
&#123;
    return numVertices;
&#125;

std::vector&lt;glm::vec3&gt; ImportedModel::getVertices()
&#123;
    return vertices;
&#125;

std::vector&lt;glm::vec2&gt; ImportedModel::getTexCoords()
&#123;
    return texCoords;
&#125;

std::vector&lt;glm::vec3&gt; ImportedModel::getNormals()
&#123;
    return normals;
&#125;

ModelImporter::ModelImporter()
&#123;&#125;

void ModelImporter::parseOBJ(const std::string &amp;filePath)
&#123;
    float x, y, z;
    std::string content;
    std::ifstream fin(filePath, std::ios::in);
    std::string line = &quot;&quot;;
    while (!fin.eof())
    &#123;
        getline(fin, line);
        if (line.compare(0, 2, &quot;v &quot;) == 0)
        &#123;
            std::stringstream s(line.erase(0, 1));
            s &gt;&gt; x &gt;&gt; y &gt;&gt; z;
            vertVals.push_back(x);
            vertVals.push_back(y);
            vertVals.push_back(z);
        &#125;
        if (line.compare(0, 2, &quot;vt&quot;) == 0)
        &#123;
            std::stringstream s(line.erase(0, 2));
            s &gt;&gt; x &gt;&gt; y;
            stVals.push_back(x);
            stVals.push_back(y);
        &#125;
        if (line.compare(0, 2, &quot;vn&quot;) == 0)
        &#123;
            std::stringstream s(line.erase(0, 2));
            s &gt;&gt; x &gt;&gt; y &gt;&gt; z;
            normalVals.push_back(x);
            normalVals.push_back(y);
            normalVals.push_back(z);
        &#125;
        if (line.compare(0, 2, &quot;f &quot;) == 0)
        &#123;
            std::string oneCorner, v, t, n;
            std::stringstream s(line.erase(0, 2));
            for (int i = 0; i &lt; 3; ++ i)
            &#123;
                std::getline(s, oneCorner, ' ');
                std::stringstream oneCornerSS(oneCorner);
                std::getline(oneCornerSS, v, '/');
                std::getline(oneCornerSS, t, '/');
                std::getline(oneCornerSS, n, '/');

                int vertRef = (std::stoi(v) - 1) * 3;
                int tcRef = (std::stoi(t) - 1) * 2;
                int nmRef = (std::stoi(n) - 1) * 3;

                triangleVerts.push_back(vertVals[vertRef]);
                triangleVerts.push_back(vertVals[vertRef + 1]);
                triangleVerts.push_back(vertVals[vertRef + 2]);

                texCoords.push_back(stVals[tcRef]);
                texCoords.push_back(stVals[tcRef + 1]);

                normals.push_back(normalVals[nmRef]);
                normals.push_back(normalVals[nmRef + 1]);
                normals.push_back(normalVals[nmRef + 2]);
            &#125;
        &#125;
    &#125;
&#125;

int ModelImporter::getNumVertices()
&#123;
    return triangleVerts.size() / 3;
&#125;

std::vector&lt;float&gt; ModelImporter::getVertices()
&#123;
    return triangleVerts;
&#125;

std::vector&lt;float&gt; ModelImporter::getTexCoords()
&#123;
    return texCoords;
&#125;

std::vector&lt;float&gt; ModelImporter::getNormals()
&#123;
    return normals;
&#125;
</code></pre>
</details>
<h2 id="七-光照">七、光照</h2>
<h3 id="7-1-光照模型">7.1 光照模型</h3>
<p>光照模型有时也称为着色模型。</p>
<p>常见的光照模型称为 ADS 模型，基于标记为 A、D 和 S 三种类型的反射：</p>
<ul>
<li>A：环境光反射（ambient reflection）：模拟低级光照，影响场景中的所有物体。</li>
<li>D：漫反射（diffuse reflection）：根据光线的入射角度调整物体亮度。</li>
<li>S：镜面反射（specular reflection）：展示物体的光泽，通过在物体表面上，光线直接地反射到我们的眼睛的位置，策略性地放置适当大小的高光来体现。</li>
</ul>
<p>使用 ADS 光照模型需要指定用于像素输出的 RGBA 值上因光照<br>
而产生的分量。因素包括：</p>
<ul>
<li>光源类型及其环境光反射、漫反射和镜面反射特性；</li>
<li>对象材质的环境光反射、漫反射和镜面反射特征；</li>
<li>对象材质的“光泽度”；</li>
<li>光线照射物体的角度；</li>
<li>从中查看场景的角度。</li>
</ul>
<h3 id="7-2-光源">7.2 光源</h3>
<p>常见的光源类型有：</p>
<ul>
<li>全局光：通常称为全局环境光，仅包含环境光组件</li>
<li>定向光：远距离光</li>
<li>位置光：点光源</li>
<li>聚光灯</li>
</ul>
<p>全局环境光用于显示对象的每个像素都有相同的光照。</p>
<ul>
<li>全局环境光模拟了现实世界光线经过多次反射，<strong>无法确定光源和方向</strong>。</li>
<li>仅有环境光反射分量，没有漫反射或镜面反射分量。</li>
<li>通常被建模为偏暗的白光。</li>
<li>用 RGBA 值设定：<code>float globalAmbient[4] = &#123;0.6f, 0.6f, 0.6f, 1.0f&#125;;</code>
<ul>
<li>RGBA 值的范围是 0.0 到 1.0。A 设置为1。</li>
</ul>
</li>
</ul>
<p>定向光或远距离光</p>
<ul>
<li><strong>没有源位置但具有方向</strong>。用于模拟光源距离非常远，光线接近平行的情况。</li>
<li>定向光对物体的影响取决于光照角度，物体朝向定向光的一侧比对侧更亮。</li>
<li>建模定向光需要指定其方向（向量）及其环境、漫反射和镜面特征。</li>
<li>用 RGBA 设定，如指向 z 轴负方向的红色定向光代码：</li>
</ul>
<pre><code class="language-cpp">float dirLightAmbient[4] = &#123;0.1f, 0.0f, 0.0f, 1.0f&#125;;
float dirLightDiffuse[4] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;;
float dirLightSpecular[4] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;;
float dirLightDirection[3] = &#123;0.0f, 0.0f, -1.0f&#125;;
</code></pre>
<p>位置光在 3D 场景中具有特定位置，用以体现靠近场景的光源。</p>
<ul>
<li><strong>位置光没有方向</strong>，因为它对场景中每个顶点的光照方向都不同。</li>
<li>位置光还可以包含衰减因子，用于模拟它们的强度随着距离减小的程度。</li>
<li>用 RGBA 设定，如位置(5,2,-3)处的红色位置光可以指定为：</li>
</ul>
<pre><code class="language-cpp">float posLightAmbient[4] = &#123;0.1f, 0.0f, 0.0f, 1.0f&#125;;
float posLightDiffuse[4] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;;
float posLightSpecular[4] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;;
float posLightPosition[3] = &#123;5.0f, 2.0f, -3.0f&#125;;
</code></pre>
<ul>
<li>衰减因子有许多建模方式，其中一种是使用恒定衰减、线性衰减和二次方衰减，引入3个非负可调参数，与离光源的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 结合进行计算：</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>k</mi><mi>c</mi></msub><mo>+</mo><msub><mi>k</mi><mi>l</mi></msub><mi>d</mi><mo>+</mo><msub><mi>k</mi><mi>q</mi></msub><msup><mi>d</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">attenuationFactor = \frac{1}{k_c + k_l d + k_q d^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.293548em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">k_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：应永远大于等于1；</p>
</li>
<li>
<p>另外两个参数至少有一个大于零；</p>
</li>
<li>
<p>使得因子取值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，并当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 增大时接近0。</p>
</li>
<li>
<p>将因子与光的强度相乘即可。</p>
</li>
</ul>
<p>聚光灯</p>
<ul>
<li><strong>同时具有位置和方向</strong>。</li>
<li>聚光灯参数如下图</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_spotlightargs.jpg" alt="聚光灯参数，图源计算机图形学编程（第二版）"></p>
<ul>
<li>具有衰减指数模拟随光束角度的强度变化，具有衰减因子模拟光束距离衰减。
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 时，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 的余弦的衰减指数次幂来计算强度因子。</li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 时，强度因子为0。</li>
<li>强度因子取值范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，将强度因子乘光的强度即可模拟锥形效果。</li>
</ul>
</li>
<li>用 RGBA 设定，如位置(5,2,-3)处向下照射 z 轴负方向的红色聚光灯可以表示为：</li>
</ul>
<pre><code class="language-cpp">float spotLightAmbient[4] = &#123;0.1f, 0.0f, 0.0f, 1.0f&#125;;
float spotLightDiffuse[4] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;;
float spotLightSpecular[4] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;;
float spotLightPosition[3] = &#123;5.0f, 2.0f, -3.0f&#125;;
float spotLightDirection[3] = &#123;0.0f, 0.0f, -1.0f&#125;;
float spotLightCutoff = 20.0f;
float spotLightExponent = 10.0f;
</code></pre>
<p><em>当设计拥有许多光源的系统时，程序员应该考虑创建相应的类结构，如定义 Light 类及其子类 GlobalAmbient、Directional、Positional、Spotlight</em></p>
<h3 id="7-3-材质">7.3 材质</h3>
<p>场景中给物体的外观添加光照，产生反射特性。即对象与 ADS 光照模型相互作用。</p>
<p>通过指定4个值，在 ADS 光照模型中模拟材质：</p>
<ul>
<li>环境光反射</li>
<li>漫反射</li>
<li>镜面反射</li>
<li>光泽</li>
</ul>
<p>如锡铝合金的效果，指定：</p>
<pre><code class="language-cpp">float pewterMatAmbient[4] = &#123;0.11f, 0.06f, 0.11f, 1.0f&#125;;
float pewterMatDiffuse[4] = &#123;0.43f, 0.47f, 0.54f, 1.0f&#125;;
float pewterMatSpecular[4] = &#123;0.33f, 0.33f, 0.52f, 1.0f&#125;;
</code></pre>
<p>没有纹理的物体在渲染时，可以指定材质特性。此处预定义一些可选择的材质（置于Util类中）：</p>
<details><summary>黄金、白银、青铜材质代码</summary>
<pre><code class="language-cpp">// 黄金材质的环境光
float *Util::goldAmbient()
&#123;
    static float ambient[4] = &#123; 0.2473f, 0.1995f, 0.0745f, 1.0f &#125;;
    return ambient;
&#125;

// 黄金材质的漫反射
float *Util::goldDiffuse()
&#123;
    static float diffuse[4] = &#123; 0.7516f, 0.6065f, 0.2265f, 1.0f &#125;;
    return diffuse;
&#125;

// 黄金材质的镜面反射
float *Util::goldSpecular()
&#123;
    static float specular[4] = &#123; 0.6283f, 0.5559f, 0.3661f, 1.0f &#125;;
    return specular;
&#125;

// 黄金材质的光泽度
float Util::goldShininess()
&#123;
    return 51.2f;
&#125;

// 白银材质的环境光
float *Util::silverAmbient()
&#123;
    static float ambient[4] = &#123; 0.1923f, 0.1923f, 0.1923f, 1.0f &#125;;
    return ambient;
&#125;

// 白银材质的漫反射
float *Util::silverDiffuse()
&#123;
    static float diffuse[4] = &#123; 0.5075f, 0.5075f, 0.5075f, 1.0f &#125;;
    return diffuse;
&#125;

// 白银材质的镜面反射
float *Util::silverSpecular()
&#123;
    static float specular[4] = &#123; 0.5083f, 0.5083f, 0.5083f, 1.0f &#125;;
    return specular;
&#125;

// 白银材质的光泽度
float Util::silverShininess()
&#123;
    return 51.2f;
&#125;

// 青铜材质的环境光
float *Util::bronzeAmbient()
&#123;
    static float ambient[4] = &#123; 0.2125f, 0.1275f, 0.054f, 1.0f &#125;;
    return ambient;
&#125;

// 青铜材质的漫反射
float *Util::bronzeDiffuse()
&#123;
    static float diffuse[4] = &#123; 0.714f, 0.4284f, 0.18144f, 1.0f &#125;;
    return diffuse;
&#125;

// 青铜材质的镜面反射
float *Util::bronzeSpecular()
&#123;
    static float specular[4] = &#123; 0.393548f, 0.271906f, 0.166721f, 1.0f &#125;;
    return specular;
&#125;

// 青铜材质的光泽度
float Util::bronzeShininess()
&#123;
    return 25.6f;
&#125;
</code></pre>
</details>
<p><strong>这些代码仅仅提供了用于描述并存储场景中元素所需光照和材质特性的一种方式，仍然需要自己计算光照。</strong></p>
<h3 id="7-4-ads光照计算">7.4 ADS光照计算</h3>
<p>当绘制场景时，每个顶点坐标都会进行变换以将 3D 世界模拟到 2D 屏幕上。每个像素的颜色都是栅格化、纹理贴图以及插值的结果。</p>
<p>现在需要加入一个新的步骤来调整这些栅格化之后的像素颜色，以便反应场景中的光照和材质。</p>
<p>首先确定每个像素的反射强度 I：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>=</mo><msub><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>I</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>+</mo><msub><mi>I</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{observed} = I_{ambient} + I_{diffuse} + I_{specular}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中环境光值为场景环境光与材质环境光分量的乘积（RGB分别乘积）：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mtext> </mtext><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msubsup><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msubsup><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msubsup><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msubsup><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msubsup><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msubsup><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msubsup><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow></msubsup></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">I_{ambient}=Light_{ambient}\ Material_{ambient}=
\begin{cases}
I_{ambient}^{red}=Light_{ambient}^{red}Material_{ambient}^{red}\\
I_{ambient}^{green}=Light_{ambient}^{green}Material_{ambient}^{green}\\
I_{ambient}^{blue}=Light_{ambient}^{blue}Material_{ambient}^{blue}
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.3986920000000005em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.3986920000000005em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.3986920000000005em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中漫反射分量基于光对于平面的入射角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_angleOfIncidence.png" alt="入射角"></p>
<p>其中确定入射角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 需要：</p>
<ol>
<li>求从绘制向量到光源的向量（或与光照方向相反的向量） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></li>
<li>渲染物体表明的法向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li>
</ol>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>由</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>I</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>N</mi><mo>⋅</mo><mi>L</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>N</mi><mi mathvariant="normal">∥</mi><mi>L</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo>≤</mo><mi>θ</mi><mo>≤</mo><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr></mtable></mrow><mspace linebreak="newline"></mspace><mtext>得</mtext><msub><mi>I</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mtext> </mtext><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mtext> </mtext><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>N</mi><mo>⋅</mo><mi>L</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>N</mi><mi mathvariant="normal">∥</mi><mi>L</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mtext>同样分别进行</mtext><mi>R</mi><mi>G</mi><mi>B</mi><mtext>运算</mtext></mrow><annotation encoding="application/x-tex">由\begin{cases}
I_{diffuse}=\cos(\theta)Light_{diffuse}Material_{diffuse}\\
\cos(\theta)=\frac{N\cdot L}{\vert N\|L\vert}\\
-\frac{\pi}{2}\leq\theta\leq\frac{\pi}{2}
\end{cases}\\
得I_{diffuse}=Light_{diffuse}\ Material_{diffuse}\ \max(\frac{N\cdot L}{\vert N\|L\vert},0)\\
同样分别进行RGB运算
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.4079999999999995em;vertical-align:-1.9539999999999997em;"></span><span class="mord cjk_fallback">由</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.454em;"><span style="top:-4.454000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0140000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">∥</span><span class="mord mathdefault mtight">L</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.4860000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9539999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord cjk_fallback">得</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">∥</span><span class="mord mathdefault">L</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">别</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">算</span></span></span></span></span></p>
<p>其中镜面反射分量除了与入射角相关，也与光在表面上的反射角以及观察点与反光表面之间的夹角相关。下图 R 表示光反射，V 表示观察向量（像素到眼睛）。</p>
<ul>
<li>V 是从眼睛到像素的取反。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 越小，镜面反射分量越大。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 用于计算镜面反射分量的方式取决于物体的光泽度。光泽度越大越闪亮，则入射光更多反射给眼睛；光泽度较小，不那么闪亮，则镜面高光会散开。</li>
</ul>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_observationPointIncidence.png" alt="观察点入射角"></p>
<p>反光度可以用衰减函数建模，衰减函数表示角度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 增大时镜面反射分量衰减到0的速度。</p>
<ul>
<li>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><mi>cos</mi><mo>⁡</mo></mo><mi>n</mi></msup><mo stretchy="false">(</mo><mi>φ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\cos^n(\varphi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">cos</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">φ</span><span class="mclose">)</span></span></span></span> 进行衰减，指数越大，衰减速度越快。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 又叫作材质的反光度因子。</li>
<li>反光度因子以光泽度形式给出。</li>
</ul>
</li>
</ul>
<p>镜面反射计算如下（实际运算使用RGB运算）：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mtext> </mtext><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mtext> </mtext><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>R</mi><mo>⋅</mo><mi>V</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>R</mi><mi mathvariant="normal">∥</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">I_{specular}=Light_{specular}\ Material_{specular}\ \max((\frac{R\cdot V}{\vert R\|V\vert})^n,0)\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop">max</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<h3 id="7-5-实现ads光照">7.5 实现ADS光照</h3>
<p>平滑着色方法：</p>
<ul>
<li>Gouraud 着色</li>
<li>Phong 着色</li>
</ul>
<h4 id="7-5-1-gouraud-着色">7.5.1 Gouraud 着色</h4>
<p>这方法又称为双线性光强插值法</p>
<p>使用 3D 图形管线中的自动插值渲染，适用于现代显卡。过程如下：</p>
<ol>
<li>确定每个顶点的颜色，并进行光照相关计算。</li>
<li>允许正常的栅格化过程在插入像素时对颜色也进行插值（同时也对光照进行插值）。</li>
</ol>
<p>OpenGL 中，大多数光照计算都是顶点着色器中完成，片段着色器仅传递并展示自动插值的光照后的颜色。</p>
<ul>
<li>顶点着色器
<ol>
<li>根据顶点计算 N、L、V 和 R 向量</li>
<li>计算 A、D、S分量</li>
<li>输出属性、光照后的颜色、<code>gl_position</code></li>
</ol>
</li>
<li>片段着色器
<ol>
<li>传入插值：颜色、位置</li>
</ol>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_goldtorus.jpg" alt="通过 Gouraud 着色的黄金材质环面"></p>
<p>程序代码如下：</p>
<details><summary>Util类</summary>
<pre><code class="language-cpp">// Util.h
#pragma once

#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;SOIL2/soil2.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

class Util
&#123;
public:
    static std::string readShaderSource(const std::string &amp;path);
    static void printShaderLog(GLuint shader);
    static void printProgramLog(GLuint program);
    static bool checkOpenGLerror();

    static GLuint createShadeProgram(const std::string vpath, const std::string fpath);
    static GLuint loadTexture(const std::string &amp;imgPath);

    static float *goldAmbient();
    static float *goldDiffuse();
    static float *goldSpecular();
    static float goldShininess();

    static float *silverAmbient();
    static float *silverDiffuse();
    static float *silverSpecular();
    static float silverShininess();

    static float *bronzeAmbient();
    static float *bronzeDiffuse();
    static float *bronzeSpecular();
    static float bronzeShininess();
&#125;;
</code></pre>
<pre><code class="language-cpp">// Util.cpp
#include &quot;Util.h&quot;

/*
* 从文件中读取 GLSL 代码
* @param path 文件路径
*/
std::string Util::readShaderSource(const std::string &amp;path)
&#123;
    std::string content = &quot;&quot;;
    std::ifstream fileStream(path, std::ios::in);
    std::string line = &quot;&quot;;
    while (!fileStream.eof())
    &#123;
        getline(fileStream, line);
        content.append(line + &quot;\n&quot;);
    &#125;
    fileStream.close();
    return content;
&#125;

/*
* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容
* @param shader 着色器标识
*/
void Util::printShaderLog(GLuint shader)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetShaderInfoLog(shader, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Shader Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 当 GLSL 链接失败时，显示 OpenGL 日志内容
* @param program 着色器程序标识
*/
void Util::printProgramLog(GLuint program)
&#123;
    int len = 0;
    int chWrittn = 0;
    char *log;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;len);
    if (len &gt; 0)
    &#123;
        log = new char[len];
        glGetProgramInfoLog(program, len, &amp;chWrittn, log);
        std::cout &lt;&lt; &quot;Program Info: &quot; &lt;&lt; log &lt;&lt; &quot;\n&quot;;
        delete[] log;
    &#125;
&#125;

/*
* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误
*/
bool Util::checkOpenGLerror()
&#123;
    bool err = false;
    int glErr = glGetError();
    while (glErr != GL_NO_ERROR)
    &#123;
        std::cout &lt;&lt; &quot;glError: &quot; &lt;&lt; glErr &lt;&lt; &quot;\n&quot;;
        err = true;
        glErr = glGetError();
    &#125;
    return err;
&#125;

/*
* 创建着色器程序
* @param vpath 顶点着色器路径
* @param fpath 片段着色器路径
*/
GLuint Util::createShadeProgram(const std::string vpath, const std::string fpath)
&#123;
    // 记录错误信息
    GLint vertCompiled, fragCompiled, linked;

    // 顶点着色器
    std::string vs = readShaderSource(vpath);
    // 片段着色器
    std::string fs = readShaderSource(fpath);
    const char *vshaderSource = vs.c_str();
    const char *fshaderSource = fs.c_str();

    // 分别存入 vShader 和 fShader 变量
    GLuint vShader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER);

    // 将 GLSL 代码从字符串载入空着色器对象中
    glShaderSource(vShader, 1, &amp;vshaderSource, NULL);
    glShaderSource(fShader, 1, &amp;fshaderSource, NULL);

    // 编译顶点着色器
    glCompileShader(vShader);
    checkOpenGLerror();
    glGetShaderiv(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);
    if (vertCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;vertex compilation failed\n&quot;;
        printShaderLog(vShader);
    &#125;
    // 编译片段着色器
    glCompileShader(fShader);
    checkOpenGLerror();
    glGetShaderiv(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);
    if (fragCompiled == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;fragment compilation failed\n&quot;;
        printShaderLog(fShader);
    &#125;

    GLuint vProgram = glCreateProgram();
    glAttachShader(vProgram, vShader);
    glAttachShader(vProgram, fShader);
    glLinkProgram(vProgram);
    checkOpenGLerror();
    glGetProgramiv(vProgram, GL_LINK_STATUS, &amp;linked);
    if (linked == GL_FALSE)
    &#123;
        std::cout &lt;&lt; &quot;linking failed\n&quot;;
        printProgramLog(vProgram);
    &#125;

    return vProgram; // 返回着色器程序ID
&#125;

/*
* 从文件中读取纹理图像并返回纹理 ID
* @param imgPath 图像文件路径
*/
GLuint Util::loadTexture(const std::string &amp;imgPath)
&#123;
    GLuint textureID;
    textureID = SOIL_load_OGL_texture(imgPath.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    if (textureID == 0)
        std::cout &lt;&lt; &quot;Failed to load texture: &quot; &lt;&lt; imgPath &lt;&lt; &quot;\n&quot;;
    return textureID;
&#125;

// 黄金材质的环境光
float *Util::goldAmbient()
&#123;
    static float ambient[4] = &#123; 0.2473f, 0.1995f, 0.0745f, 1.0f &#125;;
    return ambient;
&#125;

// 黄金材质的漫反射
float *Util::goldDiffuse()
&#123;
    static float diffuse[4] = &#123; 0.7516f, 0.6065f, 0.2265f, 1.0f &#125;;
    return diffuse;
&#125;

// 黄金材质的镜面反射
float *Util::goldSpecular()
&#123;
    static float specular[4] = &#123; 0.6283f, 0.5559f, 0.3661f, 1.0f &#125;;
    return specular;
&#125;

// 黄金材质的光泽度
float Util::goldShininess()
&#123;
    return 51.2f;
&#125;

// 白银材质的环境光
float *Util::silverAmbient()
&#123;
    static float ambient[4] = &#123; 0.1923f, 0.1923f, 0.1923f, 1.0f &#125;;
    return ambient;
&#125;

// 白银材质的漫反射
float *Util::silverDiffuse()
&#123;
    static float diffuse[4] = &#123; 0.5075f, 0.5075f, 0.5075f, 1.0f &#125;;
    return diffuse;
&#125;

// 白银材质的镜面反射
float *Util::silverSpecular()
&#123;
    static float specular[4] = &#123; 0.5083f, 0.5083f, 0.5083f, 1.0f &#125;;
    return specular;
&#125;

// 白银材质的光泽度
float Util::silverShininess()
&#123;
    return 51.2f;
&#125;

// 青铜材质的环境光
float *Util::bronzeAmbient()
&#123;
    static float ambient[4] = &#123; 0.2125f, 0.1275f, 0.054f, 1.0f &#125;;
    return ambient;
&#125;

// 青铜材质的漫反射
float *Util::bronzeDiffuse()
&#123;
    static float diffuse[4] = &#123; 0.714f, 0.4284f, 0.18144f, 1.0f &#125;;
    return diffuse;
&#125;

// 青铜材质的镜面反射
float *Util::bronzeSpecular()
&#123;
    static float specular[4] = &#123; 0.393548f, 0.271906f, 0.166721f, 1.0f &#125;;
    return specular;
&#125;

// 青铜材质的光泽度
float Util::bronzeShininess()
&#123;
    return 25.6f;
&#125;
</code></pre>
</details>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint mvLoc, projLoc, nLoc;

// 光源属性
GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;
// 材质属性
GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;
glm::vec3 currentLightPos, lightPosV;    // 模型和视觉空间中的光照位置
float lightPos[3];    // 光照位置的浮点数组

// 初始化光照位置
glm::vec3 initialLightLoc = glm::vec3(5.0f, 2.0f, 2.0f);

// 白光特性
float globalAmbient[4] = &#123; 0.7f, 0.7f, 0.7f, 1.0f &#125;;
float lightAmbient[4] = &#123; 0.0f, 0.0f, 0.0f, 1.0f &#125;;
float lightDiffuse[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightSpecular[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;

float *matAmb = Util::goldAmbient();
float *matDif = Util::goldDiffuse();
float *matSpe = Util::goldSpecular();
float matShi = Util::goldShininess();

//Sphere model(48);
Torus model(48, 0.5f, 0.2f);
//ImportedModel model(&quot;unicorn.obj&quot;);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void installLights(glm::mat4 vMatrix)
&#123;
    // 将光源位置转换为视图空间坐标，存入浮点数组
    lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));
    lightPos[0] = lightPosV.x;
    lightPos[1] = lightPosV.y;
    lightPos[2] = lightPosV.z;

    // 在着色器获取光源位置和材质属性
    globalAmbLoc = glGetUniformLocation(renderProgram, &quot;globalAmbient&quot;);
    ambLoc = glGetUniformLocation(renderProgram, &quot;light.ambient&quot;);
    diffLoc = glGetUniformLocation(renderProgram, &quot;light.diffuse&quot;);
    specLoc = glGetUniformLocation(renderProgram, &quot;light.specular&quot;);
    posLoc = glGetUniformLocation(renderProgram, &quot;light.position&quot;);
    mAmbLoc = glGetUniformLocation(renderProgram, &quot;material.ambient&quot;);
    mDifLoc = glGetUniformLocation(renderProgram, &quot;material.diffuse&quot;);
    mSpecLoc = glGetUniformLocation(renderProgram, &quot;material.specular&quot;);
    mShiLoc = glGetUniformLocation(renderProgram, &quot;material.shininess&quot;);

    // 在着色器中为光源与材质统一变量赋值
    glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);
    glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);
    glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);
    glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);
    glProgramUniform3fv(renderProgram, posLoc, 1, lightPos);
    glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);
    glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);
    glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);
    glProgramUniform1f(renderProgram, mShiLoc, matShi);
&#125;

void makeVertexArray()
&#123;
    std::vector&lt;int&gt; ind = model.getIndices();
    std::vector&lt;glm::vec3&gt; vert = model.getVertices();
    std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
    std::vector&lt;glm::vec3&gt; norm = model.getNormals();

    std::vector&lt;float&gt; pvalues;    // 顶点位置
    std::vector&lt;float&gt; tvalues;    // 纹理坐标
    std::vector&lt;float&gt; nvalues;    // 法向量

    for (int i = 0; i &lt; model.getNumVertices(); ++ i)
    &#123;
        pvalues.push_back(vert[i].x);
        pvalues.push_back(vert[i].y);
        pvalues.push_back(vert[i].z);
        tvalues.push_back(tex[i].s);
        tvalues.push_back(tex[i].t);
        nvalues.push_back(norm[i].x);
        nvalues.push_back(norm[i].y);
        nvalues.push_back(norm[i].z);
    &#125;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]);

    glGenBuffers(numVBO, vbo);
    // 顶点坐标放入缓冲区0
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
    // 纹理坐标放入缓冲区1
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
    // 法向量放入缓冲区2
    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
    // 顶点索引放入缓冲区3
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
    nLoc = glGetUniformLocation(renderProgram, &quot;norm_matrix&quot;);

    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
    mMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));

    // 基于当前光源位置，初始化光照
    currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);
    installLights(vMat);

    mvMat = vMat * mMat;
    // 构建 MV 矩阵的逆转置矩阵，用于变换法向量
    invTrMat = glm::transpose(glm::inverse(mvMat));

    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));

    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(1);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    //glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());
    // 利用索引 vbo3 来查找要绘制的顶点
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Light&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>定义函数 <code>installLights()</code> 将光源在视觉空间中的位置和材质的 ADS 特性读入相应的统一变量。</li>
<li>直接对法向量应用 MV 矩阵不能保证法向量依然与物体表面垂直。使用 MV 矩阵的逆转置矩阵，用于变换法向量。</li>
<li>变量 lightPosV 包含光源在相机空间中的位置，每帧只需要计算一次。</li>
</ul>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

struct PositionalLight
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec3 position;
&#125;;

struct Material
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    float shininess;
&#125;;

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec3 vertNormal;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;    // 用于变换法向量
uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;

out vec4 color;

void main()
&#123;
    // 将顶点位置和法向量转换到视觉空间
    // 计算视觉空间光照向量（从顶点到光源）
    vec4 P = mv_matrix * vec4(vertPos, 1.0);
    vec3 N = normalize((norm_matrix * vec4(vertNormal, 0.0)).xyz);
    vec3 L = normalize(light.position - P.xyz);

    // 视觉向量等于视觉空间中负顶点位置
    vec3 V = normalize(-P.xyz);

    // R 是 -L 的相对于表面向量 N 的镜像
    vec3 R = reflect(-L, N);

    // 环境光、漫反射和镜面反射分量
    vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz;
    vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * max(dot(N, L), 0.0);
    vec3 specular = pow(max(dot(R, V), 0.0f), material.shininess) * material.specular.xyz * light.specular.xyz;

    // 将颜色输出到片段着色器

    gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
    color = vec4(ambient + diffuse + specular, 1.0);
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>字段选择器符号“.xyz”，是将 <code>vec4</code> 转换为仅包含其前 3 个元素的等效 <code>vec3</code> 的“快捷方式”。</li>
<li><code>normalize()</code> 用来将向量转换为单位长度。</li>
<li><code>reflect()</code> 函数用与计算一个向量基于另一个向量的反射。</li>
<li><code>dot()</code> 函数为点乘运算。</li>
</ul>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

in vec4 color;
out vec4 fragColor;

void main()
&#123;
    fragColor = color;
&#125;
</code></pre>
</details>
<p>Gouraud 着色容易受到其他伪影影响。</p>
<ul>
<li>如果镜面高光范围内一个模型顶点也没有，那么它可能不会被渲染出来。</li>
<li>镜面反射分量是依顶点计算的，因此，当模型的所有顶点都没有镜面反射分量时，其栅格化后的像素也不会有镜面反射效果。</li>
</ul>
<h4 id="7-5-2-phong-着色">7.5.2 Phong 着色</h4>
<p>该算法的结构类似 Gouraud 着色算法，不同之处在于光照计算是<strong>按像素而非顶点</strong>完成的。</p>
<ul>
<li>顶点着色器
<ol>
<li>计算向量 N、L、V</li>
<li>输出属性 N、L、V、<code>gl_position</code></li>
</ol>
</li>
<li>片段着色器
<ol>
<li>传入插值 N、L、V</li>
<li>计算 R、θ、φ</li>
<li>计算 ADS 分量</li>
<li>输出颜色</li>
</ol>
</li>
</ul>
<p>将之前在顶点着色器中实现的过程移到片段着色器中进行。</p>
<p>故 main.cpp和 Util 类无需改变，只需修改着色器的代码。</p>
<p>对于原始的 Phong 进行优化：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 的计算是非必须的。</li>
<li>角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 可以通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的角平分线向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 得到。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mi>L</mi><mo>+</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">H = L + V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>φ</mi></mrow><annotation encoding="application/x-tex">\theta = \frac{1}{2}\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">φ</span></span></span></span></li>
<li>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 代替 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 就已经可以获得足够好的结果。</li>
</ul>
</li>
<li>最后镜面反射分量在光泽度乘 3.0 作为改善镜面高光的微调。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_optobPointIncidence.png" alt="使用α代替φ"></p>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

struct PositionalLight
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec3 position;
&#125;;

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec3 vertNormal;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;    // 用于变换法向量
uniform PositionalLight light;

out vec3 normals;    // 视觉空间顶点法向量
out vec3 lightDir;    // 指向光源的向量
out vec3 halfVector;// 角平分线向量 H

void main()
&#123;
    vec3 _vertPos;    // 视觉空间中的顶点位置
    // 输出顶点位置、光照方向和法向量到光栅着色器进行插值
    _vertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;
    lightDir = light.position - _vertPos;
    normals = (norm_matrix * vec4(vertNormal, 1.0)).xyz;
    halfVector = (lightDir + (-_vertPos)).xyz;
    gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

struct PositionalLight
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec3 position;
&#125;;

struct Material
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    float shininess;
&#125;;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;

in vec3 normals;
in vec3 lightDir;
in vec3 halfVector;
out vec4 fragColor;

void main()
&#123;
    // 归一化光照向量、法向量、平分线向量
    vec3 L = normalize(lightDir);
    vec3 N = normalize(normals);
    vec3 H = normalize(halfVector);

    // 计算光照与平面法向量间的角度
    float cosTheta = dot(L, N);
    // 计算法向量 N 与角平分线向量 H 之间的角度
    float cosPhi = dot(H, N);

    // 按像素计算 ADS 分量，合并构建输出颜色
    vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz;
    vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * max(cosTheta, 0.0);
    vec3 specular = light.specular.xyz * material.specular.xyz * pow(max(cosPhi, 0.0), material.shininess * 3.0);

    fragColor = vec4(ambient + diffuse + specular, 1.0);
&#125;
</code></pre>
</details>
<h3 id="7-6-结合光照和纹理">7.6 结合光照和纹理</h3>
<p>结合光照和纹理的方式取决于物体的特性及其纹理的目的：</p>
<ul>
<li>纹理图像很写实地反映了物体真实的表面外观；</li>
<li>物体同时具有材质和纹理；</li>
<li>材质包括阴影和反射信息；</li>
<li>有多种光或多个纹理</li>
</ul>
<p>当物体拥有一个简单的纹理，同时进行光照时，简单的方法是：</p>
<ol>
<li>在片段着色器中完全将材质特性去除；</li>
<li>使用纹理取样所得纹理颜色代替材质的 ADS 值。</li>
</ol>
<ul>
<li>对于闪亮表面：
<ul>
<li>纹理颜色影响了环境光和漫反射分量，而镜面反射颜色仅由光源决定。</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">fragColor = textureColor * (ambient + diffuse) + specular;
</code></pre>
<ul>
<li>
<p>对于非闪亮表面：</p>
<ul>
<li>
<p>镜面高光部分应当包含物体表面颜色。</p>
<pre><code class="language-cpp">fragColor = textureColor * (ambient + diffuse + specular);
</code></pre>
</li>
</ul>
</li>
<li>
<p>对于物体既有 ADS 材质，又有纹理图像，加权求和。</p>
</li>
</ul>
<pre><code class="language-cpp">textureColor = texture(samp, texCoord);
lightColor = (ambLight * ambMaterial) + (diffLight * diffMaterial) + specLight;
fragColor = 0.5 * textureColor + 0.5 * lightColor;
</code></pre>
<ul>
<li>结合了光照、材质、纹理，并能够扩展到多个光源、多种材质的情况。</li>
</ul>
<pre><code class="language-cpp">texture1Color = texture(sampler1, texCoord);
texture2Color = texture(sampler2, texCoord);
light1Color = (ambLight1 * ambMaterial) + (diffLight1 * diffMaterial) + specLight1;
light2Color = (ambLight2 * ambMaterial) + (diffLight2 * diffMaterial) + specLight2;
fragColor = 0.25 * texture1Color + 
            0.25 * texture2Color +
            0.25 * light1Color +
            0.25 * light2Color;
</code></pre>
<p>稍作尝试的一个例子：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_movinglight.gif" alt="青铜材质、冰块纹理、移动光源下的恐龙"></p>
<p>对于这个例子的代码（ImportedModel 类和 Util 类同之前）：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint mvLoc, projLoc, nLoc;
GLuint textureID;

// 光源属性
GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;
// 材质属性
GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;
glm::vec3 currentLightPos, lightPosV;    // 模型和视觉空间中的光照位置
float lightPos[3];    // 光照位置的浮点数组

// 初始化光照位置
glm::vec3 initialLightLoc = glm::vec3(5.0f, 2.0f, 2.0f);

// 白光特性
float globalAmbient[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightAmbient[4] = &#123; 0.0f, 0.0f, 0.0f, 1.0f &#125;;
float lightDiffuse[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightSpecular[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;

float *matAmb = Util::bronzeAmbient();
float *matDif = Util::bronzeDiffuse();
float *matSpe = Util::bronzeSpecular();
float matShi = Util::bronzeShininess();

//Sphere model(48);
//Torus model(48, 0.5f, 0.2f);
// 加载的模型还不能使用索引
ImportedModel model(&quot;model/velociraptor.obj&quot;);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    glViewport(0, 0, width, height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void installLights(glm::mat4 vMatrix)
&#123;
    // 将光源位置转换为视图空间坐标，存入浮点数组
    lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));
    lightPos[0] = lightPosV.x;
    lightPos[1] = lightPosV.y * 10.0f * cos(glfwGetTime() * 2.0f);
    lightPos[2] = lightPosV.z;

    // 在着色器获取光源位置和材质属性
    globalAmbLoc = glGetUniformLocation(renderProgram, &quot;globalAmbient&quot;);
    ambLoc = glGetUniformLocation(renderProgram, &quot;light.ambient&quot;);
    diffLoc = glGetUniformLocation(renderProgram, &quot;light.diffuse&quot;);
    specLoc = glGetUniformLocation(renderProgram, &quot;light.specular&quot;);
    posLoc = glGetUniformLocation(renderProgram, &quot;light.position&quot;);
    mAmbLoc = glGetUniformLocation(renderProgram, &quot;material.ambient&quot;);
    mDifLoc = glGetUniformLocation(renderProgram, &quot;material.diffuse&quot;);
    mSpecLoc = glGetUniformLocation(renderProgram, &quot;material.specular&quot;);
    mShiLoc = glGetUniformLocation(renderProgram, &quot;material.shininess&quot;);

    // 在着色器中为光源与材质统一变量赋值
    glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);
    glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);
    glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);
    glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);
    glProgramUniform3fv(renderProgram, posLoc, 1, lightPos);
    glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);
    glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);
    glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);
    glProgramUniform1f(renderProgram, mShiLoc, matShi);
&#125;

void makeVertexArray()
&#123;
    //std::vector&lt;int&gt; ind = model.getIndices();
    std::vector&lt;glm::vec3&gt; vert = model.getVertices();
    std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
    std::vector&lt;glm::vec3&gt; norm = model.getNormals();

    std::vector&lt;float&gt; pvalues;    // 顶点位置
    std::vector&lt;float&gt; tvalues;    // 纹理坐标
    std::vector&lt;float&gt; nvalues;    // 法向量

    for (int i = 0; i &lt; model.getNumVertices(); ++ i)
    &#123;
        pvalues.push_back(vert[i].x);
        pvalues.push_back(vert[i].y);
        pvalues.push_back(vert[i].z);
        tvalues.push_back(tex[i].s);
        tvalues.push_back(tex[i].t);
        nvalues.push_back(norm[i].x);
        nvalues.push_back(norm[i].y);
        nvalues.push_back(norm[i].z);
    &#125;

    glGenVertexArrays(numVAO, vao);
    glBindVertexArray(vao[0]);

    glGenBuffers(numVBO, vbo);
    // 顶点坐标放入缓冲区0
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
    // 纹理坐标放入缓冲区1
    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
    // 法向量放入缓冲区2
    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
    // 顶点索引放入缓冲区3
    //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    //glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
    renderProgram = Util::createShadeProgram(&quot;Phong/vertex.glsl&quot;, &quot;Phong/fragment.glsl&quot;);
    cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;

    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
    pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

    makeVertexArray();

    textureID = Util::loadTexture(&quot;textureImg/ice.jpg&quot;);
    glBindTexture(GL_TEXTURE_2D, textureID);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
    glClear(GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glUseProgram(renderProgram);

    mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
    projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
    nLoc = glGetUniformLocation(renderProgram, &quot;norm_matrix&quot;);

    vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
    mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, -1.0f, 0.0f));
    mMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f));
    mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(5.0f, 5.0f, 5.0f));

    // 基于当前光源位置，初始化光照
    currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);
    installLights(vMat);

    mvMat = vMat * mMat;
    // 构建 MV 矩阵的逆转置矩阵，用于变换法向量
    invTrMat = glm::transpose(glm::inverse(mvMat));

    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
    glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
    glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));

    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(1);

    glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(2);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glGenerateMipmap(GL_TEXTURE_2D);
    if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;))
    &#123;
        GLfloat anisoSetting = 0.0f;
        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);
    &#125;

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());
    // 利用索引 vbo3 来查找要绘制的顶点
    //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
    //glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
    if (!glfwInit())    exit(EXIT_FAILURE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Light&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
    glfwSwapInterval(1);

    glfwSetWindowSizeCallback(window, windowSizeCallback);

    init(window);

    while (!glfwWindowShouldClose(window))
    &#123;
        display(window, glfwGetTime());
        glfwSwapBuffers(window);
        glfwPollEvents();
    &#125;
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
&#125;
</code></pre>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-cpp">// vertex.glsl
#version 460 core

struct PositionalLight
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec3 position;
&#125;;

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec2 texCoord;
layout(location = 2) in vec3 vertNormal;

layout(binding = 0) uniform sampler2D samp;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;    // 用于变换法向量
uniform PositionalLight light;

out vec3 normals;    // 视觉空间顶点法向量
out vec3 lightDir;    // 指向光源的向量
out vec3 halfVector;// 角平分线向量 H
out vec2 tc;

void main()
&#123;
    vec3 _vertPos;    // 视觉空间中的顶点位置
    // 输出顶点位置、光照方向和法向量到光栅着色器进行插值
    _vertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;
    lightDir = light.position - _vertPos;
    normals = (norm_matrix * vec4(vertNormal, 1.0)).xyz;
    halfVector = (lightDir + (-_vertPos)).xyz;
    gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
    tc = texCoord;
&#125;
</code></pre>
<pre><code class="language-cpp">// fragment.glsl
#version 460 core

struct PositionalLight
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec3 position;
&#125;;

struct Material
&#123;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    float shininess;
&#125;;

layout(binding = 0) uniform sampler2D samp;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;

in vec2 tc;
in vec3 normals;
in vec3 lightDir;
in vec3 halfVector;
out vec4 fragColor;

void main()
&#123;
    // 归一化光照向量、法向量、视觉向量
    vec3 L = normalize(lightDir);
    vec3 N = normalize(normals);
    vec3 H = normalize(halfVector);

    // 计算光照与平面法向量间的角度
    float cosTheta = dot(L, N);
    // 计算法向量 N 与角平分线向量 H 之间的角度
    float cosPhi = dot(H, N);

    // 按像素计算 ADS 分量，合并构建输出颜色
    vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz;
    vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * max(cosTheta, 0.0);
    vec3 specular = light.specular.xyz * material.specular.xyz * pow(max(cosPhi, 0.0), material.shininess * 3.0);

    vec4 textureColor = texture(samp, tc);
    vec4 lightColor = light.ambient + light.diffuse + light.specular;
    vec4 stripLightColor = vec4(ambient + diffuse + specular, 1.0);

    fragColor = 0.3 * textureColor + 0.7 * stripLightColor;
&#125;
</code></pre>
</details>
<h2 id="八-阴影">八、阴影</h2>
<h3 id="8-1-投影阴影">8.1 投影阴影</h3>
<p>投影阴影：给定一个位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1, z_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的点光源，一个需要渲染的物体（物体上的点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_w, y_w, z_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）和一个投射阴影的平面，可以通过生成一个变换矩阵：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_projectedShadow.png" alt="投影阴影"></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>w</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>S</mi></msub><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>z</mi><mi>S</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_w, y_w, z_w)\rightarrow(x_S,0,z_S)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>通常使用暗色物体与地平面纹理混合作为阴影的纹理。</li>
</ul>
<p>投影阴影易于实现，但仅适用于平坦表面。</p>
<h3 id="8-2-阴影体">8.2 阴影体</h3>
<p>找到被物体阴影覆盖的阴影体，之后减少视体与阴影体相交部分中的多边形的颜色强度。</p>
<p>阴影体的优点在于其高度准确，比起其他方法来更不容易产生伪影。</p>
<p>几何着色器可以用于计算阴影体，模板缓冲区可以用于判断像素<br>
是否在阴影体内。有些显卡对于特定的阴影体操作优化提供了硬件支持。</p>
<h3 id="8-3-阴影贴图">8.3 阴影贴图</h3>
<p>阴影贴图的想法：光线无法“看到”的任何东西都在阴影中。也就是说，如果对象 1 阻挡光线到达对象 2，等同于光线不能“看到”对象 2</p>
<p>所以计算策略是：暂时将相机移动到光的位置，应用 Z-buffer 算法，然后使用生成的深度信息来计算。</p>
<p>由此可得，渲染场景需要两轮：</p>
<ul>
<li>第一轮从光源角度渲染场景（不绘制）。对于每个像素，深度缓冲区包含光源与最近的对象之间的距离。
<ul>
<li>生成深度缓冲区。</li>
</ul>
</li>
<li>将深度缓冲区复制到纹理对象。
<ul>
<li>当纹理对象用于储存阴影深度信息时，称其为阴影纹理。</li>
<li>将深度缓冲区复制到纹理中的过程称为“阴影贴图”。</li>
</ul>
</li>
<li>第二轮从相机角度渲染场景（正常渲染）。对于每个像素，在阴影纹理中查找相应的位置。
<ul>
<li>如果相机到渲染点的距离大于从阴影纹理检索到的值，则在该像素处绘制的对象离光源的距离比当前离光源最近的对象离光源更远，得出该像素处于阴影中。</li>
</ul>
</li>
</ul>
<p>阴影的处理：仅渲染环境光，忽略漫反射和镜面反射分量。</p>
<h4 id="8-3-1-第一轮-从光源位置绘制">8.3.1 第一轮——从光源位置绘制</h4>
<p>第一轮中并不是真的在显示其中绘制场景，故仅需用到顶点着色器。</p>
<p>通过变换矩阵（构建观察矩阵）移动相机：</p>
<ul>
<li>相机移动到光源的位置</li>
<li>相机方向朝向呈现的区域</li>
</ul>
<p>第一轮需要处理的细节：</p>
<ol>
<li>配置缓冲区和阴影纹理。</li>
<li>禁用颜色输出。</li>
<li>在光源处为视野中的物体构建一个 LookAt 矩阵。</li>
<li>启用 GLSL 第一轮着色器程序，准备接受 MVP 矩阵。
<ul>
<li>M：对象的模型矩阵</li>
<li>V：LookAt 矩阵作为观察矩阵</li>
<li>P：透视矩阵</li>
<li>该 MVP 矩阵 称为 <code>shadowMVP</code>。</li>
</ul>
</li>
<li>为每个对象创建一个 <code>shadowMVP</code> 矩阵，并调用 <code>glDrawArrays()</code>。</li>
</ol>
<p>顶点着色器变成：</p>
<pre><code class="language-glsl">#version 460 core

layout(location = 0) in vec3 vertPos;
uniform mat4 shadowMVP;

void main()
&#123;
	gl_Position = shadowMVP * vec4(vertPos, 1.0);
&#125;
</code></pre>
<p>片段着色器变成：</p>
<pre><code class="language-glsl">#version 460 core
void main() &#123;&#125;
</code></pre>
<h4 id="8-3-2-将深度缓冲区复制到纹理">8.3.2 将深度缓冲区复制到纹理</h4>
<p>OpenGL 提供了两种将深度缓冲区深度数据放入纹理单元的方法：</p>
<ol>
<li>生成空阴影纹理，然后使用命令 <code>glCopyTexImage2D()</code> 将活动的深度缓冲区复制到阴影纹理中。</li>
<li>在第一轮中构建“自定义帧缓冲区”，并使用命令 <code>glFrameBufferTexture2D()</code> 将阴影纹理附加到上面。
<ul>
<li>使用该方法无须将深度缓冲区复制到纹理，因为缓冲区已经附加了纹理，深度信息由 OpenGL 自动放入纹理中。</li>
</ul>
</li>
</ol>
<h4 id="8-3-3-第二轮-从相机位置绘制">8.3.3 第二轮——从相机位置绘制</h4>
<p>第二轮需要渲染完整的场景、其中的所有物体以及光照、材质和装饰场景中物体的纹理，同时还确定阴影。</p>
<p>使用两个 MVP 矩阵：</p>
<ol>
<li>一个将对象坐标转换为屏幕坐标的标准 MVP 矩阵（像之前一样）；</li>
<li>一个是第一轮生成的 shadowMVP 矩阵，用于从光源的角度进行渲染，即从阴影纹理中查找深度信息。</li>
</ol>
<p>从纹理贴图查找像素时，应该处理 OpenGL 相机空间使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 而纹理贴图使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 空间的问题：</p>
<ul>
<li>使用额外的变换矩阵  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。
<ul>
<li>用于从相机空间到纹理空间的转换</li>
</ul>
</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">B = \begin{bmatrix}
0.5 &amp; 0 &amp; 0 &amp; 0.5 \\
0 &amp; 0.5 &amp; 0 &amp; 0.5 \\
0 &amp; 0 &amp; 0.5 &amp; 0.5 \\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 和 <code>shadowMVP</code> 矩阵相乘，得到 <code>shadowMVP2</code> 矩阵。</p>
<p>第二轮的大概操作：</p>
<ol>
<li>构建变换矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，用于从光照空间转换到纹理空间。</li>
<li>启用阴影纹理，进行查找。</li>
<li>启用颜色输出。</li>
<li>启用 GLSL 第二轮渲染程序。</li>
<li>根据相机正常位置为对象构建 MVP 矩阵。</li>
<li>构建 shadowMVP2 矩阵。着色器用其查找阴影纹理中的像素坐标。</li>
<li>将生成的变换矩阵发送到着色器统一变量。</li>
<li>启用包含顶点、法向量和纹理坐标的缓冲区。</li>
<li>调用 <code>glDrawArrays()</code>。</li>
</ol>
<p>着色器的工作：</p>
<ul>
<li>顶点着色器将顶点位置从相机空间转换为光照空间，将结果发送到顶点属性中的片段着色器。</li>
<li>片段着色器调用 <code>textureProj()</code> 函数指示像素是否处于引用中（返回0或1）。如果位于阴影中，则剔除漫反射和镜面反射。
<ul>
<li>使用特殊采样器变量类型 <code>sampler2DShadow</code>，可以附加到程序中的阴影纹理中。</li>
</ul>
</li>
</ul>
<p>关注细节：正在渲染的像素和阴影纹理中的值的深度比较</p>
<ol>
<li>在模型空间中使用顶点坐标，与 shadowMVP2 相乘生成阴影纹理坐标（对应于投影到光照空间中的顶点坐标，是之前从光源视角生成的）。</li>
<li>经过插值后的光照空间（3D）坐标 (x, y, z) 在片段着色器中使用情况：
<ul>
<li>z 分量表示从光到像素的距离；</li>
<li>(x, y) 分量用于检索存储在阴影纹理（2D）中的深度信息。</li>
</ul>
</li>
<li>将该检索的值（到最靠近光的物体的距离）与 z 进行比较。</li>
</ol>
<p>例子效果展示如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_shadow.jpg" alt="光从左往右发出"></p>
<p>代码：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

const int numVAO = 1, numVBO = 5;
GLuint vao[numVAO], vbo[numVBO];

GLuint renderProgram1, renderProgram2;

int width, height;
float aspect;

GLuint mvLoc, projLoc, nLoc, sLoc;
GLuint textureID;

// 光源属性
GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;
// 材质属性
GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;
glm::vec3 currentLightPos, lightPosV;	// 模型和视觉空间中的光照位置
float lightPos[3];	// 光照位置的浮点数组

// 白光特性
float globalAmbient[4] = &#123; 0.7f, 0.7f, 0.7f, 1.0f &#125;;
float lightAmbient[4] = &#123; 0.0f, 0.0f, 0.0f, 1.0f &#125;;
float lightDiffuse[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightSpecular[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;

// 材质
struct Material
&#123;
	float *ambient, *diffuse, *specular;
	float shininess;
&#125;;

Material gold&#123; Util::goldAmbient(), Util::goldDiffuse(), Util::goldSpecular(), Util::goldShininess() &#125;;
Material silver&#123; Util::silverAmbient(), Util::silverDiffuse(), Util::silverSpecular(), Util::silverShininess() &#125;;

// 阴影相关
int scSizeX, scSizeY;
GLuint shadowTex, shadowBuffer;
glm::mat4 lightVmatrix, lightPmatrix;
glm::mat4 shadowMVP1, shadowMVP2;
glm::mat4 b;

// 模型相关
//Sphere model(48);
Torus model1(48, 0.6f, 0.4f);
// 加载的模型还不能使用索引
ImportedModel model2(&quot;model/pyr.obj&quot;);

// 位置相关
glm::vec3 cameraLoc(0.0f, 0.0f, 6.0f);
glm::vec3 lightLoc(-3.8f, 2.2f, 1.1f);
glm::vec3 model1Loc(1.6f, 0.0f, -0.3f);
glm::vec3 model2Loc(-1.0f, 0.1f, 0.3f);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void installLights(GLuint renderProgram, glm::mat4 vMatrix, Material &amp;m)
&#123;
	// 将光源位置转换为视图空间坐标，存入浮点数组
	lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));
	lightPos[0] = lightPosV.x;
	lightPos[1] = lightPosV.y;
	lightPos[2] = lightPosV.z;

	// 在着色器获取光源位置和材质属性
	globalAmbLoc = glGetUniformLocation(renderProgram, &quot;globalAmbient&quot;);
	ambLoc = glGetUniformLocation(renderProgram, &quot;light.ambient&quot;);
	diffLoc = glGetUniformLocation(renderProgram, &quot;light.diffuse&quot;);
	specLoc = glGetUniformLocation(renderProgram, &quot;light.specular&quot;);
	posLoc = glGetUniformLocation(renderProgram, &quot;light.position&quot;);
	mAmbLoc = glGetUniformLocation(renderProgram, &quot;material.ambient&quot;);
	mDifLoc = glGetUniformLocation(renderProgram, &quot;material.diffuse&quot;);
	mSpecLoc = glGetUniformLocation(renderProgram, &quot;material.specular&quot;);
	mShiLoc = glGetUniformLocation(renderProgram, &quot;material.shininess&quot;);

	// 在着色器中为光源与材质统一变量赋值
	glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);
	glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);
	glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);
	glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);
	glProgramUniform3fv(renderProgram, posLoc, 1, lightPos);
	glProgramUniform4fv(renderProgram, mAmbLoc, 1, m.ambient);
	glProgramUniform4fv(renderProgram, mDifLoc, 1, m.diffuse);
	glProgramUniform4fv(renderProgram, mSpecLoc, 1, m.specular);
	glProgramUniform1f(renderProgram, mShiLoc, m.shininess);
&#125;

void makeVertexArray()
&#123;
	// model1的顶点构建
	std::vector&lt;int&gt; model1Ind = model1.getIndices();
	std::vector&lt;glm::vec3&gt; vert = model1.getVertices();
	std::vector&lt;glm::vec3&gt; norm = model1.getNormals();

	std::vector&lt;float&gt; model1Pvalues;	// 顶点位置
	std::vector&lt;float&gt; model1Nvalues;	// 法向量

	for (int i = 0; i &lt; model1.getNumVertices(); ++ i)
	&#123;
		model1Pvalues.push_back(vert[i].x);
		model1Pvalues.push_back(vert[i].y);
		model1Pvalues.push_back(vert[i].z);
		model1Nvalues.push_back(norm[i].x);
		model1Nvalues.push_back(norm[i].y);
		model1Nvalues.push_back(norm[i].z);
	&#125;

	// model2的顶点构建
	vert = model2.getVertices();
	norm = model2.getNormals();

	std::vector&lt;float&gt; model2Pvalues;	// 顶点位置
	std::vector&lt;float&gt; model2Nvalues;	// 法向量

	for (int i = 0; i &lt; model2.getNumVertices(); ++ i)
	&#123;
		model2Pvalues.push_back(vert[i].x);
		model2Pvalues.push_back(vert[i].y);
		model2Pvalues.push_back(vert[i].z);
		model2Nvalues.push_back(norm[i].x);
		model2Nvalues.push_back(norm[i].y);
		model2Nvalues.push_back(norm[i].z);
	&#125;

	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);
	glGenBuffers(numVBO, vbo);

	// model1
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, 4 * model1Pvalues.size(), &amp;model1Pvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, 4 * model1Nvalues.size(), &amp;model1Nvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * model1Ind.size(), &amp;model1Ind[0], GL_STATIC_DRAW);

	// model2
	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glBufferData(GL_ARRAY_BUFFER, 4 * model2Pvalues.size(), &amp;model2Pvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, vbo[4]);
	glBufferData(GL_ARRAY_BUFFER, 4 * model2Nvalues.size(), &amp;model2Nvalues[0], GL_STATIC_DRAW);
&#125;

void setupShadowBuffers(GLFWwindow *window)
&#123;
	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	scSizeX = width;
	scSizeY = height;

	// 创建自定义帧缓冲区
	glGenFramebuffers(1, &amp;shadowBuffer);

	// 创建阴影纹理并让它存储深度信息
	glGenTextures(1, &amp;shadowTex);
	glBindTexture(GL_TEXTURE_2D, shadowTex);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT32,
		scSizeX, scSizeY, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram1 = Util::createShadeProgram(&quot;shadows/vertex1.glsl&quot;, &quot;shadows/fragment1.glsl&quot;);
	renderProgram2 = Util::createShadeProgram(&quot;shadows/vertex2.glsl&quot;, &quot;shadows/fragment2.glsl&quot;);

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();
	setupShadowBuffers(window);

	b = glm::mat4(
		0.5f, 0.0f, 0.0f, 0.0f,
		0.0f, 0.5f, 0.0f, 0.0f,
		0.0f, 0.0f, 0.5f, 0.0f,
		0.5f, 0.5f, 0.5f, 1.0f);
&#125;

void passOne()
&#123;
	glUseProgram(renderProgram1);

	// 绘制model1
	mMat = glm::translate(glm::mat4(1.0f), model1Loc);
	mMat = glm::rotate(mMat, 25.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));

	shadowMVP1 = lightPmatrix * lightVmatrix * mMat;
	sLoc = glGetUniformLocation(renderProgram1, &quot;shadowMVP&quot;);
	glUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP1));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glClear(GL_DEPTH_BUFFER_BIT);
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[2]);
	glDrawElements(GL_TRIANGLES, model1.getNumIndices(), GL_UNSIGNED_INT, 0);

	// 绘制model2
	mMat = glm::translate(glm::mat4(1.0f), model2Loc);
	mMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));
	mMat = glm::rotate(mMat, 40.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f));

	shadowMVP1 = lightPmatrix * lightVmatrix * mMat;
	glUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP1));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	glDrawArrays(GL_TRIANGLES, 0, model2.getNumVertices());
&#125;

void passTwo()
&#123;
	glUseProgram(renderProgram2);

	mvLoc = glGetUniformLocation(renderProgram2, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram2, &quot;proj_matrix&quot;);
	nLoc = glGetUniformLocation(renderProgram2, &quot;norm_matrix&quot;);
	sLoc = glGetUniformLocation(renderProgram2, &quot;shadowMVP&quot;);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));

	// 绘制model1
	mMat = glm::translate(glm::mat4(1.0f), model1Loc);
	mMat = glm::rotate(mMat, 25.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));

	currentLightPos = glm::vec3(lightLoc);
	installLights(renderProgram2, vMat, gold);
	mvMat = vMat * mMat;
	invTrMat = glm::transpose(glm::inverse(mvMat));
	shadowMVP2 = b * lightPmatrix * lightVmatrix * mMat;

	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
	glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));
	glUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP2));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[1]);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glClear(GL_DEPTH_BUFFER_BIT);
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[2]);
	glDrawElements(GL_TRIANGLES, model1.getNumIndices(), GL_UNSIGNED_INT, 0);

	// 绘制model2
	mMat = glm::translate(glm::mat4(1.0f), model2Loc);
	mMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));
	mMat = glm::rotate(mMat, 40.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f));

	currentLightPos = glm::vec3(lightLoc);
	installLights(renderProgram2, vMat, silver);

	mvMat = vMat * mMat;
	invTrMat = glm::transpose(glm::inverse(mvMat));
	shadowMVP2 = b * lightPmatrix * lightVmatrix * mMat;

	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
	glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));
	glUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP2));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	glDrawArrays(GL_TRIANGLES, 0, model2.getNumVertices());
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);

	currentLightPos = glm::vec3(lightLoc);
	lightVmatrix = glm::lookAt(currentLightPos, glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
	lightPmatrix = glm::perspective(60.0f * 3.14159f / 180.0f, aspect, 0.1f, 1000.0f);

	glBindFramebuffer(GL_FRAMEBUFFER, shadowBuffer);
	glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, shadowTex, 0);

	glDrawBuffer(GL_NONE);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_POLYGON_OFFSET_FILL);
	glPolygonOffset(2.0f, 4.0f);

	passOne();

	glDisable(GL_POLYGON_OFFSET_FILL);

	glBindFramebuffer(GL_FRAMEBUFFER, 0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, shadowTex);

	glDrawBuffer(GL_FRONT);

	passTwo();
&#125;

int main()
&#123;
	if (!glfwInit())	exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Light&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)	exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>第一轮的着色器</summary>
<pre><code class="language-glsl">// vertex1.glsl
#version 460 core

layout(location = 0) in vec3 vertPos;

uniform mat4 shadowMVP;

void main()
&#123;
	gl_Position = shadowMVP * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment1.glsl
#version 460 core

void main()&#123;&#125;
</code></pre>
</details>
<details><summary>第二轮的着色器</summary>
<pre><code class="language-glsl">// vertex2.glsl
#version 460

struct PositionalLight
&#123;
	vec4 ambient, diffuse, specular;
	vec3 position;
&#125;;

struct Material
&#123;
	vec4 ambient, diffuse, specular;
	float shininess;
&#125;;

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec3 vertNormal;

out vec3 vNormal, vLightDir, vVertPos, vHalfVec;
out vec4 shadowCoord;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;
uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;
uniform mat4 shadowMVP;

void main()
&#123;
	// 输出顶点位置
	vVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;
	// 获取一个从顶点到光线的向量并输出
	vLightDir = light.position - vVertPos;
	// 在视图空间中获得一个顶点法向量输出
	vNormal = (norm_matrix * vec4(vertNormal, 0.0)).xyz;
	// 计算顶点的半向量
	vHalfVec = (vLightDir - vVertPos).xyz;

	shadowCoord = shadowMVP * vec4(vertPos, 1.0);

	gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment2.glsl
#version 460 core

struct PositionalLight
&#123;
	vec4 ambient, diffuse, specular;
	vec3 position;
&#125;;

struct Material
&#123;
	vec4 ambient, diffuse, specular;
	float shininess;
&#125;;

in vec3 vNormal, vLightDir, vVertPos, vHalfVec;
in vec4 shadowCoord;
out vec4 fragColor;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;
uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;
uniform mat4 shadowMVP;
layout(binding = 0) uniform sampler2DShadow shadowTex;

void main()
&#123;
	vec3 L = normalize(vLightDir);
	vec3 N = normalize(vNormal);
	vec3 V = normalize(-vVertPos);
	vec3 H = normalize(vHalfVec);

	float inShadow = textureProj(shadowTex, shadowCoord);

	fragColor = globalAmbient * material.ambient + light.ambient * material.ambient;

	if (inShadow != 0.0)
	&#123;
		fragColor +=
			light.diffuse * material.diffuse * max(dot(L, N), 0.0) +
			light.specular * material.specular * pow(max(dot(H, N), 0.0), material.shininess * 3);
	&#125;
&#125;
</code></pre>
</details>
<h3 id="8-4-柔和阴影">8.4 柔和阴影</h3>
<p>使用百分比临近滤波 PCF 生成柔和阴影。</p>
<p>一种用于实现 PCF 的常见算法是：</p>
<ul>
<li>对每个像素附近的 4 个纹元（纹理图像像素）进行采样，其中样本通过像素对应纹元的特定偏移量选择。</li>
<li>对于每个像素，都需要改变偏移量，并用新的偏移量确定采样的 4 个纹元。</li>
<li>使用交错的方式改变偏移量的方法被称为抖动，它旨在使柔和阴影的边界不会由于采样点不足而看起来“结块”。</li>
</ul>
<p>假设有4种偏移模式，每次取一种计算像素 <code>glFragCorrd mod 2</code> 值选择当前偏移，结果可能为：(0,0)、(1,0)、(0,1)、(1,1)。</p>
<p>偏移模式通常在 x 和 y 方向上指定，具有-1.5、-0.5、+0.5和+1.5不同组合：</p>
<p>4种计算结果对应的偏移模式采样点如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">计算结果</th>
<th style="text-align:center">(0,0)</th>
<th style="text-align:center">(0,1)</th>
<th style="text-align:center">(1,0)</th>
<th style="text-align:center">(1,1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>假设随便一组，对其4个采样点分别调用 <code>textureProj()</code>，将得到的4个结果相加求平均，确定阴影中采样点的百分比，以此百分比作系数，确定渲染当前像素时要应用的漫反射和镜面反射分量。</p>
<p>采样点可以有多个，但渲染速度也会随之下降。</p>
<p>64个采样点柔和阴影效果如下：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_softShadows.jpg" alt="柔和阴影"></p>
<p>仅需修改第二轮的片段着色器：</p>
<details><summary>fragment2.glsl</summary>
<pre><code class="language-glsl">#version 460 core

struct PositionalLight
&#123;
	vec4 ambient, diffuse, specular;
	vec3 position;
&#125;;

struct Material
&#123;
	vec4 ambient, diffuse, specular;
	float shininess;
&#125;;

in vec3 vNormal, vLightDir, vVertPos, vHalfVec;
in vec4 shadowCoord;
out vec4 fragColor;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;
uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;
uniform mat4 shadowMVP;
layout(binding = 0) uniform sampler2DShadow shadowTex;

float lookup(float ox, float oy)
&#123;
	float t = textureProj(shadowTex,
		shadowCoord + vec4(ox * 0.001 * shadowCoord.w, oy * 0.001 * shadowCoord.w,
			-0.01, 0.0));
	return t;
&#125;

void main()
&#123;
	float shadowFactor = 0.0;
	vec3 L = normalize(vLightDir);
	vec3 N = normalize(vNormal);
	vec3 V = normalize(-vVertPos);
	vec3 H = normalize(vHalfVec);

	float swidth = 2.5;	// 可调整的阴影扩散量
	// 64 个采样点
	float endp = swidth * 3.0 + swidth / 2.0;
	for (float m = -endp; m &lt;= endp; m += swidth)
		for (float n = -endp; n &lt;= endp; n += swidth)
			shadowFactor += lookup(m, n);

	shadowFactor /= 64.0;

	vec4 shadowColor = globalAmbient * material.ambient + light.ambient * material.ambient;
	vec4 lightedColor = light.diffuse * material.diffuse * max(dot(L, N), 0.0) +
		light.specular * material.specular *
		pow(max(dot(H, N), 0.0), material.shininess * 3.0);

	fragColor = vec4((shadowColor.xyz + shadowFactor * (lightedColor.xyz)), 1.0);
&#125;
</code></pre>
</details>
<p>有些时候，在场景中的某些对象拥有纹理时，添加阴影时必须确保片段着色器正确区分阴影纹理和其他纹理。一种简单的方法是将它们绑定到不同的纹理单元：</p>
<pre><code class="language-glsl">layout(binding = 0) uniform sampler2DShadow shadowTex;
layout(binding = 1) uniform sampler2D tex;
</code></pre>
<p>然后通过绑定值引用两个采样器。</p>
<p>当场景使用多个灯光时，则需要多个阴影纹理，即每个光源需要一个阴影纹理。</p>
<ul>
<li>每个光源都需要单独执行第 1 轮渲染，并在第 2 轮渲染中合并结果。</li>
</ul>
<h2 id="九-天空和背景">九、天空和背景</h2>
<h3 id="9-1-天空盒">9.1 天空盒</h3>
<p>天空盒：</p>
<ol>
<li>实例化一个立方体对象</li>
<li>将立方体的纹理设置为所需的环境</li>
<li>将立方体围绕相机设置</li>
</ol>
<p>如何为地平线制作纹理：</p>
<ul>
<li>使用一个包含6个面的纹理图像。</li>
<li>可使用 Terragen、Blender、PS等软件工具辅助构建贴图图像。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_cubeTexCoord.png" alt="立方体贴图纹理坐标"></p>
<p>如何让天空盒看起来距离很远：</p>
<ul>
<li>确保纹理表现看起来像远处的地平线。</li>
<li>禁用深度测试并先渲染天空盒，然后启用深度测试再渲染其他对象。
<ul>
<li>深度缓冲区的值仍全设为1.0（最远距离）。</li>
</ul>
</li>
<li>使天空盒随着相机移动。</li>
</ul>
<h3 id="9-2-穹顶">9.2 穹顶</h3>
<p>与天空盒类似，不过使用带纹理的球体或半球体代替带纹理的立方体。</p>
<p>一样需要先禁用深度测试渲染穹顶，再将相机置于穹顶的中心位置。</p>
<p>穹顶相比天空盒：</p>
<ul>
<li>优点：不易受到畸变和接缝的影响（尽管在纹理图像<br>
中必须考虑极点处的球形畸变）。</li>
<li>缺点：球体或穹顶模型比立方体模型更复杂，穹顶有更多的顶点，其数量取决于期望的精度。</li>
</ul>
<h3 id="9-3-实现天空盒">9.3 实现天空盒</h3>
<h4 id="9-3-1-从头开始构建天空盒">9.3.1 从头开始构建天空盒</h4>
<p>效果如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_skybox.jpg" alt="天空盒"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

const int numVAO = 1, numVBO = 5;
GLuint vao[numVAO], vbo[numVBO];

GLuint renderProgram;

int width, height;
float aspect;

GLuint mvLoc, projLoc;
GLuint textureID, skyboxTex;

glm::mat4 pMat, vMat, mMat, mvMat;

// 模型相关
//Sphere model(48);
Torus model(48, 0.5f, 0.2f);
// 加载的模型还不能使用索引
//ImportedModel model2(&quot;model/pyr.obj&quot;);

// 位置相关
glm::vec3 cameraLoc(0.0f, 0.0f, 5.0f);
glm::vec3 modelLoc(0.0f, -0.75, 0.0f);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
	// 立方体天空盒
	float cubeVertexPositions[108] =
	&#123;
		-1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
		-1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
	&#125;;
	float cubeTextureCoord[72] =
	&#123;
		1.00f, 0.666666f, 1.00f, 0.333333f, 0.75f, 0.333333f,
		0.75f, 0.333333f, 0.75f, 0.666666f, 1.00f, 0.666666f,
		0.75f, 0.333333f, 0.50f, 0.333333f, 0.75f, 0.666666f,
		0.50f, 0.333333f, 0.50f, 0.666666f, 0.75f, 0.666666f,
		0.50f, 0.333333f, 0.25f, 0.333333f, 0.50f, 0.666666f,
		0.25f, 0.333333f, 0.25f, 0.666666f, 0.50f, 0.666666f,
		0.25f, 0.333333f, 0.00f, 0.333333f, 0.25f, 0.666666f,
		0.00f, 0.333333f, 0.00f, 0.666666f, 0.25f, 0.666666f,
		0.25f, 0.333333f, 0.50f, 0.333333f, 0.50f, 0.000000f,
		0.50f, 0.000000f, 0.25f, 0.000000f, 0.25f, 0.333333f,
		0.25f, 1.000000f, 0.50f, 1.000000f, 0.50f, 0.666666f,
		0.50f, 0.666666f, 0.25f, 0.666666f, 0.25f, 1.000000f,
	&#125;;

	std::vector&lt;int&gt; modelInd = model.getIndices();
	std::vector&lt;glm::vec3&gt; vert = model.getVertices();
	std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
	std::vector&lt;glm::vec3&gt; norm = model.getNormals();

	std::vector&lt;float&gt; modelPvalues;	// 顶点位置
	std::vector&lt;float&gt; modelTvalues;	// 纹理坐标
	std::vector&lt;float&gt; modelNvalues;	// 法向量

	for (int i = 0; i &lt; model.getNumVertices(); ++ i)
	&#123;
		modelPvalues.push_back(vert[i].x);
		modelPvalues.push_back(vert[i].y);
		modelPvalues.push_back(vert[i].z);
		modelTvalues.push_back(tex[i].s);
		modelTvalues.push_back(tex[i].t);
		modelNvalues.push_back(norm[i].x);
		modelNvalues.push_back(norm[i].y);
		modelNvalues.push_back(norm[i].z);
	&#125;
	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);
	glGenBuffers(numVBO, vbo);

	// 天空盒
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(cubeTextureCoord), cubeTextureCoord, GL_STATIC_DRAW);
	// model
	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ARRAY_BUFFER, 4 * modelPvalues.size(), &amp;modelPvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glBufferData(GL_ARRAY_BUFFER, 4 * modelTvalues.size(), &amp;modelTvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * modelInd.size(), &amp;modelInd[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();
	textureID = Util::loadTexture(&quot;textureImg/brick1.jpg&quot;);
	skyboxTex = Util::loadTexture(&quot;textureImg/alien.jpg&quot;);

	glBindTexture(GL_TEXTURE_2D, textureID);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));

	// 天空盒
	glUseProgram(renderProgram);
	// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置
	mMat = glm::translate(glm::mat4(1.0f), cameraLoc);
	mvMat = vMat * mMat;

	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, skyboxTex);

	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);    // 观察立方体内部，反转方向
	glDisable(GL_DEPTH_TEST);
	// 无深度测试下绘制天空盒
	glDrawArrays(GL_TRIANGLES, 0, 36);
	glEnable(GL_DEPTH_TEST);

	// 绘制场景对象
	glUseProgram(renderProgram);
	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

	mMat = glm::translate(glm::mat4(1.0f), modelLoc);
	mMat = glm::rotate(mMat, glm::radians(15.0f), glm::vec3(1.0f, 0.0f, 0.0f));
	mvMat = vMat * mMat;

	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, textureID);

	glClear(GL_DEPTH_BUFFER_BIT);
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glDepthFunc(GL_LEQUAL);
	glDrawArrays(GL_TRIANGLES, 0, 36);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);
	glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
	if (!glfwInit())	exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Skybox&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)	exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-glsl">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec2 texCoord;
out vec2 tc;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

void main()
&#123;
	tc = texCoord;
	gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment.glsl
#version 460 core

in vec2 tc;
out vec4 fragColor;

layout(binding = 0) uniform sampler2D s;

void main()
&#123;
	fragColor = texture(s, tc);
&#125;
</code></pre>
</details>
<h4 id="9-3-2-使用opengl立方体贴图">9.3.2 使用OpenGL立方体贴图</h4>
<p>OpenGL 纹理立方体贴图使用带有 3 个变量的纹理坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s, t, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 访问。</p>
<p>立方体贴图的另一个特性是，其中的图像以纹理图像的左上角作为纹理坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p>
<p>另外定义函数 <code>loadCubeMap()</code> 函数读入6个单独的立方体面图像文件，以这种形式再调用 <code>SOIL_load_OGL_cubemap()</code> 进行构建纹理。该函数置于 <code>Util</code> 类中。</p>
<p>效果截图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_skybox2.jpg" alt="天空盒"></p>
<p>代码如下：</p>
<details><summary>新增函数</summary>
<pre><code class="language-cpp">GLuint Util::loadCubeMap(const std::string &amp;mapDirPath)
&#123;
	GLuint textureRef;
	std::string xp = mapDirPath + &quot;/xp.jpg&quot;;
	std::string xn = mapDirPath + &quot;/xn.jpg&quot;;
	std::string yp = mapDirPath + &quot;/yp.jpg&quot;;
	std::string yn = mapDirPath + &quot;/yn.jpg&quot;;
	std::string zp = mapDirPath + &quot;/zp.jpg&quot;;
	std::string zn = mapDirPath + &quot;/zn.jpg&quot;;
	textureRef = SOIL_load_OGL_cubemap(xp.c_str(), xn.c_str(), yp.c_str(), yn.c_str(), zp.c_str(), zn.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_MIPMAPS);
	if (textureRef == 0)	std::cout &lt;&lt; &quot;Failed to load texture: &quot; &lt;&lt; mapDirPath &lt;&lt; &quot;\n&quot;;
	return textureRef;
&#125;
</code></pre>
</details>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

GLuint renderProgram, renderProgramCubeMap;

int width, height;
float aspect;

GLuint mvLoc, projLoc, vLoc;
GLuint textureID, skyboxTex;

glm::mat4 pMat, vMat, mMat, mvMat;

// 模型相关
//Sphere model(48);
Torus model(48, 0.8f, 0.4f);
// 加载的模型还不能使用索引
//ImportedModel model2(&quot;model/pyr.obj&quot;);

// 位置相关
glm::vec3 cameraLoc(0.0f, 0.0f, 5.0f);
glm::vec3 modelLoc(0.0f, 0.0f, 0.0f);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
	// 立方体天空盒
	float cubeVertexPositions[108] =
	&#123;
		-1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
		-1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
	&#125;;

	std::vector&lt;int&gt; modelInd = model.getIndices();
	std::vector&lt;glm::vec3&gt; vert = model.getVertices();
	std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
	std::vector&lt;glm::vec3&gt; norm = model.getNormals();

	std::vector&lt;float&gt; modelPvalues;	// 顶点位置
	std::vector&lt;float&gt; modelTvalues;	// 纹理坐标
	std::vector&lt;float&gt; modelNvalues;	// 法向量

	for (int i = 0; i &lt; model.getNumVertices(); ++ i)
	&#123;
		modelPvalues.push_back(vert[i].x);
		modelPvalues.push_back(vert[i].y);
		modelPvalues.push_back(vert[i].z);
		modelTvalues.push_back(tex[i].s);
		modelTvalues.push_back(tex[i].t);
		modelNvalues.push_back(norm[i].x);
		modelNvalues.push_back(norm[i].y);
		modelNvalues.push_back(norm[i].z);
	&#125;
	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);
	glGenBuffers(numVBO, vbo);

	// 天空盒
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);
	// model
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, 4 * modelPvalues.size(), &amp;modelPvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ARRAY_BUFFER, 4 * modelTvalues.size(), &amp;modelTvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * modelInd.size(), &amp;modelInd[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
	renderProgramCubeMap = Util::createShadeProgram(&quot;vertexCubeMap.glsl&quot;, &quot;fragmentCubeMap.glsl&quot;);

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();
	textureID = Util::loadTexture(&quot;textureImg/brick1.jpg&quot;);
	skyboxTex = Util::loadCubeMap(&quot;textureImg/cubeMap&quot;);
    // 尝试混合立方体相邻的边以减少或消除接缝
	glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);

	glBindTexture(GL_TEXTURE_2D, textureID);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));

	// 天空盒
	glUseProgram(renderProgramCubeMap);
	// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置

	vLoc = glGetUniformLocation(renderProgramCubeMap, &quot;v_matrix&quot;);
	glUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(vMat));

	projLoc = glGetUniformLocation(renderProgramCubeMap, &quot;p_matrix&quot;);
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTex);

	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glDisable(GL_DEPTH_TEST);
	// 无深度测试下绘制天空盒
	glDrawArrays(GL_TRIANGLES, 0, 36);
	glEnable(GL_DEPTH_TEST);

	// 绘制场景对象
	glUseProgram(renderProgram);
	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);

	mMat = glm::translate(glm::mat4(1.0f), modelLoc);
	mMat = glm::rotate(mMat, glm::radians(35.0f), glm::vec3(1.0f, 0.0f, 0.0f));
	mvMat = vMat * mMat;

	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, textureID);

	glClear(GL_DEPTH_BUFFER_BIT);
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glDepthFunc(GL_LEQUAL);
	glDrawArrays(GL_TRIANGLES, 0, 36);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
	glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
	if (!glfwInit())	exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Skybox&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)	exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>立方体贴图着色器</summary>
<pre><code class="language-glsl">// vertexCubeMap.glsl
#version 460 core

layout(location = 0) in vec3 vertPos;
out vec3 tc;

uniform mat4 v_matrix;
uniform mat4 p_matrix;

void main()
&#123;
	tc = vertPos;
	mat4 v3_matrix = mat4(mat3(v_matrix));
    // 大小转换为 3×3，然后转换回 4×4。移除了平移分量，同时保留了旋转（平移值在转换矩阵的第四列中）
	gl_Position = p_matrix * v3_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragmentCubeMap.glsl
#version 460 core

in vec3 tc;
out vec4 fragColor;

layout(binding = 0) uniform samplerCube samp;

void main()
&#123;
	fragColor = texture(samp, tc);
&#125;
</code></pre>
</details>
<details><summary>描绘场景的着色器</summary>
<pre><code class="language-glsl">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec2 texCoord;
out vec2 tc;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

void main()
&#123;
	tc = texCoord;
	gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment.glsl
#version 460 core

in vec2 tc;
out vec4 fragColor;

layout(binding = 0) uniform sampler2D s;

void main()
&#123;
	fragColor = texture(s, tc);
&#125;
</code></pre>
</details>
<h3 id="9-4-环境贴图">9.4 环境贴图</h3>
<p>环境贴图：使用立方体贴图来构造反射对象本身。</p>
<ul>
<li>在光照时计算过反射向量，现在使用反射向量从纹理贴图中查找值。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_envmap.gif" alt="环境贴图例子"></p>
<p>仍然需要两组着色器，一组用于立方体贴图，一组用于场景物体（环面）。</p>
<p>程序上：</p>
<ul>
<li><code>makeVertexArray()</code> 函数中：
<ul>
<li>构建环面的法向量缓冲区</li>
<li>去掉环面的纹理坐标缓冲区</li>
</ul>
</li>
<li><code>display()</code> 函数中：
<ul>
<li>创建变换法向量的矩阵并关联到统一变量</li>
<li>激活环面法向量缓冲区</li>
<li>激活立方体贴图为环面的纹理</li>
</ul>
</li>
<li>顶点着色器中：
<ul>
<li>输出变换的顶点和法向量，用于计算反射向量</li>
</ul>
</li>
<li>片段着色器中：
<ul>
<li>计算反射向量</li>
<li>从立方体贴图使用反射向量检索输出颜色</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

GLuint renderProgram, renderProgramCubeMap;

int width, height;
float aspect;

GLuint mvLoc, projLoc, vLoc, nLoc;
GLuint skyboxTex;

float rotAmt;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;

// 模型相关
//Sphere model(48);
Torus model(48, 0.8f, 0.4f);
// 加载的模型还不能使用索引
//ImportedModel model2(&quot;model/pyr.obj&quot;);

// 位置相关
glm::vec3 cameraLoc(0.0f, 0.0f, 5.0f);
glm::vec3 modelLoc(0.0f, 0.0f, 0.0f);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void makeVertexArray()
&#123;
	// 立方体天空盒
	float cubeVertexPositions[108] =
	&#123;
		-1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,
		-1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f
	&#125;;

	std::vector&lt;int&gt; modelInd = model.getIndices();
	std::vector&lt;glm::vec3&gt; vert = model.getVertices();
	std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
	std::vector&lt;glm::vec3&gt; norm = model.getNormals();

	std::vector&lt;float&gt; modelPvalues;	// 顶点位置
	std::vector&lt;float&gt; modelTvalues;	// 纹理坐标
	std::vector&lt;float&gt; modelNvalues;	// 法向量

	for (int i = 0; i &lt; model.getNumVertices(); ++ i)
	&#123;
		modelPvalues.push_back(vert[i].x);
		modelPvalues.push_back(vert[i].y);
		modelPvalues.push_back(vert[i].z);
		modelTvalues.push_back(tex[i].s);
		modelTvalues.push_back(tex[i].t);
		modelNvalues.push_back(norm[i].x);
		modelNvalues.push_back(norm[i].y);
		modelNvalues.push_back(norm[i].z);
	&#125;
	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);
	glGenBuffers(numVBO, vbo);

	// 天空盒
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);
	// model
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, 4 * modelPvalues.size(), &amp;modelPvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ARRAY_BUFFER, 4 * modelTvalues.size(), &amp;modelTvalues[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * modelInd.size(), &amp;modelInd[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram = Util::createShadeProgram(&quot;vertex.glsl&quot;, &quot;fragment.glsl&quot;);
	renderProgramCubeMap = Util::createShadeProgram(&quot;vertexCubeMap.glsl&quot;, &quot;fragmentCubeMap.glsl&quot;);

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();
	skyboxTex = Util::loadCubeMap(&quot;textureImg/lakeCubeMap&quot;);
	glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));

	// 天空盒
	glUseProgram(renderProgramCubeMap);
	// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置

	vLoc = glGetUniformLocation(renderProgramCubeMap, &quot;v_matrix&quot;);
	glUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(vMat));

	projLoc = glGetUniformLocation(renderProgramCubeMap, &quot;p_matrix&quot;);
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTex);

	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glDisable(GL_DEPTH_TEST);
	// 无深度测试下绘制天空盒
	glDrawArrays(GL_TRIANGLES, 0, 36);
	glEnable(GL_DEPTH_TEST);

	// 绘制场景对象
	glUseProgram(renderProgram);
	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
	nLoc = glGetUniformLocation(renderProgram, &quot;norm_matrix&quot;);

	rotAmt = currentTime * 0.5f;
	mMat = glm::translate(glm::mat4(1.0f), modelLoc);
	mMat = glm::rotate(mMat, rotAmt, glm::vec3(1.0f, 0.0f, 0.0f));
	mvMat = vMat * mMat;
	invTrMat = glm::transpose(glm::inverse(mvMat));

	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
	glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	// 环面纹理现在是立方体贴图
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTex);

	glClear(GL_DEPTH_BUFFER_BIT);
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glDepthFunc(GL_LEQUAL);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
	glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
	if (!glfwInit())	exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Skybox&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)	exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>描绘场景的着色器</summary>
<pre><code class="language-glsl">// vertex.glsl
#version 460 core

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec3 normal;
out vec3 vNormal;
out vec3 vVertPos;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;

void main()
&#123;
	vVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;
	vNormal = (norm_matrix * vec4(normal, 0.0)).xyz;
	gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment.glsl
#version 460 core

in vec3 vVertPos;
in vec3 vNormal;
out vec4 fragColor;

layout(binding = 0) uniform samplerCube t;

void main()
&#123;
	vec3 r = -reflect(normalize(-vVertPos), normalize(vNormal));
	fragColor = texture(t, r);
&#125;
</code></pre>
</details>
<p>环境贴图的主要限制之一是它只能构建反射立方体贴图内容的对象。</p>
<ul>
<li>在场景中渲染的其他对象并不会出现在使用贴图模拟反射的对象中。</li>
<li>可以使用模板缓冲区或其他教程实现反射出多个物体的效果。</li>
</ul>
<hr>
<p>使用 SOIL2 可以很方便加载纹理贴图，但也有其他方法：</p>
<ul>
<li>使用 <code>stb_image.h</code>：
<ul>
<li>包含头文件</li>
<li>使用 <code>glGenTextures()</code> 为立方体贴图创建纹理及其 ID</li>
<li>使用 <code>glBindTexture()</code> 指定纹理 ID 和 <code>GL_TEXTURE_CUBE_MAP</code></li>
<li>使用 <code>stbi_load()</code> 加载纹理文件</li>
<li>使用 <code>glTexImage2D()</code> 将图像分配给立方体的各个面</li>
</ul>
</li>
</ul>
<p><em>SOIL2 以及包含文件 stb_image.h</em></p>
<p><em>也许Terragen对于制作贴图不错。</em></p>
<hr>
<h2 id="十-增强表面细节">十、增强表面细节</h2>
<h3 id="10-1-凹凸贴图">10.1 凹凸贴图</h3>
<p>如果想让一个物体看起来好像有凹凸，一种方法是计算表面确实凹凸不平时其上的法向量，然后模拟法向量。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_disturbNorm.png" alt="扰动法向量"></p>
<p>使用正弦函数生成凹凸不平的法向量。</p>
<ul>
<li>顶点着色器需要将未经变换的顶点传递给片段着色器</li>
</ul>
<p>效果如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_bumps.jpg" alt="过程式凹凸贴图"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 4;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint mvLoc, projLoc, nLoc;

// 光源属性
GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;
// 材质属性
GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;
glm::vec3 currentLightPos, lightPosV;    // 模型和视觉空间中的光照位置
float lightPos[3];    // 光照位置的浮点数组

// 初始化光照位置
glm::vec3 initialLightLoc = glm::vec3(5.0f, 2.0f, 2.0f);

// 白光特性
float globalAmbient[4] = &#123; 0.7f, 0.7f, 0.7f, 1.0f &#125;;
float lightAmbient[4] = &#123; 0.0f, 0.0f, 0.0f, 1.0f &#125;;
float lightDiffuse[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightSpecular[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;

float *matAmb = Util::silverAmbient();
float *matDif = Util::silverDiffuse();
float *matSpe = Util::silverSpecular();
float matShi = Util::silverShininess();

//Sphere model(48);
Torus model(48, 0.5f, 0.2f);
//ImportedModel model(&quot;unicorn.obj&quot;);

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void installLights(glm::mat4 vMatrix)
&#123;
	// 将光源位置转换为视图空间坐标，存入浮点数组
	lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));
	lightPos[0] = lightPosV.x;
	lightPos[1] = lightPosV.y;
	lightPos[2] = lightPosV.z;

	// 在着色器获取光源位置和材质属性
	globalAmbLoc = glGetUniformLocation(renderProgram, &quot;globalAmbient&quot;);
	ambLoc = glGetUniformLocation(renderProgram, &quot;light.ambient&quot;);
	diffLoc = glGetUniformLocation(renderProgram, &quot;light.diffuse&quot;);
	specLoc = glGetUniformLocation(renderProgram, &quot;light.specular&quot;);
	posLoc = glGetUniformLocation(renderProgram, &quot;light.position&quot;);
	mAmbLoc = glGetUniformLocation(renderProgram, &quot;material.ambient&quot;);
	mDifLoc = glGetUniformLocation(renderProgram, &quot;material.diffuse&quot;);
	mSpecLoc = glGetUniformLocation(renderProgram, &quot;material.specular&quot;);
	mShiLoc = glGetUniformLocation(renderProgram, &quot;material.shininess&quot;);

	// 在着色器中为光源与材质统一变量赋值
	glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);
	glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);
	glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);
	glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);
	glProgramUniform3fv(renderProgram, posLoc, 1, lightPos);
	glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);
	glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);
	glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);
	glProgramUniform1f(renderProgram, mShiLoc, matShi);
&#125;

void makeVertexArray()
&#123;
	std::vector&lt;int&gt; ind = model.getIndices();
	std::vector&lt;glm::vec3&gt; vert = model.getVertices();
	std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
	std::vector&lt;glm::vec3&gt; norm = model.getNormals();

	std::vector&lt;float&gt; pvalues;    // 顶点位置
	std::vector&lt;float&gt; tvalues;    // 纹理坐标
	std::vector&lt;float&gt; nvalues;    // 法向量

	for (int i = 0; i &lt; model.getNumVertices(); ++ i)
	&#123;
		pvalues.push_back(vert[i].x);
		pvalues.push_back(vert[i].y);
		pvalues.push_back(vert[i].z);
		tvalues.push_back(tex[i].s);
		tvalues.push_back(tex[i].t);
		nvalues.push_back(norm[i].x);
		nvalues.push_back(norm[i].y);
		nvalues.push_back(norm[i].z);
	&#125;

	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);

	glGenBuffers(numVBO, vbo);
	// 顶点坐标放入缓冲区0
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
	// 纹理坐标放入缓冲区1
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
	// 法向量放入缓冲区2
	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
	// 顶点索引放入缓冲区3
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram = Util::createShadeProgram(&quot;bumpMap/vertex.glsl&quot;, &quot;bumpMap/fragment.glsl&quot;);
	cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);
	glUseProgram(renderProgram);

	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
	nLoc = glGetUniformLocation(renderProgram, &quot;norm_matrix&quot;);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
	mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	mMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));

	// 基于当前光源位置，初始化光照
	currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);
	installLights(vMat);

	mvMat = vMat * mMat;
	// 构建 MV 矩阵的逆转置矩阵，用于变换法向量
	invTrMat = glm::transpose(glm::inverse(mvMat));

	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());
	// 利用索引 vbo3 来查找要绘制的顶点
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);
	glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
	if (!glfwInit())    exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Bumps&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-glsl">// vertex.glsl
#version 460 core

struct PositionalLight
&#123;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec3 position;
&#125;;

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec3 vertNormal;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;
uniform PositionalLight light;

out vec3 varyingNormal;
out vec3 varyingLightDir;
out vec3 varyingVertPos;
out vec3 originalVertex;

void main()
&#123;
	varyingVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;
	varyingLightDir = light.position - varyingVertPos;
	varyingNormal = (norm_matrix * vec4(vertNormal, 0.0)).xyz;
	originalVertex = vertPos;

	gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment.glsl
#version 460 core

struct PositionalLight
&#123;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec3 position;
&#125;;

struct Material
&#123;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	float shininess;
&#125;;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;

in vec3 varyingNormal;
in vec3 varyingLightDir;
in vec3 varyingVertPos;
in vec3 originalVertex;

out vec4 fragColor;

void main()
&#123;
	vec3 L = normalize(varyingLightDir);
	vec3 N = normalize(varyingNormal);
	vec3 V = normalize(-varyingVertPos);

	float a = 0.25;		// 凸起深度
	float b = 100.0;	// 凸起宽度
	float x = originalVertex.x;
	float y = originalVertex.y;
	float z = originalVertex.z;
	N.x = varyingNormal.x + a * sin(b * x);
	N.y = varyingNormal.y + a * sin(b * y);
	N.z = varyingNormal.z + a * sin(b * z);
	N = normalize(N);

	vec3 R = normalize(reflect(-L, N));

	// 计算光照与平面法向量间的角度
	float cosTheta = dot(L, N);
	// 计算法向量 N 与角平分线向量 H 之间的角度
	float cosPhi = dot(V, R);

	fragColor = globalAmbient * material.ambient +
		light.ambient * material.diffuse +
		light.diffuse * material.diffuse * max(cosTheta, 0.0) +
		light.specular * material.specular * pow(max(cosPhi, 0.0), material.shininess);
&#125;
</code></pre>
</details>
<h3 id="10-2-法线贴图">10.2 法线贴图</h3>
<p>凹凸贴图可以使用查找表来替换法向量的形式替代。</p>
<p>以查找表的方法实现凹凸细节叫作法线贴图。</p>
<p>可以将法向量存储在彩色图像文件中，恰好 RGB 三通道对应向量的 xyz。</p>
<ul>
<li>RGB 值以字节形式存储，通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</li>
<li>向量限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1,+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mi>x</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mi>y</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mi>z</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
R=(N_x+1)/2 \\
G=(N_y+1)/2 \\
B=(N_z+1)/2
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>法线贴图使用一个图像（称为法线图）文件，该图像文件包含在光照下所期望表面外观的法向量。</p>
<ul>
<li>法向量的 x 和 y 分量表示其被扰动后与“垂直”方向的偏差，z 分量设置为 1。</li>
<li>严格垂直的向量（即没有偏差）将表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p>但发现图查找到的法向量不能直接使用，因为并没有考虑法向量在物体上的位置以及在相机空间种的方向。</p>
<ul>
<li>建立转换矩阵，将法向量转换到相机空间。</li>
</ul>
<p>在对象顶点出，考虑对象的切平面，取切平面两个相互垂直的向量（切向量和副切向量），可以通过计算切向量和法向量的叉积构建副切向量。</p>
<ul>
<li>如果模型没有定义切向量，还需计算切向量。</li>
<li>对于那些表面无法求导、无法精确求解切向量的模型，其切向量可以通过近似得到。</li>
</ul>
<p>切向量一样通过 VBO 传递到顶点着色器中。</p>
<p>一旦在相机空间中得到法向量、切向量和副切向量，就可以构造矩阵（称为 TBN 矩阵）。</p>
<ul>
<li>该矩阵用于将从法线贴图中检索到的法向量转换为在相机空间中相对于物体表面的法向量。</li>
<li>在片段着色器中，新法向量的计算在 <code>calcNewNormal()</code> 函数中完成。
<ul>
<li>该函数包含 <code>dot(tangent, normal)</code> 的计算确保切向量垂直于法向量。新的切向量和法向量的叉积就是副切向量。</li>
</ul>
</li>
</ul>
<p>制作法线图可以通过 GIMP 和 PS 等工具完成。</p>
<table>
<thead>
<tr>
<th style="text-align:center">法线贴图例子</th>
<th style="text-align:center">法线图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_normMap.jpg"></td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_normalMapping.jpg"></td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 5;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint mvLoc, projLoc, nLoc;

// 光源属性
GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;
// 材质属性
GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;
glm::vec3 currentLightPos, lightPosV;    // 模型和视觉空间中的光照位置
float lightPos[3];    // 光照位置的浮点数组

// 初始化光照位置
glm::vec3 initialLightLoc = glm::vec3(-5.0f, 2.0f, 5.0f);

// 白光特性
float globalAmbient[4] = &#123; 0.7f, 0.7f, 0.7f, 1.0f &#125;;
float lightAmbient[4] = &#123; 0.0f, 0.0f, 0.0f, 1.0f &#125;;
float lightDiffuse[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightSpecular[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;

float *matAmb = Util::goldAmbient();
float *matDif = Util::goldDiffuse();
float *matSpe = Util::goldSpecular();
float matShi = Util::goldShininess();

Sphere model(48);
//Torus model(48, 0.5f, 0.2f);
//ImportedModel model(&quot;unicorn.obj&quot;);

GLuint texture;

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void installLights(glm::mat4 vMatrix)
&#123;
	// 将光源位置转换为视图空间坐标，存入浮点数组
	lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));
	lightPos[0] = lightPosV.x;
	lightPos[1] = lightPosV.y;
	lightPos[2] = lightPosV.z;

	// 在着色器获取光源位置和材质属性
	globalAmbLoc = glGetUniformLocation(renderProgram, &quot;globalAmbient&quot;);
	ambLoc = glGetUniformLocation(renderProgram, &quot;light.ambient&quot;);
	diffLoc = glGetUniformLocation(renderProgram, &quot;light.diffuse&quot;);
	specLoc = glGetUniformLocation(renderProgram, &quot;light.specular&quot;);
	posLoc = glGetUniformLocation(renderProgram, &quot;light.position&quot;);
	mAmbLoc = glGetUniformLocation(renderProgram, &quot;material.ambient&quot;);
	mDifLoc = glGetUniformLocation(renderProgram, &quot;material.diffuse&quot;);
	mSpecLoc = glGetUniformLocation(renderProgram, &quot;material.specular&quot;);
	mShiLoc = glGetUniformLocation(renderProgram, &quot;material.shininess&quot;);

	// 在着色器中为光源与材质统一变量赋值
	glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);
	glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);
	glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);
	glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);
	glProgramUniform3fv(renderProgram, posLoc, 1, lightPos);
	glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);
	glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);
	glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);
	glProgramUniform1f(renderProgram, mShiLoc, matShi);
&#125;

void makeVertexArray()
&#123;
	std::vector&lt;int&gt; ind = model.getIndices();
	std::vector&lt;glm::vec3&gt; vert = model.getVertices();
	std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
	std::vector&lt;glm::vec3&gt; norm = model.getNormals();
	std::vector&lt;glm::vec3&gt; tang = model.getTangents();

	std::vector&lt;float&gt; pvalues;    // 顶点位置
	std::vector&lt;float&gt; tvalues;    // 纹理坐标
	std::vector&lt;float&gt; nvalues;    // 法向量
	std::vector&lt;float&gt; tanvalues;  // 切线

	for (int i = 0; i &lt; model.getNumVertices(); ++ i)
	&#123;
		pvalues.push_back(vert[i].x);
		pvalues.push_back(vert[i].y);
		pvalues.push_back(vert[i].z);
		tvalues.push_back(tex[i].s);
		tvalues.push_back(tex[i].t);
		nvalues.push_back(norm[i].x);
		nvalues.push_back(norm[i].y);
		nvalues.push_back(norm[i].z);
		tanvalues.push_back(tang[i].x);
		tanvalues.push_back(tang[i].y);
		tanvalues.push_back(tang[i].z);
	&#125;

	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);

	glGenBuffers(numVBO, vbo);
	// 顶点坐标放入缓冲区0
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
	// 纹理坐标放入缓冲区1
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
	// 法向量放入缓冲区2
	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
	// 切向量放入缓冲区3
	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glBufferData(GL_ARRAY_BUFFER, 4 * tanvalues.size(), &amp;tanvalues[0], GL_STATIC_DRAW);
	// 顶点索引放入缓冲区4
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram = Util::createShadeProgram(&quot;normalMap/vertex.glsl&quot;, &quot;normalMap/fragment.glsl&quot;);
	cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();

	texture = Util::loadTexture(&quot;normalMap/castleroofNORMAL.jpg&quot;);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);
	glUseProgram(renderProgram);

	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
	nLoc = glGetUniformLocation(renderProgram, &quot;norm_matrix&quot;);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
	mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -1.0f));
	mMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));

	// 基于当前光源位置，初始化光照
	currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);
	installLights(vMat);

	mvMat = vMat * mMat;
	// 构建 MV 矩阵的逆转置矩阵，用于变换法向量
	invTrMat = glm::transpose(glm::inverse(mvMat));

	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(2);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[3]);
	glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(3);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, texture);

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());
	// 利用索引 vbo3 来查找要绘制的顶点
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);
	glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
	if (!glfwInit())    exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Bumps&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>球体类新增</summary>
<pre><code class="language-cpp">// Sphere.cpp
void Sphere::init(int _prec)
&#123;
	numVertices = (_prec + 1) * (_prec + 1);
	numIndices = _prec * _prec * 6;
	for (int i = 0; i &lt; numVertices; ++ i)
	&#123;
		vertices.push_back(glm::vec3());
		texCoords.push_back(glm::vec2());
		normals.push_back(glm::vec3());
		tangents.push_back(glm::vec3());
	&#125;

	for (int i = 0; i &lt; numIndices; ++ i)
		indices.push_back(0);

	// 计算三角形顶点
	for (int i = 0; i &lt;= _prec; ++ i)
		for (int j = 0; j &lt;= _prec; ++ j)
		&#123;
			float y = static_cast&lt;float&gt;(cos(toRadians(180.0f - i * 180.0f / _prec)));
			float x = - static_cast&lt;float&gt;(cos(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y))));
			float z = static_cast&lt;float&gt;(sin(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y))));
			vertices[i * (_prec + 1) + j] = glm::vec3(x, y, z);
			// 计算切向量（新增）
			if (((x == 0) and (y == 1) and (z == 0)) or ((x == 0) and (y == -1) and (z == 0)))
				tangents[i * (_prec + 1) + j] = glm::vec3(0.0f, 0.0f, -1.0f);
			else
				tangents[i * (_prec + 1) + j] = glm::cross(glm::vec3(0.0f, 1.0f, 0.0f), glm::vec3(x, y, z));
            // 新增上述计算切向量
			texCoords[i * (_prec + 1) + j] = glm::vec2(j * 1.0f / _prec, i * 1.0f / _prec);
			normals[i * (_prec + 1) + j] = glm::vec3(x, y, z);
		&#125;
        // ...
&#125;

std::vector&lt;glm::vec3&gt; Sphere::getTangents()
&#123;
	return tangents;
&#125;
</code></pre>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-glsl">// vertex.glsl
#version 460 core

struct PositionalLight
&#123;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec3 position;
&#125;;

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec2 texCoord;
layout(location = 2) in vec3 vertNormal;
layout(location = 3) in vec3 vertTangent;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;
uniform mat4 norm_matrix;	// 用于变换法向量
uniform PositionalLight light;

out vec3 varyingLightDir;
out vec3 varyingVertPos;
out vec3 varyingNormal;
out vec3 varyingTangent;
out vec3 originalVertex;
out vec2 tc;
out vec3 varyingHalfVector;

void main()
&#123;
	varyingVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;
	varyingLightDir = light.position - varyingVertPos;
	tc = texCoord;

	originalVertex = vertPos;

	varyingNormal = (norm_matrix * vec4(vertNormal, 0.0)).xyz;
	varyingTangent = (norm_matrix * vec4(vertTangent, 0.0)).xyz;

	varyingHalfVector = normalize(normalize(varyingLightDir) + normalize(-varyingVertPos)).xyz;

	gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment.glsl
#version 460 core

struct PositionalLight
&#123;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec3 position;
&#125;;

struct Material
&#123;
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	float shininess;
&#125;;

layout(binding = 0) uniform sampler2D nromsamp;

uniform vec4 globalAmbient;
uniform PositionalLight light;
uniform Material material;

in vec3 varyingLightDir;
in vec3 varyingNormal;
in vec3 varyingVertPos;
in vec3 varyingTangent;
in vec3 originalVertPos;
in vec2 tc;
in vec3 varyingHalfVector;

out vec4 fragColor;

vec3 calcNewNormal()
&#123;
	vec3 normal = normalize(varyingNormal);
	vec3 tangent = normalize(varyingTangent);
	tangent = normalize(tangent - dot(tangent, normal) * normal);
	vec3 bitangent = cross(normal, tangent);
	mat3 tbn = mat3(tangent, bitangent, normal);
	vec3 retrievedNormal = texture(nromsamp, tc).xyz;
	vec3 newNormal = tbn * retrievedNormal;
	newNormal = normalize(newNormal);
	return newNormal;
&#125;

void main()
&#123;
	vec3 L = normalize(varyingLightDir);
	vec3 N = calcNewNormal();
	vec3 R = normalize(reflect(-L, N));
	vec3 H = normalize(varyingHalfVector);

	// 计算光照与平面法向量间的角度
	float cosTheta = dot(L, N);
	// 计算法向量 N 与角平分线向量 H 之间的角度
	float cosPhi = dot(H, N);

	fragColor = globalAmbient * material.ambient +
		light.ambient * material.ambient +
		light.diffuse * material.diffuse * max(0.0, cosTheta) +
		light.specular * material.specular * pow(max(0.0, cosPhi), material.shininess);
&#125;
</code></pre>
</details>
<p>可以使用纹理加法线贴图，使得模型更逼真。</p>
<ul>
<li>法线贴图也可以使用多级渐远纹理贴图改善效果。</li>
<li>法线贴图的各向异性过滤更有效，它不但减少了闪烁的伪影，同时还保留了细节。</li>
</ul>
<h3 id="10-3-高度贴图">10.3 高度贴图</h3>
<p>使用纹理图像来存储高度值，然后使用该高度值来提升（或降低）顶点位置。</p>
<ul>
<li>含有高度信息的图像称为高度图。</li>
</ul>
<p>使用高度图更改对象的顶点的方法称为高度贴图。</p>
<ul>
<li>黑色为高度低，白色为高度高。</li>
</ul>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_heightMap.jpg" alt="高度贴图"></p>
<p>用于展示的高度图和纹理图如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">高度图</th>
<th style="text-align:center">纹理图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_height.jpg"></td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_ice.jpg"></td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<pre><code class="language-cpp">#include &lt;iostream&gt;
// 导入 GLEW 库
#include &lt;GL/glew.h&gt;
// 导入 GLFW 库
#include &lt;GLFW/glfw3.h&gt;
// 导入 GLM 库
#include &lt;glm/glm.hpp&gt;

#include &quot;Util.h&quot;
#include &lt;stack&gt;
#include &quot;Sphere.h&quot;
#include &quot;Torus.h&quot;
#include &quot;ImportedModel.h&quot;

GLuint renderProgram;

const int numVAO = 1, numVBO = 3;
GLuint vao[numVAO], vbo[numVBO];

int width, height;
float aspect;

double cameraX, cameraY, cameraZ;
GLuint mvLoc, projLoc, nLoc;

// 光源属性
GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;
// 材质属性
GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;

glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;
glm::vec3 currentLightPos, lightPosV;    // 模型和视觉空间中的光照位置
float lightPos[3];    // 光照位置的浮点数组

// 初始化光照位置
glm::vec3 initialLightLoc = glm::vec3(-5.0f, 2.0f, 5.0f);

// 白光特性
float globalAmbient[4] = &#123; 0.7f, 0.7f, 0.7f, 1.0f &#125;;
float lightAmbient[4] = &#123; 0.0f, 0.0f, 0.0f, 1.0f &#125;;
float lightDiffuse[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;
float lightSpecular[4] = &#123; 1.0f, 1.0f, 1.0f, 1.0f &#125;;

float *matAmb = Util::goldAmbient();
float *matDif = Util::goldDiffuse();
float *matSpe = Util::goldSpecular();
float matShi = Util::goldShininess();

//Sphere model(48);
//Torus model(48, 0.5f, 0.2f);
ImportedModel model(&quot;heightMap/grid.obj&quot;);

GLuint heightMap;
GLuint texture;

static void windowSizeCallback(GLFWwindow *window, int width, int height)
&#123;
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	glViewport(0, 0, width, height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);
&#125;

void installLights(glm::mat4 vMatrix)
&#123;
	// 将光源位置转换为视图空间坐标，存入浮点数组
	lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));
	lightPos[0] = lightPosV.x;
	lightPos[1] = lightPosV.y;
	lightPos[2] = lightPosV.z;

	// 在着色器获取光源位置和材质属性
	globalAmbLoc = glGetUniformLocation(renderProgram, &quot;globalAmbient&quot;);
	ambLoc = glGetUniformLocation(renderProgram, &quot;light.ambient&quot;);
	diffLoc = glGetUniformLocation(renderProgram, &quot;light.diffuse&quot;);
	specLoc = glGetUniformLocation(renderProgram, &quot;light.specular&quot;);
	posLoc = glGetUniformLocation(renderProgram, &quot;light.position&quot;);
	mAmbLoc = glGetUniformLocation(renderProgram, &quot;material.ambient&quot;);
	mDifLoc = glGetUniformLocation(renderProgram, &quot;material.diffuse&quot;);
	mSpecLoc = glGetUniformLocation(renderProgram, &quot;material.specular&quot;);
	mShiLoc = glGetUniformLocation(renderProgram, &quot;material.shininess&quot;);

	// 在着色器中为光源与材质统一变量赋值
	glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);
	glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);
	glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);
	glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);
	glProgramUniform3fv(renderProgram, posLoc, 1, lightPos);
	glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);
	glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);
	glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);
	glProgramUniform1f(renderProgram, mShiLoc, matShi);
&#125;

void makeVertexArray()
&#123;
	std::vector&lt;glm::vec3&gt; vert = model.getVertices();
	std::vector&lt;glm::vec2&gt; tex = model.getTexCoords();
	std::vector&lt;glm::vec3&gt; norm = model.getNormals();

	std::vector&lt;float&gt; pvalues;    // 顶点位置
	std::vector&lt;float&gt; tvalues;    // 纹理坐标
	std::vector&lt;float&gt; nvalues;    // 法向量

	for (int i = 0; i &lt; model.getNumVertices(); ++ i)
	&#123;
		pvalues.push_back(vert[i].x);
		pvalues.push_back(vert[i].y);
		pvalues.push_back(vert[i].z);
		tvalues.push_back(tex[i].s);
		tvalues.push_back(tex[i].t);
		nvalues.push_back(norm[i].x);
		nvalues.push_back(norm[i].y);
		nvalues.push_back(norm[i].z);
	&#125;

	glGenVertexArrays(numVAO, vao);
	glBindVertexArray(vao[0]);

	glGenBuffers(numVBO, vbo);
	// 顶点坐标放入缓冲区0
	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), &amp;pvalues[0], GL_STATIC_DRAW);
	// 纹理坐标放入缓冲区1
	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), &amp;tvalues[0], GL_STATIC_DRAW);
	// 法向量放入缓冲区2
	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), &amp;nvalues[0], GL_STATIC_DRAW);
&#125;

void init(GLFWwindow *window)
&#123;
	renderProgram = Util::createShadeProgram(&quot;heightMap/vertex.glsl&quot;, &quot;heightMap/fragment.glsl&quot;);
	cameraX = 0.03f; cameraY = 0.03f; cameraZ = 0.8f;

	glfwGetFramebufferSize(window, &amp;width, &amp;height);
	aspect = static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height);
	pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);

	makeVertexArray();

	texture = Util::loadTexture(&quot;textureImg/ice.jpg&quot;);
	heightMap = Util::loadTexture(&quot;heightMap/height.jpg&quot;);
&#125;

void display(GLFWwindow *window, double currentTime)
&#123;
	glClear(GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT);
	glUseProgram(renderProgram);

	mvLoc = glGetUniformLocation(renderProgram, &quot;mv_matrix&quot;);
	projLoc = glGetUniformLocation(renderProgram, &quot;proj_matrix&quot;);
	nLoc = glGetUniformLocation(renderProgram, &quot;norm_matrix&quot;);

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
	mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	mMat = glm::rotate(mMat, 15.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));

	// 基于当前光源位置，初始化光照
	currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);
	installLights(vMat);

	mvMat = vMat * mMat;
	// 构建 MV 矩阵的逆转置矩阵，用于变换法向量
	invTrMat = glm::transpose(glm::inverse(mvMat));

	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
	glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
	glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));

	glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(2);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, texture);

	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, heightMap);

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());
	// 利用索引 vbo3 来查找要绘制的顶点
	//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);
	//glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);
&#125;

int main()
&#123;
	if (!glfwInit())    exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	GLFWwindow *window = glfwCreateWindow(800, 600, &quot;Bumps&quot;, NULL, NULL);
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK)    exit(EXIT_FAILURE);
	glfwSwapInterval(1);

	glfwSetWindowSizeCallback(window, windowSizeCallback);

	init(window);

	while (!glfwWindowShouldClose(window))
	&#123;
		display(window, glfwGetTime());
		glfwSwapBuffers(window);
		glfwPollEvents();
	&#125;
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
&#125;
</code></pre>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<pre><code class="language-glsl">// vertex.glsl
#version 430

layout(location = 0) in vec3 vertPos;
layout(location = 1) in vec2 texCoord;
layout(location = 2) in vec3 vertNormal;

layout(binding = 1) uniform sampler2D h; // 高度图

out vec2 tc;

uniform mat4 mv_matrix;
uniform mat4 proj_matrix;

void main()
&#123;
	vec4 p = vec4(vertPos, 1.0) + vec4((vertNormal * ((texture(h, texCoord).r) / 5.0f)), 1.0f);
	tc = texCoord;
	gl_Position = proj_matrix * mv_matrix * p;
&#125;
</code></pre>
<pre><code class="language-glsl">// fragment.glsl
#version 460 core

in vec2 tc;
out vec4 fragColor;

layout(binding = 0)  uniform sampler2D t;	// 纹理

void main()
&#123;
	fragColor = texture(t, tc);
&#125;
</code></pre>
</details>
<p>凹凸贴图或法线贴图的一个基本限制是：</p>
<ul>
<li>虽然能够在所渲染对象的内部提供表面细节，</li>
<li>但是物体轮廓（外边界）无法显示这些细节（仍保持平滑）。</li>
</ul>
<p>高度贴图在用于实际修改顶点位置时修复了这个缺陷，但它也有其自身的局限性。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-01-09</span>
            
                <span>该篇文章被 Fingsinz</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/C/'>
                            C++
                        </a>
                    
                        <a href='/tags/OpenGL/'>
                            OpenGL
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            ©2023-2024 Fingsinz&#39;s Space 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>不忘初心，方得始终。</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    
    
    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>


    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


</html>