<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="设计模式 - C++" />
    <meta name="hexo-theme-A4" content="v1.8.9" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Fingsinz&#39;s space | 风信梓</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: white;  
        }
        body {
            color: #000000;
            background: #bed2bb;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #000000;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #000000;
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: white; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: #6b798e;
        }

        .post-md a {
            color: #6b798e;
        }

        .nav li a {
            color: #6b798e;
        }

        .archive-main a:link {
            color: #6b798e;
        }
        .archive-main a:visited {
            color: #6b798e; 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: white;
        }

        .paper {
            background: #bed2bb;
        }

        .index-main {
            background: white;
        }

        .paper-main {
            background: white;
        }

        .wl-panel {
            background: white;
        }

        .archive li:nth-child(odd) {
            background: white;
            ;
        }

        .archive li:nth-child(even) {
            background: white;
        }

        .post-md table tr:nth-child(odd) td {
            background: white;
        }

        .post-md table tr:nth-child(even) td {
            background: white;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #6b798e;
            border-left-color: #6b798e;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Fingsinz&#39;s space</a> 
            <span class="description">我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页🏚️</a></li>
            
        
            
                <li><a href="/list/">文章📄</a></li>
            
        
            
                <li><a href="/notes/">笔记📔</a></li>
            
        
            
                <li><a href="/funny/">趣事💡</a></li>
            
        
            
                <li><a href="/about/">关于🧑</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            设计模式 - C++
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">创建型模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">简单工厂模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="post-toc-text">简单工厂模式定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="post-toc-text">简单工厂模式动机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="post-toc-text">简单工厂模式结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="post-toc-text">简单工厂模式代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="post-toc-text">简单工厂模式优缺点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="post-toc-text">简单工厂模式适用环境</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="post-toc-text">简单工厂模式总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">工厂方法模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="post-toc-text">工厂方法模式定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="post-toc-text">工厂方法模式动机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="post-toc-text">工厂方法模式结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="post-toc-text">工厂方法模式代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="post-toc-text">工厂方法模式优缺点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="post-toc-text">工厂方法模式适用环境</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="post-toc-text">工厂方法模式扩展</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="post-toc-text">工厂方法模式总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">抽象工厂模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="post-toc-text">抽象工厂模式定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="post-toc-text">抽象工厂模式动机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="post-toc-text">抽象工厂模式结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="post-toc-text">抽象工厂模式代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="post-toc-text">抽象工厂模式优缺点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="post-toc-text">抽象工厂模式适用环境</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="post-toc-text">开闭原则</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="post-toc-text">抽象工厂模式总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">建造者模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="post-toc-text">建造者模式定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="post-toc-text">建造者模式动机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="post-toc-text">建造者模式结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="post-toc-text">建造者模式代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="post-toc-text">建造者模式优缺点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="post-toc-text">建造者模式适用环境</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="post-toc-text">建造者模式总结</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">结构型模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">行为型模式</span></a></li></ol>
            
        
        <div class=".article-gallery"><p>关键词：C++、设计模式</p>
<span id="more"></span>
<hr>
<blockquote>
<p><strong>Reference：</strong><br>
<a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh-cn/latest/index.html">图说设计模式</a></p>
</blockquote>
<p>软件模式是应用于软件开发领域的模式，即软件开发的总体指导思路或参照样板。</p>
<h2 id="创建型模式">创建型模式</h2>
<h3 id="简单工厂模式">简单工厂模式</h3>
<h4 id="简单工厂模式定义">简单工厂模式定义</h4>
<p>简单工厂模式（Simple Factory Pattern），又称为静态工厂模式（Static Factory Pattern），属于创建型模式。</p>
<ul>
<li>专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父亲。</li>
<li>可以根据参数的不同返回不同类的实例。</li>
</ul>
<h4 id="简单工厂模式动机">简单工厂模式动机</h4>
<p>考虑一个界面，其中可以有多个按钮，每个按钮可以对应不同的功能。</p>
<ul>
<li>这些按钮都源自同一个基类，通过继承基类后修改部分属性和方法使得呈现不同的表现。</li>
<li>在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象。</li>
</ul>
<h4 id="简单工厂模式结构">简单工厂模式结构</h4>
<p>简单工厂模式包含以下角色：</p>
<ul>
<li>Factory（工厂角色）：负责实现创建所有实例的内部逻辑。</li>
<li>Product（抽象产品角色）：是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。</li>
<li>ConcreteProduct（具体产品角色）：是创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_SimpleFactory.png" title="简单工厂模式" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_SimpleFactory.png" alt="简单工厂模式"></a></p>
<h4 id="简单工厂模式代码">简单工厂模式代码</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/tree/master/SimpleFactory">Gitee</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/tree/master/SimpleFactory">Github</a></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Factory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Product.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Product *product = Factory::<span class="built_in">createProduct</span>(<span class="string">"ProductA"</span>);</span><br><span class="line">	product-&gt;<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> product;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="简单工厂模式优缺点">简单工厂模式优缺点</h4>
<p>优点：</p>
<ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>可以通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<h4 id="简单工厂模式适用环境">简单工厂模式适用环境</h4>
<ul>
<li>工厂类负责创建的对象比较少：
<ul>
<li>由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
</ul>
</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：
<ul>
<li>客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
</li>
</ul>
<h4 id="简单工厂模式总结">简单工厂模式总结</h4>
<ol>
<li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li>
<li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。
<ul>
<li>可以根据参数的不同返回不同类的实例。</li>
<li>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li>
</ul>
</li>
<li>简单工厂模式包含三个角色。
<ul>
<li>工厂角色负责实现创建所有实例的内部逻辑；</li>
<li>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；</li>
<li>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>
</ul>
</li>
<li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li>
<li>简单工厂模式的优缺点：
<ul>
<li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责。</li>
<li>其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li>
</ul>
</li>
<li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心</li>
</ol>
<h3 id="工厂方法模式">工厂方法模式</h3>
<h4 id="工厂方法模式定义">工厂方法模式定义</h4>
<p>工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫虚拟构造器模式或者多态工厂模式，属于类创建型模式。</p>
<ul>
<li>工厂父类负责定义创建产品对象的公共接口，工厂子类负责生成具体的产品对象。</li>
<li>将产品类的实例化操作放到工厂子类中完成。</li>
</ul>
<h4 id="工厂方法模式动机">工厂方法模式动机</h4>
<p>考虑一个界面，其中可以有多个按钮，每个按钮可以对应不同的功能。</p>
<ul>
<li>先定义一个抽象的按钮工厂类，再定义具体的工厂来去实现各种按钮。</li>
<li>如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例。</li>
</ul>
<h4 id="工厂方法模式结构">工厂方法模式结构</h4>
<p>工厂方法模式包含以下角色：</p>
<ul>
<li>Product：抽象产品。</li>
<li>ConcreteProduct：具体产品。</li>
<li>Factory：抽象工厂。</li>
<li>ConcreteFactory：具体工厂。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_FactoryMethod.png" title="工厂方法模式" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_FactoryMethod.png" alt="工厂方法模式"></a></p>
<h4 id="工厂方法模式代码">工厂方法模式代码</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/tree/master/FactoryMethod">Gitee</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/tree/master/FactoryMethod">Github</a></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Factory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ConcreteFactoryA.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ConcreteFactoryB.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Product.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Factory *factoryA = <span class="keyword">new</span> <span class="built_in">ConcreteFactoryA</span>();</span><br><span class="line">	Factory *factoryB = <span class="keyword">new</span> <span class="built_in">ConcreteFactoryB</span>();</span><br><span class="line"></span><br><span class="line">	Product *pro1 = factoryA-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">	Product *pro2 = factoryB-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line"></span><br><span class="line">	pro1-&gt;<span class="built_in">use</span>();</span><br><span class="line">	pro2-&gt;<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> factoryA;</span><br><span class="line">	<span class="keyword">delete</span> factoryB;</span><br><span class="line">	<span class="keyword">delete</span> pro1;</span><br><span class="line">	<span class="keyword">delete</span> pro2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="工厂方法模式优缺点">工厂方法模式优缺点</h4>
<p>优点：</p>
<ul>
<li>工厂方法用来创建客户所需要的产品，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
<h4 id="工厂方法模式适用环境">工厂方法模式适用环境</h4>
<ul>
<li>一个类不知道它所需要的对象的类：
<ul>
<li>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可。</li>
<li>具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
</ul>
</li>
<li>一个类通过其子类来指定创建哪个对象：
<ul>
<li>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
</ul>
</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h4 id="工厂方法模式扩展">工厂方法模式扩展</h4>
<ul>
<li>使用多个工厂方法：
<ul>
<li>在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求。</li>
</ul>
</li>
<li>产品对象的重复使用：
<ul>
<li>工厂对象将已经创建过的产品保存到一个集合（如数组、List等）中，然后根据客户对产品的请求，对集合进行查询。</li>
<li>如果有满足要求的产品对象，就直接将该产品返回客户端；</li>
<li>如果集合中没有这样的产品对象，那么就创建一个新的满足要求的产品对象，然后将这个对象在增加到集合中，再返回给客户端。</li>
</ul>
</li>
<li>多态性的丧失和模式的退化：
<ul>
<li>如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。</li>
<li>一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生了退化。</li>
<li>当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法时，工厂方法模式就退化成简单工厂模式。</li>
</ul>
</li>
</ul>
<h4 id="工厂方法模式总结">工厂方法模式总结</h4>
<ol>
<li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。</li>
<li>工厂方法模式包含四个角色：
<ul>
<li>抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；</li>
<li>具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；</li>
<li>抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；</li>
<li>具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li>
</ul>
</li>
<li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</li>
<li>工厂方法模式的优缺点：
<ul>
<li>优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；</li>
<li>其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
<li>工厂方法模式适用情况包括：
<ul>
<li>一个类不知道它所需要的对象的类；</li>
<li>一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li>
</ul>
</li>
</ol>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<h4 id="抽象工厂模式定义">抽象工厂模式定义</h4>
<p>抽象工厂（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类，属于对象创建型模式。</p>
<ul>
<li>又称为 Kit 模式。</li>
</ul>
<h4 id="抽象工厂模式动机">抽象工厂模式动机</h4>
<p>工厂方法模式：具体工厂负责生产具体产品，每一个具体工厂对应一种具体产品。但是有时候一个工程可以提供多个产品对象。</p>
<p>抽象工厂模式与工厂方法模式的区别是：</p>
<ul>
<li>工厂方法模式针对一个产品等级结构；</li>
<li>抽象工厂模式面对多个产品等级结构。</li>
</ul>
<p><em>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</em></p>
<p><em>在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</em></p>
<p>抽象工厂是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<h4 id="抽象工厂模式结构">抽象工厂模式结构</h4>
<p>抽象工厂模式包含以下角色：</p>
<ul>
<li>AbstractFactory：抽象工厂。</li>
<li>ConcreteFactory：具体工厂。</li>
<li>AbstractProduct：抽象产品。</li>
<li>ConcreteProduct：具体产品。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_AbstractFactory.png" title="抽象工厂模式" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_AbstractFactory.png" alt="抽象工厂模式"></a></p>
<h4 id="抽象工厂模式代码">抽象工厂模式代码</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/tree/master/AbstractFactory">Gitee</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/tree/master/AbstractFactory">Github</a></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AbstractFactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AbstractProductA.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AbstractProductB.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ConcreteFactory1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ConcreteFactory2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	AbstractFactory *factory1 = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">	AbstractProductA *productA1 = factory1-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">	AbstractProductB *productB1 = factory1-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">	productA1-&gt;<span class="built_in">use</span>();</span><br><span class="line">	productB1-&gt;<span class="built_in">eat</span>();</span><br><span class="line"></span><br><span class="line">	AbstractFactory *factory2 = <span class="keyword">new</span> <span class="built_in">ConcreteFactory2</span>();</span><br><span class="line">	AbstractProductA *productA2 = factory2-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">	AbstractProductB *productB2 = factory2-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">	productA2-&gt;<span class="built_in">use</span>();</span><br><span class="line">	productB2-&gt;<span class="built_in">eat</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> factory1;</span><br><span class="line">	<span class="keyword">delete</span> factory2;</span><br><span class="line">	<span class="keyword">delete</span> productA1;</span><br><span class="line">	<span class="keyword">delete</span> productB1;</span><br><span class="line">	<span class="keyword">delete</span> productA2;</span><br><span class="line">	<span class="keyword">delete</span> productB2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="抽象工厂模式优缺点">抽象工厂模式优缺点</h4>
<p>优点：</p>
<ul>
<li>所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li>
<li>产品族中的多个对象被设计成一起工作时，能够保证客户端始终只使用同一个产品族中的对象。</li>
<li>增加新的具体工厂和产品族很方便，符合“开闭原则”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。
<ul>
<li>因为抽象工厂角色中规定了所有可能被创建的产品集合。</li>
<li>支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
</ul>
</li>
<li>增加新的工厂和产品族容易，增加新的产品等级结构麻烦。</li>
</ul>
<h4 id="抽象工厂模式适用环境">抽象工厂模式适用环境</h4>
<p>使用抽象工厂模式：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<p>在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</p>
<h4 id="开闭原则">开闭原则</h4>
<p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<ol>
<li>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</li>
<li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</li>
</ol>
<h4 id="抽象工厂模式总结">抽象工厂模式总结</h4>
<ul>
<li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</li>
<li>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li>
</ul>
<ol>
<li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</li>
<li>抽象工厂模式包含四个角色：
<ul>
<li>抽象工厂用于声明生成抽象产品的方法；</li>
<li>具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；</li>
<li>抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；</li>
<li>具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li>
</ul>
</li>
<li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</li>
<li>抽象工厂模式的优缺点：
<ul>
<li>主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；</li>
<li>主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
</ul>
</li>
<li>抽象工厂模式适用情况包括：
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族；</li>
<li>属于同一个产品族的产品将在一起使用；</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
</li>
</ol>
<h3 id="建造者模式">建造者模式</h3>
<h4 id="建造者模式定义">建造者模式定义</h4>
<p>建造者模式（Builder Pattern，生成器模式）是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。属于对象创建型模式。</p>
<ul>
<li>一步步创建一个复杂的对象。</li>
</ul>
<h4 id="建造者模式动机">建造者模式动机</h4>
<p>比如汽车，包括车轮、方向盘、发动机等各个部件。可以通过建造者模式对其进行设计与描述，将部件和其组装过程粉卡，一步步创建一个复杂的对象。</p>
<p>软件开发中也有像汽车一样的复杂对象，拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。</p>
<ul>
<li>而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</li>
</ul>
<p>复杂对象相当于一辆汽车，对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。建造者返回给客户端的是一个已经建造完毕的完整产品对象。</p>
<h4 id="建造者模式结构">建造者模式结构</h4>
<p>建造者模式包含以下角色：</p>
<ul>
<li>Builder：抽象建造者。</li>
<li>ConcreteBuilder：具体建造者。</li>
<li>Director：指挥者。</li>
<li>Product：产品角色。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Builder.png" title="建造者模式" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Builder.png" alt="建造者模式"></a></p>
<h4 id="建造者模式代码">建造者模式代码</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/tree/master/Builder">Gitee</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/tree/master/Builder">Github</a></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ConcreteBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Director.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Builder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Product.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ConcreteBuilder *builder = <span class="keyword">new</span> <span class="built_in">ConcreteBuilder</span>();</span><br><span class="line">	Director *director = <span class="keyword">new</span> <span class="built_in">Director</span>();</span><br><span class="line">	director-&gt;<span class="built_in">setBuilder</span>(builder);</span><br><span class="line"></span><br><span class="line">	Product pd = director-&gt;<span class="built_in">construct</span>();</span><br><span class="line">	pd.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> builder;</span><br><span class="line">	<span class="keyword">delete</span> director;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="建造者模式优缺点">建造者模式优缺点</h4>
<p>优点：</p>
<ul>
<li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，用户使用不同的具体建造者即可得到不同的产品对象。</li>
<li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h4 id="建造者模式适用环境">建造者模式适用环境</h4>
<p>在以下情况下可以使用建造者模式：</p>
<ul>
<li>需要生成的产品对象有复杂的内部结构，且通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h4 id="建造者模式总结">建造者模式总结</h4>
<p>建造者模式的简化：当系统中只需要一个具体建造者</p>
<ul>
<li>省略抽象建造者</li>
<li>省略指挥者
<ul>
<li>当系统中只需要一个具体建造者，让 Builder 角色扮演指挥者与建造者双重角色。</li>
</ul>
</li>
</ul>
<p>与抽象工厂模式的比较：</p>
<ul>
<li>建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。
<ul>
<li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式。</li>
<li>建造者模式包含如下四个角色：
<ul>
<li>抽象建造者为创建一个产品对象的各个部件指定抽象接口；</li>
<li>具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；</li>
<li>产品角色是被构建的复杂对象，包含多个组成部件；</li>
<li>指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。</li>
</ul>
</li>
<li>在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：
<ul>
<li>一方面它隔离了客户与生产过程；</li>
<li>另一方面它负责控制产品的生成过程。</li>
<li>指挥者针对抽象建造者编程，客户端可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li>
</ul>
</li>
<li>建造者模式的优缺点：
<ul>
<li>主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；</li>
<li>主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
</li>
<li>建造者模式适用情况包括：
<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序；</li>
<li>对象的创建过程独立于创建该对象的类；</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li>
</ul>
</li>
</ul>
<h2 id="结构型模式">结构型模式</h2>
<h2 id="行为型模式">行为型模式</h2>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-03-24</span>
            
                <span>该篇文章被 Fingsinz</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/C/'>
                            C++
                        </a>
                    
                        <a href='/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/'>
                            设计模式
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            ©2023-2024 

            
                

            
                
                    / <a href="/"> Fingsinz&#39;s Space </a>
                

            
                
                    / <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/fingsinz"> 知乎 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


</html>