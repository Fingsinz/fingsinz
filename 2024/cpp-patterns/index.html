
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.0" theme-name="Stellar" theme-version="1.33.0">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>设计模式 - C++ - Fingsinz</title>

  
  <meta name="description" content="关键词：C++、设计模式">
  
  <meta name="keywords" content="CPP,设计模式">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.0">


  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Fingsinz","sameAs":[],"image":"/images/avatar.jpg"},"dateCreated":"2024-03-24T21:01:22+08:00","dateModified":"2024-08-07T14:15:18+08:00","datePublished":"2024-03-24T21:01:22+08:00","description":"关键词：C++、设计模式","headline":"设计模式 - C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://fingsinz.space/2024/cpp-patterns/"},"publisher":{"@type":"Organization","name":"Fingsinz","sameAs":[],"image":"/images/avatar.jpg","logo":{"@type":"ImageObject","url":"/images/avatar.jpg"}},"url":"https://fingsinz.space/2024/cpp-patterns/","keywords":"CPP, 设计模式","image":[]}</script>
  
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">Fingsinz</div><div class="sub cap">Fingsinz's space</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#c7c6b6"><span>博客</span></a><a class="nav-item" title="文档" href="/docs/" style="color:#a72126"><span>文档</span></a><a class="nav-item" title="探索" href="/explore/" style="color:#12264f"><span>探索</span></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>

<widget class="widget-wrapper markdown"><div class="widget-body fs14"><p>欢迎来到我的博客<br>
博客📄：一些小文章<br>
笔记📔：个人学习记录<br>
文档🗂️：一些项目的文档<br>
探索💡：一些发现</p>

<div class="linklist center" style="grid-template-columns:repeat(1,1fr);">
<a class="link" title="Github" target="_blank" rel="noopener" href="https://github.com/Fingsinz"><div class="flex"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/><span>Github</span></div></a></div></div></widget>


</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-03-24T13:01:22.000Z">2024-03-24</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-08-07T06:15:18.663Z">2024-08-07</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>设计模式 - C++</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>关键词：C++、设计模式</p>
<span id="more"></span>
<hr>
<blockquote>
<p>Reference：<a target="_blank" rel="noopener" href="https://kamacoder.com/designpattern.php">卡码网KamaCoder - 设计模式精讲 - https://kamacoder.com/designpattern.php</a></p>
</blockquote>
<h2 id="创建型设计模式">创建型设计模式</h2>
<h3 id="单例模式">单例模式</h3>
<p>单例模式是<strong>创建型设计模式</strong>，保证一个类只有一个实例，并提供全局访问方法实现这个实例。</p>
<h4 id="单例模式的使用情形">单例模式的使用情形</h4>
<ol>
<li>资源共享：多个模块共享某个资源的时候，比如需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。</li>
<li>只有一个实例。</li>
<li>懒加载：对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用。</li>
</ol>
<h4 id="单例模式的优点">单例模式的优点</h4>
<ol>
<li>全局控制：保证只有一个实例，这样就可以严格的控制怎样访问它以及何时访问它。</li>
<li>节省资源：避免多次创建了相同的对象，从⽽节省了系统资源，⽽且多个模块还可以通过单例实例共享数据。</li>
<li>懒加载：可以实现懒加载，需要时才实例化。</li>
</ol>
<h4 id="单例模式的基本原则">单例模式的基本原则</h4>
<ol>
<li>不允许外部代码创建实例。</li>
<li>唯一实例保存在私有静态变量中。</li>
<li>通过公有静态方法获取唯一实例。</li>
</ol>
<h4 id="单例模式的实现">单例模式的实现</h4>
<ol>
<li>饿汉式：类加载时就完成了实例创建。</li>
<li>懒汉式：需要使用实例时在创建。
<ul>
<li>多个线程同时获取实例时，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建。这个时候需要使用同步机制。</li>
</ul>
</li>
</ol>
<p>单例模式参考代码：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Singleton.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span> &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton <span class="type">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton <span class="type">const</span> &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式设计题">单例模式设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1074">【设计模式专题之单例模式】1.小明的购物车 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。</p>
<p>输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。</p>
<p>输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 “商品名称 购买数量”。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Singleton/main.cpp">Singleton/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Singleton/main.cpp">Singleton/main.cpp (gitee.com)</a></p>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p>简单工厂模式：将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。</p>
<ul>
<li>三个主要角色，工厂类、抽象产品、具体产品。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_SimpleFactory.png" alt=""></p>
<p>工厂方法模式是<strong>创建型设计模式</strong>。</p>
<ul>
<li>简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。</li>
<li>工厂方法模式引⼊了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码。</li>
</ul>
<p>工厂方法模式的角色：</p>
<ul>
<li>抽象工厂：一个接口，包含一个抽象的工厂方法。</li>
<li>具体工厂：创建具体产品。</li>
<li>抽象产品：产品的接口。</li>
<li>具体产品：实现抽象产品接口，是工厂创建的对象。</li>
</ul>
<h4 id="工厂方法模式的使用情形">工厂方法模式的使用情形</h4>
<p>工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品。当创建对象涉及一系列复杂的初始化逻 辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。</p>
<h4 id="工厂方法模式的实现">工厂方法模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_FactoryMethod.png" alt=""></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteProductA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ConcreteProductA\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteProductB</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ConcreteProductB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactoryA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactoryA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactoryB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactoryB</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式设计题">工厂方法模式设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1076">【设计模式专题之工厂方法模式】2.积木工厂 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。</p>
<p>接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 “Circle” 和 “Square” 两种。整数表示该积木生产的数量。</p>
<p>对于每个积木，输出一行字符串表示该积木的信息。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/FactoryMethod/main.cpp">FactoryMethod/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/FactoryMethod/main.cpp">FactoryMethod/main.cpp(gitee.com)</a></p>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<p>抽象工厂模式是<strong>创建型设计模式</strong>。抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用。</p>
<p>在工厂方法模式中，每个具体工厂只负责创建单一的产品。但是如果有多类产品呢，比如说“手机”，一个品牌的手机有高端机、中低端机之分，这些具体的产品都需要建立一个单独的工厂类，但是它们都是相互关联的，都共同属于同一个品牌，这就可以使用到抽象工厂模式。</p>
<p>抽象工厂模式包括多个抽象产品、多个具体产品、一个抽象工厂和多个具体工厂，每个具体工厂负责创建一组相关产品。</p>
<h4 id="简单工厂-工厂方法-抽象工厂的区别">简单工厂、工厂方法、抽象工厂的区别</h4>
<ul>
<li>
<p>简单工厂模式：一个工厂方法创建<strong>所有</strong>具体产品；</p>
</li>
<li>
<p>工厂方法模式：一个工厂方法创建<strong>一个</strong>具体产品；</p>
</li>
<li>
<p>抽象工厂模式：一个工厂方法可以创建<strong>一类</strong>具体产品。</p>
</li>
</ul>
<h4 id="工厂方法模式的使用情形">工厂方法模式的使用情形</h4>
<p>抽象工厂模式能够保证一系列相关的产品一起使⽤，并且在不修改客户端代码的情况下，可以方便地替换整个产品系列。但是当需要增加新的产品类时，除了要增加新的具体产品类，还需要修改抽象工厂及其所有的具体工厂类，扩展性相对较差。</p>
<p>典型的应用场景是使用抽象工厂模式来创建与不同数据库的连接对象。</p>
<h4 id="抽象工厂模式的实现">抽象工厂模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_AbstractFactory.png" alt=""></p>
<p>遵循以下步骤：</p>
<ul>
<li>定义（一个或多个）抽象产品，声明产品的公共方法。</li>
<li>实现具体产品类。</li>
<li>定义抽象工厂，声明一组可用于创建产品的方法。</li>
<li>实现具体工厂。</li>
<li>客户端中使用抽象工厂和抽象产品。</li>
</ul>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">AbstractProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA1</span> : <span class="keyword">public</span> ::AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductA1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ProductA1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA2</span> : <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductA2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ProductA2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB1</span> : <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductB1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eat ProductB1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB2</span> : <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductB2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eat ProductB2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactory1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactory1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactory2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactory2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂模式设计题">抽象工厂模式设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1077">【设计模式专题之抽象工厂模式】3. 家具工厂 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家新开了两个工厂用来生产家具，一个生产现代风格的沙发和椅子，一个生产古典风格的沙发和椅子，现在工厂收到了一笔订单，请你帮他设计一个系统，描述订单需要生产家具的信息。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。</p>
<p>接下来的 N 行，每行输入一个字符串，字符串表示家具的类型。家具类型分为 “modern” 和 “classical” 两种。</p>
<p>对于每笔订单，输出字符串表示该订单需要生产家具的信息。</p>
<p>modern订单会输出下面两行字符串</p>
<p>modern chair</p>
<p>modern sofa</p>
<p>classical订单会输出下面两行字符串</p>
<p>classical chair</p>
<p>classical soft</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/AbstractFactory/main.cpp">AbstractFactory/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/AbstractFactory/main.cpp">AbstractFactory/main.cpp(gitee.com)</a></p>
<h3 id="建造者模式">建造者模式</h3>
<p>建造者（生成器）模式是<strong>创建型设计模式</strong>。主要思想是将对象的构建过程分为多个步骤，每个步骤定义一个抽象接口，具体构建过程有具体建造者类完成，同时有一个指导者类负责协调建造者的工作。</p>
<p>建造者模式有以下角色：</p>
<ul>
<li>产品：被构建的负责对象，包含多个组成部分。</li>
<li>抽象建造者：定义构建产品各部分的抽象类和一个返回复杂产品的方法。</li>
<li>具体建造者：实现抽象类的方法，构建产品各部分。</li>
<li>指导者：调用具体建造者的方法，按照一定顺序或逻辑构建。</li>
</ul>
<h4 id="建造者模式的使用情形">建造者模式的使用情形</h4>
<p>比如 Junit 中的测试构建器 TestBuilder，构建测试对象。</p>
<h4 id="建造者模式的优点和缺点">建造者模式的优点和缺点</h4>
<ul>
<li>将一个复杂对象的构建与其表示分离。</li>
<li>同样的构建过程可以创建不同的表示。</li>
<li>适用于复杂对象的创建。</li>
<li>当产品的构建过程发⽣变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难。</li>
</ul>
<h4 id="建造者模式的实现">建造者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Builder.png" alt=""></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPart1</span><span class="params">(<span class="type">const</span> std::string&amp; part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPart2</span><span class="params">(<span class="type">const</span> std::string&amp; part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getProduct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="string">&quot; &quot;</span> + part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string part1;</span><br><span class="line">    std::string part2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">getProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> : <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildPart1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        product-&gt;<span class="built_in">setPart1</span>(<span class="string">&quot;Part1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildPart2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        product-&gt;<span class="built_in">setPart2</span>(<span class="string">&quot;Part2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product* <span class="title">getProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product* product = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(Builder* builder)</span> </span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildPart1</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildPart2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="建造者模式设计题">建造者模式设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1084">【设计模式专题之建造者模式】4. 自行车加工 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家新开了一家自行车工厂，用于使用自行车配件（车架 frame 和车轮 tires ）进行组装定制不同的自行车，包括山地车和公路车。</p>
<p>山地车使用的是Aluminum Frame（铝制车架）和 Knobby Tires（可抓地轮胎），公路车使用的是 Carbon Frame （碳车架）和 Slim Tries。</p>
<p>现在它收到了一笔订单，要求定制一批自行车，请你使用【建造者模式】告诉小明这笔订单需要使用那些自行车配置吧。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。</p>
<p>接下来的 N 行，每行输入一个字符串，字符串表示客户的自行车需求。</p>
<p>字符串可以包含关键词 “mountain” 或 “road”，表示客户需要山地自行车或公路自行车。</p>
<p>对于每笔订单，输出该订单定制的自行车配置。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Builder/main.cpp">Builder/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Builder/main.cpp">Builder/main.cpp(gitee.com)</a></p>
<h3 id="原型模式">原型模式</h3>
<p>原型模式是<strong>创建型设计模式</strong>。核心思想是基于现有的对象创建新的对象。</p>
<p>原型模式包含两个重点模块：</p>
<ol>
<li>抽象原型类，且具有克隆自身的方法。</li>
<li>具体原型类，实现克隆方法，复制当前对象并返回一个新对象。</li>
</ol>
<h4 id="原型模式的使用情形">原型模式的使用情形</h4>
<p>通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。</p>
<p>当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式。</p>
<p>在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。</p>
<p>原型模式的例子：</p>
<ul>
<li>Java 提供了 Object 类的  <code>clone()</code> 方法，可以实现对象的浅拷贝。类需要实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法。</li>
<li>在 .NET 中，ICloneable 接口提供了 Cloneable 接口并重写 <code>Clone</code> 方法，可以用于实现对象的克隆。</li>
<li>Spring 框架中的 Bean 的作用域之一是原型作用域（Prototype Scope），在这个作用域下，Spring 框架会为每次请求创建⼀个新的 Bean 实例，类似于原型模式。</li>
</ul>
<h4 id="原型模式的实现">原型模式的实现</h4>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Prototype</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Prototype *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> Prototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcretePrototype</span>(std::string <span class="type">const</span> &amp;data) : <span class="built_in">m_data</span>(data) &#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ConcretePrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Prototype *<span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(<span class="keyword">this</span>-&gt;m_data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原型模式设计题">原型模式设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1083">【设计模式专题之原型模式】5. 矩形原型 (kamacoder.com)</a>：</p>
<blockquote>
<p>公司正在开发一个图形设计软件，其中有一个常用的图形元素是矩形。设计师在工作时可能需要频繁地创建相似的矩形，而这些矩形的基本属性是相同的（颜色、宽度、高度），为了提高设计师的工作效率，请你使用原型模式设计一个矩形对象的原型。使用该原型可以快速克隆生成新的矩形对象。</p>
<p>首先输入一个字符串，表示矩形的基本属性信息，包括颜色、长度和宽度，用空格分隔，例如 “Red 10 5”。</p>
<p>然后输入一个整数 N（1 ≤ N ≤ 100），表示使用原型创建的矩形数量。</p>
<p>对于每个矩形，输出一行字符串表示矩形的详细信息，如 “Color: Red, Width: 10,Height: 5”。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Prototype/main.cpp">Prototype/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Prototype/main.cpp">Prototype/main.cpp(gitee.com)</a></p>
<h2 id="结构型设计模式">结构型设计模式</h2>
<h3 id="适配器模式">适配器模式</h3>
<p>适配器模式是<strong>结构型设计模式</strong>。它将一个类的接口转换成客户希望的另一个接口，充当两个不同接口的桥梁，让不兼容的类一起工作。</p>
<p>适配器模式的基本角色有：</p>
<ul>
<li>目标接口：客户端希望使用的接口。</li>
<li>适配器类：实现客户端使用的接口，包含一个需要适配的类实例，起到转接扩展的作用。</li>
<li>被适配者：需要被适配的类。</li>
</ul>
<h4 id="适配器模式的使用情形">适配器模式的使用情形</h4>
<p>扮演着补救和扩展角色。</p>
<p>不同的项目和库可能使用不同的日志框架，不同的日志框架提供的 API 也不同，因此引⼊了适配器模式使得不同的 API 适配为统一接口。</p>
<p>Spring MVC 中，<code>HandlerAdapter</code> 接口就是适配器模式，将处理器适配到框架中，使得不同类型的处理器能够统一处理请求。</p>
<h4 id="适配器模式的实现">适配器模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Adapter.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;specificRequest&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> : <span class="keyword">public</span> Target &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Adapter</span>(Adaptee *adaptee) &#123;</span><br><span class="line">		m_adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		m_adaptee-&gt;<span class="built_in">specificRequest</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Adaptee *m_adaptee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="适配器模式设计题">适配器模式设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1085">【设计模式专题之适配器模式】6. 扩展坞 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明购买了一台新电脑，该电脑使用 TypeC 接口，为了确保新电脑可以使用现有的USB接口充电器和数据线，他购买了一个TypeC到USB的扩展坞。</p>
<p>请你使用适配器模式设计并实现这个扩展坞系统，确保小明的新电脑既可以通过扩展坞使用现有的USB接口充电线和数据线，也可以使用TypeC接口充电。</p>
<p>题目包含多行输入，第一行输入一个数字 N （1 &lt; N &lt;= 20)，表示后面有N组测试数据。</p>
<p>之后N行都是一个整数，1表示使用电脑本身的TypeC接口，2表示使用扩展坞的USB接口充电。</p>
<p>根据每行输入，输出相应的充电信息。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Adapter/main.cpp">Adapter/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Adapter/main.cpp">Adapter/main.cpp(gitee.com)</a></p>
<h3 id="代理模式">代理模式</h3>
<p>代理模式是<strong>结构型设计模式</strong>，用于控制对其他对象的访问。</p>
<p>代理模式允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。</p>
<ul>
<li>通常用于在访问某对象时引入间接层（中介作用），可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。</li>
</ul>
<p>比如进行文件加载，为了避免直接访问“文件&quot;对象，可以新增一个代理对象，代理对象中有一个对“文件对象&quot;的引用，在代理对象的 <code>1oad</code> 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查，<br>
然后调用真实文件对象的 <code>1oad</code> 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。</p>
<p>代理模式的角色有：</p>
<ul>
<li>抽象主题：抽象类，声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题：定义了代理类所代表的真实对象。</li>
<li>代理类。</li>
</ul>
<h4 id="代理模式的使用情形">代理模式的使用情形</h4>
<p>代理模式可以在实际操作的前后添加一些额外的操作，但在多个对象交互之间可能会增加复杂性且降低性能。</p>
<p>代理模式在许多工具和库中也有应用：</p>
<ul>
<li>Spring 框架的 AOP 模块；</li>
<li>Java 提供动态代理机制；</li>
<li>Android 的 Glide 框架 使用代理模式实现图片的延迟加载。</li>
</ul>
<h4 id="代理模式的实现">代理模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Proxy.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;RealSubject: Handling request.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		realSubject.<span class="built_in">request</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	RealSubject realSubject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代理模式目的是控制对对象的访问，同时还可以加入一些额外的逻辑；</p>
<p>适配器模式目的是使不兼容的对象能够协同工作，将一个类的接口转换成另一个类的接口。</p>
<h4 id="代理模式的设计题">代理模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1088">【设计模式专题之代理模式】7-小明买房子 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明想要购买一套房子，他决定寻求一家房屋中介来帮助他找到一个面积超过100平方米的房子，只有符合条件的房子才会被传递给小明查看。</p>
<p>第一行是一个整数 N（1 ≤ N ≤ 100），表示可供查看的房子的数量。</p>
<p>接下来的 N 行，每行包含一个整数，表示对应房子的房屋面积。</p>
<p>对于每个房子，输出一行，表示是否符合购房条件。如果房屋面积超过100平方米，输出 “YES”；否则输出 “NO”。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Proxy/main.cpp">Proxy/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Proxy/main.cpp">Proxy/main.cpp(gitee.com)</a></p>
<h3 id="装饰模式">装饰模式</h3>
<p>装饰模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>在不定义子类的情况下动态的给对象添加⼀些额外的功能。</li>
</ul>
<p>举个例子，假设有一个基础的图形类，想要为图形类添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类。这时就可以考虑使用装饰模式来动态地添加，而不需要修改图形类本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。</p>
<p>装饰模式包含四个角色：</p>
<ul>
<li>组件：抽象类，是具体组件和装饰者的父类，定义了具体组件需要实现的方法。</li>
<li>具体组件：实现组件的具体方法，是被装饰的对象。</li>
<li>装饰类：一个抽象类，给具体组件添加功能，但具体功能由具体装饰者完成，包含一个组件对象引用。</li>
<li>具体装饰类：扩展实现装饰类，负责向组件对象添加新的行为。</li>
</ul>
<h4 id="装饰模式的使用情形">装饰模式的使用情形</h4>
<ul>
<li>不希望使用继承生成子类，给现有的类添加附加功能时；</li>
<li>动态的添加和覆盖功能。</li>
</ul>
<p>Java 的 I/O 库 中，装饰模式用于增强 I/O 的功能。</p>
<h4 id="装饰模式的实现">装饰模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Decorator.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Component</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ConcreteComponent operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Decorator</span>(Component *component) : <span class="built_in">m_component</span>(component) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		m_component-&gt;<span class="built_in">operation</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Component *m_component;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator</span>(Component *component) : <span class="built_in">Decorator</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		Decorator::<span class="built_in">operation</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ConcreteDecorator operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="装饰模式的设计题">装饰模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1086">【设计模式专题装饰模式】8-咖啡加糖 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明喜欢品尝不同口味的咖啡，他发现每种咖啡都可以加入不同的调料，比如牛奶、糖和巧克力。他决定使用装饰者模式制作自己喜欢的咖啡。</p>
<p>请设计一个简单的咖啡制作系统，使用装饰者模式为咖啡添加不同的调料。系统支持两种咖啡类型：黑咖啡（Black Coffee）和拿铁（Latte）。</p>
<p>多行输入，每行包含两个数字。第一个数字表示咖啡的选择（1 表示黑咖啡，2 表示拿铁），第二个数字表示要添加的调料类型（1 表示牛奶，2 表示糖）。</p>
<p>根据每行输入，输出制作咖啡的过程，包括咖啡类型和添加的调料。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Decorator/main.cpp">Decorator/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Decorator/main.cpp">Decorator/main.cpp(gitee.com)</a></p>
<h3 id="外观模式">外观模式</h3>
<p>外观模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>定义一个高层接口，使得子系统更容易使用，同时也隐藏了子系统。</li>
</ul>
<p>外观模式的角色有：</p>
<ul>
<li>外观类：对外的一个统一的高层接口。</li>
<li>子系统类：实现子系统的功能，处理外观类指派的任务。</li>
</ul>
<h4 id="外观模式的使用情形">外观模式的使用情形</h4>
<p>外观模式隐藏了系统的复杂性，使得客户端不需要直接与子系统交互，只需与外观接口交互即可。</p>
<p>但是如果要添加子系统或者修改子系统的行为，那么需要修改外观类，违背“开闭原则”。</p>
<p>使用外观模式的例子：</p>
<ul>
<li>Spring 框架的 <code>ApplicationContext</code> 可以看作是外观。</li>
<li>JDBC 提供了一个用于数据库交互的接口，<code>DriverManager</code> 类。</li>
<li>Android 系统的 API。</li>
</ul>
<h4 id="外观模式的实现">外观模式的实现</h4>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;operationA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;operationB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;operationC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		subSystemA.<span class="built_in">operationA</span>();</span><br><span class="line">		subSystemB.<span class="built_in">operationB</span>();</span><br><span class="line">		subSystemC.<span class="built_in">operationC</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SubSystemA subSystemA;</span><br><span class="line">	SubSystemB subSystemB;</span><br><span class="line">	SubSystemC subSystemC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="外观模式的设计题">外观模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1089">【设计模式专题之外观模式】9-电源开关 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家的电源总开关控制了家里的三个设备：空调、台灯和电视机。每个设备都有独立的开关密码，分别用数字1、2和3表示。即输入1时，空调关闭，输入2时，台灯关闭，输入3时，电视机关闭，当输入为4时，表示要关闭所有设备。请你使用外观模式编写程序来描述电源总开关的操作。</p>
<p>第一行是一个整数 N（1 &lt;= N &lt;= 100），表示后面有 N 行输入。</p>
<p>接下来的 N 行，每行包含一个数字，表示对应设备的开关操作（1表示关闭空调，2表示关闭台灯，3表示关闭电视机，4表示关闭所有设备）。</p>
<p>输出关闭所有设备后的状态，当输入的数字不在1-4范围内时，输出Invalid device code.</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Facade/main.cpp">Facade/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Facade/main.cpp">Facade/main.cpp(gitee.com)</a></p>
<h3 id="桥接模式">桥接模式</h3>
<p>桥接模式是<strong>结构型设计模式</strong>。其 UML 图很像一座桥。</p>
<ul>
<li>将抽象部分与实现部分分离，通过组合建立两个类之间的联系，而不是继承。</li>
</ul>
<p>桥接模式的角色有：</p>
<ul>
<li>抽象：抽象类，定义抽象部分的接口，维护一个对实现的引用。</li>
<li>修正抽象：对抽象类进行扩展。</li>
<li>实现：定义实现的接口，抽象化接口的实现。</li>
<li>具体实现：实现接口的具体类，实现具体操作。</li>
</ul>
<p>举个例子，图形编辑器中，每一种图形都需要蓝色、红色、黄色不同的颜色。</p>
<ul>
<li>不使用桥接模式，可能需要为每一种图形类型和每一种颜色都创建一个具体的子类；</li>
<li>使用桥接模式可以将图形和颜色两个维度分离，两个维度都可以独立进行变化和扩展，如果要新增其他颜色，只需添加新的 Co1or 子类，不影响图形类；反之亦然。</li>
</ul>
<h4 id="桥接模式的使用情形">桥接模式的使用情形</h4>
<p>使用情况：</p>
<ul>
<li>一个类存在两个独立变化的维度，且两个维度都需要扩展时；</li>
<li>不希望使用继承时。</li>
</ul>
<p>适用于多个独立变化维度，需要灵活扩展的系统。</p>
<h4 id="桥接模式的实现">桥接模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Bridge.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationA</span> : <span class="keyword">public</span> Implementation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationB</span> : <span class="keyword">public</span> Implementation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Abstraction</span>(Implementation *impl) : <span class="built_in">impl</span>(impl) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Implementation *impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> : <span class="keyword">public</span> Abstraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RefinedAbstraction</span>(Implementation *impl) : <span class="built_in">Abstraction</span>(impl) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		impl-&gt;<span class="built_in">operationImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="桥接模式的设计题">桥接模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1092">【设计模式专题之桥接模式】10-万能遥控器 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有一个万能遥控器，能够支持多个品牌的电视。每个电视可以执行开机、关机和切换频道的操作，请你使用桥接模式模拟这个操作。</p>
<p>第一行是一个整数 N（1 &lt;= N &lt;= 100），表示后面有 N 行输入。</p>
<p>接下来的 N 行，每行包含两个数字。第一个数字表示创建某个品牌的遥控和电视，第二个数字表示执行的操作。</p>
<p>其中，0 表示创建 Sony 品牌的电视，1 表示创建 TCL 品牌的遥控和电视；</p>
<p>2 表示开启电视、3表示关闭电视，4表示切换频道。</p>
<p>对于每个操作，输出相应的执行结果。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Bridge/main.cpp">Bridge/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Bridge/main.cpp">Bridge/main.cpp(gitee.com)</a></p>
<h3 id="组合模式">组合模式</h3>
<p>组合模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>将对象组合成树状结构来表示部分和整体的层次关系。</li>
</ul>
<p>组合模式使得客户端可以统一处理单个对象和对象的集合。</p>
<p>组合模式的角色有：</p>
<ul>
<li>组件：根节点，定义组合中所有对象的通用接口，定义共性内容。</li>
<li>叶子：实现组件的内容，表示组合中的叶子对象。</li>
<li>合成：存储子部件，实现对子部件的相关操作，比如添加、删除、获取子组件等。</li>
</ul>
<p>比如，省份中包含了多个城市，如果比喻成一个树形结构，城市就是叶子节点，它是省份的组成部分，而省份就是合成节点，可以包含其他城市。省份和城市都是组件，它们都有一些共同的操作，比如获取信息。</p>
<p>通过组合模式，整个省份的获取信息操作可以一次性执行，无需关心省份中的具体城市。</p>
<h4 id="组合模式的使用情形">组合模式的使用情形</h4>
<p>可以使得客户端统一处理单个对象和组合对象。适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。</p>
<h4 id="组合模式的实现">组合模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Combination.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Component</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Leaf operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点：包含叶子节点的操作行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component *component)</span> </span>&#123;</span><br><span class="line">		m_component.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Component&gt;(component));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component *component)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Composite operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;component : m_component) &#123;</span><br><span class="line">			component-&gt;<span class="built_in">operation</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;Component&gt;&gt; m_component;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合模式的设计题">组合模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1090">【设计模式专题之组合模式】11-公司组织架构 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明所在的公司内部有多个部门，每个部门下可能有不同的子部门或者员工。</p>
<p>请你设计一个组合模式来管理这些部门和员工，实现对公司组织结构的统一操作。部门和员工都具有一个通用的接口，可以获取他们的名称以及展示公司组织结构。</p>
<p>第一行是一个整数 N（1 &lt;= N &lt;= 100），表示后面有 N 行输入。</p>
<p>接下来的 N 行，每行描述一个部门或员工的信息。部门的信息格式为 D 部门名称，员工的信息格式为 E 员工名称，其中 D 或 E 表示部门或员工。</p>
<p>输出公司的组织结构，展示每个部门下的子部门和员工</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Combination/main.cpp">Combination/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Combination/main.cpp">Combination/main.cpp(gitee.com)</a></p>
<h3 id="享元模式">享元模式</h3>
<p>享元模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>对象被设计为可共享的，可被多个上下文使用。</li>
</ul>
<p>认识并区分内部状态和外部状态：</p>
<ul>
<li>内部状态：指那些可以被多个对象共享的状态，存储在享元对象内部，对于所有享元对象都是相同的，这部分状态通常是不变的。</li>
<li>外部状态：享元对象依赖的、可变的部分，这部分状态不存储在享元对象内部，而是使用享元对象时通过参数传递给对象。</li>
</ul>
<p>享元模式的角色有：</p>
<ul>
<li>抽象享元类：所以具体享元类的共享接口，包含对外部状态的操作。</li>
<li>具体享元类：继承实现享元接口，包含内部状态。</li>
<li>享元工厂类：创建并管理享元对象，当用户请求时，提供实例。</li>
<li>客户端：维护外部状态，在使用享元对象时，将外部状态传递给享元对象。</li>
</ul>
<h4 id="享元模式的使用情形">享元模式的使用情形</h4>
<p>享元模式适用于包含大量相似对象，并且这些对象的内部状态可以共享。</p>
<p>具体的应用场景包括文本编辑器，图形编辑器，游戏中的角色创建，这些对象的内部状态比较固定（外观，技能，形状），但是外部状态变化比较大时，可以使用。</p>
<h4 id="享元模式的实现">享元模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_FlyWeight.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyWeight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FlyWeight</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">(std::string externalState)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyWeight</span> : <span class="keyword">public</span> FlyWeight &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyWeight</span>(std::string <span class="type">const</span>&amp; state)</span><br><span class="line">            : <span class="built_in">m_state</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(std::string externalState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteFlyWeight: &quot;</span> &lt;&lt; m_state &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; externalState &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_state; <span class="comment">// 内部状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyWeightFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FlyWeight* <span class="title">getFlyWeight</span><span class="params">(std::string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_flyweights.<span class="built_in">find</span>(key) == m_flyweights.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            FlyWeight* flyweight = <span class="keyword">new</span> <span class="built_in">ConcreteFlyWeight</span>(key);</span><br><span class="line">            m_flyweights[key] = flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_flyweights[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, FlyWeight*&gt; m_flyweights;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="享元模式的设计题">享元模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1091">【设计模式专题之享元模式】12-图形编辑器 (kamacoder.com)</a>：</p>
<blockquote>
<p>在一个图形编辑器中，用户可以绘制不同类型的图形，包括圆形（CIRCLE）、矩形（RECTANGLE）、三角形（TRIANGLE）等。现在，请你实现一个图形绘制程序，要求能够共享相同类型的图形对象，以减少内存占用。</p>
<p>输入包含多行，每行表示一个绘制命令。每个命令包括两部分：</p>
<p>图形类型（Circle、Rectangle 或 Triangle）</p>
<p>绘制的坐标位置（两个整数，分别表示 x 和 y）</p>
<p>对于每个绘制命令，输出相应图形被绘制的位置信息。如果图形是首次绘制，输出 “drawn at”，否则输出 “shared at”。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/FlyWeight/main.cpp">FlyWeight/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/FlyWeight/main.cpp">FlyWeight/main.cpp(gitee.com)</a></p>
<h2 id="行为型设计模式">行为型设计模式</h2>
<h3 id="观察者模式">观察者模式</h3>
<p>观察者模式（发布-订阅模式）是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义了一种一对多的依赖关系，多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。</li>
</ul>
<p>观察者模式有两个角色：</p>
<ul>
<li>主题：被观察的对象，维护一组观察者，自身变化时通知观察者。</li>
<li>观察者：观察主题的对象，当主题发生变化，会得到通知。</li>
</ul>
<p>具体可以设计为四个角色：</p>
<ul>
<li>抽象主题：抽象类，提供注册、删除和通知观察者的方法，通常包含一个状态。</li>
<li>抽象观察者：抽象类，包含一个更新方法。</li>
<li>具体主题：主题的具体实现，维护一个观察者列表，实现抽象类的方法。</li>
<li>具体观察者：观察者的具体实现，每个具体观察者都注册到具体主题中，实现抽象类方法。</li>
</ul>
<p>观察者模式可以将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。</p>
<h4 id="观察者模式的使用情形">观察者模式的使用情形</h4>
<p>观察者模式特别适用于一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。</p>
<ul>
<li>图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于 GUl 框架，比如 Java 的 Swing 框架。</li>
<li>前端开发中，比较典型的例子是前端框架 Vue，当数据发生变化时，视图会自动更新。</li>
<li>分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。</li>
</ul>
<h4 id="观察者模式的实现">观察者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Observer.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer *observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer *observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ConcreteSubject</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer *observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">emplace_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer *observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer), observers.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObserver</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::string state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">        <span class="built_in">notifyObserver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer *&gt; observers;</span><br><span class="line">    std::string state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ConcreteObserver</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteObserver: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="观察者模式的设计题">观察者模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1075">【设计模式专题之观察者模式】13. 时间观察者 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明所在的学校有一个时钟（主题），每到整点时，它就会通知所有的学生（观察者）当前的时间，请你使用观察者模式实现这个时钟通知系统。</p>
<p>注意点：时间从 0 开始，并每隔一个小时更新一次。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示学生的数量。</p>
<p>接下来的 N 行，每行包含一个字符串，表示学生的姓名。</p>
<p>最后一行是一个整数，表示时钟更新的次数。</p>
<p>对于每一次时钟更新，输出每个学生的姓名和当前的时间。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Observer/main.cpp">Observer/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Observer/main.cpp">Observer/main.cpp(gitee.com)</a></p>
<h3 id="策略模式">策略模式</h3>
<p>策略模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义一系列算法（完成相同工作，实现不同），并将每个算法封装起来，可以相互替换，算法的变化不会影响使用算法的客户。</li>
</ul>
<p>策略模式的角色有：</p>
<ul>
<li>策略类：抽象类，定义所有支持的算法。</li>
<li>具体策略类：实现策略类的方法。</li>
<li>上下文类：包含一个策略实例，并在需要时调用策略对象方法。</li>
</ul>
<p>举个例子，电商网站对于商品的折扣策略有不同的算法，比如新用户满减优惠，不同等级会员的打折情况不同。</p>
<ul>
<li>
<p>一般情况下，产生大量的 if-e1se 语句，并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。</p>
</li>
<li>
<p>可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。</p>
</li>
</ul>
<h4 id="策略模式的使用情形">策略模式的使用情形</h4>
<p>使用策略模式的情形：</p>
<ul>
<li>
<p>当一个系统根据业务场景需要动态地在几种算法中选择一种时，例如，根据用户的行为选择不同的计费策略。</p>
</li>
<li>
<p>当代码中存在大量条件判断，条件判断的区别仅仅在于行为。</p>
</li>
</ul>
<p>在已有的工具库中，Java 标准库中的 Comparator 接口就使用了策略模式，通过实现这个接口，可以创建不同的比较器（指定不同的排序策略）来满足不同的排序需求。</p>
<h4 id="策略模式的实现">策略模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Strategy.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Called ConcreteStrategyA&#x27;s AlgorithmInterface&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Called ConcreteStrategyB&#x27;s AlgorithmInterface&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy)</span><br><span class="line">            : <span class="built_in">m_strategy</span>(strategy) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ContextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_strategy-&gt;<span class="built_in">AlgorithmInterface</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* m_strategy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="策略模式的设计题">策略模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1082">【设计模式专题之策略模式】14. 超市打折 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家的超市推出了不同的购物优惠策略，你可以根据自己的需求选择不同的优惠方式。其中，有两种主要的优惠策略：</p>
<ol>
<li>九折优惠策略：原价的90%。</li>
<li>满减优惠策略：购物满一定金额时，可以享受相应的减免优惠。</li>
</ol>
<p>具体的满减规则如下：</p>
<p>满100元减5元</p>
<p>满150元减15元</p>
<p>满200元减25元</p>
<p>满300元减40元</p>
<p>请你设计一个购物优惠系统，用户输入商品的原价和选择的优惠策略编号，系统输出计算后的价格。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示需要计算优惠的次数。</p>
<p>接下来的 N 行，每行输入两个整数，第一个整数M( 0 &lt; M &lt; 400) 表示商品的价格, 第二个整数表示优惠策略，1表示九折优惠策略，2表示满减优惠策略</p>
<p>每行输出一个数字，表示优惠后商品的价格</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Strategy/main.cpp">Strategy/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Strategy/main.cpp">Strategy/main.cpp(gitee.com)</a></p>
<h3 id="命令模式">命令模式</h3>
<p>命令模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>允许将请求封装成一个对象（命令对象，包含执行操作所需的所有信息），并将命令对象按照一定顺序存储在队列中，再逐一调用执行，命令支持反向操作、撤消重做。</li>
</ul>
<p>命令模式的角色有：</p>
<ul>
<li>抽象命令类：抽象类，定义执行操作的接口。</li>
<li>具体命令类：实现命令，执行具体操作。</li>
<li>接收者类：接受并执行命令的对象。</li>
<li>调用者：发起请求的对象。不关心命令的具体实现。</li>
</ul>
<p>使用时创建具体的命令对象和接收者对象，将其组装起来。</p>
<h4 id="命令模式的使用情形">命令模式的使用情形</h4>
<p>命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。</p>
<ul>
<li>
<p>撤销操作：需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。</p>
</li>
<li>
<p>队列请求：命令模式可以将请求排队，形成一个命令队列，依次执行命令。</p>
</li>
<li>
<p>可扩展性：可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。</p>
</li>
<li>
<p>但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。</p>
</li>
</ul>
<p>命令模式同样有着很多现实场景的应用：</p>
<ul>
<li>比如 Git 中的很多操作，如提交（commit）、合并（merge）等，都可以看作是命令模式的应用，用户通过执行相应的命令来操作版本库。</li>
<li>Java 的 GUI 编程中，很多事件处理机制也都使用了命令模式。例如，每个按钮都有一个关联的Action，它代表一个命令，按钮的点击触发 Action 的执行。</li>
</ul>
<h4 id="命令模式的实现">命令模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Receiver::action()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invoker</span>(Command *command)</span><br><span class="line">            : <span class="built_in">m_command</span>(command) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_command-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_command;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>(Receiver receiver)</span><br><span class="line">            : <span class="built_in">m_receiver</span>(receiver) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_receiver.<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver m_receiver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="命令模式的设计题">命令模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1093">【设计模式专题之命令模式】15-自助点餐机 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明去奶茶店买奶茶，他可以通过在自助点餐机上来点不同的饮品，请你使用命令模式设计一个程序，模拟这个自助点餐系统的功能。</p>
<p>输入第一行是一个整数 n（1 ≤ n ≤ 100），表示点单的数量。接下来的 n 行，每行包含一个字符串，表示点餐的饮品名称。</p>
<p>输出执行完所有点单后的制作情况，每行输出一种饮品的制作情况。如果制作完成，输出 “XXX is ready!”，其中 XXX 表示饮品名称。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Command/main.cpp">Command/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Command/main.cpp">Command/main.cpp(gitee.com)</a></p>
<h3 id="中介者模式">中介者模式</h3>
<p>中介者模式也称为调停者模式，是<strong>行为型设计模式</strong>。</p>
<ul>
<li>通过一个中介对象来封装一组对象之间的交互，从而使得这些对象之间不需要相互引用。</li>
</ul>
<p>中介者模式的角色有：</p>
<ul>
<li>抽象中介者：抽象类，定义中介者接口，用于各个具体同事对象之间的通信。</li>
<li>具体中介者：实现抽象类方法，协调各个具体同事对象的交互关系。</li>
<li>抽象同事类：抽象类，定义同事类接口，维护一个对中介者对象的引用，用于通信。</li>
<li>具体同事类：实现抽象类方法，每个具体同事类只知道自己的行为，不了解其他同事类的情况。</li>
</ul>
<h4 id="与代理模式区别">与代理模式区别</h4>
<p>中介者模式与代理模式在表述上类似，但是解决不同类型的问题：</p>
<ul>
<li>中介者模式通过一个中介者对象，使得系统中的<strong>其他对象通过中介者进行通信交互</strong>，降低了系统各个对象间的直接耦合。</li>
<li>代理模式通过一个代理类，使得客户端可以与目标对象进行通信，且可以在<strong>调用实际目标对象方法前后进行额外的操作</strong>，控制对象的访问。</li>
</ul>
<h4 id="中介者模式的使用情形">中介者模式的使用情形</h4>
<p>中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。</p>
<p>中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化，</p>
<h4 id="中介者模式的实现">中介者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Mediator.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(Colleague *colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">(std::string <span class="type">const</span> &amp;message, Colleague *colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Register</span><span class="params">(Colleague *colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_colleagues.<span class="built_in">push_back</span>(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string <span class="type">const</span> &amp;message, Colleague *colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;c : m_colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != colleague) &#123;</span><br><span class="line">                c-&gt;<span class="built_in">receive</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Colleague *&gt; m_colleagues;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Colleague</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Mediator *m_mediator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueA</span>(Mediator *mediator) &#123;</span><br><span class="line">        m_mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_mediator-&gt;<span class="built_in">Send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ColleagueA received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueB</span>(Mediator *mediator) &#123;</span><br><span class="line">        m_mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_mediator-&gt;<span class="built_in">Send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ColleagueB received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="中介者模式的设计题">中介者模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1094">【设计模式专题之中介者模式】16-简易聊天室 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明正在设计一个简单的多人聊天室系统，有多个用户和一个聊天室中介者，用户通过中介者进行聊天，请你帮他完成这个系统的设计。</p>
<p>第一行包括一个整数N,表示用户的数量（1 &lt;= N &lt;= 100) 第二行是N个用户，比如User1 User2 User3，用空格分隔。第三行开始，每行包含两个字符串，表示消息的发出者和消息内容，用空格分隔。</p>
<p>对于每个用户，输出一行，包含该用户收到的所有消息内容。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Mediator/main.cpp">Mediator/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Mediator/main.cpp">Mediator/main.cpp(gitee.com)</a></p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>备忘录模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>允许在不暴露对象实现的情况下捕获对象的内部状态并在对象之外保存这个状态，以便可以还原状态。</li>
</ul>
<p>备忘录的角色有：</p>
<ul>
<li>发起人：需要还原状态的对象，负责创建备忘录，使用备忘录记录。</li>
<li>备忘录：存储发起人对象的内部状态，包含发起人部分或全部状态信息，但对外不可见，仅发起人可见。</li>
<li>管理者：负责（一个或多个）存储备忘录对象，但不了解其内部结构。</li>
</ul>
<h4 id="备忘录模式的使用情形">备忘录模式的使用情形</h4>
<p>备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过备份对象往往会消耗较多的内存，资源消耗增加。</p>
<p>备忘录模式常常用来实现撤销和重做功能，比如在 Java Swing GUI 编程中，<code>javax.swing.undo</code> 包中的撤销（undo）和重做（redo）机制使用了备忘录模式。<code>UndoManager</code> 和 <code>UndoableEdit</code> 接口是与备忘录模式相关的主要类和接口。</p>
<h4 id="备忘录模式的实现">备忘录模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(std::string state)</span><br><span class="line">            : <span class="built_in">m_state</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::string state)</span> </span>&#123;</span><br><span class="line">        m_state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento *<span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Memento</span>(m_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restoreFromMemento</span><span class="params">(Memento *memento)</span> </span>&#123;</span><br><span class="line">        m_state = memento-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMemento</span><span class="params">(Memento *memento)</span> </span>&#123;</span><br><span class="line">        m_mementos.<span class="built_in">emplace_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento *<span class="title">getMemento</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt; m_mementos.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> m_mementos[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Memento *&gt; m_mementos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="备忘录模式的设计题">备忘录模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1095">【设计模式专题之备忘录模式】17-redo计数器应用 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明正在设计一个简单的计数器应用，支持增加（Increment）和减少（Decrement）操作，以及撤销（Undo）和重做（Redo）操作，请你使用备忘录模式帮他实现。</p>
<p>输入包含若干行，每行包含一个字符串，表示计数器应用的操作，操作包括 “Increment”、“Decrement”、“Undo” 和 “Redo”。</p>
<p>对于每个 “Increment” 和 “Decrement” 操作，输出当前计数器的值，计数器数值从0开始 对于每个 “Undo” 操作，输出撤销后的计数器值。 对于每个 “Redo” 操作，输出重做后的计数器值。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Memento/main.cpp">Memento/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Memento/main.cpp">Memento/main.cpp(gitee.com)</a></p>
<h3 id="模板方法模式">模板方法模式</h3>
<p>模板方法模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义一个算法骨架，将一些步骤的实现延迟到子类。</li>
</ul>
<p>模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>举个简单的例子，做一道菜通常都需要包含至少三步：准备食材；亨饪过程；上菜。</p>
<p>不同菜品的亨饪过程是不一样的，但是可以先定义一个“骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。</p>
<p>模板方法模式的角色有：</p>
<ul>
<li>模板类：一个模板方法和若干个基本方法构成。
<ul>
<li>模板方法定义逻辑的骨架，按照顺序调用包含的基本方法。</li>
<li>基本方法通常是抽象方法，由子类实现。</li>
<li>基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，可以在具体子类中继承或重写。</li>
</ul>
</li>
<li>具体类：继承自模板类，实现在模板类中定义的抽象方法。</li>
</ul>
<h4 id="模板方法模式的使用情形">模板方法模式的使用情形</h4>
<p>模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。</p>
<p>总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板方法模式来处理。如：</p>
<ul>
<li>Spring 框架中的 <code>JdbcTemplate</code> 类使用了模板方法模式，其中定义了一些执行数据库操作的模板方法，具体的数据库操作由回调函数提供。</li>
<li>Java 的 JDK 源码中，<code>AbstractList</code> 类也使用了模板方法模式，它提供了一些通用的方法，其中包括一些模板方法。具体的列表操作由子类实现。</li>
</ul>
<h4 id="模板方法模式的实现">模板方法模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">step1</span>();</span><br><span class="line">        <span class="built_in">step2</span>();</span><br><span class="line">        <span class="built_in">step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step3</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 3\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="模板方法模式的设计题">模板方法模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1087">【设计模式专题之模板方法模式】18-咖啡馆 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。</p>
<p>咖啡制作过程包括以下步骤：</p>
<ol>
<li>研磨咖啡豆 Grinding coffee beans</li>
<li>冲泡咖啡 Brewing coffee</li>
<li>添加调料 Adding condiments</li>
</ol>
<p>其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk。</p>
<p>多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。</p>
<p>根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/TemplateMethod/main.cpp">TemplateMethod/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/TemplateMethod/main.cpp">TemplateMethod/main.cpp(gitee.com)</a></p>
<h3 id="迭代器模式">迭代器模式</h3>
<p>迭代器模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>提供一种统一的方式访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。</li>
</ul>
<p>迭代器模式的角色有：</p>
<ul>
<li>迭代器抽象类：定义访问和遍历元素的接口。</li>
<li>具体迭代器：实现抽象迭代器。</li>
<li>抽象聚合类：定义创建迭代器接口，创建迭代器对象。</li>
<li>具体聚合类：实现抽象聚合类方法。</li>
</ul>
<h4 id="迭代器模式的使用情形">迭代器模式的使用情形</h4>
<p>迭代器模式使用很广泛。客户端不需要知道集合的内部结构，只需要关心迭代器和迭代器接口就可以完成元素的访问。如：</p>
<ul>
<li>Java 的集合类，<code>ArrayList</code>、<code>LinkedList</code>。</li>
<li>Python 的 <code>iter()</code> 、 <code>next()</code>。</li>
<li>C++ 中 STL 的迭代器，<code>begin()</code>、<code>end()</code>。</li>
</ul>
<h4 id="迭代器模式的实现">迭代器模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterator</span>(std::vector&lt;T&gt; elements)</span><br><span class="line">            : <span class="built_in">m_elements</span>(elements)</span><br><span class="line">            , m_idx = <span class="number">0</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="type">bool</span> <span class="built_in">hasNext</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_idx &lt; m_elements.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_elements[m_idx++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_idx;</span><br><span class="line">    std::vector&lt;T&gt; m_elements;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象聚合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator&lt;T&gt; *<span class="title">createIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体聚合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterable</span> : <span class="keyword">public</span> Iterable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterable</span>(std::vector&lt;T&gt; elements)</span><br><span class="line">            : <span class="built_in">m_elements</span>(elements) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; *<span class="title">createIterator</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>(m_elements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; m_elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器模式的设计题">迭代器模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1099">【设计模式专题之迭代器模式】19-学生名单 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明是一位老师，在进行班级点名时，希望有一个学生名单系统，请你实现迭代器模式提供一个迭代器使得可以按顺序遍历学生列表。</p>
<p>第一行是一个整数 N （1 &lt;= N &lt;= 100), 表示学生的数量。</p>
<p>接下来的 N 行，每行包含一个学生的信息，格式为 姓名 学号</p>
<p>输出班级点名的结果，即按顺序遍历学生列表，输出学生的姓名和学号</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Iterator/main.cpp">Iterator/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Iterator/main.cpp">Iterator/main.cpp(gitee.com)</a></p>
<h3 id="状态模式">状态模式</h3>
<p>状态模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>将对象每个状态的行为封装在一个具体类中，使得每个状态类相互独立，对象从而可以在运行时动态改变。</li>
</ul>
<p>状态模式的角色有：</p>
<ul>
<li>抽象状态类：抽象类，封装 Context 的一个特定状态相关的行为。</li>
<li>具体状态类：为每一个具体状态实现一个行为。</li>
<li>Context 类：维护一个具体状态的子类实例，实例定义当前状态。</li>
</ul>
<h4 id="状态模式的使用情形">状态模式的使用情形</h4>
<p>适用于一个对象在不同状态下有不同的行为。</p>
<p>适用于有限状态机的场景，其中对象的行为在运行时可以根据内部状态的改变而改变。</p>
<p>在游戏开发中，Unity 3D 的 Animator 控制器就是一个状态机。它允许开发人员定义不同的状态（动画状态），并通过状态转换来实现角色的动画控制和行为切换。</p>
<h4 id="状态模式的实现">状态模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;状态A下的操作\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;状态B下的操作\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(State *state)</span> </span>&#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">handle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *currentState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="状态模式的设计题">状态模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1097">【设计模式专题之状态模式】20-开关台灯 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（“ON”）、关闭（“OFF”）和闪烁（“blink”）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。</p>
<p>第一行是一个整数 n（1 &lt;= n &lt;= 1000），表示接收的命令数量。</p>
<p>接下来的 n 行，每行包含一个字符串 s，表示一个命令（“ON”、“OFF&quot;或&quot;blink”）。</p>
<p>对于每个命令，输出一行，表示执行该命令后灯泡的状态。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/State/main.cpp">State/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/State/main.cpp">State/main.cpp(gitee.com)</a></p>
<h3 id="责任链模式">责任链模式</h3>
<p>责任链模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>允许构建一个对象链，请求从链的一端进入，沿着链上的对象依次处理，直至链上某个对象能够处理该请求。</li>
</ul>
<p>责任链模式的角色有：</p>
<ul>
<li>处理者：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一处理者的链接。</li>
<li>具体处理者：实现处理请求的方法，判断能否处理，能处理则处理，否则传递下一处理者。</li>
</ul>
<h4 id="责任链模式的使用情形">责任链模式的使用情形</h4>
<p>责任链模式优点有：</p>
<ul>
<li>
<p>降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与自己相关的请求，客户端不需要知道具体是哪个处理者处理请求。</p>
</li>
<li>
<p>增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满足不同需求。</p>
</li>
</ul>
<p>但是由于一个请求可能会经过多个处理者，这可能会导致一些性能问题，并且如果整个链上也没有合适的处理者来处理请求，就会导致请求无法被处理。</p>
<p>实际使用有 Java 开发中过滤器的链式处理，以及 Spring 框架中的拦截器，都组装成一个处理链对请求、响应进行处理。</p>
<h4 id="责任链模式的实现">责任链模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> requestId)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(Handler *next)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Handler *m_nextHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandle</span>(requestId)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ConcreteHandler::handleRequest() &quot;</span> &lt;&lt; requestId &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_nextHandler-&gt;<span class="built_in">handleRequest</span>(requestId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无法处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="built_in">setNextHandler</span>(Handler *next) &#123;</span><br><span class="line">        m_nextHandler = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">int</span> requestId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据具体情况判断是否能处理请求</span></span><br><span class="line">        <span class="keyword">return</span> requestId &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="责任链模式的设计题">责任链模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1100">【设计模式专题之责任链模式】21-请假审批 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。</p>
<p>审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。</p>
<p>第一行是一个整数N（1 &lt;= N &lt;= 100), 表示请求申请的数量。</p>
<p>接下来的N行，每行包括一个请求申请的信息，格式为&quot;姓名 请假天数&quot;</p>
<p>对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/ResponsibilityChain/main.cpp">ResponsibilityChain/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/ResponsibilityChain/main.cpp">ResponsibilityChain/main.cpp(gitee.com)</a></p>
<h3 id="解释器模式">解释器模式</h3>
<p>解释器模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义了语言的文法，并且建立一个解释器解释句子。</li>
</ul>
<p>解释器模式的角色有：</p>
<ul>
<li>抽象表达式：定义了解释器抽象类，包含解释器方法。</li>
<li>终结符表达式：语法中不能再分解为更小单元的符号。</li>
<li>非终结符表达式：复杂表达式，由终结符和其他非终结符组成。</li>
<li>上下文：解释器之外的全局信息，存储解释器中间结果，也可以向解释器传递信息。</li>
</ul>
<p>比如表达式 <code>1+1</code>，数字 <code>1</code> 是终结符，而运算符 <code>+</code> 需要两个操作数，属于非终结符。</p>
<h4 id="解释器模式的使用情形">解释器模式的使用情形</h4>
<p>当需要解释和执行特定领域或业务规则的语言时，可以使用解释器模式。例如：</p>
<ul>
<li>SQL 解释器;</li>
<li>正则表达式解释器。</li>
</ul>
<p>但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使用要慎重。</p>
<h4 id="解释器模式的实现">解释器模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TerminalExpression</span>(<span class="type">int</span> value)</span><br><span class="line">            : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式，此处举例为加法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(Expression *left, Expression *right)</span><br><span class="line">            : <span class="built_in">m_left</span>(left)</span><br><span class="line">            , <span class="built_in">m_right</span>(right) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_left-&gt;<span class="built_in">interpret</span>() + m_right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Expression *m_left;</span><br><span class="line">    Expression *m_right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 存储一些全局信息或状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解释器模式的设计题">解释器模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1096">【设计模式专题之解释器模式】22-数学表达式 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明正在设计一个计算器，用于解释用户输入的简单数学表达式，每个表达式都是由整数、加法操作符+、乘法操作符组成的，表达式中的元素之间用空格分隔，请你使用解释器模式帮他实现这个系统。</p>
<p>每行包含一个数学表达式，表达式中包含整数、加法操作符（+）和乘法操作符（*）。 表达式中的元素之间用空格分隔。</p>
<p>对于每个输入的数学表达式，每行输出一个整数，表示对应表达式的计算结果。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Interpreter/main.cpp">Interpreter/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Interpreter/main.cpp">Interpreter/main.cpp(gitee.com)</a></p>
<h3 id="访问者模式">访问者模式</h3>
<p>访问者模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>在不改变对象结构的前提下，对对象中的元素进行新的操作。</li>
</ul>
<p>访问者模式的角色有：</p>
<ul>
<li>抽象访问者：抽象类，声明访问者可以访问的元素，以及声明访问方法。</li>
<li>具体访问者：实现了抽象类的方法。</li>
<li>抽象元素：定义方法接受访问者的访问。</li>
<li>具体元素：实现抽象元素的方法。</li>
<li>对象结构：元素的集合，负责遍历元素，并调用元素的接受方法。</li>
</ul>
<h4 id="访问者模式的使用情形">访问者模式的使用情形</h4>
<p>访问者模式结构较为复杂，但是访问者模式将同一类操作封装在一个访问者中，使得相关的操作彼此集中，提高了代码的可读性和维护性。</p>
<p>常用于对象结构比较稳定，但经常需要在此对象结构上定义新的操作，这样就无需修改现有的元素类，只需要定义新的访问者来添加新的操作。</p>
<h4 id="访问者模式的实现">访问者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Visitor.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象元素类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA *element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB *element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorA</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorA visit ConcreElementA\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorA visit ConcreElementB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorB</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorB visit ConcreElementA\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorB visit ConcreElementB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Element *element)</span> </span>&#123;</span><br><span class="line">        m_elements.<span class="built_in">emplace_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Element *element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(m_elements.<span class="built_in">begin</span>(), m_elements.<span class="built_in">end</span>(), element);</span><br><span class="line">        <span class="keyword">if</span> (it != m_elements.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            m_elements.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element *element : m_elements) &#123;</span><br><span class="line">            element-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Element *&gt; m_elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="访问者模式的设计题">访问者模式的设计题</h4>
<p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1098">【设计模式专题之访问者模式】23-图形的面积 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有一些圆形和长方形面积的土地，请你帮他实现一个访问者模式，使得可以通过访问者计算每块土地的面积。</p>
<p>图形的面积计算规则如下：</p>
<ul>
<li>圆形的面积计算公式为：3.14 * 半径 * 半径</li>
<li>矩形的面积计算公式为：长 * 宽</li>
</ul>
<p>第一行是一个整数 n（1 &lt;= n &lt;= 1000），表示图形的数量。</p>
<p>接下来的 n 行，每行描述一个图形，格式为 “Circle r” 或 “Rectangle width height”，其中 r、width、height 是正整数。</p>
<p>对于每个图形，输出一行，表示该图形的面积。</p>
</blockquote>
<p>参考代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fingsinz/Patterns/blob/master/Visitor/main.cpp">Visitor/main.cpp(github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Visitor/main.cpp">Visitor/main.cpp(gitee.com)</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/20/">WSL安装记录</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/LinuxServerCpp/">Linux 服务器编程入门尝试 - C++</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap" style="column-count:2;"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">关于</span><a href="/about/me/">关于我</a><a href="/about/site/">关于博客</a></div></div><div class="text"><p>本站由 <a href="/">Fingsinz</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.0">Stellar 1.33.0</a> 主题创建。<br>
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="true"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">创建型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">单例模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">单例模式的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-text">单例模式的基本原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">单例模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">单例模式设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">工厂方法模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">工厂方法模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">工厂方法模式设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简单工厂、工厂方法、抽象工厂的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">工厂方法模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">抽象工厂模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">抽象工厂模式设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">建造者模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">建造者模式的优点和缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">建造者模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">建造者模式设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">原型模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">原型模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">原型模式设计题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">结构型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">适配器模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">适配器模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">适配器模式设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">代理模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">代理模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">代理模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">装饰模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">装饰模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">装饰模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">外观模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">外观模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">外观模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">桥接模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">桥接模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">桥接模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">组合模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">组合模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">组合模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">享元模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">享元模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">享元模式的设计题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">行为型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">观察者模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">观察者模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">观察者模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">策略模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">策略模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">策略模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">命令模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">命令模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">命令模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">中介者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-text">与代理模式区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">中介者模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">中介者模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">中介者模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">备忘录模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">备忘录模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">备忘录模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">模板方法模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">模板方法模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">模板方法模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">迭代器模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">迭代器模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">迭代器模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">状态模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">状态模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">状态模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">责任链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">责任链模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">责任链模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">责任链模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">解释器模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">解释器模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">解释器模式的设计题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">访问者模式的使用情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">访问者模式的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">访问者模式的设计题</span></a></li></ol></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
