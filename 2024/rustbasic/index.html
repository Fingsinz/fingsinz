<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Rust 语言学习记录" />
    <meta name="hexo-theme-A4" content="v1.8.3" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Fingsinz&#39;s space | 风信梓</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: white;  
        }
        body {
            color: #000000;
            background: #bed2bb;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #000000;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #000000;
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: white; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: #6b798e;
        }

        .post-md a {
            color: #6b798e;
        }

        .nav li a {
            color: #6b798e;
        }

        .archive-main a:link {
            color: #6b798e;
        }
        .archive-main a:visited {
            color: #6b798e; 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: white;
        }

        .paper {
            background: #bed2bb;
        }

        .index-main {
            background: white;
        }

        .paper-main {
            background: white;
        }

        .wl-panel {
            background: white;
        }

        .archive li:nth-child(odd) {
            background: white;
            ;
        }

        .archive li:nth-child(even) {
            background: white;
        }

        .post-md table tr:nth-child(odd) td {
            background: white;
        }

        .post-md table tr:nth-child(even) td {
            background: white;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #6b798e;
            border-left-color: #6b798e;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Fingsinz&#39;s space</a> 
            <span class="description">我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页🏚️</a></li>
            
        
            
                <li><a href="/list/">文章📄</a></li>
            
        
            
                <li><a href="/categories/">分类🗂️</a></li>
            
        
            
                <li><a href="/notes/">笔记✏️</a></li>
            
        
            
                <li><a href="/about/">关于🧑</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Rust 语言学习记录
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%89%8D%E8%A8%80"><span class="post-toc-text">前言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-rust"><span class="post-toc-text">什么是 Rust</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#rust-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="post-toc-text">Rust 的优势</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#windows-%E4%B8%8B%E5%AE%89%E8%A3%85-rust"><span class="post-toc-text">Windows 下安装 Rust</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8-vscode-%E4%B8%8A%E4%BD%BF%E7%94%A8-rust"><span class="post-toc-text">在 VSCode 上使用 Rust</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F"><span class="post-toc-text">第一个 Rust 程序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98"><span class="post-toc-text">下载依赖卡顿问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#rust-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="post-toc-text">Rust 基础入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="post-toc-text">变量绑定与解构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A"><span class="post-toc-text">变量绑定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E4%B8%8E%E5%8F%AF%E5%8F%98"><span class="post-toc-text">变量的不可变与可变</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="post-toc-text">忽略未使用的变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84"><span class="post-toc-text">变量解构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="post-toc-text">不可变量与常量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD"><span class="post-toc-text">变量遮蔽</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">基本类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">数值类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E6%BA%A2%E5%87%BA"><span class="post-toc-text">整数运算溢出</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E9%98%B1"><span class="post-toc-text">浮点数陷阱</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#nan"><span class="post-toc-text">NaN</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97"><span class="post-toc-text">数字运算</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BA%8F%E5%88%97"><span class="post-toc-text">序列</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-as-%E5%AE%8C%E6%88%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">使用 As 完成类型转换</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%89%E7%90%86%E6%95%B0%E4%B8%8E%E5%A4%8D%E6%95%B0"><span class="post-toc-text">有理数与复数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6-%E5%B8%83%E5%B0%94-%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">字符、布尔、单元类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="post-toc-text">语句与表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0"><span class="post-toc-text">函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8"><span class="post-toc-text">所有权和借用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="post-toc-text">所有权</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="post-toc-text">栈与堆</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E5%8E%9F%E5%88%99"><span class="post-toc-text">所有权的原则</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="post-toc-text">变量绑定背后的数据交互</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">拷贝（浅拷贝）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%85%8B%E9%9A%86-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">克隆（深拷贝）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83"><span class="post-toc-text">转移所有权</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="post-toc-text">函数传值与返回</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8"><span class="post-toc-text">引用和借用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="post-toc-text">引用和解引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="post-toc-text">不可变引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="post-toc-text">可变引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#nll"><span class="post-toc-text">NLL</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="post-toc-text">悬垂引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="post-toc-text">借用规则总结</span></a></li></ol></li></ol></li></ol></li></ol>
            
        
        <div class=".article-gallery"><p>关键词：Rust</p>
<span id="more"></span>
<hr>
<p><strong>References：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a></li>
<li><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/">Rust 程序设计语言 中文版</a></li>
</ul>
<h2 id="前言">前言</h2>
<h3 id="什么是-rust">什么是 Rust</h3>
<p>Rust 是一门新的静态编译编程语言，其功能定位与 C++ 相似，它的 1.0 版本于 2015 年发布。</p>
<p><code>rustc</code> 使用 LLVM 作为它的后端。</p>
<p>Rust 支持多种平台和架构：x86、ARM、WebAssembly、Linux、Mac、Windows……</p>
<p>Rust 被广泛用于各种设备中：</p>
<ul>
<li>固件和引导程序</li>
<li>智能显示器</li>
<li>手机</li>
<li>桌面</li>
<li>服务器</li>
</ul>
<p>Rust 和 C++ 适用于类似的场景：</p>
<ul>
<li>极高的灵活性。</li>
<li>高度的控制能力。</li>
<li>能够在资源匮乏的设备（如手机）上运行。</li>
<li>没有运行时和垃圾收集。</li>
<li>关注程序可靠性和安全性，而不会牺牲任何性能。</li>
</ul>
<p>Rust 系统由许多工具组成：</p>
<ul>
<li><code>rustc</code>：Rust 编译器，将 <code>.rs</code> 文件转换为二进制文件和其他中间格式。</li>
<li><code>cargo</code>：Rust 依赖项管理器和构建工具（包管理工具）。负责下载依赖项并在构建项目时传递给编译器。其还附带内置的测试运行程序，用于执行单元测试。</li>
<li><code>rustup</code>：Rust 工具链安装和更新工具。当更新版本时，其用于安装并更新 <code>rustc</code> 和 <code>cargo</code>。还可用于下载标准库的文档，同时安装多个 Rust 版本。</li>
</ul>
<p>Rust 区分版本。这些版本支持对语言进行向后不兼容的更改。</p>
<ul>
<li>为防止破坏代码，版本是可选的： 通过 <code>Cargo.toml</code> 文件为 <code>crate</code> 选择合适的版本。</li>
<li>为免分割生态系统，Rust 编译器可以混合使用为不同版本编写的代码。</li>
</ul>
<h4 id="rust-的优势">Rust 的优势</h4>
<p>编译时内存安全：在编译时可防止所有类内存 bug。</p>
<ul>
<li>不存在未初始化的变量。</li>
<li>不存在“双重释放”。</li>
<li>不存在“释放后使用”。</li>
<li>不存在 NULL 指针。</li>
<li>不存在被遗忘的互斥锁。</li>
<li>不存在线程之间的数据竞争。</li>
<li>不存在迭代器失效。</li>
</ul>
<p>没有未定义的运行时行为：每个 Rust 语句的行为都有明确定义。</p>
<ul>
<li>数组访问有边界检查。</li>
<li>整数溢出有明确定义（panic 或回绕）。</li>
</ul>
<p>现代语言功能：具有与高级语言一样丰富且人性化的表达能力。</p>
<ul>
<li>枚举和模式匹配。</li>
<li>泛型。</li>
<li>无额外开销的外部函数接口（FFI）。</li>
<li>零成本抽象。</li>
<li>强大的编译器错误提示。</li>
<li>内置依赖管理器。</li>
<li>对测试的内置支持。</li>
<li>优秀的语言服务协议（Language Server Protocol）支持。</li>
</ul>
<h3 id="windows-下安装-rust">Windows 下安装 Rust</h3>
<p>可执行二进制文件下载地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/tools/install">https://www.rust-lang.org/zh-CN/tools/install</a></li>
<li><a target="_blank" rel="noopener" href="https://rustup.rs/">https://rustup.rs/</a></li>
<li>两个地址下载一个即可。</li>
</ul>
<p>点击运行 <code>rustup-init.exe</code>。</p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_install.jpg" title="安装路径提示" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_install.jpg" alt="安装路径提示"></a></p>
<p>显示默认安装在 C 盘。</p>
<ul>
<li>此处已做修改，自定义安装路径。</li>
</ul>
<p>自定义安装路径步骤如下：</p>
<ol>
<li>创建自定义文件夹，我此处为 <code>D:/rust</code>。在内创建两个文件夹，分别为 <code>.cargo</code> 和 <code>.rustup</code>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_newpath.jpg" title="创建文件夹" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_newpath.jpg" alt="创建文件夹"></a></p>
<ol start="2">
<li>配置环境变量：把新建的文件夹添加到环境变量中。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_cargohome.jpg" title="CargoHome" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_cargohome.jpg" alt="CargoHome"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_rustuphome.jpg" title="RustupHome" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_rustuphome.jpg" alt="RustupHome"></a></p>
<ol start="3">
<li>在 <code>PATH</code> 环境变量中加入上两个变量。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_addPath.jpg" title="添加到PATH" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_addPath.jpg" alt="添加到PATH"></a></p>
<p>至此再打开 <code>rustup-init.exe</code>，观察路径是否修改。</p>
<p>接着输入 <code>1</code> 执行默认安装即可。</p>
<h3 id="在-vscode-上使用-rust">在 VSCode 上使用 Rust</h3>
<p>步骤如下：</p>
<ol>
<li>在扩展中查找并安装 <code>rust-analyzer</code> 和 <code>Native Debug</code> 两个插件。</li>
</ol>
<ul>
<li>另外两个推荐插件：
<ul>
<li>Even Better TOML，支持 .toml 文件完整特性</li>
<li>Error Lens，更好的获得错误展示</li>
</ul>
</li>
</ul>
<ol start="2">
<li>新建代码文件夹，在终端使用命令生成工程：</li>
</ol>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>编写代码后，在终端使用命令运行：</li>
</ol>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">cargo run</span><br></pre></td></tr></tbody></table></figure>
<h4 id="第一个-rust-程序">第一个 Rust 程序</h4>
<p>每一个语言一开始会有它的 Hello World。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>函数以 <code>fn</code> 开头。</li>
<li>代码块以 <code>{</code> 开头，以 <code>}</code> 结尾。</li>
<li>Rust 有卫生宏，<code>println!</code> 就是一个例子。
<ul>
<li>这意味着它们不会意外地捕获它们所在作用域中的标识符。</li>
</ul>
</li>
<li>Rust 字符串是 <code>UTF-8</code> 编码，可以包含 Unicode 字符。</li>
</ul>
<h3 id="下载依赖卡顿问题">下载依赖卡顿问题</h3>
<p>解决方法是：覆盖默认的镜像地址</p>
<p>在 <code>$HOME/.cargo/config.toml</code> 添加以下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">replace-with = 'ustc'</span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry = "git://mirrors.ustc.edu.cn/crates.io-index"</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建一个新的镜像源 <code>[source.ustc]</code>，然后将默认的 <code>crates-io</code> 替换成新的镜像源: <code>replace-with = 'ustc'</code>。</li>
</ul>
<h2 id="rust-基础入门">Rust 基础入门</h2>
<p>速览语法：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 使用let来声明变量，进行绑定，默认a是不可变的</span></span><br><span class="line">    <span class="comment">// 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>; <span class="comment">// 语句的末尾必须以分号结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动指定b的类型为i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在数值中带上类型:30i32表示数值是30，类型是i32</span></span><br><span class="line">    <span class="comment">// 声明变量时添加 mut 表示变量是可变的，mut是mutable的缩写</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="number">30i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还能在数值和类型中间添加一个下划线，让可读性更好</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = <span class="number">30_i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = <span class="title function_ invoke__">add</span>(<span class="title function_ invoke__">add</span>(a, b), <span class="title function_ invoke__">add</span>(c, d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块</span></span><br><span class="line">    <span class="comment">// 该函数将指定的格式化字符串输出到标准输出中(控制台)</span></span><br><span class="line">    <span class="comment">// {}是占位符，在具体执行过程中，会把e的值代入进来</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"( a + b ) + ( c + d ) = {}"</span>, e);</span><br><span class="line">    <span class="comment">// println! 会自动推导出具体的类型，因此无需手动指定输出类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(i: <span class="type">i32</span>, j: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="comment">// 返回相加值，这里可以省略return</span></span><br><span class="line">    <span class="comment">// 不添加 ;，表示返回 i + j，添加则表示返回空。</span></span><br><span class="line">    i + j</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="变量绑定与解构">变量绑定与解构</h3>
<p>Rust 默认变量是不可修改的，这使得程序运行时性能上的提升。</p>
<p>在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 <a target="_blank" rel="noopener" href="https://course.rs/practice/naming.html">Rust 命名规范</a>。</p>
<h4 id="变量绑定">变量绑定</h4>
<p>在其他语言中，如 <code>int a = 1</code> 称为赋值。但 Rust 中， <code>let a = 1</code> 称为 <strong>变量绑定</strong>。</p>
<p>绑定一词源自 Rust 的所有权问题。</p>
<ul>
<li>任何内存对象都是有主人的（Owner），对象完全属于它的主人。</li>
<li>绑定就是把这个对象绑定给一个变量，使变量成为它的主人。</li>
</ul>
<h4 id="变量的不可变与可变">变量的不可变与可变</h4>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;  <span class="comment">// 错误：x 是不可变的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, y);</span><br><span class="line">    y = <span class="number">11</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种不可变的优势是：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。</p>
<h4 id="忽略未使用的变量">忽略未使用的变量</h4>
<p>Rust 的高安全性会认为不使用的变量可能会是个 BUG，所以进行警告。</p>
<p>使用下划线 <code>_</code> 开头的变量名会被忽略。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="变量解构">变量解构</h4>
<p><code>let</code> 不仅可以进行变量的绑定，还可以进行复杂变量的解构。</p>
<ul>
<li>从一个相对复杂的变量中，匹配出该变量的一部分内容。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 匹配 a 和 b</span></span><br><span class="line">    <span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>, <span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {} {}"</span>, a, b);</span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {} {}"</span>, a, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="不可变量与常量">不可变量与常量</h4>
<p>Rust 默认的是不可变量。常量是经过 <code>const</code> 修饰的量，且在 Rust 中值类型必须标注。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123</span>; <span class="comment">// 可以编译，但可能有警告，因为该变量没有被使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> b: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">2</span>;  <span class="comment">// 错误：常量不能被重新赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="变量遮蔽">变量遮蔽</h4>
<p>像上面写过的，Rust 允许声明相同的变量名，且后声明的变量名会遮蔽前面声明的。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x = : {x}"</span>); <span class="comment">// 12</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x = : {x}"</span>); <span class="comment">// 6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这个程序首先将数值 5 绑定到 <code>x</code>，然后通过重复使用 <code>let x =</code> 来遮蔽之前的 <code>x</code>，并取原来的值加上 1，所以 <code>x</code> 的值变成了 6。第三个 <code>let</code> 语句同样遮蔽前面的 <code>x</code>，取之前的值并乘上 2，得到的 <code>x</code> 最终值为 12。</li>
<li>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</li>
</ul>
<p>变量遮蔽的用处，在于在某个作用域内无需再使用之前的变量时，就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<h3 id="基本类型">基本类型</h3>
<p>内置数据类型有：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类型</th>
<th style="text-align:center">字面量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">有符号整数</td>
<td style="text-align:center"><code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>isize</code></td>
<td style="text-align:center"><code>-10</code>、<code>0</code>、<code>1_000</code>、<code>123_i64</code></td>
</tr>
<tr>
<td style="text-align:center">无符号整数</td>
<td style="text-align:center"><code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code></td>
<td style="text-align:center"><code>0</code>、<code>123</code>、<code>10_u16</code></td>
</tr>
<tr>
<td style="text-align:center">浮点数</td>
<td style="text-align:center"><code>f32</code>、<code>f64</code></td>
<td style="text-align:center"><code>3.14</code>、<code>-10.0e20</code>、<code>2_f32</code></td>
</tr>
<tr>
<td style="text-align:center">Unicode 标量类型</td>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>'a'</code>、<code>'α'</code>、<code>'∞'</code></td>
</tr>
<tr>
<td style="text-align:center">布尔值</td>
<td style="text-align:center"><code>bool</code></td>
<td style="text-align:center"><code>true</code>、<code>false</code></td>
</tr>
<tr>
<td style="text-align:center">单元类型</td>
<td style="text-align:center"><code>()</code></td>
<td style="text-align:center">其唯一的值也是 <code>()</code></td>
</tr>
</tbody>
</table>
<ul>
<li>数字中的下划线均可忽略，仅方便辨识，即 <code>1_000</code> 可以写成 <code>1000</code>，<code>123_i64</code> 等价 <code>123i64</code></li>
</ul>
<p>每种类型占用空间为：</p>
<ul>
<li><code>iN</code>、<code>uN</code> 和 <code>fN</code> 占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 位。</li>
<li><code>isize</code> 和 <code>usize</code> 占用一个指针大小的空间。</li>
<li><code>char</code> 占用 4 个字节，32 位空间。</li>
<li><code>bool</code> 占用 1 个字节，8 位空间。</li>
</ul>
<p>类型推导与标注：编译器必须在编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型。</p>
<ul>
<li>Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型。</li>
<li>在某些情况下，Rust 编译器无法推导出变量类型，需要手动去给予一个类型标注。</li>
</ul>
<h4 id="数值类型">数值类型</h4>
<h5 id="整数运算溢出">整数运算溢出</h5>
<p>关于运算时整数溢出：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mul</span>(a: <span class="type">i16</span>, b: <span class="type">i16</span>, c: <span class="type">i16</span>) <span class="punctuation">-&gt;</span> <span class="type">i16</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_product</span> = <span class="title function_ invoke__">mul</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 尝试与溢出相乘，有符号整数16位的最大值为65535</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic（崩溃,Rust 使用这个术语来表明程序因错误而退出）。</li>
</ul>
<p>可以显式处理溢出，通过标准库针对原始数字类型提供的方法：</p>
<ul>
<li><code>wrapping_*</code> 在所有模式下都按照补码循环溢出规则，如 <code>wrapping_add</code>。</li>
<li><code>checked_*</code> 在发生溢出时返回 <code>None</code> 值。</li>
<li><code>overflowing_*</code> 返回该值和一个指示是否存在溢出的布尔值。</li>
<li><code>saturating_*</code> 可以限定计算后的结果不超过目标类型的最大值或低于最小值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = a.<span class="title function_ invoke__">checked_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = a.<span class="title function_ invoke__">overflowing_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = a.<span class="title function_ invoke__">saturating_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{a}"</span>);    <span class="comment">// 255</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{b}"</span>);    <span class="comment">// 19</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{c:?}"</span>);  <span class="comment">// None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{d:?}"</span>);  <span class="comment">// (19, true)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{e}"</span>);    <span class="comment">// 255</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="浮点数陷阱">浮点数陷阱</h5>
<p>浮点数的使用需要谨慎，原因：</p>
<ol>
<li>浮点数往往是数字的近似表达（并不是精确的）。</li>
<li>浮点数在某些特性上时反直觉的（比如比较时）。</li>
</ol>
<p>所以：</p>
<ul>
<li>避免在浮点数上判断相等；</li>
<li>当结果在数学上存在未定义时需要小心。</li>
</ul>
<p>一段代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">abc</span>: (<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span>: (<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"abc (f32)"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"   0.1 + 0.2: {:x}"</span>, (abc.<span class="number">0</span> + abc.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"         0.3: {:x}"</span>, (abc.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"xyz (f64)"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"   0.1 + 0.2: {:x}"</span>, (xyz.<span class="number">0</span> + xyz.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3fd3333333333334</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"         0.3: {:x}"</span>, (xyz.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3fd3333333333333</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(abc.<span class="number">0</span> + abc.<span class="number">1</span> == abc.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(xyz.<span class="number">0</span> + xyz.<span class="number">1</span> == xyz.<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="nan">NaN</h5>
<p>对于数学上未定义的结果，比如负数取平方根，会返回一个 <code>NaN</code>表示。</p>
<ul>
<li>所有与 <code>NaN</code> 交互的操作都会返回一个 <code>NaN</code>。</li>
<li><code>NaN</code> 并不能用于比较。</li>
</ul>
<p>可以使用 <code>is_nan()</code> 方法判断是否为 <code>NaN</code>。</p>
<h5 id="数字运算">数字运算</h5>
<p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。</p>
<p>更多，运算符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">是否可重载</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td>
<td style="text-align:center">宏展开</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>!expr</code></td>
<td style="text-align:center">按位非或逻辑非</td>
<td style="text-align:center">Not</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center"><code>var != expr</code></td>
<td style="text-align:center">不等比较</td>
<td style="text-align:center">PartialEq</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center"><code>expr % expr</code></td>
<td style="text-align:center">算术取模</td>
<td style="text-align:center">Rem</td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center"><code>var %= expr</code></td>
<td style="text-align:center">算术取模与赋值</td>
<td style="text-align:center">RemAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;expr</code>, <code>&amp;mut expr</code></td>
<td style="text-align:center">借用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td>
<td style="text-align:center">借用指针类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>expr &amp; expr</code></td>
<td style="text-align:center">按位与</td>
<td style="text-align:center">BitAnd</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;=</code></td>
<td style="text-align:center"><code>var &amp;= expr</code></td>
<td style="text-align:center">按位与及赋值</td>
<td style="text-align:center">BitAndAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center"><code>expr &amp;&amp; expr</code></td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>expr * expr</code></td>
<td style="text-align:center">算术乘法</td>
<td style="text-align:center">Mul</td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center"><code>var *= expr</code></td>
<td style="text-align:center">算术乘法与赋值</td>
<td style="text-align:center">MulAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>*expr</code></td>
<td style="text-align:center">解引用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>*const type</code>, <code>*mut type</code></td>
<td style="text-align:center">裸指针</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>trait + trait</code>, <code>'a + trait</code></td>
<td style="text-align:center">复合类型限制</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>expr + expr</code></td>
<td style="text-align:center">算术加法</td>
<td style="text-align:center">Add</td>
</tr>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center"><code>var += expr</code></td>
<td style="text-align:center">算术加法与赋值</td>
<td style="text-align:center">AddAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>,</code></td>
<td style="text-align:center"><code>expr, expr</code></td>
<td style="text-align:center">参数以及元素分隔符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>- expr</code></td>
<td style="text-align:center">算术取负</td>
<td style="text-align:center">Neg</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>expr - expr</code></td>
<td style="text-align:center">算术减法</td>
<td style="text-align:center">Sub</td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center"><code>var -= expr</code></td>
<td style="text-align:center">算术减法与赋值</td>
<td style="text-align:center">SubAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>-&gt;</code></td>
<td style="text-align:center"><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td>
<td style="text-align:center">函数与闭包，返回类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center"><code>expr.ident</code></td>
<td style="text-align:center">成员访问</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td>
<td style="text-align:center">右排除范围</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>..expr</code></td>
<td style="text-align:center">结构体更新语法</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td>
<td style="text-align:center">“与剩余部分”的模式绑定</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>...</code></td>
<td style="text-align:center"><code>expr...expr</code></td>
<td style="text-align:center">模式: 范围包含模式</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>expr / expr</code></td>
<td style="text-align:center">算术除法</td>
<td style="text-align:center">Div</td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center"><code>var /= expr</code></td>
<td style="text-align:center">算术除法与赋值</td>
<td style="text-align:center">DivAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>pat: type</code>, <code>ident: type</code></td>
<td style="text-align:center">约束</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>ident: expr</code></td>
<td style="text-align:center">结构体字段初始化</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>'a: loop {...}</code></td>
<td style="text-align:center">循环标志</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>;</code></td>
<td style="text-align:center"><code>expr;</code></td>
<td style="text-align:center">语句和语句结束符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>;</code></td>
<td style="text-align:center"><code>[...; len]</code></td>
<td style="text-align:center">固定大小数组语法的部分</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>expr &lt;&lt; expr</code></td>
<td style="text-align:center">左移</td>
<td style="text-align:center">Shl</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;=</code></td>
<td style="text-align:center"><code>var &lt;&lt;= expr</code></td>
<td style="text-align:center">左移与赋值</td>
<td style="text-align:center">ShlAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center"><code>expr &lt; expr</code></td>
<td style="text-align:center">小于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center"><code>expr &lt;= expr</code></td>
<td style="text-align:center">小于等于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center"><code>var = expr</code>, <code>ident = type</code></td>
<td style="text-align:center">赋值/等值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center"><code>expr == expr</code></td>
<td style="text-align:center">等于比较</td>
<td style="text-align:center">PartialEq</td>
</tr>
<tr>
<td style="text-align:center"><code>=&gt;</code></td>
<td style="text-align:center"><code>pat =&gt; expr</code></td>
<td style="text-align:center">匹配准备语法的部分</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center"><code>expr &gt; expr</code></td>
<td style="text-align:center">大于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center"><code>expr &gt;= expr</code></td>
<td style="text-align:center">大于等于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>expr &gt;&gt; expr</code></td>
<td style="text-align:center">右移</td>
<td style="text-align:center">Shr</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;=</code></td>
<td style="text-align:center"><code>var &gt;&gt;= expr</code></td>
<td style="text-align:center">右移与赋值</td>
<td style="text-align:center">ShrAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>@</code></td>
<td style="text-align:center"><code>ident @ pat</code></td>
<td style="text-align:center">模式绑定</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>expr ^ expr</code></td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">BitXor</td>
</tr>
<tr>
<td style="text-align:center"><code>^=</code></td>
<td style="text-align:center"><code>var ^= expr</code></td>
<td style="text-align:center">按位异或与赋值</td>
<td style="text-align:center">BitXorAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>|</code></td>
<td style="text-align:center"><code>pat | pat</code></td>
<td style="text-align:center">模式选择</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>|</code></td>
<td style="text-align:center"><code>expr | expr</code></td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">BitOr</td>
</tr>
<tr>
<td style="text-align:center"><code>|=</code></td>
<td style="text-align:center"><code>var |= expr</code></td>
<td style="text-align:center">按位或与赋值</td>
<td style="text-align:center">BitOrAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>||</code></td>
<td style="text-align:center"><code>expr || expr</code></td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center"><code>expr?</code></td>
<td style="text-align:center">错误传播</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h5 id="序列">序列</h5>
<p>即基于范围，如 <code>1..5</code> 生成从1到4的连续数字，左闭右开，常用于循环中。</p>
<ul>
<li><code>1..=5</code> 即可表示全闭区间。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1 2 3 4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="使用-as-完成类型转换">使用 As 完成类型转换</h5>
<p>使用 <code>As</code> 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型。</p>
<h5 id="有理数与复数">有理数与复数</h5>
<p>社区开发的高质量 Rust 数值库：<a target="_blank" rel="noopener" href="https://crates.io/crates/num">num</a>。</p>
<p>导入也十分简单：</p>
<ol>
<li>创建工程：<code>cargo new complex-num</code>；</li>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 添加 <code>num = "0.4.0"</code>。</li>
<li>导入 <code>num</code>：<code>use num::Complex;</code>。</li>
<li><code>cargo build &amp;&amp; cargo run</code>。</li>
</ol>
<p>实例代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Complex { re: <span class="number">2.1</span>, im: -<span class="number">1.2</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">11.1</span>, <span class="number">22.2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} + {}i"</span>, result.re, result.im);</span><br><span class="line">    <span class="comment">// 13.2 + 21i</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="字符-布尔-单元类型">字符、布尔、单元类型</h4>
<p>字符：</p>
<ul>
<li>所有的 Unicode 值都可以作为 Rust 字符。</li>
<li>Unicode 为 4 字节编码，故字符类型也占用 4 个字节。</li>
</ul>
<p>布尔类型：</p>
<ul>
<li>占用 1 字节。</li>
</ul>
<p>单元类型：</p>
<ul>
<li>就是 <code>()</code>，唯一的值也为 <code>()</code>，可以理解为 <code>void</code>。</li>
<li><code>main</code> 函数返回的就是单元类型。</li>
<li>可以用 <code>()</code> 作为 map 的值，表示不关注具体的值，只关注 <code>key</code>。</li>
</ul>
<p><em>Rust中没有返回值的函数称为发散函数，即无法收敛的函数。</em></p>
<h4 id="语句与表达式">语句与表达式</h4>
<p>Rust 的语句和表达式：</p>
<ul>
<li>语句会执行一些操作但是不会返回一个值</li>
<li>表达式会在求值后返回一个值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">0</span>; <span class="comment">// 语句</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">// 语句</span></span><br><span class="line">x + <span class="number">1</span>       <span class="comment">// 表达式</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>表达式总要返回值，且不能包含分号</strong></p>
<ul>
<li>带上分号则变成一条语句。</li>
</ul>
<p><code>let</code> 也是语句，故不能将 <code>let</code> 语句赋值给其他值。</p>
<p>表达式可以成为语句的一部分，例如 <code>let y = 6</code> 中，<code>6</code> 就是一个表达式，处理后后返回一个值 <code>6</code>。</p>
<p><em>能返回值，它就是表达式。</em></p>
<h4 id="函数">函数</h4>
<p>大概的格式如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>规范上，函数名和变量名需要使用蛇形命名法。</li>
<li>函数的位置随便，不在乎定义在何处。</li>
</ul>
<p>Rust 中定义函数如果需要具备参数 <strong>必须声明参数名称和类型</strong> 。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="title function_ invoke__">fun</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) </span><br><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x 的值为 : {}"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"y 的值为 : {}"</span>, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Rust 函数声明返回值类型的方式：</p>
<ul>
<li>在参数声明之后用 <code>-&gt;</code> 来声明函数返回值的类型。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">{</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在函数体中，随时都可以以 <code>return</code> 关键字结束函数运行并返回一个类型合适的值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ten</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当函数无返回值时：</p>
<ul>
<li>返回一个 <code>()</code>。</li>
<li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code>。</li>
</ul>
<p>上面的发散函数，可以用 <code>!</code> 作返回类型，表示永不返回。</p>
<ul>
<li>这种语法往往用作会导致程序崩溃的函数。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">eend</span>() <span class="punctuation">-&gt;</span> ! {</span><br><span class="line">    <span class="built_in">panic!</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="所有权和借用">所有权和借用</h3>
<h4 id="所有权">所有权</h4>
<p>Rust 使用 <strong>所有权系统</strong>。</p>
<p>对于内存管理方面，计算机语言出现了三种流派：</p>
<ul>
<li>垃圾回收机制（GC）：程序运行时不断寻找不再使用的内存，代表有 Java、Go；</li>
<li>手动管理内存：通过调用函数方式进行申请和释放内存，代表有 C++；</li>
<li>通过所有权管理内存：编译器在编译时会根据一系列规则进行检查。
<ul>
<li>检查只发生在编译器，所有在运行期并不会有性能上的损失。</li>
</ul>
</li>
</ul>
<p>C 语言上的不安全：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> *c = <span class="string">"xyz"</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>上述代码可以编译通过。</li>
<li><code>a</code> 为局部变量，当离开作用域时，其内存会被系统回收，从而返回成了悬挂指针。</li>
<li><code>c</code> 的值时常量，存储在常量区，其生命周期为整个程序运行期间，当程序结束系统才会回收这片内存。</li>
</ul>
<h5 id="栈与堆">栈与堆</h5>
<p>栈：先进后出。栈中的所有数据都必须占用已知且固定大小的内存空间。</p>
<p>堆：可存放对于大小未知或可能变化的数据。</p>
<ul>
<li>当往堆上放入数据时，请求一定大小的内存空间，OS在堆的某处寻找并标记区域为已使用，返回该地址的指针。这个过程称为在堆上分配内存（分配）。</li>
<li>指针会被推入栈中，通过栈中的指针获取在堆上的数据。</li>
</ul>
<p>两者在性能上：在栈上分配内存比在堆上分配内存要快，处理器在栈上分配数据会比在堆上分配数据更高效。</p>
<p>当代码调用函数时，传递给函数的参数（可能指向堆上数据的指针和函数的局部变量）依次入栈；当调用结束时，这些值按相反顺序出栈。</p>
<p>堆上的数据是缺乏组织的，所以管理堆上数据的分配和释放尤为重要。</p>
<ul>
<li>当没有及时释放时，便造成了内存泄漏（数据无法被回收）。</li>
</ul>
<h5 id="所有权的原则">所有权的原则</h5>
<p>原则如下：</p>
<ol>
<li>Rust 中每一个值都被一个变量所拥有，该变量称为值的所有者（Owner）。</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。</li>
<li>当变量（所有者）离开作用域时，这个值将被丢弃。</li>
</ol>
<h5 id="变量绑定背后的数据交互">变量绑定背后的数据交互</h5>
<p>了解深拷贝和浅拷贝。</p>
<blockquote>
<p>简单来说，深拷贝在内存上独立，复制内容在新的内存空间上。浅拷贝在内存上共享。比如把A复制到B，如果是深复制，则A和B独立互不影响；如果是浅复制，在修改A，B也会改变。</p>
</blockquote>
<h6 id="拷贝-浅拷贝">拷贝（浅拷贝）</h6>
<p>浅拷贝只发生在栈上，如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></tbody></table></figure>
<p>基本类型在编译时是已知大小，会存储在栈上，所以拷贝其值是快速的。</p>
<p>Rust 具有 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。</p>
<ul>
<li>如果拥有 <code>Copy</code> 特征，则一个旧变量在被赋值给其他变量后仍可用，即赋值的过程是拷贝的过程。</li>
</ul>
<p>规则：</p>
<ul>
<li>任何基本类型的组合可以 <code>Copy</code>；</li>
<li>不需要分配内存或某种形式的资源的类型是可以 <code>Copy</code></li>
</ul>
<p>一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型；</li>
<li>所有浮点数类型；</li>
<li>布尔类型；</li>
<li>字符类型；</li>
<li>包含的类型都可 <code>Copy</code> 的元组；</li>
<li>不可变引用 <code>&amp;T</code>
<ul>
<li><code>&amp;mut T</code> 是可变引用，不可以 <code>Copy</code>。</li>
</ul>
</li>
</ul>
<h6 id="克隆-深拷贝">克隆（深拷贝）</h6>
<p><strong>Rust 永远不会自动创建数据的深拷贝。</strong></p>
<ul>
<li>任何自动的复制都不是深拷贝。</li>
</ul>
<p>当需要深度复制数据时，使用方法 <code>clone()</code>。</p>
<ul>
<li>使用 <code>clone()</code> 会降低程序性能</li>
</ul>
<h6 id="转移所有权">转移所有权</h6>
<p>有代码如下：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是浅拷贝，且没有发生所有权的转移。</li>
<li>整个过程的赋值都是通过浅拷贝方式完成，发生在栈中，所以不需要所有权转移。</li>
</ul>
<p>另有代码如下：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>String</code> 为字符串类型，是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存（跟 C++ 的 <code>std::vector</code> 类似）。
<ul>
<li>即不会自动拷贝。</li>
</ul>
</li>
<li>此时处理方式为：当 <code>s1</code> 被赋予 <code>s2</code> 后，Rust 认为 <code>s1</code> 不再有效，因此也无需在 <code>s1</code> 离开作用域后 drop（丢弃） 任何东西。
<ul>
<li>把所有权从 <code>s1</code> 转移给了 <code>s2</code>，<code>s1</code> 在被赋予 <code>s2</code> 后就马上失效了。</li>
<li>这种类似于移动语义的机制，C++ 的 <code>std::move()</code>。</li>
</ul>
</li>
</ul>
<p>如果真的有两个所有者，那么当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放（double free）</strong> 的错误。</p>
<h5 id="函数传值与返回">函数传值与返回</h5>
<p>将值传递给函数，一样会发生移动或者赋值。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">// s 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                        <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line">                        <span class="comment">// println!("s value: {}", s); // 报错，s 已经移出作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// x 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x value: {}"</span>, x); <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line"><span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) {</span><br><span class="line">    <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_string);</span><br><span class="line">} <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) {</span><br><span class="line">    <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_integer);</span><br><span class="line">} <span class="comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于返回的值：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>(); <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">// s2 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// s2 被移动到 takes_and_gives_back 中,它也将返回值移给 s3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1: {:?}"</span>, s1);</span><br><span class="line">    <span class="comment">// println!("s2: {:?}", s2); // s2 被移走</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s3: {:?}"</span>, s3);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line"><span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gives_ownership 将返回值移动给调用它的函数</span></span><br><span class="line"><span class="comment">/// #### 返回值</span></span><br><span class="line"><span class="comment">/// 返回一个 String 的所有权</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    some_string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="comment">/// #### 参数</span></span><br><span class="line"><span class="comment">/// * `a_string` - 要被移动给调用者的 String</span></span><br><span class="line"><span class="comment">/// #### 返回值</span></span><br><span class="line"><span class="comment">/// 将接收到的 String 的所有权返回出去</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于所有权，所以总是把一个值传来传去来使用它。</p>
<h4 id="引用和借用">引用和借用</h4>
<p>Rust 具有 <strong>借用</strong> 这一概念。</p>
<ul>
<li>借用：获取变量的引用。
<ul>
<li>如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。</li>
</ul>
</li>
</ul>
<h5 id="引用和解引用">引用和解引用</h5>
<p>常规引用是一个指针类型，指向了对象存储的内存地址。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>*</code> 进行解引用。</li>
</ul>
<h5 id="不可变引用">不可变引用</h5>
<p>有如下代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> {</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">// 构造一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} {}"</span>, s1, len);</span><br><span class="line">    <span class="comment">// hello 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>此处函数传入字符串，但无需再用返回的方式传出所有权。</li>
<li>函数参数为 <code>&amp;String</code>。</li>
<li><code>&amp;</code> 在此处表示引用，允许使用值，但不获取所有权。</li>
<li><code>&amp;s1</code> 为指向 <code>s1</code> 的引用，但不拥有它。</li>
</ul>
<p>这样借用可以进行对变量一定的访问。</p>
<h5 id="可变引用">可变引用</h5>
<p>当然也可以试着修改借用的变量。（得寸进尺）</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) {</span><br><span class="line">    string.<span class="title function_ invoke__">push_str</span>(<span class="string">", 🌏"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);</span><br><span class="line">    <span class="comment">// hello, 🌏</span></span><br><span class="line">    <span class="comment">// 由于 Unicode 编码，当然 🌏 也可以显示</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>s</code> 是可变类型，<code>&amp;mut s</code> 是可变的引用，<code>string: &amp;mut String</code> 是接收可变引用的参数。</li>
</ul>
<p>但是，<strong>可变引用同时只能存在一个</strong>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="comment">// let r2 = &amp;mut s; // 报错</span></span><br><span class="line">    <span class="comment">// print!("{} {}", r1, r2);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可变借用 <code>r1</code> 持续到最后一次使用的位置（即输出）；</li>
<li>在 <code>r1</code> 存活间，又尝试创建第二个可变借用 <code>r2</code> 是会引起出错的。</li>
</ul>
<p>这种限制的好处就是使 Rust 在编译期就避免数据竞争。数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。</p>
<p>数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<p><em>可以通过加大括号限制作用域的方式解决部分问题。引用的作用域从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号</em></p>
<p>还有一件事，<strong>可变引用与不可变引用不能同时存在</strong>。（太安全了吧QAQ）</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="comment">// 大问题，不能将`s`借用为可变的，因为它也被借用为不可变的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}, and {}"</span>, r1, r2, r3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以理解为，正在借用不可变引用的用户，肯定不希望借用的东西莫名其妙被改了。</li>
</ul>
<h5 id="nll">NLL</h5>
<p>NLL：Not-Lexical-Lifetimes，一种 Rust 编译器优化行为。</p>
<ul>
<li>用于找到某个引用在作用域 <code>}</code> 结束前就不再被使用的代码位置。</li>
</ul>
<h5 id="悬垂引用">悬垂引用</h5>
<p>悬垂引用也叫做悬垂指针。</p>
<ul>
<li>指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。</li>
</ul>
<p>如在 C++ 中，易见的悬挂：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> aa = *<span class="built_in">fun</span>();</span><br><span class="line">	cout &lt;&lt; aa;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这其实是可以编译通过，但函数 <code>fun</code> 返回的指针式悬挂的。
<ul>
<li>当 <code>fun</code> 中的 <code>a</code> 离开作用域时，<code>a</code> 会被释放，但 <code>fun</code> 返回的指针仍然指向 <code>a</code>。</li>
</ul>
</li>
</ul>
<p>在 Rust 中编译器可以确保 <strong>引用永远也不会变成悬垂状态</strong>。</p>
<ul>
<li>当获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。（🐂牛）</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = <span class="title function_ invoke__">no_dangle</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> {</span><br><span class="line">    <span class="comment">// 报错：该函数返回了一个借用的值，但是已经找不到它所借用值的来源</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    &amp;a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="comment">// 正常的，返回一个解引用，即值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    *&amp;a</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="借用规则总结">借用规则总结</h5>
<ul>
<li>同一时刻，要么只有一个可变引用，要么有任意数量的不可变引用。</li>
<li>引用必须总是有效的（非悬挂）。</li>
</ul>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-03-04</span>
            
                <span>该篇文章被 Fingsinz</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Rust/'>
                            Rust
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            ©2023-2024 

            
                

            
                
                    / <a href="/"> Fingsinz&#39;s Space </a>
                

            
                
                    / <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/fingsinz"> 知乎 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
    </body>


</html>