<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>Fingsinz&#39;s space</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Fingsinz&#39;s space">
<meta property="og:url" content="https://fingsinz.github.io/index.html">
<meta property="og:site_name" content="Fingsinz&#39;s space">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fingsinz">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 6.3.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Fingsinz&#39;s space" rel="home">Fingsinz&#39;s space</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">主页Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/daily">日常Daily</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/notes">笔记Notes</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">归档Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about">关于About</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-1" class="post-1 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/articles/1/">记第一次成功创建博客</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/articles/1/" data-id="cli8zk3nv000124doe8dv9mfu" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <ul>
<li>第一次成功创建博客</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/articles/1/">
    <time datetime="2023-05-29T14:24:21.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li></ul>

    </footer>
</article>






  
    <article id="post-应用层" class="post-应用层 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/" data-id="cli8zk3nz000324dogktr2tis" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="域名系统DNS（Domain-Name-System）"><a href="#域名系统DNS（Domain-Name-System）" class="headerlink" title="域名系统DNS（Domain Name System）"></a>域名系统DNS（Domain Name System）</h2><h3 id="域名系统概述"><a href="#域名系统概述" class="headerlink" title="域名系统概述"></a>域名系统概述</h3><ul>
<li><p>域名系统，是一种将域名转换为IP地址的系统。在互联网上，每个网站都有一个唯一的IP地址，这个地址是由一串数字组成的，但是人们很难记住这些数字。DNS系统的作用就是将这些数字转化为易于记忆的域名。</p>
</li>
<li><p>互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS。</p>
</li>
<li><p>互联网的域名系统DNS被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS使大多数名字都在本地进行解析（resolve），仅少量解析需要在互联网上通信，因此DNS系统效率很高。</p>
</li>
<li><p>域名到IP地址的解析是由分布在互联网上的许多域名服务器程序共同完成。</p>
</li>
</ul>
<h3 id="互联网的域名结构"><a href="#互联网的域名结构" class="headerlink" title="互联网的域名结构"></a>互联网的域名结构</h3><ul>
<li><p>任何一个连接在互联网上的主机或路由器都有一个唯一的层次结构的名字，即域名。</p>
</li>
<li><p>域名的结构由标号序列组成，各标号之间使用点隔开。如<code>www.bing.com</code>。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">www</th>
<th align="center">.</th>
<th align="center">bing</th>
<th>.</th>
<th>com</th>
</tr>
</thead>
<tbody><tr>
<td align="center">三级域名</td>
<td align="center"></td>
<td align="center">二级域名</td>
<td></td>
<td>顶级域名</td>
</tr>
</tbody></table>
<ul>
<li><p>DNS系统由多个服务器组成，它们分为不同的层次，形成了一个分层的结构。最上层是根域名服务器，它们存储了所有的顶级域名（如.com、.org等），并将请求转发到相应的顶级域名服务器。顶级域名服务器存储了二级域名（如.baidu.com、google.com等）的信息，并将请求转发到相应的权威域名服务器。权威域名服务器存储了具体的域名解析信息（即将域名转换为IP地址的信息）。</p>
</li>
<li><p>顶级域名分为三大类</p>
</li>
</ul>
<ol>
<li><p>国家顶级域名nTLD：如<code>cn</code>、<code>us</code>等。</p>
</li>
<li><p>通用顶级域名gTLD：如<code>com</code>、<code>org</code>等。</p>
</li>
<li><p>基础结构域名（infrastructure domain）：只有<code>arpa</code>，用于反向域名解析，因此又称为反向域名。</p>
</li>
</ol>
<ul>
<li>我国二级域名分为两大类</li>
</ul>
<ol>
<li><p>类别域名：如<code>ac</code>、<code>com</code>、<code>edu</code>、<code>gov</code>、<code>mil</code>、<code>net</code>、<code>org</code>。</p>
</li>
<li><p>行政区域名：如<code>bj</code>（北京）等。</p>
</li>
</ol>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul>
<li><p>一个服务器负责管辖的（或有权限的）范围叫作区（zone）。</p>
</li>
<li><p>各单位根据具体情况来划分自己管辖范围的区。在一个区中的所有节点必须是能够连通                                                                                                                                    的。</p>
</li>
<li><p>域名服务器有根域名服务器、顶级域名范围、权限域名服务器和本地域名服务器四种类型。</p>
</li>
<li><p>根域名服务器</p>
</li>
</ul>
<p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</p>
<p>在互联网上共有13个不同IP地址的根域名服务器，它们的名字是用一个英文字母命名，从a一直到m（前13个字母）。</p>
<ul>
<li>顶级域名服务器</li>
</ul>
<p>顶级域名服务器负责管理在该顶级域名服务器</p>
<ul>
<li>权限域名服务器</li>
</ul>
<p>负责一个区的域名服务器。</p>
<ul>
<li>本地域名服务器</li>
</ul>
<p>当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。</p>
<ul>
<li>假定域名为m.xyz.com 的主机想知道另一台主机（域名为 y.abc.com)的 IP地址。例如，主机 m.xyz.com 打算发送邮件给主机 y.abc.com。这时就必须知道主机 y.abc.com的IP地址。下面是几个查询步骤:</li>
</ul>
<ol>
<li><p>主机m.xyz.com先向其本地域名服务器dns.xyz.com进行递归查询。</p>
</li>
<li><p>本地域名服务器采用迭代查询。它先向一个根域名服务器查询。</p>
</li>
<li><p>根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 dns.com的IP地址。</p>
</li>
<li><p>本地域名服务器向顶级域名服务器dns.com进行查询。</p>
</li>
<li><p>顶级域名服务器dns.com 告诉本地域名服务器，下一次应查询的权限域名服务器dns.abc.com的IP地址。</p>
</li>
<li><p>本地域名服务器向权限域名服务器dns.abc.com进行查询。</p>
</li>
<li><p>权限域名服务器 dns.abc.com 告诉本地域名服务器，所查询的主机的IP地址。</p>
</li>
<li><p>本地域名服务器最后把查询结果告诉主机m.xyz.com。</p>
</li>
</ol>
<h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2><h3 id="FTP概述"><a href="#FTP概述" class="headerlink" title="FTP概述"></a>FTP概述</h3><h3 id="FTP的基本工作原理"><a href="#FTP的基本工作原理" class="headerlink" title="FTP的基本工作原理"></a>FTP的基本工作原理</h3><ul>
<li><p>文件传送协议FTP只提供文件传送的一些基本的服务，它使用TCP可靠的运输服务。</p>
</li>
<li><p>FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p>
</li>
<li><p>FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</p>
</li>
</ul>
<h3 id="简单文件传送协议TFTP"><a href="#简单文件传送协议TFTP" class="headerlink" title="简单文件传送协议TFTP"></a>简单文件传送协议TFTP</h3><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="万维网概述"><a href="#万维网概述" class="headerlink" title="万维网概述"></a>万维网概述</h3><h3 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h3><h3 id="超文本传送协议HTTP"><a href="#超文本传送协议HTTP" class="headerlink" title="超文本传送协议HTTP"></a>超文本传送协议HTTP</h3><ul>
<li><p>HTTP是面向事务的超媒体文件。</p>
</li>
<li><p>HTTP的操作过程：为了使超文本的连接能够高效率地完成，需要用HTTP协议来传送一切必须的信息。</p>
</li>
<li><p>用户点击URL：<a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn/chn/yxsz/index.htm-4%E5%90%8E%E6%89%80%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E4%BB%B6">http://www.tsinghua.edu.cn/chn/yxsz/index.htm-4后所发生的事件</a></p>
</li>
</ul>
<ol>
<li><p>浏览器分析超链指向页面的URL。</p>
</li>
<li><p>浏览器向DNS请求解析<a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn的ip地址./">www.tsinghua.edu.cn的IP地址。</a></p>
</li>
<li><p>域名系统DNS 解析出清华大学服务器的IP地址。</p>
</li>
<li><p>浏览器与服务器建立TCP连接。</p>
</li>
<li><p>浏览器发出取文件命令：GET&#x2F;chn&#x2F;yxsz&#x2F;index.htm。</p>
</li>
<li><p>服务器给出响应，把文件index.htm 发给浏览器。</p>
</li>
<li><p>TCP连接释放。</p>
</li>
<li><p>浏览器显示“清华大学院系设置”文件index.htm 中的所有文本。</p>
</li>
</ol>
<ul>
<li><p>持续工作</p>
</li>
<li><p>代理服务器</p>
</li>
<li><p>HTTP报文结构</p>
</li>
</ul>
<p>请求报文</p>
<ul>
<li>在服务器上存放用户的信息</li>
</ul>
<h3 id="万维网的文档"><a href="#万维网的文档" class="headerlink" title="万维网的文档"></a>万维网的文档</h3><ul>
<li><p>HTML</p>
</li>
<li><p>CSS</p>
</li>
</ul>
<h3 id="万维网和信息检索系统"><a href="#万维网和信息检索系统" class="headerlink" title="万维网和信息检索系统"></a>万维网和信息检索系统</h3><h3 id="博客和微博"><a href="#博客和微博" class="headerlink" title="博客和微博"></a>博客和微博</h3><h3 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h3><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h3><h3 id="简单邮件传送协议SMTP"><a href="#简单邮件传送协议SMTP" class="headerlink" title="简单邮件传送协议SMTP"></a>简单邮件传送协议SMTP</h3><ul>
<li>SMTP缺点</li>
</ul>
<ol>
<li><p>SMTP不能传送可执行文件或其他的二进制对象。</p>
</li>
<li><p>SMTP限于传送7位的ASCII码。</p>
</li>
</ol>
<h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><h3 id="邮件读取协议POP3和IMAP"><a href="#邮件读取协议POP3和IMAP" class="headerlink" title="邮件读取协议POP3和IMAP"></a>邮件读取协议POP3和IMAP</h3><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><h3 id="通用互联网邮件扩充MIME"><a href="#通用互联网邮件扩充MIME" class="headerlink" title="通用互联网邮件扩充MIME"></a>通用互联网邮件扩充MIME</h3><ul>
<li>5个首部</li>
</ul>
<h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><h2 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h2><h2 id="应用进程跨越网络的通信"><a href="#应用进程跨越网络的通信" class="headerlink" title="应用进程跨越网络的通信"></a>应用进程跨越网络的通信</h2><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/">
    <time datetime="2023-05-28T16:00:00.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-数据链路层" class="post-数据链路层 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" data-id="cli8zk3o4000924dode3t5xoq" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <ul>
<li><p>数据链路层使用的信道：点对点信道；广播信道。</p>
</li>
<li><p>点对点信道：使用一对一的点对点通信方式。</p>
</li>
<li><p>广播信道：使用一对多的广播通信方式。</p>
</li>
</ul>
<h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><ul>
<li>链路（link）是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li>
</ul>
<p>一条链路只是一条通路的一个组成部分。</p>
<ul>
<li>数据链路（data link）除了物理线路外，还必须有通信协议来控制这些数据的传输。</li>
</ul>
<p>若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<ul>
<li><p>另外的术语：物理链路和逻辑链路，逻辑链路&#x3D;物理链路+协议。</p>
</li>
<li><p>点对点信道的数据链路层的协议数据单元是帧，数据链路层传送的是帧。</p>
</li>
</ul>
<p>数据链路层像个数字管道，在这条管道上传输的数据单位是帧。</p>
<ul>
<li>点对点信道的数据链路层在进行通信时的主要步骤如下：</li>
</ul>
<ol>
<li><p>结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。</p>
</li>
<li><p>结点A把封装好的帧发送给结点B的数据链路层。</p>
</li>
<li><p>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层；否则丢弃这个帧。</p>
</li>
</ol>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul>
<li><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样构成一个帧。</p>
</li>
<li><p>首部和尾部具有许多控制信息，一个重要作用就是进行帧定界。</p>
</li>
<li><p>每一种数据链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元MTU。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>帧开始</th>
<th>IP数据报</th>
<th>帧结束</th>
</tr>
</thead>
<tbody><tr>
<td>帧首部</td>
<td>帧的数据部分$\leq MTU$</td>
<td>帧尾部</td>
</tr>
</tbody></table>
<ul>
<li>用控制字符进行帧定界。</li>
</ul>
<p>控制字符<code>SOH</code>（Start Of Header），表示帧的首部开始。控制字符<code>EOT</code>（End of Transmission），表示帧的结束。</p>
<p>具有明确的帧定界符才是完整的帧。</p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><ul>
<li>透明传输：不管所传数据是什么样的比特组合，都能在链路上传输。</li>
</ul>
<p><strong>“透明”表示：某一个实际存在的事物看起来却好像不存在一样。</strong></p>
<p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样。否则会出现帧定界的错误。当遇到数据中碰巧出现字符“EOT”时就传不过去。数据中的“EOT”被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。</p>
<ul>
<li>解决透明传输：字节填充或字符填充。<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。如果转义字符也出现在数据中，那么仍在转义字符的前面插入一个转义字符。</li>
</ul>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul>
<li><p>产生比特差错：1和0的变换。</p>
</li>
<li><p>误码率：传输错误的比特占所传输比特总数的比率。</p>
</li>
</ul>
<p>误码率与信噪比关系很大。</p>
<ul>
<li>循环冗余检验CRC，能够实现无比特差错传输。</li>
</ul>
<h5 id="CRC循环冗余校验（Cyclic-Redundancy-Check）"><a href="#CRC循环冗余校验（Cyclic-Redundancy-Check）" class="headerlink" title="CRC循环冗余校验（Cyclic Redundancy Check）"></a>CRC循环冗余校验（Cyclic Redundancy Check）</h5><h6 id="CRC码的基本思想"><a href="#CRC码的基本思想" class="headerlink" title="CRC码的基本思想"></a>CRC码的基本思想</h6><ul>
<li><p>数据发送接受方约定一个“除数”（二进制）。</p>
</li>
<li><p>K个信息位和R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信息位</th>
<th align="center">校验位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">K位</td>
<td align="center">R位</td>
</tr>
</tbody></table>
<ul>
<li>收到数据后，进行除法检查余数是否为0。</li>
</ul>
<h6 id="如何构造"><a href="#如何构造" class="headerlink" title="如何构造"></a>如何构造</h6><ul>
<li>假设生成多项式为$G(x)&#x3D;x^3+x^2+1$，信息码为101001，求对应CRC码。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信息位</th>
<th align="center">校验位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">K位</td>
<td align="center">R位</td>
</tr>
</tbody></table>
<ol>
<li>确定K、R以及生成多项式对应的二进制编码。</li>
</ol>
<p>由生成多项式$G(x)&#x3D;1·x^3+1·x^2+0·x+1·x^0$，得对应的二进制编码为1101。</p>
<p>$K&#x3D;信息码长度&#x3D;6$，$R&#x3D;生成多项式最高次幂&#x3D;3$，CRC位数<code>N=K+R=9</code>。</p>
<ol start="2">
<li>移位</li>
</ol>
<p>信息码左移<code>R</code>位，低位补0。</p>
<ol start="3">
<li>相除</li>
</ol>
<p>对移位后的信息码，用生成多项式进行模2除法，产生余数。</p>
<p><img src="/.io//CRC%E6%B1%82%E6%A0%A1%E9%AA%8C%E4%BD%8D.jpg"></p>
<p>得到对应CRC码：<code>101001001</code></p>
<h6 id="如何检错纠错"><a href="#如何检错纠错" class="headerlink" title="如何检错纠错"></a>如何检错纠错</h6><ul>
<li><p>如发送：<code>101001001</code>记为$C_9C_8C_7C_6C_5C_4C_3C_2C_1$。</p>
</li>
<li><p>接收方：<code>101001001</code>用<code>1101</code>进行模2除，余数为<code>000</code>代表没有出错。</p>
</li>
<li><p>接收方：<code>101001011</code>用<code>1101</code>进行模2除，余数为<code>010</code>代表出错。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">接受</th>
<th align="center">余数</th>
<th align="center">出错位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10100100<font color="red">0</font></td>
<td align="center">001</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1010010<font color="red">1</font>1</td>
<td align="center">010</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">101001<font color="red">1</font>01</td>
<td align="center">100</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">10100<font color="red">0</font>001</td>
<td align="center">101</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">1010<font color="red">1</font>1001</td>
<td align="center">111</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">101<font color="red">1</font>01001</td>
<td align="center">011</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">10<font color="red">0</font>001001</td>
<td align="center">110</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">1<font color="red">1</font>1001001</td>
<td align="center">001</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"><font color="red">0</font>01001001</td>
<td align="center">010</td>
<td align="center">9</td>
</tr>
</tbody></table>
<ul>
<li>K个信息位，R个校验位，若生成多项式选择得当，且$2^R\geq K+R+1$，则CRC码可纠正1位错。</li>
</ul>
<p>上述例子中，总位数有9位，而校验位只有3位，$2^3&#x3D;8$，则不能表示所有的错误位置。</p>
<ul>
<li>理论上可以得出CRC校验码的特点：</li>
</ul>
<ol>
<li>可检测出所有奇数个错误；</li>
<li>可检测出所有双比特的错误；</li>
<li>可检测出所有小于等于校验位长度的连续错误。</li>
</ol>
<ul>
<li><p>在数据后面添加上冗余码称为帧检验序列FCS。</p>
</li>
<li><p>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码。</p>
</li>
<li><p>仅用循环冗余检验CRC差错检测技术只能做到无差错接受。</p>
</li>
</ul>
<p>凡是接收端数据链路层接受的帧，都能以非常接近1的概率认为这些帧在传输过程中没有产生差错。</p>
<p>无比特差错和无传输差错是不同的概念。</p>
<h2 id="点对点协议PPP（Point-to-Point-Protocol）"><a href="#点对点协议PPP（Point-to-Point-Protocol）" class="headerlink" title="点对点协议PPP（Point-to-Point Protocol）"></a>点对点协议PPP（Point-to-Point Protocol）</h2><h3 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h3><ul>
<li><p>用户计算机和ISP进行通信时所使用的数据链路层协议就是PPP协议。</p>
</li>
<li><p>PPP协议应该满足的需求</p>
</li>
</ul>
<ol>
<li><p>简单——首要要求。</p>
</li>
<li><p>封装成帧——必须规定特殊的字符作为帧定界符。</p>
</li>
<li><p>透明性——必须保证数据传输的透明性。</p>
</li>
<li><p>多种网络协议——能够在同一条物理链路上同时支持多种网络层协议。</p>
</li>
<li><p>多种类型网络——能够在多种类型网络上使用。</p>
</li>
<li><p>差错检测——必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p>
</li>
<li><p>检测连接状态——能够即使自动检测出链路是否处于正常工作状态。</p>
</li>
<li><p>最大传送单元——必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。</p>
</li>
<li><p>网络层地址协商——必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</p>
</li>
<li><p>数据压缩协商——必须提供一种方法来协商使用数据压缩算法。</p>
</li>
</ol>
<ul>
<li>PPP协议不需要的功能</li>
</ul>
<ol>
<li><p>纠错</p>
</li>
<li><p>流量控制</p>
</li>
<li><p>序号</p>
</li>
<li><p>多点线路</p>
</li>
<li><p>半双工或单工线路</p>
</li>
</ol>
<ul>
<li>PPP协议组成部分：</li>
</ul>
<ol>
<li><p>一个将IP数据报封装到串行链路的方法。</p>
</li>
<li><p>链路控制协议LCP（Link Control Protocol）。</p>
</li>
<li><p>网络控制协议NCP（Network Control Protocol）。</p>
</li>
</ol>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><h4 id="帧各字段的意义"><a href="#帧各字段的意义" class="headerlink" title="帧各字段的意义"></a>帧各字段的意义</h4><ul>
<li><p>PPP帧首部和尾部分别为4个字段和2个字段。</p>
</li>
<li><p>首部</p>
</li>
</ul>
<p>标志字段F（Flag），规定为<code>0x7E</code>，是PPP帧的定界符，占用1个字节；</p>
<p>地址字段A，规定为<code>0xFF</code>，占用1个字节；</p>
<p>控制字段C，规定为<code>0x03</code>，占用1个字节；</p>
<p>协议占用2个字节。当协议字段为<code>0x0021</code>时，PPP帧的信息字段就是IP数据报。当协议字段为<code>0xC021</code>时，则信息字段是PPP链路控制协议LCP的数据。当协议字段为<code>0x8021</code>时，表示这是网络层的控制数据。</p>
<ul>
<li><p>信息字段的长度是可变的，不超过1500字节。</p>
</li>
<li><p>尾部第一个字段是使用CRC的帧检验序列FCS，第二个字段是标志字段F。</p>
</li>
</ul>
<h4 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h4><ul>
<li>当信息字段中出现和标志字段一样的比特<code>0x7E</code>组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。当</li>
</ul>
<p>PPP使用异步传输时，它把转义字符定义为<code>0x7D</code>即<code>01111101</code>，并使用字节填充。</p>
<ul>
<li>RFC1662规定了填充方法：</li>
</ul>
<ol>
<li><p>把信息字段中出现的每一个<code>0x7E</code>字节转变成为2字节序列<code>0x7D,0x5E</code>。</p>
</li>
<li><p>若信息字段中出现了一个<code>0x7D</code>的字节（即出现了和转义字符一样的比特组合），则把<code>0x7D</code>转变为2字节序列<code>0x7D,0x5D</code>。</p>
</li>
<li><p>若信息字段中出现了ASCII码的控制字符（数值小于<code>0x20</code>的字符），则在该字符前加入一个<code>0x7D</code>字节，同时将该字符的编码加以改变。如出现了<code>0x03</code>（在控制字符中是“传输结束”ETX）就要把它转变为2字节序列<code>0x7D,0x23</code>。<br>发送端进行了修改，但接收端在收到数据在进行于发送端字节填充相反的变换。</p>
</li>
</ol>
<h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><ul>
<li><p>零比特填充的具体做法：在发送端，先扫描整个信息字段，只要发现有5个连续1，则立即填入一个0（防止被认为是标志字段F）。接收端在收到一个帧时，先找到标志字段F以确认一个帧的边界，接着再用硬件对其中的比特流进行扫描，当发现5个连续的1时，就把这5个连续1后的一个0删除，还原成原来的信息比特流。</p>
</li>
<li><p>上述方法保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p>
</li>
</ul>
<h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><p><img src="/.io//PPP%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.jpg"></p>
<ul>
<li>PPP协议有5个工作状态：</li>
</ul>
<ol>
<li><p>链路静止（Link Dead）：PPP链路的起始和终止状态永远是链路静止，这个阶段发生在链接失败，或一方被告知断开连接（例如，用户已经完成了他或她的拨号连接）。</p>
</li>
<li><p>链路建立（LCP 连接建立）（Link Establishment Phase）：发送者与接收者之间建立连接。</p>
</li>
<li><p>鉴别用户身份（身份验证）（Authentication Phase）：使用用户名和口令对建立的链接进行身份验证，确定对方的身份是否合法。</p>
</li>
<li><p>网络层协议（NCP 建立）（Network-Layer Protocol Phase）：在建立的PPP链路上，根据具体需要选择所要使用的网络层协议，并为该协议建立NCP（网络控制协议）。</p>
</li>
<li><p>链路终止（LCP连接终止）（Link Termination Phase）：链路连接的关闭及资源的释放。</p>
</li>
</ol>
<ul>
<li><p>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。PC 机向路由器发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧)这些分组及其响应选择一些PPP参数，并进行网络层配置，网络控制程序NCP 给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p>
</li>
<li><p>PPP协议不是纯粹的数据链路层的协议，还包括物理层和网络层的内容。</p>
</li>
<li><p>当用户个人电脑通过调制解调器呼叫路由器时，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP就进入“链路建立”（Link Establish）状态，其目的是建立链路层的LCP连接。这时LCP开始协商一些配置选项，即发送LCP的配置请求帧（Configure-Request）。这是个 PPP帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。</p>
</li>
<li><p>链路的另一端可以发送以下几种响应中的一种：</p>
</li>
</ul>
<ol>
<li><p>配置确认帧（Configure-Ack）所有选项都接受。</p>
</li>
<li><p>配置否认帧（Configure-Nak）所有选项都理解但不能接受。</p>
</li>
<li><p>配置拒绝帧（Configure-Reject）选项有的无法识别或不能接受，需要协商。</p>
</li>
</ol>
<ul>
<li><p>LCP配置选项包括链路上的最大帧长、所使用的<strong>鉴别协议</strong>（authentication protocol）的规约（如果有的话），以及不使用PPP帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在PPP帧的首部中省略这两个字节）。协商结束后双方就建立了 LCP链路，接着就进入“<strong>鉴别</strong>”（Authenticate）状态。在这一状态，只允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用口令鉴别协议PAP（Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的口令握手鉴别协议 CHAP <strong>（Challenge-Handshake Authentication Protocol）。若鉴别身份失败，则转到“</strong>链路终止<strong>”（Link Terminate）状态。若鉴别成功，则进入“</strong>网络层协议**”（Network-Layer Protocol）状态。</p>
</li>
<li><p>在“<strong>网络层协议</strong>”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信。</p>
</li>
<li><p>如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块（如分配 IP 地址）时就要使用 NCP 中支持 IP的协议——<strong>IP 控制协议 IPCP</strong> （IP Control Protocol）。IPCP 分组也封装成PPP帧（其中的协议字段为<code>0x8021</code>）在PPP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和IP首部，以减少在链路上发送的比特数。</p>
</li>
<li><p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”（Link Open）状态。链路的两个 PPP端点可以彼此向对方发送分组。两个 PPP端点还可发送<strong>回送请求</strong>LCP分组（Echo-Request）和<strong>回送回答</strong>LCP分组（Echo-Reply），以检查链路的状态。</p>
</li>
<li><p>数据传输结束后，可以由链路的一端发出终止请求LCP分组（Terminate-Request）请求终止链路连接，在收到对方发来的终止确认 LCP 分组（Terminate-Ack）后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，也会从“<strong>链路打开</strong>”状态转到“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”的状态。</p>
</li>
</ul>
<h2 id="使用广播通信的数据链路层"><a href="#使用广播通信的数据链路层" class="headerlink" title="使用广播通信的数据链路层"></a>使用广播通信的数据链路层</h2><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><ul>
<li><p>特点：网络为一个单位所拥有；地理范围和站点数目有限。</p>
</li>
<li><p>局域网具有如下主要优点：</p>
</li>
</ul>
<ol>
<li><p>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</p>
</li>
<li><p>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</p>
</li>
<li><p>提高了系统的可靠性、可用性和残存性。</p>
</li>
</ol>
<ul>
<li>共享信道：静态划分信道和动态媒体接入控制。</li>
</ul>
<p>静态划分信道包括频分复用、时分复用、波分复用和码分复用灯，但代价较高不适合局域网使用。动态媒体接入控制又称多点接入，特点是信道并非在用户通信时固定分配给用户。</p>
<ul>
<li>动态媒体接入又分为随机接入和受控接入。</li>
</ul>
<p>随机接入的特点是所有用户可随机地发送信息，但如果恰巧多用户同时发送信息时，出现信息碰撞冲突，所以要有解决碰撞的网络协议。受控接入的特点是用户不能随机地发送信息而必须服从一定的控制，这类典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（又称轮询）。</p>
<h4 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h4><ul>
<li><p>以太网的两个标准：DIX Ethernet V2和IEEE 802.3。</p>
</li>
<li><p>IEEE802委员会把局域网的数据链路层拆成两个子层：逻辑链路控制LLC（Logical Link Control）和媒体接入控制MAC（Medium Access Control）。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的。</p>
</li>
</ul>
<h4 id="适配器的作用"><a href="#适配器的作用" class="headerlink" title="适配器的作用"></a>适配器的作用</h4><ul>
<li><p>计算机与外界局域网的连接时通过通信适配器（adapter）进行的。</p>
</li>
<li><p>适配器本来是一块网络接口板，又称为通信适配器或网络接口卡NIC，或“网卡”。</p>
</li>
<li><p>重要功能：串行&#x2F;并行转换；数据缓存；安装设备驱动程序；实现以太网协议。</p>
</li>
</ul>
<h3 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><ul>
<li>以太网采用广播方式发送。</li>
</ul>
<p>总线上的每一个工作的计算机都能检测到发送的数据信号。但由于数据帧首部写入地址匹配问题，只有某个计算机才能接收。</p>
<ul>
<li>以太网采用两种重要措施</li>
</ul>
<ol>
<li>采用较为灵活的无连接的工作方式。</li>
</ol>
<p>不必先建立连接就可以直接发送数据。对发送的数据帧不进行编号，也不要求对方发回确认。</p>
<p>以太网提供的服务时不可靠的交付，即尽最大努力的交互。</p>
<p>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</p>
<p>如果发现了数据帧丢失了一些数据，于是把这些数据重新传递给以太网进行重传，但以太网并不知道这是重传帧，而是当作新的数据帧来发送。</p>
<ol start="2">
<li>以太网发送的数据都是用曼彻斯特编码。</li>
</ol>
<p>曼彻斯特编码的缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</p>
<ul>
<li><p>CSMA&#x2F;CD含义： 载波监听多点接入&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection）。</p>
</li>
<li><p>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。</p>
</li>
<li><p>“载波监听”是指每一个站在发送数据之前先要检测总线上是否有其他计算机在发送数据，如果有，则暂时不发送数据，以免发生碰撞。</p>
</li>
</ul>
<p>总线上并没有什么“载波”。因此，“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p>
<ul>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。“碰撞检测”也成为“冲突检测”。</li>
</ul>
<p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将增大。当适配器检测到的信号电压变化幅度超过一定的门限值，就认为总线上至少有两个站同时在发送数据。</p>
<ul>
<li><p>为什么要进行碰撞检测？<br>由于电磁波在总线上的传播速率是有限的。 碰撞的结果是两个帧都变得无用。</p>
</li>
<li><p>使用CSMA&#x2F;CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p>
</li>
<li><p>争用期</p>
</li>
</ul>
<p>最先发送数据帧的站，在发送数据帧后至多经过时间$2τ$就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延$2τ$称为争用期或碰撞窗口。经过争用期后还没有检测到碰撞，才能肯定此次发送不会发生碰撞。</p>
<p>10Mbit&#x2F;s以太网取51.2μs为争用期长度。对于10Mbit&#x2F;s以太网，在争用期可发送512bit，即64字节。这意味着以太网在发送数据时，若前64字节没有发送冲突，则后续的数据就不会发送冲突。</p>
<p>如果发生冲突，一定在发送前64字节之内。由于冲突而终止发送，此时发送出去的数据一定小于64字节。<strong>以太网规定了最短有效帧长为64字节</strong>，凡长度小于64字节的帧都是由于冲突而异常终止的无效帧。</p>
<ul>
<li>最短帧长计算</li>
</ul>
<p>$$<br>最短帧长 &#x3D; 争用期长度 × 数据传输速率<br>$$<br>$$<br>争用期长度是指端到端传输时延 τ 的两倍。<br>$$<br>$$<br>最短帧长 &#x3D; 2τ × 数据传输速率<br>$$</p>
<ul>
<li>二进制指数类型退避算法</li>
</ul>
<p>发送碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能在发送数据。基本退避时间取为争用期$2τ$。从整数集合$[0,1,…,(2^k-1)]$中随机取出一个数，记为$r$。重传所需时延就是$r$倍的基本退避时间。</p>
<p>参数$k$计算：$k&#x3D;Min[重传次数,10]$，当$k\leq 10$时，参数$k$等于重传次数。</p>
<p>当重传达16次仍不能成功时丢弃此帧，并向高层报告。</p>
<ul>
<li>强化碰撞</li>
</ul>
<p>一旦发生了碰撞：立即停止发送数据；再继续发送32比特或48比特的人为干扰信号。</p>
<ul>
<li>CSMA&#x2F;CD协议的要点</li>
</ul>
<ol>
<li><p>准备发送。在发送之前，必须先检测信道。</p>
</li>
<li><p>检测信道。若检测到信道忙，应不停检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内保持空闲（保证了帧间最小间隔），就发送这个帧。</p>
</li>
<li><p>检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里有两种可能性。</p>
</li>
</ol>
<p>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做，回到步骤1。</p>
<p>发送失败：在争用期内检测到碰撞。这是立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法。等待r倍512比特时间后，返回到步骤2，继续检测信道。但若重传达16次仍不成功，则停止重传而向上报错。</p>
<h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><ul>
<li>物理上是星型，逻辑上是总线型。</li>
</ul>
<p>为了降低成本，最初由粗的同轴电缆变成细的同轴电缆最后变成无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收；</p>
<ul>
<li><p>采用双绞线的以太网采用星形拓扑，在星形中心则增加了一种可靠性非常高的设备，叫作集线器（hub）。</p>
</li>
<li><p>1990年，IEEE制定星形以太网10BASE-T的标准802.3i。10表示速度10Mbit&#x2F;s，BASE指的是连接线上的信号是基带信号，T代表双绞线。</p>
</li>
</ul>
<p>使用无屏蔽双绞线，采用星形拓扑。每个站需要两队双绞线用于发送和接收。双绞线两端使用RJ-45插头。</p>
<ul>
<li>集线器的一些特点</li>
</ul>
<p>逻辑上仍是一个总线网，各工作站使用的还是CSMA&#x2F;CD协议，并共享逻辑上的总线，在同一时刻至多只允许一个站发送数据。</p>
<ol>
<li><p>能够扩展网络：集线器可以将多个网络设备连接在一起，扩展网络的范围和接入设备的数量。</p>
</li>
<li><p>传输速率较慢：集线器的传输速率较慢，一般为10Mbps或100Mbps，无法满足高速数据传输的需求。</p>
</li>
<li><p>无法分割网络：集线器不具备分割网络的能力，所有连接的设备共享同一个网络地址。</p>
</li>
<li><p>无法过滤数据：集线器无法过滤数据包，所有的数据包都会被广播到所有连接的设备上。</p>
</li>
<li><p>便宜易用：集线器的价格较为低廉，且使用简单，适合小型网络的搭建。</p>
</li>
<li><p>可靠性较低：由于集线器无法检测网络中的故障点，不进行碰撞检测，一旦出现故障，整个网络将会受到影响。</p>
</li>
</ol>
<h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><ul>
<li>以太网的信道利用率是指在一定时间内，实际传输数据的时间与总时间的比值。</li>
</ul>
<p>由于在以太网中，传输数据需要占用一定的时间，而且在传输数据时可能会出现冲突、重传等情况，因此实际传输数据的时间会比总时间要短，信道利用率也就相应地降低。</p>
<ul>
<li><p>以太网总的信道利用率并不能达到100%。</p>
</li>
<li><p>假设发送帧需要的时间是$T_0$，则成功发送一个帧需要占用信道的时间是$T_0+τ$，多一个单程端到端时延$τ$。因此必须经过时间$T_0+τ$后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">争用期</th>
<th align="center">争用期</th>
<th align="center">……</th>
<th align="center">争用期</th>
<th align="center">发送成功</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$2τ$</td>
<td align="center">$2τ$</td>
<td align="center"></td>
<td align="center">$2τ$</td>
<td align="center">$T_0$</td>
<td align="center">$τ$</td>
</tr>
</tbody></table>
<p>前面争用期时间为发生碰撞的情况，后面从发送成功到一个$τ$时间为占用信道时间。</p>
<h4 id="以太网参数α"><a href="#以太网参数α" class="headerlink" title="以太网参数α"></a>以太网参数α</h4><ul>
<li><p>定义参数$α$，以太网单程端到端时延$τ$与帧发送时间$T_0$之比，$α&#x3D;\frac t {T_0}$。当$α\rightarrow 0$，表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。$α$越大，表明争用期所占的比例增大，每发生一次碰撞浪费许多信道资源，使得信道利用率明显降低。</p>
</li>
<li><p>从式子可得当数据率一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短。</p>
</li>
</ul>
<h4 id="信道利用率的最大值-S-max"><a href="#信道利用率的最大值-S-max" class="headerlink" title="信道利用率的最大值$S_{max}$"></a>信道利用率的最大值$S_{max}$</h4><ul>
<li>使用非常理想化的考虑，计算极限信道利用率：</li>
</ul>
<p>$$<br>S_{max}&#x3D;\frac {T_0}{T_0+τ}&#x3D;\frac 1 {1+a}<br>$$</p>
<p>只有参数$α$远小于1才能得到尽可能高的极限信道利用率。若参数$α$远大于1，则极限信道利用率就远小于1，而此时实际的信道利用率就更小。当以太网的利用率达到30%时就已经处于重载的情况。</p>
<h3 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h3><h4 id="MAC层的硬件地址"><a href="#MAC层的硬件地址" class="headerlink" title="MAC层的硬件地址"></a>MAC层的硬件地址</h4><ul>
<li>MAC地址（Media Access Control Address），又称硬件地址或物理地址，是用于唯一标识网络设备的地址。在计算机网络中，MAC地址是以太网协议中的一个重要参数，用于识别数据包发送者和接收者。</li>
</ul>
<p>MAC地址，实际上就是适配器地址或适配器标识符EUI-48。</p>
<p>802标准所说的“地址”严格说应该是每一个站的“名字”或标识符。</p>
<ul>
<li>MAC地址由48位二进制数表示，通常被表示为12个十六进制数，每两个十六进制数之间用冒号或短横线隔开。MAC地址由两部分组成：厂商代码和设备标识符。</li>
</ul>
<p>厂商代码是由IEEE（Institute of Electrical and Electronics Engineers）注册管理机构分配的，占用24位二进制数。设备标识符是由厂商自己分配的，占用24位二进制数。</p>
<p>IEEE规定地址字段的第一字节最低位为I&#x2F;G位。I&#x2F;G表示Individual&#x2F;Group。当I&#x2F;G位&#x3D;0，地址字段表示一个单站地址；当I&#x2F;G位&#x3D;1，地址字段表示一个组地址。所有48位都为1，地址字段是广播地址。</p>
<p>IEEE规定地址字段的第一字节最低位为G&#x2F;L位。G&#x2F;L表示Global&#x2F;Local。当G&#x2F;L位&#x3D;0，是全球管理（保证在全球没有相同的地址），厂商向IEEE购买的OUI都属于全球管理。当G&#x2F;L位&#x3D;1，是本地管理，这时用户可任意分配网络上的地址。</p>
<ul>
<li>MAC地址是<strong>唯一</strong>的，每个网络设备都会被分配一个唯一的MAC地址。MAC地址通常被写在设备的网卡上，由网卡芯片固化在硬件中。在以太网中，MAC地址被用于识别数据包发送者和接收者。</li>
</ul>
<p>当一个数据包从源设备发送到目的设备时，数据包中会包含源MAC地址和目的MAC地址。网络设备通过比对数据包中的目的MAC地址和自己的MAC地址，来判断是否接收该数据包。如果目的MAC地址与设备的MAC地址相同，设备就会接收该数据包并进行处理，否则就会忽略该数据包。<br>总之，MAC地址是网络设备的一个重要标识，它是由网络设备的物理硬件决定的，一般情况下不会改变。它在网络通信中起到了重要的作用。</p>
<h5 id="适配器检查MAC地址"><a href="#适配器检查MAC地址" class="headerlink" title="适配器检查MAC地址"></a>适配器检查MAC地址</h5><ul>
<li><p>适配器（Network Adapter）是计算机中用于连接计算机与网络之间的设备，也称为网卡（Network Interface Card）。在计算机网络中，适配器通常用于接收和发送网络数据包。</p>
</li>
<li><p>适配器通常具有一个硬件地址，也称为MAC地址。检查MAC地址是指在数据包到达适配器时，适配器会首先检查数据包中的目的MAC地址是否与自己的MAC地址相同。</p>
</li>
</ul>
<p>相同，接收该数据包并将其传递给计算机进行处理。</p>
<p>不同，忽略该数据包。</p>
<ul>
<li><p>“发往本站的帧”包括：单播帧（一对一，即收到的帧的MAC地址与本站硬件地址相同）、广播帧（一对全体，即发送给本局域网上所有站点的帧，全1地址）和多播帧（一对多，即发送给本局域网一部分站点的帧）。</p>
</li>
<li><p>所有的适配器都至少能够识别前两种帧，即能识别单播地址和广播地址。</p>
</li>
<li><p>只有目的地址才能使用广播地址和多播地址。</p>
</li>
</ul>
<h4 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h4><ul>
<li>常用的以太网MAC帧格式有两种标准：DIX Ethernet V2标准（以太网V2标准）和IEEE的802.3标准。</li>
</ul>
<h5 id="以太网V2标准的MAC帧格式"><a href="#以太网V2标准的MAC帧格式" class="headerlink" title="以太网V2标准的MAC帧格式"></a>以太网V2标准的MAC帧格式</h5><p>以太网的帧最短是64字节，而现在目的地址，原地址，类型和FCS占了18字节，所以IP数据报有效数据最小是46字节。</p>
<table>
<thead>
<tr>
<th align="center">前同步码</th>
<th align="center">SFD</th>
<th align="center">目的地址</th>
<th align="center">源地址</th>
<th align="center">类型</th>
<th align="center">数据（IP数据报）</th>
<th align="center">FCS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7byte</td>
<td align="center">1byte</td>
<td align="center">6byte</td>
<td align="center">6byte</td>
<td align="center">2byte</td>
<td align="center">46~1500byte</td>
<td align="center">4byte</td>
</tr>
</tbody></table>
<p>从目的地址到FCS为一个以太网MAC帧。</p>
<ol>
<li><p>前导码（前同步码）（Preamble）：7个字节的前导码，用于标识一个数据帧的开始，具体内容为1010……1010。</p>
</li>
<li><p>帧起始定界符（Start Frame Delimiter，SFD）：1个字节的帧起始定界符，用于标识前导码的结束，内容为10101011。</p>
</li>
<li><p>目的MAC地址（Destination MAC Address）：6个字节的目的MAC地址，表示接收数据包的设备的MAC地址。</p>
</li>
<li><p>源MAC地址（Source MAC Address）：6个字节的源MAC地址，表示发送数据包的设备的MAC地址。</p>
</li>
<li><p>以太网类型（Ethernet Type）：2个字节的以太网类型字段，用于指示数据帧中携带的数据的类型。常见的以太网类型有IP协议、ARP协议等。</p>
</li>
<li><p>数据（Data）：46~1500个字节的数据，用于携带传输的信息。当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的MAC帧长不小于64字节。</p>
</li>
<li><p>帧校验序列（Frame Check Sequence，FCS）：4个字节的帧校验序列，用于检测数据帧是否出错。FCS是通过CRC算法生成的，它包含了整个数据帧的数据内容。当传输媒体的误码率为$1×10^{-8}$时，MAC子层可使未检测到的差错小于$1×10^{-14}$。</p>
</li>
</ol>
<h5 id="IEEE802-3MAC-帧格式"><a href="#IEEE802-3MAC-帧格式" class="headerlink" title="IEEE802.3MAC 帧格式"></a>IEEE802.3MAC 帧格式</h5><ol>
<li><p>前导码（Preamble）：7个字节的前导码，用于标识一个数据帧的开始，具体内容为1010……1010。</p>
</li>
<li><p>帧起始定界符（Start Frame Delimiter，SFD）：1个字节的帧起始定界符，用于标识前导码的结束，内容为10101011。</p>
</li>
<li><p>目的MAC地址（Destination MAC Address）：6个字节的目的MAC地址，表示接收数据包的设备的MAC地址。</p>
</li>
<li><p>源MAC地址（Source MAC Address）：6个字节的源MAC地址，表示发送数据包的设备的MAC地址。</p>
</li>
<li><p>长度&#x2F;类型（Length&#x2F;Type）：2个字节的长度&#x2F;类型字段，用于指示数据帧中携带的数据的类型。如果该字段的值小于等于1500，则表示该字段指示了数据的长度；否则，表示该字段指示了数据的类型，例如IP协议、ARP协议等。</p>
</li>
<li><p>数据（Data）：46~1500个字节的数据，用于携带传输的信息。</p>
</li>
<li><p>帧校验序列（Frame Check Sequence，FCS）：4个字节的帧校验序列，用于检测数据帧是否出错。FCS是通过CRC算法生成的，它包含了整个数据帧的数据内容。</p>
</li>
<li><p>帧间隔（Interframe Gap，IFG）：12个字节的帧间隔，用于在两个数据帧之间进行时序的调整，以保证数据传输的稳定性。</p>
</li>
</ol>
<ul>
<li>与以太网V2MAC帧格式相似，区别在于：</li>
</ul>
<ol>
<li>IEEE 802.3规定的MAC帧的第三个字段是“长度&#x2F;类型”。</li>
</ol>
<p>当这个字段值大于0x0600时（相当于十进制的1536），就表示“类型”。这样的帧和以太网V2 MAC 帧完全一样。</p>
<p>当这个字段值小于0x0600时才表示“长度”。</p>
<ol start="2">
<li>当“长度&#x2F;类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧。</li>
</ol>
<p>现在市场上流行的都是以太网V2的MAC帧，但大家也常常称为IEEE 802.3标准的MAC帧。</p>
<h5 id="无效MAC帧"><a href="#无效MAC帧" class="headerlink" title="无效MAC帧"></a>无效MAC帧</h5><ul>
<li><p>数据字段的长度与长度字段的值不一致；</p>
</li>
<li><p>帧的长度不是整数个字节；</p>
</li>
<li><p>用收到的帧检验序列FCS查出有差错;</p>
</li>
<li><p>数据字段的长度不在46~1500字节之间。</p>
</li>
<li><p>有效的MAC帧长度为64~1518字节之间。</p>
</li>
<li><p>对于检查出的无效MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p>
</li>
</ul>
<h5 id="帧的最小间隔"><a href="#帧的最小间隔" class="headerlink" title="帧的最小间隔"></a>帧的最小间隔</h5><ul>
<li>帧间最小间隔为9.6 μs，相当于96 bit的发送时间。</li>
</ul>
<p>一个站在检测到总线开始空闲后，还要等待9.6μs才能再次发送数据。</p>
<p>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
<h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><ul>
<li><p>使用光纤扩展</p>
</li>
<li><p>使用集线器扩展</p>
</li>
</ul>
<p>集线器集联：使网络中计算机增加，变成一个大的冲突域，冲突域数量变少了，但是数量增加了，会造成效率降低。（越多效率越低，不适合使用超过30个集线器）</p>
<p>优点：使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。扩大了以太网覆盖的地理范围。</p>
<p>缺点：碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p>
<h3 id="在数据链路层扩展以太网-更常用的方法"><a href="#在数据链路层扩展以太网-更常用的方法" class="headerlink" title="在数据链路层扩展以太网(更常用的方法)"></a>在数据链路层扩展以太网(更常用的方法)</h3><ul>
<li>早期使用网桥，现在使用以太网交换机。</li>
</ul>
<h4 id="使用网桥"><a href="#使用网桥" class="headerlink" title="使用网桥"></a>使用网桥</h4><ul>
<li><p>在数据链路层扩展局域网是使用网桥。使用网桥可以拓展以太网的覆盖范围和提高网络性能。网桥是一种数据链路层设备，它可以连接多个以太网段，将它们组成一个逻辑上的单一网络。网桥通过学习每个网络中的MAC地址，将数据包从一个网络转发到另一个网络，从而实现不同网络之间的通信。</p>
</li>
<li><p>网桥工作在数据链路层，他根据MAC帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到对应的接口，或把它丢弃。</p>
</li>
<li><p>使用网桥拓展以太网的步骤如下：</p>
</li>
</ul>
<ol>
<li><p>确定网络拓扑结构：首先需要确定网络中存在的以太网段，以及它们之间的连接方式和拓扑结构。根据网络拓扑结构，选择合适的网桥类型和数量。</p>
</li>
<li><p>配置网桥参数：将网桥接入网络中，配置网桥的参数，如MAC地址、IP地址、子网掩码等。这些参数可以通过网桥设备的管理接口进行配置。</p>
</li>
<li><p>学习MAC地址：网桥通过学习每个以太网段中的MAC地址，建立MAC地址表，记录每个MAC地址所在的网络段。当网桥收到一个数据包时，它会查询MAC地址表，将数据包转发到目标网络段中的设备。</p>
</li>
<li><p>转发数据包：当网桥接收到一个数据包时，它会首先检查目标MAC地址所在的网络段是否与源MAC地址所在的网络段相同。如果目标MAC地址不在同一网络段中，则网桥会将数据包转发到目标网络段中；否则，网桥会将数据包丢弃。<br>使用网桥可以将多个以太网段组成一个逻辑上的单一网络，提高网络的可靠性和性能。同时，网桥还可以隔离不同的网络段，防止网络中的广播风暴和冲突，提高网络的安全性和稳定性。</p>
</li>
</ol>
<ul>
<li>网桥的自学习算法：</li>
</ul>
<p>若从A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A。网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</p>
<ul>
<li>好处</li>
</ul>
<p>过滤了通信量；扩大了物理范围；提高了可靠性；可互联不同的物理层，不同MAC子层和不同速率。</p>
<ul>
<li>坏处</li>
</ul>
<p>存储转发增加了时延；在MAC地址子层并没有流量控制功能；具有不同MAC子层的网段桥接在一起时时延更大；网桥值适合于用户数不太多和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</p>
<h4 id="使用以太网交换机"><a href="#使用以太网交换机" class="headerlink" title="使用以太网交换机"></a>使用以太网交换机</h4><ul>
<li><p>以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口。</p>
</li>
<li><p>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</p>
</li>
<li><p>以太网交换机的交换方式：存储转发方式、直通（cutthrough）方式</p>
</li>
<li><p>以太网交换机的特点：</p>
</li>
</ul>
<ol>
<li><p>高性能：以太网交换机采用硬件转发方式，能够实现高速数据传输和低延迟。通过交换机的缓存和转发能力，可以提高网络的吞吐量和性能。</p>
</li>
<li><p>灵活性：以太网交换机支持多种接口类型和速率，可以适应不同的网络环境和需求。同时，交换机还支持多种协议和网络服务，如VLAN、QoS等，提供更加灵活的网络配置和管理方式。</p>
</li>
<li><p>自学习：交换机可以自动学习网络中每个设备的MAC地址，并建立MAC地址表，记录设备的物理地址和端口号。当交换机收到一个数据包时，它会查询MAC地址表，将数据包转发到目标设备的端口上。</p>
</li>
<li><p>分割冲突域：以太网交换机将每个端口作为一个独立的冲突域，可以防止网络中的冲突和广播风暴。这种方式可以提高网络的可靠性和稳定性。</p>
</li>
<li><p>透明性：以太网交换机对网络上的设备和协议是透明的，不会影响设备之间的通信和网络协议的运行。同时，交换机还支持多种网络协议，如TCP&#x2F;IP、UDP、ICMP等，提供更加灵活的网络应用方式。</p>
</li>
</ol>
<h5 id="以太网交换机的自学习功能"><a href="#以太网交换机的自学习功能" class="headerlink" title="以太网交换机的自学习功能"></a>以太网交换机的自学习功能</h5><ul>
<li>以太网交换机的自学习功能的具体操作流程</li>
</ul>
<ol>
<li><p>当交换机接收到一个新的数据帧时，它会检查该帧的目标MAC地址，并将该地址与其端口关联起来，将该地址记录到其转发表中。</p>
</li>
<li><p>如果转发表中已经有了目标MAC地址的条目，则交换机可以直接将数据帧发送到对应的端口，而无需对所有端口进行广播。</p>
</li>
<li><p>如果转发表中没有目标MAC地址的条目，则交换机会将数据帧广播到所有连接的端口上，并记录下发送这个数据帧的源MAC地址和相应的端口信息。</p>
</li>
<li><p>一旦交换机确定了结构记录在转发表中的目标地址所对应的端口，它就只向那一个端口发送数据帧。</p>
</li>
<li><p>当交换机接收到新的数据帧时，它会再次更新转发表，删除多余或错误的信息，并学习记录新的MAC地址和端口信息。</p>
</li>
</ol>
<h5 id="交换机使用生成树协议"><a href="#交换机使用生成树协议" class="headerlink" title="交换机使用生成树协议"></a>交换机使用生成树协议</h5><ul>
<li><p>IEEE802.1D标准制定了一个生成树协议STP，用于消除兜圈子死循环现象。</p>
</li>
<li><p>生成树协议（Spanning Tree Protocol，STP）是一种用于以太网交换机网络中避免环路的协议。STP通过建立一棵生成树，保证网络中只有一条主干路径，从而避免数据包在网络中不断循环，造成网络拥塞和死锁。</p>
</li>
<li><p>生成树算法（Spanning Tree Algorithm）是用于实现生成树协议的具体算法，最常用的是经典的 IEEE 802.1D 标准，该标准定义了以下步骤：</p>
</li>
</ul>
<ol>
<li><p>选举根桥：在网络中，选举一个交换机作为根桥。根桥的选择通常是根据交换机的优先级和MAC地址来确定的。</p>
</li>
<li><p>计算路径开销：每个交换机计算到根桥的路径开销，路径开销包括端口的开销和链路的开销。其中，端口的开销是指端口的优先级和状态，链路的开销是指链路的带宽和延迟等因素。</p>
</li>
<li><p>选举根端口：每个非根交换机选举一个根端口，选举原则是选择路径开销最小的端口作为根端口。如果有多个端口开销相等，则根据端口的优先级和MAC地址来选择。</p>
</li>
<li><p>选举指定端口：每个交换机选举一个指定端口，指定端口是指连接网络中某个设备的端口。选举原则是选择路径开销次小的端口作为指定端口。如果有多个端口开销相等，则根据端口的优先级和MAC地址来选择。</p>
</li>
<li><p>阻塞端口：在生成树中，如果存在环路，则需要选择一些端口进行阻塞，从而避免数据包在网络中不断循环。阻塞端口是指连接到环路上的端口，选举原则是选择路径开销最大的端口进行阻塞。</p>
</li>
</ol>
<h5 id="从总线以太网到星形以太网"><a href="#从总线以太网到星形以太网" class="headerlink" title="从总线以太网到星形以太网"></a>从总线以太网到星形以太网</h5><ul>
<li><p>从总线以太网到星形以太网是以太网架构的演进历程，总线以太网是最早的以太网架构，所有设备共享同一条传输介质。而星形以太网采用了集线器&#x2F;交换机来分割网络，将每个设备连接到一个中心节点，从而提高了网络的可靠性和性能。</p>
</li>
<li><p>总线以太网使用CSMA&#x2F;CD协议，以半双工方式工作，存在碰撞问题。而以太网交换机实现的星形以太网以全双工方式工作，不存在碰撞问题，但由于帧结构未改变，仍采用以太网的帧结构，所以还叫做以太网。</p>
</li>
</ul>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul>
<li><p>虚拟局域网（Virtual Local Area Network，VLAN）是一种将物理网络划分为多个逻辑网络的技术。VLAN可以通过软件配置来实现，无需更改物理网络拓扑结构，从而方便网络管理和配置。</p>
</li>
<li><p>VLAN可以将一组网络设备划分为一个独立的逻辑网络，不同的VLAN之间可以相互隔离，从而提高网络安全性和灵活性。例如，可以将某个部门的计算机划分到一个VLAN中，使得该部门的计算机只能与该VLAN中的其他设备进行通信，而无法与其他VLAN中的设备通信。</p>
</li>
<li><p>VLAN的实现可以基于端口、MAC地址、IP地址等多种方式，常见的实现方式包括：</p>
</li>
</ul>
<ol>
<li><p>基于端口：将交换机的端口划分到不同的VLAN中，不同VLAN之间通过路由器进行通信。</p>
</li>
<li><p>基于MAC地址：将设备的MAC地址作为VLAN的标识符，相同VLAN中的设备拥有相同的MAC地址前缀。</p>
</li>
<li><p>基于IP地址：将设备的IP地址作为VLAN的标识符，相同VLAN中的设备拥有相同的IP地址前缀。</p>
</li>
</ol>
<ul>
<li>VLAN的优点包括：</li>
</ul>
<ol>
<li><p>提高网络安全性：不同的VLAN之间可以相互隔离，从而避免未经授权的访问和攻击。</p>
</li>
<li><p>灵活性高：可以根据不同的需求和场景，灵活地划分不同的VLAN，从而提高网络的灵活性和可扩展性。</p>
</li>
<li><p>管理和配置方便：VLAN的管理和配置可以通过软件进行，无需更改物理网络拓扑结构，从而方便网络管理和配置。<br>综上所述，VLAN是一种将物理网络划分为多个逻辑网络的技术，可以提高网络安全性和灵活性，方便网络管理和配置。</p>
</li>
</ol>
<ul>
<li>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</li>
</ul>
<h4 id="虚拟局域网使用的以太网帧格式"><a href="#虚拟局域网使用的以太网帧格式" class="headerlink" title="虚拟局域网使用的以太网帧格式"></a>虚拟局域网使用的以太网帧格式</h4><ul>
<li>虚拟局域网（VLAN）使用的以太网帧格式与普通的以太网帧格式基本一致，但在帧头和帧尾中加入了VLAN标记。下面是VLAN使用的以太网帧格式：</li>
</ul>
<ol>
<li><p>目的MAC地址（6个字节）：表示帧的接收方的MAC地址。</p>
</li>
<li><p>源MAC地址（6个字节）：表示帧的发送方的MAC地址。</p>
</li>
<li><p>VLAN标记（4个字节）：包含802.1Q标记类型和标记控制信息。</p>
</li>
</ol>
<p>VLAN标记的前两个字节总是设置为0x8100（即二进制10000001 00000000），称为IEEE802.1Q标记类型。</p>
<p>当数据链路层检测到MAC帧的源地址字段后面的两个字节值为0x8100时，就知道现在插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。后面的两个字节，前3位时用户优先级字段，接着的一位时规范格式提示符CFI（Canonical Format Indicator），最后12位时该虚拟局域网VLAN标识符VID（VLAN ID）唯一标志这个以太网帧属于哪一个VLAN。</p>
<ol start="4">
<li><p>类型&#x2F;长度字段（2个字节）：表示帧中上层协议的类型或数据长度。</p>
</li>
<li><p>数据字段（46~1500个字节）：表示上层协议的数据。</p>
</li>
<li><p>帧校验序列（FCS）（4个字节）：对整个帧进行校验，用于检测传输错误。</p>
</li>
<li><p>帧尾（1个字节）：表示帧的结束。</p>
</li>
</ol>
<h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><ul>
<li>高速以太网（High-Speed Ethernet)是一种以太网技术，用于实现高速数据传输。</li>
</ul>
<h3 id="100BASE-T以太网"><a href="#100BASE-T以太网" class="headerlink" title="100BASE-T以太网"></a>100BASE-T以太网</h3><ul>
<li><p>100BASE-T是一种以太网技术，也被称为快速以太网。它可以在100Mbps的传输速度下运行，并且使用双绞线作为物理媒介来传输数据。</p>
</li>
<li><p>100BASE-T以太网使用了交织的4B&#x2F;5B编码方案来将字节转换为信号。这种编码方案可以保证数据传输的稳定性和可靠性。它还使用了基带传输技术，即直接将数字信号发送到传输媒介上，避免了模拟信号的转换，从而提高了传输效率。</p>
</li>
<li><p>在100BASE-T以太网中，数据通过RJ-45插座连接到双绞线上，双绞线再连接到集线器或交换机等网络设备上。由于采用了CSMA&#x2F;CD协议，所以多台计算机可以同时使用同一个以太网来进行通信。</p>
</li>
<li><p>100Base-T以太网的物理层标准</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">媒体</th>
<th align="center">网段的最大长度</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100BASE-TX</td>
<td align="center">铜缆</td>
<td align="center">100m</td>
<td align="center">两对UTP5类线或屏蔽双绞线STP</td>
</tr>
<tr>
<td align="center">100BASE-T4</td>
<td align="center">铜缆</td>
<td align="center">100m</td>
<td align="center">4对UTP3类线或5类线</td>
</tr>
<tr>
<td align="center">100BASE-FX</td>
<td align="center">光缆</td>
<td align="center">2000m</td>
<td align="center">两根光纤，发送和接收各一根</td>
</tr>
</tbody></table>
<ul>
<li>特点</li>
</ul>
<p>可以实现全双工通信(注意，如果交换机上某一路连接着集线器(半双工)，则这一路不能实现全双工)而无冲突，此时不使用CSMA&#x2F;CD协议。</p>
<p>MAC帧格式不变，仍是802.3 标准。</p>
<p>最短帧长度不变，但是一个网段的最大电缆长度减少到100m。</p>
<p>帧间间隔从9.6微秒缩小到0.96微秒。</p>
<h3 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h3><ul>
<li><p>允许在1 Gb&#x2F;s下全双工或半双工工作方式。</p>
</li>
<li><p>使用802.3标准的帧格式。</p>
</li>
<li><p>在半双工下使用CSMA&#x2F;CD协议。</p>
</li>
<li><p>当吉比特以太网在全双工方式时，不用载波延伸和分组冲突。</p>
</li>
<li><p>与10Base-T和100Base-T技术向后兼容。</p>
</li>
<li><p>1000Base-X以太网的物理层：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">媒体</th>
<th align="center">网段最大长度</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000BASE-SX</td>
<td align="center">光缆</td>
<td align="center">550m</td>
<td align="center">多模光纤（50和62.5μm）</td>
</tr>
<tr>
<td align="center">1000BASE-LX</td>
<td align="center">光缆</td>
<td align="center">5000m</td>
<td align="center">单模光纤（10μm）多模光纤（50和62.5μm）</td>
</tr>
<tr>
<td align="center">1000BASE-CX</td>
<td align="center">铜缆</td>
<td align="center">25m</td>
<td align="center">使用2对屏蔽双绞线电缆STP</td>
</tr>
<tr>
<td align="center">1000BASE-T</td>
<td align="center">铜缆</td>
<td align="center">100m</td>
<td align="center">使用4对UTP5类线</td>
</tr>
</tbody></table>
<h3 id="10吉比特以太网和更快的以太网"><a href="#10吉比特以太网和更快的以太网" class="headerlink" title="10吉比特以太网和更快的以太网"></a>10吉比特以太网和更快的以太网</h3><ul>
<li><p>MAC帧格式不变，仍是802.3 标准。</p>
</li>
<li><p>使用光纤而不是铜线。</p>
</li>
<li><p>只能工作在全双工方式，没有争用问题。</p>
</li>
<li><p>它的出现使工作范围从局域网扩大到城域网和广域网，实现了端到端的以太网传输。</p>
</li>
<li><p>优点：技术成熟；互操作性好；广域网中使用以太网便宜；统一的帧格式。</p>
</li>
<li><p>40GB&#x2F;100GB以太网物理层标准</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">物理层</th>
<th align="center">40GB以太网</th>
<th align="center">10GB以太网</th>
</tr>
</thead>
<tbody><tr>
<td align="center">在背板上传输至少超过1m</td>
<td align="center">40GBASE-KR4</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在铜缆上传输至少超过7m</td>
<td align="center">40GBASE-CR4</td>
<td align="center">100GBASE-CR10</td>
</tr>
<tr>
<td align="center">在多模光纤上传输至少超过10m</td>
<td align="center">40GBASE-SR4</td>
<td align="center">100GBASE-SR10，100GBASE-SR4</td>
</tr>
<tr>
<td align="center">在单模光纤上传输至少超过10km</td>
<td align="center">40GBASE-LR4</td>
<td align="center">100GBASE-LR4</td>
</tr>
<tr>
<td align="center">在单模光纤上传输至少超过40km</td>
<td align="center">40GBASE-ER4</td>
<td align="center">100GBASE-ER4</td>
</tr>
</tbody></table>
<ul>
<li>以太网时可扩展的（速率从100Mbit&#x2F;s到100Gbit&#x2F;s）、灵活的（多媒体、全&#x2F;半双工、共享&#x2F;交换）、易于安装、稳健性好。</li>
</ul>
<h3 id="使用以太网进行宽带接入"><a href="#使用以太网进行宽带接入" class="headerlink" title="使用以太网进行宽带接入"></a>使用以太网进行宽带接入</h3><ul>
<li>以太网是一种计算机局域网技术，它可以通过使用特定的物理介质（如双绞线或光纤）将计算机设备连接到互联网服务提供商（ISP）的网络中。在宽带接入方案中，以太网通常用于将用户家庭或办公室内的路由器或调制解调器与ISP提供的宽带调制解调器相连接。这种连接方式可以提供高速、可靠的互联网连接，并且可以支持多个用户同时访问互联网。在以太网上实现宽带接入需要使用特定的协议和技术，例如动态主机配置协议（DHCP）、传输控制协议&#x2F;互联网协议（TCP&#x2F;IP）和数据包交换技术等。</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">
    <time datetime="2023-05-28T16:00:00.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-物理层" class="post-物理层 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/" data-id="cli8zk3o5000a24do1t78gp49" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><ul>
<li><p>物理层考虑传输数据比特流。</p>
</li>
<li><p>物理层的作用要尽可能屏蔽掉不同传输媒体和通信手段的差异。</p>
</li>
<li><p>用于物理层的协议被称为物理层规程。</p>
</li>
<li><p>物理层的主要任务：确定与传输媒体的接口的一些特性。</p>
</li>
</ul>
<p>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</p>
<p>电气特性：指明在接口电缆的各条线上出现的电压范围。</p>
<p>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</p>
<p>过程特性：指明对于不同功能的各种可能事件的出现顺序。</p>
<h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h3><ul>
<li>一个数据通信系统分为三部分：源系统（发送端、发送方）、传输系统（传输网络）和目的系统（接收端、接收方）。</li>
</ul>
<h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><ul>
<li><p>数据data——运送消息的实体。</p>
</li>
<li><p>信号signal——数据的电气的或电磁的表现。</p>
</li>
<li><p>模拟数据analogous data——表示时间上和幅度取值上是连续的。</p>
</li>
<li><p>数字数据digital data——表示在时间上离散的，在幅值上是经过量化的数据。</p>
</li>
<li><p>模拟信号analogous signal——代表消息的参数的取值是连续的。</p>
</li>
<li><p>数字信号digital signal——代表消息的参数的取值是离散的。</p>
</li>
<li><p>码元code——在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
</li>
<li><p>信道——一般用来表示向某一方向传送信息的媒体。</p>
</li>
<li><p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
</li>
<li><p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送或接收。</p>
</li>
<li><p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。</p>
</li>
<li><p>串行传输：数据的二进制代码在一条物理信道上将数据一位位地依次传输。</p>
</li>
<li><p>并行传输：数据以成组的方式在多条并行信道上同时传输。</p>
</li>
<li><p>基带信号（基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
</ul>
<p>基带信号往往包含低频成分，甚至直流成分，而许多信道并不能传输这种低频分量或直流分量，所以对基带信号进行调制。</p>
<ul>
<li>调制分为两大类：</li>
</ul>
<ol>
<li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍为基带信号。这种过程称为编码（coding）。<br>常用编码方式：</li>
</ol>
<p>不归零制：正电平代表1，负电平代表0。</p>
<p>归零制：正脉冲代表1，负脉冲代表0。</p>
<p>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心向下跳变代表1.可反过来定义。</p>
<p>差分曼彻斯特编码：每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</p>
<p>![编码方式](img&#x2F;编码方式.jpg &#x3D;500x)</p>
<ol start="2">
<li>带通调制：使用载波（carrier）进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道）。</li>
</ol>
<p>带通信号：经过载波调制后的信号。</p>
<p>最基本的二元制调制方法：</p>
<p>调幅（AM）：载波的振幅随基带数字信号而变化。</p>
<p>调频（FM）：载波的频率随基带数字信号而变化。</p>
<p>调相（PM）：载波的初始相位随基带数字信号而变化。</p>
<h3 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h3><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><ul>
<li><p>码元传输速率越高或信号传输距离越远或传输媒体质量越差，在信道的输出端波形的失真就越严重。</p>
</li>
<li><p>限制码元在信道上的传输速率：信道能够通过的频率范围、信噪比。</p>
</li>
</ul>
<ol>
<li>信道能够通过的频率范围</li>
</ol>
<p>码元的传输速率有上限，否则出现码间串扰的问题。如果信道的频带越宽，也就是能够通过的信号高频分量越多，可以用更高速率传送码元而不出现码间串扰。</p>
<ol start="2">
<li>信噪比</li>
</ol>
<p>噪声存在于所有电子设备和通信信道中。噪声随机产生，会使接收端对码元的判决产生错误。</p>
<p>信噪比就是信号的平均功率和噪声的平均功率之比，记作$S&#x2F;N$，度量单位为分贝（dB）。</p>
<p>$$<br>信噪比（dB）&#x3D;10log_{10}(\frac SN)（dB）<br>$$</p>
<p>香农公式：极限、无差错的信息传输速率</p>
<p>$$<br>信道极限信息传输速率C&#x3D;Wlog_2(1+\frac SN)（bit&#x2F;s）<br>$$<br>W为信道带宽，Hz为单位；S为信道内所传信号的平均功率；N为信道内部的高斯噪声功率。</p>
<p>香农公式表明：</p>
<p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法实现无差错传输。若W和S&#x2F;N没有上限，则C也没有上限。实际信道传输速率远比香农公式算出来的低。</p>
<h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><ul>
<li>传输媒体也称为传输介质或传输媒介。</li>
</ul>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><ul>
<li>电磁波被导引沿着固体媒体传播。</li>
</ul>
<h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><ul>
<li><p>最常用</p>
</li>
<li><p>模拟传输和数字传输皆可，通信距离为几到十几公里。</p>
</li>
<li><p>分为屏蔽双绞线STP和无屏蔽双绞线UTP。</p>
</li>
<li><p>根据绞合分为3类线和5类线。</p>
</li>
<li><p>对于传送数据，最常用的UTP是5类线。</p>
</li>
</ul>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul>
<li><p>很好的抗干扰特性，广泛用于传输较高速率的数据。</p>
</li>
<li><p>同轴电缆的带宽取决于电缆质量。</p>
</li>
<li><p>50Ω同轴电缆——LAN&#x2F;数字传输常用</p>
</li>
<li><p>75Ω同轴电缆——有线电视&#x2F;模拟传输常用</p>
</li>
</ul>
<h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4><ul>
<li><p>光纤是光纤通信的传输媒体。</p>
</li>
<li><p>光纤通信系统的传输带宽远远大于目前其他传输媒体的带宽。</p>
</li>
<li><p>多模光纤：存在多条不同角度入社的光线在一条光纤中传输。</p>
</li>
<li><p>单模光纤：光纤直径减少到只有一个光的波长，光线可以一直向前传播而不会产生多次反射。</p>
</li>
<li><p>光波优点：通信容量非常大；传输损耗小，中继距离长；抗雷电和电磁干扰好；无串音干扰，保密性好；体积小，重量轻。</p>
</li>
</ul>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><ul>
<li><p>就是指自由空间，这样的电磁波传输也被称为无线传输。</p>
</li>
<li><p>短波通信（高频通信）通信质量差、传输速率低。</p>
</li>
<li><p>微波主要以直线传播。</p>
</li>
<li><p>传统微波：地面微波接力通信和卫星通信。</p>
</li>
</ul>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul>
<li>复用（multiplexing）是通信技术中的基本概念。它允许用户使用一个共享的信道进行通信，降低成本，提高利用率。</li>
</ul>
<h3 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h3><h4 id="频分复用FDM（Frequency-Division-Multiplexing）"><a href="#频分复用FDM（Frequency-Division-Multiplexing）" class="headerlink" title="频分复用FDM（Frequency Division Multiplexing）"></a>频分复用FDM（Frequency Division Multiplexing）</h4><ul>
<li><p>将整个带宽分为多份，用户在分配到一定频带后，通信过程自始至终都占用这个频带。</p>
</li>
<li><p>频分复用的所有用户在同样时间占用不同的带宽资源。（“带宽”指的是频率带宽而不是数据的发送频率）</p>
</li>
</ul>
<h4 id="时分复用TDM（Time-Division-Multiplexing）"><a href="#时分复用TDM（Time-Division-Multiplexing）" class="headerlink" title="时分复用TDM（Time Division Multiplexing）"></a>时分复用TDM（Time Division Multiplexing）</h4><ul>
<li><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用的份额相等。</p>
</li>
<li><p>时分复用可能会造成线路资源的浪费。由于计算机数据的突发性，用户对分配到的子信道的利用率不高。</p>
</li>
</ul>
<h4 id="统计时分复用（Statistic-TDM）"><a href="#统计时分复用（Statistic-TDM）" class="headerlink" title="统计时分复用（Statistic TDM）"></a>统计时分复用（Statistic TDM）</h4><ul>
<li>STDM帧按需动态分配时隙。</li>
</ul>
<h3 id="波分复用（Wavelength-Division-Multiplexing）"><a href="#波分复用（Wavelength-Division-Multiplexing）" class="headerlink" title="波分复用（Wavelength Division Multiplexing）"></a>波分复用（Wavelength Division Multiplexing）</h3><ul>
<li>光的频分复用，使用一根光纤传播。</li>
</ul>
<h3 id="码分复用（Code-Division-Multiplexing）"><a href="#码分复用（Code-Division-Multiplexing）" class="headerlink" title="码分复用（Code Division Multiplexing）"></a>码分复用（Code Division Multiplexing）</h3><ul>
<li><p>在发送端将不同的用户信息采用相互正交的扩频码序列进行调制后再发送，在接收端采用相关解调来恢复原始数据。它是一种共享信道的方法，每个用户可在同一时间使用同样的频带进行通信，但使用基于码型的分割信道的方法。每个用户分配一个地址码，各个码型互不重叠，通信各方之间不会相互干扰，且抗干拢能力强。</p>
</li>
<li><p>常用名词码分多址CDMA（Code Division Multiple Access）</p>
</li>
<li><p>码片序列（chip sequence），在实用的系统中使用的是伪随机码序列。</p>
</li>
</ul>
<p>一个简单的码分复用的例子是在CDMA中，每个比特时间再划分为m个短的间隔，称为码片。通常m值为64或128。每个站被指派一个唯一的mbit码片序列。码片序列实现了扩频。</p>
<ul>
<li>CMDA的重要特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。</li>
</ul>
<h4 id="码分复用的应用计算"><a href="#码分复用的应用计算" class="headerlink" title="码分复用的应用计算"></a>码分复用的应用计算</h4><ul>
<li><p>一个站如果要发送比特1，则发送它自己的m bit码片序列，如果要发送0，则发送该码片序列的二进制反码。按照惯例将码片中的0写成<code>-1</code>，将1写成<code>+1</code>。</p>
</li>
<li><p>例如，假设有两个用户A和B，他们分别被分配了不同的码片序列：A的码片序列为<code>+1+1+1-1-1+1-1-1</code>，B的码片序列为<code>+1-1-1+1-1+1+1-1</code>。当A要发送比特0时，它会发送<code>-1-1-1+1+1-1+1+1</code>；当B要发送比特0时，它会发送<code>-1+1+1-1+1-1-1+1</code>。这样，在接收端就可以根据接收到的信号和已知的各用户的码片序列来解调并恢复原始数据。</p>
</li>
<li><p>当收到的码片序列存在大于1的值，说明该码片序列是混合叠加得到的，接收端收到的混合信号是各个站发送的码片序列之和。接收端用相同的码片序列进行<strong>规格化内积</strong>，就可以将不属于本码片序列的其他信号全部去除，只接受本码片序列所携带的信息。（即使多用户同时通信时，其信号电压会相互叠加或抵消。）</p>
</li>
</ul>
<p>通过<br>$$<br>S·T&#x3D;\frac 1m\sum^m_{i&#x3D;1}S_iT_i<br>$$</p>
<p>计算规格化内积，其中结果为+1，说明这个站发送比特1；结果为-1，说明这个站发送比特0；结果为0，说明这个站没有发送信息。</p>
<ul>
<li>例：共有4个站进行码分多址CDMA通信，4个站的码片序列为：<code>A：(-1 -1 -1 +1 +1 -1 +1 +1) 、B：(-1 -1 +1 -1 +1 +1 +1 -1)、C：(-1 +1 -1 +1 +1 +1 -1 -1) 、D：(-1 +1 -1 -1 -1 -1 +1 -1)</code>。现收到这样的码片序列：<code>( +1 -3 +3 -1 +1 +1 +1 +1)</code>，求发送站及发送的数据。</li>
</ul>
<p>由$S·T&#x3D;\frac 1m\sum^m_{i&#x3D;1}S_iT_i$计算$S·T_1&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{1i}&#x3D;1$，所以A站发送的是<code>1</code>；$S·T_2&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{2i}&#x3D;-1$，所以B站发送的是<code>0</code>；$S·T_3&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{3i}&#x3D;1$，所以C站没有发送数据；$S·T_4&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{4i}&#x3D;1$，所以D站发送的是<code>1</code>。</p>
<h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><ul>
<li><p>长途干线大都采用时分复用PCM的数字传输方式。</p>
</li>
<li><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路电话。</p>
</li>
<li><p>PCM有两个标准，北美的24路PCM（T1）和欧洲的30路PCM（E1）。我国采用E1标准。</p>
</li>
<li><p>旧的数字传输系统存在缺点：导致速率标准不统一，不是同步传输。</p>
</li>
<li><p>同步光纤网SONET（Synchronous Optical Network）</p>
</li>
</ul>
<p>SONET为光纤传输系统定义了同步传输的线路速率等级结构。</p>
<ul>
<li>同步数字系列SDH（Synchronous Digital Hierarchy）</li>
</ul>
<p>SDH一般可以跟SONET称为同义词，不同的点是SDH速率更快。</p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><ul>
<li>非对称数字用户线（Asymmetric Digital Subscriber Line）技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</li>
</ul>
<p>把0~4kHz低端频谱留给传统电话，而把原来没有利用的高端频谱留给用户上网使用。</p>
<ul>
<li>ADSL的传输距离取决于数量和用户线的线径。</li>
</ul>
<p>用户线越细，信号传输时的衰减就越大。</p>
<ul>
<li><p>ADSL所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</p>
</li>
<li><p>ADSL的特点</p>
</li>
</ul>
<ol>
<li><p>上行和下行带宽做成不对称的。上行指从用户到ISP，下行指从ISP到用户。</p>
</li>
<li><p>ADSL在用户线（铜线）的两端各安装一个ADSL调制解调器。</p>
</li>
<li><p>我国目前采用离散多音调DMT（Discrete Multi-Tone）调制技术。“多音调”就是“多载波”或“多子信道”。</p>
</li>
</ol>
<ul>
<li>ADSL的数据率</li>
</ul>
<p>ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。</p>
<p>ADSL不能保证固定的数据率。</p>
<ul>
<li><p>DSL：数字用户线。</p>
</li>
<li><p>HDSL：高速数字用户线。</p>
</li>
<li><p>SDSL：1对线的数字用户线。</p>
</li>
<li><p>VDSL：甚高速数字用户线。</p>
</li>
<li><p>RADSL：速率自适应DSL。</p>
</li>
</ul>
<h3 id="光纤同轴混合网（HFC（Hybrid-Fiber-Coax）网）"><a href="#光纤同轴混合网（HFC（Hybrid-Fiber-Coax）网）" class="headerlink" title="光纤同轴混合网（HFC（Hybrid Fiber Coax）网）"></a>光纤同轴混合网（HFC（Hybrid Fiber Coax）网）</h3><ul>
<li><p>HFC是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。</p>
</li>
<li><p>HFC网对CATV网进行了改造。</p>
</li>
</ul>
<p>HFC网将原CATV网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</p>
<ul>
<li><p>用户接口盒UIB（User Interface Box），连接在同轴电缆和用户的电视机之间。</p>
</li>
<li><p>电缆调制解调器（Cable Modem），电缆调制解调器是为HFC网而使用的调制解调器。</p>
</li>
</ul>
<h3 id="FTTx（Fiber-To-The-……）技术"><a href="#FTTx（Fiber-To-The-……）技术" class="headerlink" title="FTTx（Fiber To The ……）技术"></a>FTTx（Fiber To The ……）技术</h3><ul>
<li>FTTx是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。</li>
</ul>
<p>如：Fiber To The Home，FTTH，光纤到户；Fiber To The Building，FTTB，光纤到楼……</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/">
    <time datetime="2023-05-28T16:00:00.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-网络层" class="post-网络层 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/" data-id="cli8zk3o6000b24doe61i615p" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="网络层的几个重要概念"><a href="#网络层的几个重要概念" class="headerlink" title="网络层的几个重要概念"></a>网络层的几个重要概念</h2><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p><img src="/.io//%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1.jpg"></p>
<h4 id="虚电路服务"><a href="#虚电路服务" class="headerlink" title="虚电路服务"></a>虚电路服务</h4><ul>
<li>虚电路服务是指一种在网络层提供的服务，它类似于有连接的服务，但是与之不同的是，在传输数据前并不需要建立一个专门的连接。相反，当数据包传输时，网络会根据事先建立的虚电路来进行数据包的传输。</li>
</ul>
<p>在使用虚电路服务时，源节点首先向目标节点发送一条请求信息，该请求信息包含了通信所需的一些参数，例如虚电路的编号、端口号等等。然后目标节点接收到该请求信息后，会回复一条确认信息，同时也会在网络中建立一个虚电路。在这个过程中，每个经过的节点都会记录下该虚电路的相关信息，以方便后续数据包的传输。之后，当源节点要向目标节点传输数据时，它就会将数据包发送到网络中，并加上虚电路编号和端口号等信息。经过路由器的转发后，数据包最终到达目标节点。在这个过程中，每个节点都可以使用先前记录的虚电路信息来确保数据的正确传输。</p>
<p>与无连接服务相比，虚电路服务在传输中会更可靠，因为在建立虚电路时已经预留了一定的网络资源，包括路由器的缓存、带宽等。这样一来，传输数据时就可以更加高效地利用这些资源，提高数据传输效率。但与有连接服务相比，虚电路服务的建立和维护过程需要更多的网络开销。</p>
<p>虚电路服务常见的应用场景包括视频会议、远程桌面等要求顺序传输和时延控制的实时应用场景。</p>
<h4 id="数据报服务"><a href="#数据报服务" class="headerlink" title="数据报服务"></a>数据报服务</h4><ul>
<li>简单灵活的、无连接的、尽最大努力交付的数据包服务。</li>
</ul>
<p><strong>网络不提供端到端的可靠传输服务</strong>。这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</p>
<p>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong>。</p>
<p>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。</p>
<h4 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h4><table>
<thead>
<tr>
<th align="center">对比的方面</th>
<th align="center">虚电路服务</th>
<th align="center">数据报服务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">思路</td>
<td align="center">可靠通信应当由网络来保证</td>
<td align="center">可靠通信应当由用户主机来保证</td>
</tr>
<tr>
<td align="center">连接的建立</td>
<td align="center">必须有</td>
<td align="center">不需要</td>
</tr>
<tr>
<td align="center">终点地址</td>
<td align="center">尽在连接建立阶段使用，每个分组使用短的虚电路号</td>
<td align="center">每个分组都有终点的完整地址</td>
</tr>
<tr>
<td align="center">分组的转发</td>
<td align="center">属于同一条虚电路的分组均按照统一路由进行转发</td>
<td align="center">每个分组独立选择路由进行转发</td>
</tr>
<tr>
<td align="center">当节点出故障时</td>
<td align="center">所有通过出故障的结点的虚电路均不能工作</td>
<td align="center">出故障的结点可能会丢失分组，一些路由可能会发生变化</td>
</tr>
<tr>
<td align="center">分组的顺序</td>
<td align="center">总是按发送顺序到达终点</td>
<td align="center">到达终点的时间不一定按发送顺序</td>
</tr>
<tr>
<td align="center">端到端的差错处理和流量控制</td>
<td align="center">可以由网络负责，也可以由用户主机负责</td>
<td align="center">由用户主机负责</td>
</tr>
</tbody></table>
<h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><ul>
<li><p>网际协议 IP是 TCP&#x2F;IP 体系中两个最主要的协议之一。</p>
</li>
<li><p>与IP协议配套使用的还有三个协议：**地址解析协议ARP(Address Resolution Protocol)<strong>、</strong>网际控制报文协议ICMP(Internet Control Message Protocol)<strong>、</strong>网际组管理协议IGMP(Internet Group Management Protocol)**。</p>
</li>
</ul>
<h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><ul>
<li><p>没有一种单一的网络能够适应所有用户的需求。</p>
</li>
<li><p>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是利用IP协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。</p>
</li>
<li><p>互联网可以由多种异构网络互连组成。将网络互相连接起来要使用一些中间设备。</p>
</li>
</ul>
<p>物理层使用的中间设备叫做转发器（repeater）；数据链路层使用的中间设备叫做网桥或桥接器（bride）；网络层使用的中间设备叫做路由器（router）；在网络层以上使用的中间设备叫做网关（gateway），用网关连接两个不兼容的系统需要在高层进行协议的转换。</p>
<ul>
<li><p>使用IP协议的<strong>虚拟互连网络</strong>可简称为IP网。</p>
</li>
<li><p><strong>使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。</strong></p>
</li>
</ul>
<h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><h4 id="IP地址及其表示方法"><a href="#IP地址及其表示方法" class="headerlink" title="IP地址及其表示方法"></a>IP地址及其表示方法</h4><ul>
<li>IP地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围<strong>唯一的32位的标识符</strong>。</li>
</ul>
<p>为了提高可读性，常常每8位插入一个空格，便于阅读。</p>
<ul>
<li><p>IP地址由互联网名字和数字分配机构进行分配。</p>
</li>
<li><p>点分十进制记法：机器中存放的IP地址是32位二进制代码，每8位为一组，转化为十进制数。</p>
</li>
</ul>
<h4 id="IP地址的编址方法：分类的IP地址、子网的划分、构造超网"><a href="#IP地址的编址方法：分类的IP地址、子网的划分、构造超网" class="headerlink" title="IP地址的编址方法：分类的IP地址、子网的划分、构造超网"></a>IP地址的编址方法：分类的IP地址、子网的划分、构造超网</h4><ul>
<li>分类的IP地址，最基本的编址方法。</li>
</ul>
<p>将IP地址划分为若干个固定类。每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号host-id</strong>，它标志该主机（或路由器）。主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个IP地址在整个互联网范围内是唯一的。</p>
<p>这种两级的IP地址可以记为：<code>IP地址::=&#123;&lt;网络号&gt;,&lt;主机号&gt;&#125;</code>，<code>::=</code>表示“定义为”。</p>
<p>![](.&#x2F;img&#x2F;各类IP地址.jpg &#x3D;500x)</p>
<ul>
<li><p>A类、B类、C类地址都是单播地址（一对一通信），他们的网络号字段分别为1、2、3个字节长，网络号字段最前面有类别为，数值分别规定为0、10、110，主机号字段分别为3、2、1个字节长。</p>
</li>
<li><p>D类地址用于多播（一对多通信）。</p>
</li>
<li><p>E类地址保留为今后使用。</p>
</li>
</ul>
<h4 id="常用的三种类别的IP地址"><a href="#常用的三种类别的IP地址" class="headerlink" title="常用的三种类别的IP地址"></a>常用的三种类别的IP地址</h4><table>
<thead>
<tr>
<th align="center">网络类别</th>
<th align="center">最大可指派的网络数</th>
<th align="center">第一个可指派的网络号</th>
<th align="center">最后一个可指派的网络号</th>
<th align="center">每个网络中最大主机数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">126($2^7-2$)</td>
<td align="center">1</td>
<td align="center">126</td>
<td align="center">16777214</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">16384($2^{14}$)</td>
<td align="center">128.0</td>
<td align="center">191.255</td>
<td align="center">65534</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">2087152($2^{21}$)</td>
<td align="center">192.0.0</td>
<td align="center">223.255.255</td>
<td align="center">254</td>
</tr>
</tbody></table>
<ul>
<li>一般不适用的特殊IP地址</li>
</ul>
<table>
<thead>
<tr>
<th align="center">网络号</th>
<th align="center">主机号</th>
<th align="center">源地址使用</th>
<th align="center">目的地址使用</th>
<th align="center">代表意思</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">可以</td>
<td align="center">不可</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">host-id</td>
<td align="center">可以</td>
<td align="center">不可</td>
<td align="center">在本网络的某台主机host-id</td>
</tr>
<tr>
<td align="center">全1</td>
<td align="center">全1</td>
<td align="center">不可</td>
<td align="center">可以</td>
<td align="center">只有本网络上进行广播（各路由器均不转发）</td>
</tr>
<tr>
<td align="center">net-id</td>
<td align="center">全1</td>
<td align="center">不可</td>
<td align="center">可以</td>
<td align="center">对net-id上的所有主机进行广播</td>
</tr>
<tr>
<td align="center">127</td>
<td align="center">非全0或全1的任何数</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">用作本地软件环回测试</td>
</tr>
</tbody></table>
<h4 id="IP地址的重要特点"><a href="#IP地址的重要特点" class="headerlink" title="IP地址的重要特点"></a>IP地址的重要特点</h4><ol>
<li>IP地址是一种分等级的地址结构。</li>
</ol>
<p>分两个等级的好处是：</p>
<p>第一，IP地址管理机构在分配IP地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了IP地址的管理</p>
<p>第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</p>
<ol start="2">
<li>实际上IP地址是标志一个主机（或路由器）和一条链路的接口。</li>
</ol>
<p>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号net-id 必须是不同的。这种主机称为多归属主机(multihomed host)。</p>
<p>由于一个路由器至少应当连接到两个网络（这样它才能将IP数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的IP地址。</p>
<ol start="3">
<li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络，因而具有同样的网络号net-id。</p>
</li>
<li><p>平等，互联网同等对待每一个IP地址。</p>
</li>
</ol>
<h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><ul>
<li><p>网络层及以上使用IP地址；链路层及以下使用硬件地址。</p>
</li>
<li><p>IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。</p>
</li>
</ul>
<p><img src="/.io//IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB.jpg"></p>
<ul>
<li><p>在IP层抽象的互联网上只能看到IP数据报。</p>
</li>
<li><p>路由器只根据目的站的IP地址的网络号进行路由选择。</p>
</li>
<li><p>在局域网的链路层，只能看到MAC帧。</p>
</li>
<li><p>IP层抽象的互联网却屏蔽了下层这些很复杂的细节。只要在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。</p>
</li>
</ul>
<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><ul>
<li><p>ARP（Address Resolution Protocol）即地址解析协议，是计算机网络中常用的一种协议，用于将IP地址转换为MAC地址。在互联网协议中，每个设备都需要拥有一个唯一的IP地址，但是在局域网内，不同设备之间通信需要使用MAC地址，因此通过ARP协议可以解决这种IP地址和MAC地址之间的映射问题。</p>
</li>
<li><p>下面简要介绍ARP协议的工作原理：</p>
</li>
</ul>
<ol>
<li><p>当主机A需要与目标主机B通信时，首先需要知道目标主机的MAC地址。</p>
</li>
<li><p>主机A会检查自己的ARP缓存表是否有目标主机的IP地址对应的MAC地址记录，如果有，则直接使用该MAC地址进行通信。</p>
</li>
<li><p>如果ARP缓存表中没有对应的记录，主机A会发送一个ARP请求广播，询问局域网中哪个设备拥有该IP地址。该请求包含了源主机A的MAC地址、目标主机B的IP地址等信息。</p>
</li>
<li><p>收到ARP请求广播的设备，会检查自己的ARP缓存表来判断是否是目标主机B。如果是，该设备会将自己的MAC地址发送给主机A。</p>
</li>
<li><p>主机A收到回复后，会将目标主机B的IP地址和MAC地址记录在ARP缓存表中，并使用该MAC地址进行通信。</p>
</li>
</ol>
<ul>
<li><p>由于ARP请求广播是以广播方式发送的，因此所有设备都能够收到该消息。同时，为了防止网络中发生ARP欺骗攻击等安全问题，主机需要对更新ARP缓存表进行限制和验证。</p>
</li>
<li><p>通信时使用了IP地址（网络层地址）和MAC地址（数据链路层地址）</p>
</li>
<li><p>ARP解决<strong>同一个局域网上</strong>主机或路由器的IP地址和硬件地址的映射问题。</p>
</li>
</ul>
<h4 id="使用ARP的四种典型情况"><a href="#使用ARP的四种典型情况" class="headerlink" title="使用ARP的四种典型情况"></a>使用ARP的四种典型情况</h4><ul>
<li><p>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用ARP找到目的主机的硬件地址。</p>
</li>
<li><p>发送方是主机，要把IP数据报发送到另一个网络上的一个主机。这时用ARP找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
</li>
<li><p>发送方是路由器，要把IP数据报转发到本网络上的一个主机。这时用ARP找到目的主机的硬件地址。</p>
</li>
<li><p>发送方是路由器，要把IP数据报转发到另一个网络上的一个主机。这时用ARP找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
</li>
</ul>
<h3 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><ul>
<li><p>一个IP数据报由首部和数据两部分组成。</p>
</li>
<li><p>首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。</p>
</li>
<li><p>在首部的固定部分的后面是一些可选字段，其长度是可变的。</p>
</li>
</ul>
<h4 id="IP数据报固定部分的字段"><a href="#IP数据报固定部分的字段" class="headerlink" title="IP数据报固定部分的字段"></a>IP数据报固定部分的字段</h4><p><img src="/.io//IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.jpg"></p>
<ol>
<li><p>版本号（Version）：4位二进制数，用于表示IP协议的版本号，目前主要有IPv4和IPv6两种版本。</p>
</li>
<li><p>首部长度（Header Length）：4位二进制数，用于表示IP数据报头部的长度，以4字节为单位，因此最大值为15，即最大头部长度为60字节。</p>
</li>
<li><p>区分服务（Type of Service）：8位二进制数，用于标识IP数据报的服务类型和优先级，包括了TOS、ECN和DSCP三个子字段，主要用于QoS服务质量控制。</p>
</li>
<li><p>总长度（Total Length）：16位二进制数，用于表示整个IP数据报的长度，包括头部和数据两部分，以字节为单位，最大值为65535字节。</p>
</li>
<li><p>标识（Identification）：16位二进制数，用于标识同一个数据流中的不同数据报，主要用于分片和重新组装。</p>
</li>
<li><p>标志（Flags）：3位二进制数，用于标记IP数据报是否可以分片和是否为最后一个分片，其中第1位保留，第2位表示不分片标记（DF），第3位表示最后一个分片标记（MF）。</p>
</li>
<li><p>片偏移（Fragment Offset）：13位二进制数，用于标识当前IP数据报在原始数据报中的位置和大小，以8字节为单位，因此最大值为8191。</p>
</li>
<li><p>生存时间——占8位，TTL（Time to Live）：8位二进制数，用于保证IP数据报在网络中不会永久存在，可防止数据报在网络中无限循环，每经过一个路由器或网关，该值减1，当它减至0时，数据报将被丢弃。</p>
</li>
</ol>
<p>如今TTL字段的功能改为“跳数限制”，路由器每次转发数据报之前就把TTL值减1，直到TTL减小到零就丢弃这个数据报，TTL的单位从秒改为跳数。数据报能在互联网中经过的路由器最大跳数位255。若TTL为1，则表示这个数据报只能在本局域网中传送。</p>
<ol start="9">
<li>协议（Protocol）：8位二进制数，用于标识IP数据报中携带的协议类型，如ICMP、TCP、UDP等。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">协议名</th>
<th align="center">ICMP</th>
<th align="center">IGMP</th>
<th align="center">IP</th>
<th align="center">TCP</th>
<th align="center">EGP</th>
<th align="center">IGP</th>
<th align="center">UDP</th>
<th align="center">IPv6</th>
<th align="center">ESP</th>
<th align="center">OSPF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">协议字段值</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">17</td>
<td align="center">41</td>
<td align="center">50</td>
<td align="center">89</td>
</tr>
</tbody></table>
<ol start="10">
<li>首部检验和（Header Checksum）：16位二进制数，用于检查IP数据报头部在传输过程中是否损坏，可以保证数据的完整性。</li>
</ol>
<p><img src="/.io//IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E6%A3%80%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97.jpg"></p>
<ol start="11">
<li><p>源地址（Source Address）：32位二进制数，用于标识IP数据报的源地址，即哪个主机发出了该数据报。</p>
</li>
<li><p>目的地址（Destination Address）：32位二进制数，用于标识IP数据报的目的地址，即该数据报要被传输到哪个主机。</p>
</li>
<li><p>填充字段（Fill field）：填充0使得可变部分和填充字段的字节是4的整数倍。</p>
</li>
</ol>
<h4 id="IP数据报首部的可变部分"><a href="#IP数据报首部的可变部分" class="headerlink" title="IP数据报首部的可变部分"></a>IP数据报首部的可变部分</h4><ul>
<li><p>IP首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。</p>
</li>
<li><p>选项字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。</p>
</li>
<li><p>增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。</p>
</li>
</ul>
<h4 id="IP层转发分组的流程"><a href="#IP层转发分组的流程" class="headerlink" title="IP层转发分组的流程"></a>IP层转发分组的流程</h4><ul>
<li>路由器分组转发算法</li>
</ul>
<ol>
<li><p>从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。</p>
</li>
<li><p>若网络N与此路由器直接相连，则把数据报直接交付目的主机D；否则是间接交付，执行3。</p>
</li>
<li><p>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4。</p>
</li>
<li><p>若路由表中有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行5。</p>
</li>
<li><p>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6。</p>
</li>
<li><p>报告转发分组出错。</p>
</li>
</ol>
<h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><h4 id="从两级IP地址到三级IP地址"><a href="#从两级IP地址到三级IP地址" class="headerlink" title="从两级IP地址到三级IP地址"></a>从两级IP地址到三级IP地址</h4><ul>
<li><p>IP地址的空间利用率有时很低；给每个物理网络分配一个网络号会使路由表变得太大因而网络性能变坏；两级IP地址不够灵活。</p>
</li>
<li><p>划分子网的基本思路</p>
</li>
</ul>
<ol>
<li><p>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网（subnet）。划分子网纯属是一个单位内部的事情。本单位以外的网络看不见这个网络有多少个子网组成，对外表现为一个网络。</p>
</li>
<li><p>划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），主机号相应减少了位数。于是二级IP地址在本单位内部就变为三级IP地址：网络、子网号和主机号，表示为<code>IP地址::=&#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;</code>。</p>
</li>
<li><p>凡是从其他网络发送给本单位某台主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。</p>
</li>
</ol>
<p><img src="/.io//%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E4%BE%8B%E5%AD%90.jpg"></p>
<h4 id="子网划分的原理和方法"><a href="#子网划分的原理和方法" class="headerlink" title="子网划分的原理和方法"></a>子网划分的原理和方法</h4><ul>
<li><p>子网划分是将一个大的网络地址划分为多个小的子网。子网划分的原理是将网络地址的主机位部分拆分为多个子网的主机位和子网位，使每个子网拥有自己的网络地址和主机地址。</p>
</li>
<li><p>子网划分的方法有两种，一种是固定子网划分，另一种是可变子网划分。</p>
</li>
</ul>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><ul>
<li>子网掩码是一个用于划分网络地址和主机地址的二进制数字。它通常由32个位组成，其中以连续的1表示网络地址，剩下的以0表示主机地址。子网掩码的长度根据实际需要而定，例如常用的子网掩码有255.255.255.0、255.255.0.0等。</li>
</ul>
<p>A类地址的默认子网掩码是255.0.0.0，B类地址的默认子网掩码是255.255.0.0，C类地址的默认子网掩码是255.255.255.0。</p>
<ul>
<li><p>子网掩码的作用是通过将IP地址分组，从而实现更高效的数据传输和更有效的网络管理。通过划分子网，可以将大型网络划分为多个较小的子网，并给每个子网分配唯一的网络地址。这样，每个子网就可以独立运行和管理，而且跨子网的数据传输也会更加快速和高效。</p>
</li>
<li><p>通过IP地址和子网掩码求网络地址。</p>
</li>
</ul>
<p>求网络地址，需要对IP地址和子网掩码进行与运算。将IP地址和子网掩码转换成二进制后，对应位进行与运算，得到的结果即为网络地址。</p>
<p>以IPv4为例，假设IP地址为192.168.1.100，子网掩码为255.255.255.0（&#x2F;24前缀），则可以按照以下步骤计算出网络地址：将IP地址和子网掩码转换为二进制数字：IP地址二进制表示为11000000.10101000.00000001.01100100，子网掩码的二进制表示为11111111.11111111.11111111.00000000。对位进行与运算，得到网络地址的二进制表示为11000000.10101000.00000001.00000000。将二进制网络地址转换为点分十进制格式，即192.168.1.0。因此，该IP地址所在的网络地址为192.168.1.0。</p>
<h5 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h5><ul>
<li>计算子网掩码的方法是先确定需要划分的网络地址，然后根据需要划分的子网数目计算掩码长度。</li>
</ul>
<ol>
<li>固定子网划分的子网掩码计算方法</li>
</ol>
<p>假设给定一个网络地址和要划分的子网数，可以按照以下步骤计算子网掩码：</p>
<ul>
<li><p>确定网络地址的类别，根据类别确定默认子网掩码；</p>
</li>
<li><p>根据要划分的子网数计算需要多少位来表示子网，可以用2^n ≥ 子网数来计算需要的位数n；</p>
</li>
<li><p>用32减去网络地址的默认子网掩码的位数（即主机位数），得到剩余的位数，用来表示子网的位数；</p>
</li>
<li><p>将剩余的位数分配给子网，每个子网的位数相同；</p>
</li>
<li><p>将所有的位数相加，得到新的子网掩码。</p>
</li>
</ul>
<p>例如，假设有一个网络地址为192.168.1.0&#x2F;24，要划分成4个子网，按照上述步骤计算新的子网掩码：</p>
<ul>
<li><p>默认子网掩码为255.255.255.0；</p>
</li>
<li><p>2^2 ≥ 4，因此需要用2位来表示子网，剩余的6位表示主机；</p>
</li>
<li><p>每个子网将剩下6位共享，最大容纳主机数为2^6-2&#x3D;62；</p>
</li>
<li><p>每个子网的子网掩码是255.255.255.192（&#x2F;26）。</p>
</li>
</ul>
<ol start="2">
<li>可变子网划分的子网掩码计算方法 <font color="red"><strong>未解决</strong>!</font></li>
</ol>
<p>假设给定一个网络地址和每个子网所需的主机数，可以按照以下步骤计算子网掩码：</p>
<ul>
<li><p>确定网络地址的类别，根据类别确定默认子网掩码；</p>
</li>
<li><p>根据每个子网所需的主机数计算需要多少位来表示主机，可以用2^n ≥ 主机数+2来计算需要的位数n（加2是因为每个子网需要一个网络地址和一个广播地址）；</p>
</li>
<li><p>用32减去网络地址默认子网掩码的位数，得到剩余的位数，用来表示主机的位数；</p>
</li>
<li><p>将剩余的位数分配给主机，每个子网的主机位数不同；</p>
</li>
<li><p>将所有的位数相加，得到新的子网掩码。</p>
</li>
</ul>
<p>例如，假设有一个网络地址为192.168.1.0&#x2F;24，每个子网需要20个主机，按照上述步骤计算新的子网掩码：</p>
<ul>
<li><p>默认子网掩码为255.255.255.0；</p>
</li>
<li><p>2^5 ≥ 20+2，因此需要用5位来表示主机，剩余的3位表示子网；</p>
</li>
<li><p>将3位按比例分配给各个子网，假设划分成4个子网，则每个子网的主机位数分别为5、4、4、4；</p>
</li>
<li><p>每个子网的子网掩码分别是255.255.255.248（&#x2F;29）、255.255.255.240（&#x2F;28）、255.255.255.240（&#x2F;28）、255.255.255.240（&#x2F;28）。</p>
</li>
</ul>
<h4 id="子网划分的优缺点"><a href="#子网划分的优缺点" class="headerlink" title="子网划分的优缺点"></a>子网划分的优缺点</h4><ul>
<li><p>子网划分的优点是可以提高网络的安全性、灵活性和管理效率，同时可以减少网络冲突。</p>
</li>
<li><p>缺点是可能会浪费IP地址，因为每个子网都需要分配一定数量的IP地址。</p>
</li>
</ul>
<h4 id="子网划分的实际应用场景"><a href="#子网划分的实际应用场景" class="headerlink" title="子网划分的实际应用场景"></a>子网划分的实际应用场景</h4><ul>
<li>子网划分可以应用于各种规模的网络，特别是大型企业和机构网络。在企业网络中，可以根据部门和功能对网络进行划分，从而实现更好的管理和安全性。</li>
</ul>
<h4 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h4><h5 id="在划分子网的情况下路由器转发分组的算法"><a href="#在划分子网的情况下路由器转发分组的算法" class="headerlink" title="在划分子网的情况下路由器转发分组的算法"></a>在划分子网的情况下路由器转发分组的算法</h5><ol>
<li><p>从收到的分组的首部提取目的IP地址D。</p>
</li>
<li><p>先用各网络的子网掩码和D逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。</p>
</li>
<li><p>若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行4。</p>
</li>
<li><p>对路由表中的每一行，将子网掩码和D逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5。</p>
</li>
<li><p>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行6。</p>
</li>
<li><p>报告转发分组出错。</p>
</li>
</ol>
<h3 id="无分类编址CIDR（构造超网）"><a href="#无分类编址CIDR（构造超网）" class="headerlink" title="无分类编址CIDR（构造超网）"></a>无分类编址CIDR（构造超网）</h3><ul>
<li><p>无分类编址CIDR（Classless Inter-Domain Routing）是一种IP地址分配和路由选择的技术，与传统的基于IP地址分类的编址方式不同。</p>
</li>
<li><p>CIDR采用可变长度子网掩码，可以更加灵活地分配IP地址，而不必受到传统IP地址分类的限制。</p>
</li>
</ul>
<p>传统的IP地址分类是基于IP地址的第一个字节进行分类，将IP地址分为A、B、C、D、E五类。每一类地址都有固定的网络地址长度和主机地址长度。这种编址方式存在很多问题，比如浪费IP地址、网络划分不够灵活、路由表过大等。CIDR技术的出现解决了这些问题。</p>
<ul>
<li>CIDR技术采用可变长度子网掩码，可以更加灵活地分配IP地址，而不必受到传统IP地址分类的限制。CIDR技术允许将一个IP地址空间划分为多个子网，每个子网的掩码长度可以不同，这样可以更加高效地利用IP地址。CIDR技术还可以将多个小的IP地址空间合并成一个大的IP地址空间，这样可以减少路由器的负担，提高网络性能。总之，CIDR技术是一种更加灵活、高效的IP地址分配和路由选择技术，已经被广泛应用于互联网和企业网络中。</li>
</ul>
<h4 id="CIDR地址块"><a href="#CIDR地址块" class="headerlink" title="CIDR地址块"></a>CIDR地址块</h4><ul>
<li>CIDR地址块是一个用来表示网络地址空间的标准格式，它由一个IP地址和一个掩码组成，用斜线符号分隔。采用记法：<code>IP地址::=&#123;&lt;网络前缀&gt;,&lt;主机号&gt;&#125;</code>；也采用“斜线记法”，或称为CIDR记法，即在IP地址后面加上斜线“&#x2F;”，然后写上网络前缀所占的位数。</li>
</ul>
<p>CIDR使用32位的地址掩码，地址掩码1的个数就是网络前缀的长度。CIDR使用的地址掩码可继续称为子网掩码。如192.168.0.0&#x2F;16的表示格式。其中”&#x2F;16”表示地址的前缀长度，即网络部分所占的位数。在这个例子中，前16位为网络号，后16位为主机号。CIDR地址块通常是连续的IP地址范围，可以是一个或多个地址段。</p>
<ul>
<li><p>CIDR地址块的格式是根据网络地址和子网掩码的二进制位数来确定的，比如CIDR地址块192.168.1.0&#x2F;24表示该地址块的网络地址是192.168.1.0，子网掩码是255.255.255.0，即该地址块可以容纳256个主机。</p>
</li>
<li><p>CIDR地址块的优点在于可以将多个地址块聚合成一个更大的地址块，从而减少路由表的数量和路由器之间的交换信息量，提高网络的路由效率和性能。同时，CIDR地址块也可以灵活地分配IP地址，根据需要进行网络和子网的划分，使得地址使用更加高效和灵活。</p>
</li>
<li><p>CIDR地址块用于表示IP地址空间的聚合和路由选择。</p>
</li>
<li><p>在实际应用中，CIDR地址块被广泛应用于互联网中的路由器、防火墙、VPN等设备中，以便更好地管理和维护网络地址空间。同时，CIDR地址块也是网络工程师和管理员进行网络规划和配置时必须了解和掌握的重要技术。</p>
</li>
</ul>
<h5 id="相关计算"><a href="#相关计算" class="headerlink" title="相关计算"></a>相关计算</h5><ol>
<li>确定地址块的网络地址和掩码</li>
</ol>
<p>在CIDR地址块中，网络地址和掩码是通过斜线符号分隔的，在计算CIDR地址块时，需要确定网络地址和子网掩码的二进制位数，并将它们转换成十进制数表示。</p>
<ul>
<li>假设有一个CIDR地址块为192.168.1.0&#x2F;24，要求确定它的网络地址和子网掩码。</li>
</ul>
<p>CIDR地址块中斜线符号后面的数字24表示该地址块的子网掩码有24位为1，因此子网掩码的二进制表示为11111111.11111111.11111111.00000000，转换成十进制表示为255.255.255.0。网络地址为192.168.1.0，因此该CIDR地址块的网络地址为192.168.1.0，子网掩码为255.255.255.0。</p>
<ol start="2">
<li>确定地址块的主机数量</li>
</ol>
<p>CIDR地址块的主机数量取决于子网掩码的位数，在计算CIDR地址块时，可以根据子网掩码的位数来确定地址块的主机数量。</p>
<ul>
<li>假设有一个CIDR地址块为192.168.1.0&#x2F;24，要求确定它的主机数量。</li>
</ul>
<p>子网掩码为255.255.255.0，有24位为1，因此该CIDR地址块的主机数量为2^8-2&#x3D;254个，其中2个表示网络地址和广播地址，不可用于主机。</p>
<ol start="3">
<li>确定地址块的可用地址范围</li>
</ol>
<p>CIDR地址块的可用地址范围取决于网络地址和子网掩码的二进制位数，在计算CIDR地址块时，可以根据网络地址和子网掩码的位数来确定可用地址范围。</p>
<ul>
<li>假设有一个CIDR地址块为192.168.1.0&#x2F;24，要求确定它的可用地址范围。</li>
</ul>
<p>子网掩码为255.255.255.0，有24位为1，因此该CIDR地址块的可用地址范围是192.168.1.1~192.168.1.254，其中192.168.1.0为网络地址，192.168.1.255为广播地址，不可用于主机。</p>
<h4 id="超网的概念和作用"><a href="#超网的概念和作用" class="headerlink" title="超网的概念和作用"></a>超网的概念和作用</h4><ul>
<li><p>超网是将多个相邻的小网络合并成一个大网络。</p>
</li>
<li><p>超网的作用是可以减少路由表的数量和路由器的负担，提高网络性能。</p>
</li>
</ul>
<h4 id="超网的构造原理和方法"><a href="#超网的构造原理和方法" class="headerlink" title="超网的构造原理和方法"></a>超网的构造原理和方法</h4><ul>
<li><p>超网的构造原理是将多个相邻的小网络合并成一个大网络，并将它们的网络地址连续排列在一起，形成一个更大的网络地址。</p>
</li>
<li><p>超网的构造方法有两种，一种是手动配置，另一种是使用CIDR技术自动构造。</p>
</li>
</ul>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>超网是将多个连续的网络地址空间聚合成一个更大的网络地址空间的过程，以减少路由表的数量和路由器之间的交换信息量。</p>
<ol>
<li>基于CIDR地址构造：前缀聚合</li>
</ol>
<p>前缀聚合是将多个网络地址空间的前缀部分相同的地址聚合成一个更大的网络地址，以减少路由表中的条目数。具体步骤如下：</p>
<ul>
<li><p>按照前缀部分相同的原则，将需要聚合的网络地址空间进行分组；</p>
</li>
<li><p>对每组地址进行前缀压缩，即将相同的前缀部分保留，不同的部分用一个较短的掩码表示；</p>
</li>
<li><p>将压缩后的地址作为超网地址，并在路由器中配置该地址和相应的掩码，实现路由聚合。</p>
</li>
</ul>
<ol start="2">
<li>基于变长子网掩码（Variable Length Subnet Mask）地址构造：子网划分聚合</li>
</ol>
<p>子网划分聚合是将多个子网划分后的地址聚合成一个更大的网络地址，以减少路由表中的条目数。具体步骤如下：</p>
<ul>
<li><p>将需要聚合的子网按照相同的前缀部分进行分组；</p>
</li>
<li><p>对每组子网进行子网划分，使得每个子网的主机数量相同；</p>
</li>
<li><p>将划分后的子网聚合成一个更大的网络地址，并在路由器中配置该地址和相应的掩码，实现路由聚合。</p>
</li>
</ul>
<p>需要注意的是，在进行超网构造时，需要保证聚合后的地址仍然可以满足网络的需求，即不能出现地址冲突或主机数量不足的情况。同时，超网的构造需要考虑网络的规模和复杂程度，以便在减少路由表的数量的同时，保证网络的稳定性和可靠性。</p>
<ul>
<li>如将212.56.132.0&#x2F;24、212.56.133.0&#x2F;24、212.56.134.0&#x2F;24、212.56.135.0&#x2F;24四个C类网络聚合。</li>
</ul>
<p>比较四个地址的最长前缀，发现为22位，故聚合为212.26.132.0&#x2F;22。</p>
<h4 id="超网的优缺点"><a href="#超网的优缺点" class="headerlink" title="超网的优缺点"></a>超网的优缺点</h4><ul>
<li><p>超网的优点是可以减少路由器的负担，提高网络性能；同时可以减少路由表的数量，降低网络管理的复杂度。</p>
</li>
<li><p>缺点是可能会浪费IP地址，因为超网的子网数量比较少，每个子网需要分配更多的IP地址。</p>
</li>
</ul>
<h4 id="超网的实际应用场景"><a href="#超网的实际应用场景" class="headerlink" title="超网的实际应用场景"></a>超网的实际应用场景</h4><ul>
<li>超网可以应用于各种规模的网络，特别是在ISP网络中，可以将多个用户网络合并成一个大网络，提高网络性能和管理效率。</li>
</ul>
<h4 id="超网的管理和维护方法"><a href="#超网的管理和维护方法" class="headerlink" title="超网的管理和维护方法"></a>超网的管理和维护方法</h4><ul>
<li>超网需要进行定期的管理和维护，包括路由器配置、路由表管理、地址分配等方面。在超网的管理过程中，需要注意网络安全和地址分配的合理性。</li>
</ul>
<h2 id="IP层转发分组的过程"><a href="#IP层转发分组的过程" class="headerlink" title="IP层转发分组的过程"></a>IP层转发分组的过程</h2><h3 id="基于终点的转发"><a href="#基于终点的转发" class="headerlink" title="基于终点的转发"></a>基于终点的转发</h3><ul>
<li><p>基于终点转发的方法是一种比较常见的路由选择算法。其基本思路是根据目的地址来选择下一跳路由器，直接将分组从源节点转发到目标节点。</p>
</li>
<li><p>具体的流程如下：源主机发送分组到目标主机的IP地址；当分组经过每个路由器时，路由器将查找路由表以确定下一跳路由器；路由器将分组转发到下一跳路由器，直到最终目标主机被找到。</p>
</li>
</ul>
<p>例如，当数据包从A出发到达R1时，R1会检查路由表，发现需要将数据包转发到R2。R1会将数据包发往R2，R2再根据路由表将数据包转发到R3，最终到达目标主机B。</p>
<h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><ul>
<li><p>最长前缀匹配（Longest Prefix Match）是一种路由选择算法，用于在路由表中查找与给定目的IP地址最匹配的路由。在最长前缀匹配中，路由表中的每一条路由都有一个IP地址前缀和一个与之对应的下一跳地址，当路由器收到一个数据包时，它会根据数据包的目的IP地址查找路由表，并选择与之最匹配的路由，将数据包转发到对应的下一跳地址。</p>
</li>
<li><p>最长前缀匹配的匹配过程是从路由表中的最长前缀开始匹配，如果目的IP地址与某个路由的前缀匹配，则选择该路由；否则，继续匹配下一个最长前缀，直到找到匹配的路由或者匹配失败。</p>
</li>
</ul>
<p>例如，假设路由表中有以下两条路由：192.168.1.0&#x2F;24，下一跳地址为10.0.0.1；192.168.1.128&#x2F;25，下一跳地址为10.0.0.2。</p>
<p>当路由器接收到一个目的IP地址为192.168.1.130的数据包时，它会先用192.168.1.130与第一条路由192.168.1.0&#x2F;24进行匹配，发现不匹配；然后用192.168.1.130与第二条路由192.168.1.128&#x2F;25进行匹配，发现匹配成功。因此，路由器会选择第二条路由，并将数据包转发到下一跳地址10.0.0.2。</p>
<ul>
<li>最长前缀匹配算法能够快速准确地确定数据包的路由路径，提高网络转发效率和安全性。在实际网络应用中，最长前缀匹配算法被广泛应用于路由器、防火墙等网络设备中。</li>
</ul>
<h3 id="使用二叉线索查找转发表"><a href="#使用二叉线索查找转发表" class="headerlink" title="使用二叉线索查找转发表"></a>使用二叉线索查找转发表</h3><ul>
<li><p>二叉线索查找通常是把无分类编址的路由表存放在二叉树中，然后自上而下按层次进行查找。</p>
</li>
<li><p>使用二叉线索查找转发表的具体方法如下：将所有的转发表条目按照IP地址从左到右的顺序构造成一个二叉线索；对于每个查询的IP地址，按照从左到右的顺序依次比较它的每个二进制位。如果该位为0，则向左走，如果该位为1，则向右走。直到到达二叉线索的叶子节点，即找到了匹配的转发表项。</p>
</li>
</ul>
<p>假设有三个IP地址，分别为110.15.14.3、110.15.10.2和110.16.11.1。构造二叉线索的过程如下：</p>
<p>创建根节点，将IP地址的第一位作为判断依据。于是，将110.15.14.3插入左子树，将110.15.10.2插入右子树。此时，根节点的左子节点包含了一个指针和一个左孩子标志，右子节点包含了一个指针和一个右孩子标志。</p>
<p>对于110.15.14.3，继续向左走，将第二位为1的110.15.10.2插入右子树。此时，根节点的右子节点包含了一个指针和一个右孩子标志，右子节点的左子节点包含了一个指针和一个左孩子标志。</p>
<p>对于110.16.11.1，继续向右走，创建新的叶子节点。</p>
<p>二叉线索构造完成后，对于任何查询IP地址的请求，都可以通过遍历二叉线索来快速查找到匹配的转发表项。</p>
<h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><ul>
<li><p>ICMP（Internet Control Message Protocol）是互联网的标准协议，是IP层协议，允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
</li>
<li><p>为了提高IP数据包交付成功的机会，在网际层使用了网际控制报文协议。ICMP在IP之上，用来测试网络层有没有故障。使用最多的命令是<code>ping</code>。</p>
</li>
<li><p>ICMP报文件为IP层数据报的数据加上数据报的首部，组成IP数据报发送出去。</p>
</li>
</ul>
<h3 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h3><p><img src="/.io//ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg"></p>
<ul>
<li><p>类型(Type)：表示ICMP报文的类型，占用1个字节（8位），共定义了13种类型。</p>
</li>
<li><p>代码(Code)：表示具体的ICMP操作，通常与类型一起使用，占用1个字节，共定义了很多种不同的值。</p>
</li>
<li><p>校验和(Checksum)：用于校验ICMP报文头和数据部分，占用2个字节。</p>
</li>
<li><p>其他(Header&#x2F;Rest of header)：是指ICMP报文头的剩余部分，长度不固定。</p>
</li>
</ul>
<h3 id="ICMP报文的种类"><a href="#ICMP报文的种类" class="headerlink" title="ICMP报文的种类"></a>ICMP报文的种类</h3><ul>
<li>ICMP差错报告报文和ICMP询问报文</li>
</ul>
<table>
<thead>
<tr>
<th align="center">ICMP报文种类</th>
<th align="center">类型的值</th>
<th align="center">ICMP报文的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">差错报告报文</td>
<td align="center">3</td>
<td align="center">重点不可达</td>
</tr>
<tr>
<td align="center">差错报告报文</td>
<td align="center">11</td>
<td align="center">时间超过</td>
</tr>
<tr>
<td align="center">差错报告报文</td>
<td align="center">12</td>
<td align="center">参数问题</td>
</tr>
<tr>
<td align="center">差错报告报文</td>
<td align="center">5</td>
<td align="center">改变路由（Redirect）</td>
</tr>
<tr>
<td align="center">询问报文</td>
<td align="center">8或0</td>
<td align="center">回送（Echo）轻裘或回答</td>
</tr>
<tr>
<td align="center">询问报文</td>
<td align="center">13或14</td>
<td align="center">时间戳（Timestamp）请求或回答</td>
</tr>
</tbody></table>
<h4 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h4><p><img src="/.io//ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg"></p>
<ul>
<li>ICMP差错报告报文共分为4种类型。</li>
</ul>
<ol>
<li><p>终点不可达(Destination Unreachable)：目的主机无法到达，可能是因为主机正在关闭、主机被拒绝，或者网络无法访问等原因。</p>
</li>
<li><p>时间超时(Time Exceeded)：报告数据包在传输过程中经过的路由器数量超过了规定的时间限制，可能是因为路由表中的路由异常或网络拓扑发生变化等原因。</p>
</li>
<li><p>参数问题(Parameter Problem)：用于指示数据包中存在的参数不可接受，可能是由于数据包格式不正确或路由异常造成的。</p>
</li>
<li><p>改变路由(Redirect)：提示主机使用更优的路径转发数据包，通常是由路由器向源主机发送的。</p>
</li>
</ol>
<ul>
<li>不应发送ICMP差错报告报文的几种情况。</li>
</ul>
<ol>
<li><p>对ICMP差错报文，不再发送ICMP差错报告报文。</p>
</li>
<li><p>对第一个分片的数据报片的所有后续数据报片，都不发送ICMP差错报告报文。</p>
</li>
<li><p>对具有多播地址的数据报，都不发送ICMP差错报文。</p>
</li>
<li><p>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报，不发送ICMP差错报告报文。</p>
</li>
</ol>
<h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h4><ul>
<li>ICMP询问报文有2种类型。</li>
</ul>
<ol>
<li><p>回送请求和回答：ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问；收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。</p>
</li>
<li><p>时间戳请求和回答：ICMP时间戳请求报文是请某台主机或路由器回答当前的日期和时间；在ICMP时间戳回答报文中有一个32位的字段，其写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。</p>
</li>
</ol>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3><ul>
<li><p>PING用来测试两个主机之间的连通性</p>
</li>
<li><p>Traceroute</p>
</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="IPv6的基本首部"><a href="#IPv6的基本首部" class="headerlink" title="IPv6的基本首部"></a>IPv6的基本首部</h3><p><img src="/.io//IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg"></p>
<ul>
<li>与IPv4相比，IPv6对首部中的某些字段进行了修改：</li>
</ul>
<ol>
<li><p>取消了首部长度字段，因为它的首部长度是固定的（40字节）。</p>
</li>
<li><p>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</p>
</li>
<li><p>取消了总长度字段，改用有效载荷长度字段。</p>
</li>
<li><p>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</p>
</li>
<li><p>把TTL字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。</p>
</li>
<li><p>取消了协议字段，改用下一个首部字段。</p>
</li>
<li><p>取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP时，若检测出有差错用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正传送到目的进程为止。因此在网络层的差错检测可以精简掉。</p>
</li>
<li><p>取消了选项字段，而用扩展首部来实现选项功能。</p>
</li>
</ol>
<ul>
<li>基本首部字段组成：</li>
</ul>
<p><img src="/.io//IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%9F%BA%E6%9C%AC%E9%A6%96%E9%83%A8.jpg"></p>
<ol>
<li><p>版本号version（4位）：指定IPv6的版本号，固定为6。</p>
</li>
<li><p>流量类别traffic class（8位）：指定数据包的流量类别，包括优先级和流量类型，用于QoS（服务质量）控制。</p>
</li>
<li><p>流量标记flow label（20位）：指定数据包的流标记，用于标识数据包所属的流。</p>
</li>
<li><p>负载长度payload length（16位）：指定IPv6数据报的有效载荷长度，不包括IPv6首部。</p>
</li>
<li><p>下一个首部next header（8位）：指定下一个首部的类型，用于指示封装在IPv6包中的上层协议类型。</p>
</li>
<li><p>跳数限制top limit（8位）：与IPv4中的TTL（生存时间）类似，指定数据包在网络中最多可以经过的路由器数目。</p>
</li>
<li><p>源地址（128位）：指定数据包的源地址，用于标识数据包的发送者。</p>
</li>
<li><p>目的地址（128位）：指定数据包的目的地址，用于标识数据包的接收者。</p>
</li>
</ol>
<ul>
<li>主要变化</li>
</ul>
<ol>
<li><p>更大的地址空间：32位增大到128位；</p>
</li>
<li><p>扩展的地址层次结构；</p>
</li>
<li><p>灵活的首部格式；</p>
</li>
<li><p>改进的选项；</p>
</li>
<li><p>允许协议继续扩充；</p>
</li>
<li><p>支持即插即用（自动配置）；</p>
</li>
<li><p>支持资源的预分配；</p>
</li>
<li><p>IPv6首部改为8字节对齐。</p>
</li>
</ol>
<ul>
<li>IPv6数据报的一般形式：基本首部和有效载荷。</li>
</ul>
<h4 id="特殊首部"><a href="#特殊首部" class="headerlink" title="特殊首部"></a>特殊首部</h4><ul>
<li>IPv6的首部总长度为40字节，比IPv4的首部长度多出很多。其中有一些特殊的首部：</li>
</ul>
<ol>
<li><p>路由首部：该首部用于记录IPv6数据包在传输过程中的路由信息，可以使路由器在转发数据包时根据路由表选择最优的路径，从而提高网络性能。该首部共8字节长。</p>
</li>
<li><p>分段首部（Fragmentation Header）：IPv6和IPv4不同的是，IPv6规定了数据包只能在源节点进行分段操作，这意味着在中间路由器上不会产生数据包分片。然而，如果数据包超过了MTU（Maximum Transmission Unit），则需要将其进行分段，以保证传输的可靠性。分段首部用于记录数据包的分段情况，由于IPv6的负载部分可能很大，因此该首部需要16个字节长。</p>
</li>
<li><p>身份识别首部（Authentication Header）：该首部与安全相关，用于在保护模式下验证IPv6数据包的真实性和完整性，避免遭受攻击和窃听等安全威胁。该首部长度不定，最大值为64个字节。</p>
</li>
<li><p>加密首部（Encapsulating Security Payload）：该首部与身份识别首部类似，也是用于保证IPv6数据包的安全性，但它采用的是加密算法来对数据进行保护，使得数据在传输过程中无法被窃取或篡改。该首部长度不定。</p>
</li>
</ol>
<h3 id="IPv6的地址"><a href="#IPv6的地址" class="headerlink" title="IPv6的地址"></a>IPv6的地址</h3><ul>
<li><p>IPv6数据报的目的地址有三种基本类型：单播、多播、任播（任播的目的站是一组计算机，但数据报交付时只交付其中一个，通常是最近的一个）。</p>
</li>
<li><p>IPv6采用冒号十六进制记法指的是IPv6地址表示方法中使用冒号将128位（16个字节）地址分为8组，每组用四位十六进制数表示。由于IPv6地址比IPv4地址更长，使用冒号十六进制记法可以使IPv6地址更为简洁，易于记忆和书写。同时IPv6支持零压缩。</p>
</li>
</ul>
<p>例如，IPv6地址2001:0db8:85a3:0000:0000:8a2e:0370:7334可以简写为2001:db8:85a3::8a2e:370:7334，在这里双冒号“::”表示一连串的0。</p>
<ul>
<li>IPv6依然支持CIDR的斜线表示法。</li>
</ul>
<h4 id="IPv6地址分类"><a href="#IPv6地址分类" class="headerlink" title="IPv6地址分类"></a>IPv6地址分类</h4><table>
<thead>
<tr>
<th align="center">地址类型</th>
<th align="center">二进制前缀</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未指明地址</td>
<td align="center">00…0（128位），可记为::&#x2F;128</td>
</tr>
<tr>
<td align="center">环回地址</td>
<td align="center">00…1（128位），可记为::1&#x2F;128</td>
</tr>
<tr>
<td align="center">多播地址</td>
<td align="center">11111111（8位），可记为::1&#x2F;128</td>
</tr>
<tr>
<td align="center">本地链路单播地址</td>
<td align="center">1111111010（10位），可记为FE80::&#x2F;10</td>
</tr>
<tr>
<td align="center">全球单播地址</td>
<td align="center">除上述四种外其他的二进制前缀</td>
</tr>
</tbody></table>
<ul>
<li>未指明地址</li>
</ul>
<p>这是16 字节的全0地址，可缩写为两个冒号“::”。这个地址不能用作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的P地址。这类地址仅此一个。</p>
<ul>
<li>环回地址</li>
</ul>
<p>IPv6 的环回地址是 0:0:0:0:0:0:0:1，可缩写为::1。它的作用和IPv4的环回地址一样。这类地址也是仅此一个。</p>
<ul>
<li>多播地址</li>
</ul>
<p>功能和IPv4的一样。这类地址占IPv6地址总数的1&#x2F;256。</p>
<ul>
<li>本地链路单播地址（Link-Local Unicast Address）</li>
</ul>
<p>有些单位的网络使用TCP&#x2F;IP协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占IPv6地址总数的1&#x2F;1024。</p>
<ul>
<li>全球单播地址</li>
</ul>
<p>IPv6的这一类单播地址是使用得最多的一类。曾提出过多种方案来进一步划分这128位的单播地址。根据2006年发布的草案标准RFC4291 的建议，IPv6单播地址的划分方法非常灵活，可以如图所示的任何一种。这就是说，可把整个的128比特都作为一个结点（主机）的地址。也可用n比特作为子网前缀，用剩下的(128-n）比特作为接口标识符（相当于 IPv4的主机号)。当然也可以划分为三级，用n比特作为全球路由选择前缀，用m比特作为子网前缀，而用剩下的(128-n-m)比特作为接口标识符。</p>
<p><img src="/.io//IPv6%E7%9A%84%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.jpg"></p>
<h3 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h3><ul>
<li>向IPv6过渡只能采用逐步演进的办法，同时保证新安装的IPv6系统能够向后兼容。</li>
</ul>
<h4 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h4><ul>
<li>双协议栈（Dual Stack）是指在同一设备上同时实现IPv4和IPv6两种协议栈，从而可以在IPv4和IPv6网络之间进行无缝转换。</li>
</ul>
<p>采用双协议栈的设备可以通过IPv4和IPv6两种协议来与网络中的其他设备进行通信，从而避免了IPv4地址不足和IPv6未普及等问题。</p>
<p>在双协议栈中，每个网络接口都有一个IPv4地址和一个IPv6地址，不同协议的数据包可以使用各自的协议栈进行处理，并在需要时通过网关或路由器进行互联。在Linux系统中，可以使用ifconfig命令查看设备的IPv4和IPv6地址，也可以使用ip addr命令来查看。</p>
<p>双协议栈技术的广泛应用可以使得IPv6网络逐渐普及，而不必担心IPv4地址短缺和网络地址转换等问题。然而，在实际应用中，也存在着双协议栈对网络性能的影响、安全性问题和IPv4&#x2F;IPv6之间的互通性等挑战，需要进行适当的优化和调整。</p>
<h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4><ul>
<li>隧道技术（Tunneling）是一种在一个网络中传递另一个网络协议的方法。它通过在封装的数据包中添加一个新的头部，将这些数据包重新封装，并发送到目标节点，从而实现不同网络协议之间的通信。隧道技术可以用于连接两个独立的网络（例如不同的局域网），也可用于通过互联网连接两个远程网络。</li>
</ul>
<p>隧道技术常用的协议有多种，包括比较常见的有GRE、L2TP、PPTP等。其中，GRE协议（Generic Routing Encapsulation）是最常用的隧道技术之一。它可以将不同的IP数据包封装到GRE帧中，形成新的GRE数据包进行传输。使用GRE隧道技术可以构建虚拟专有网络（VPN），并向外扩展网络，提高网络安全性和数据传输效率。</p>
<p>在实际应用中，隧道技术被广泛用于跨越不同网络或者VPN之间的数据传输，在企业内部或者跨地区之间实现安全可靠的数据传输。但同时，隧道技术也会增加一定的链路开销和网络负担，需要在实际应用中进行合理选择和使用。</p>
<h3 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h3><ul>
<li>ICMPv6（Internet Control Message Protocol version 6）是IPv6网络层协议中的一个重要组成部分，用于在IP数据包传输过程中提供控制和错误报告功能。它可以帮助网络管理员诊断网络问题，例如路由器是否可达、连通性、MTU大小等。</li>
</ul>
<p><img src="/.io//%E6%96%B0%E6%97%A7%E7%89%88%E6%9C%AC%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B1%82.jpg"></p>
<ul>
<li><p>ICMPv6报文分为：差错报文、信息报文、邻站发现报文、组成员关系报文。</p>
</li>
<li><p>ICMPv6与IPv4版本中的ICMP有一些不同之处。下面是一些ICMPv6的特点：</p>
</li>
</ul>
<ol>
<li><p>ICMPv6支持更多的消息类型：ICMPv6支持新的消息类型，如邻居请求（Neighbor Solicitation）、邻居通告（Neighbor Advertisement）、路由器请求（Router Solicitation）、路由器通告（Router Advertisement）等，这些消息类型在IPv6网络中具有重要的作用。</p>
</li>
<li><p>ICMPv6支持数据报文片段：IPv6协议要求每个中间路由器所能转发的最大数据包长度（MTU）必须大于1280字节，但由于各种原因，可能会出现MTU小于1280字节的情况。为了解决这个问题，ICMPv6引入了数据报文片段和Path MTU发现机制，以支持更大的IPv6数据报文的传输。</p>
</li>
<li><p>ICMPv6是强制性的：在IPv6协议中，ICMPv6的实现是强制性的，所有IPv6设备必须实现ICMPv6协议，这使得ICMPv6在IPv6网络中具有重要的作用。</p>
</li>
</ol>
<h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><h3 id="有关路由选择协议的几个基本概念"><a href="#有关路由选择协议的几个基本概念" class="headerlink" title="有关路由选择协议的几个基本概念"></a>有关路由选择协议的几个基本概念</h3><h4 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h4><ul>
<li>一个理想的路由算法应满足以下特点</li>
</ul>
<ol>
<li><p>算法必须是正确的和完整的。</p>
</li>
<li><p>算法在计算上应简单。</p>
</li>
<li><p>算法应能适应通信量和网络拓扑的变化，有自适应性（鲁棒性，robustness）。</p>
</li>
</ol>
<p>静态路由选择策略——非自适应性路由选择</p>
<p>动态路由选择策略——自适应性路由选择</p>
<ol start="4">
<li><p>算法应具有稳定性。</p>
</li>
<li><p>算法应是公平的。</p>
</li>
<li><p>算法应是最佳的。</p>
</li>
</ol>
<ul>
<li>换种说法，也可满足以下特点：</li>
</ul>
<ol>
<li><p>最短路径：理想的路由算法应该能够找到最短的路径。这样可以减少数据包传输的时间和网络负载。</p>
</li>
<li><p>快速收敛：路由算法应该能够快速地适应网络拓扑变化，重新计算路径并更新路由表，以便在最短的时间内将数据包送达目的地。</p>
</li>
<li><p>无环：理想的路由算法应该能够保证不存在环路。如果存在环路，数据包可能会一直在网络中循环，导致网络阻塞。</p>
</li>
<li><p>可靠性：路由算法应该能够保证网络的可靠性，即在网络中发生故障时仍能够正常运行。</p>
</li>
<li><p>负载均衡：理想的路由算法还应该能够实现负载均衡，即将数据包分配到多个路径上，使得网络负载分布均匀。</p>
</li>
<li><p>可扩展性：路由算法应该能够适应网络规模的增长，支持更多的网络节点和路由器。</p>
</li>
<li><p>安全性：路由算法应该能够保证网络的安全性，防止黑客入侵和攻击。</p>
</li>
</ol>
<h4 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h4><h5 id="自治系统AS"><a href="#自治系统AS" class="headerlink" title="自治系统AS"></a>自治系统AS</h5><ul>
<li>自制系统AS（Autonomous System）是指企业或组织自己搭建和管理的互联网组网系统。</li>
</ul>
<p>它是一个自治的网络系统，具有统一的管理和控制，可以进行独立的路由选择和运营。</p>
<ul>
<li><p>自制系统AS通常由多个网络设备和路由器组成，这些设备可以连接到不同的ISP（Internet Service Provider）网络，也可以连接到其他自制系统AS。自制系统AS通过BGP（Border Gateway Protocol）协议与其他AS交换路由信息，实现互联互通。</p>
</li>
<li><p>自制系统AS的优点包括：</p>
</li>
</ul>
<ol>
<li><p>可以独立控制和管理网络，不受ISP的限制和影响。</p>
</li>
<li><p>可以根据需求定制网络拓扑结构和路由选择策略，提高网络效率和可靠性。</p>
</li>
<li><p>可以实现多条路径的负载平衡和路由聚合，减少网络拥塞和延迟。</p>
</li>
<li><p>可以提高网络安全性，实现访问控制、流量过滤等功能。</p>
</li>
<li><p>可以降低网络成本，避免ISP的高昂收费。</p>
</li>
</ol>
<ul>
<li>自制系统AS的缺点包括：</li>
</ul>
<ol>
<li><p>需要投入大量的人力、物力和财力，进行网络设计、搭建和运维。</p>
</li>
<li><p>需要具备一定的技术水平和经验，以便有效地管理和维护网络。</p>
</li>
<li><p>需要购买和维护网络设备和软件，增加了成本和风险。</p>
</li>
<li><p>自制系统AS无法避免Internet中出现的一些问题，如黑客攻击、网络故障等。</p>
</li>
</ol>
<h5 id="互联网的路由选择协议-1"><a href="#互联网的路由选择协议-1" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h5><ul>
<li><p>内部网关协议IGP（Interior Gateway Protocol）：RIP和OSPF</p>
</li>
<li><p>外部网关协议EGP（External Gateway Protocol）：BGP</p>
</li>
<li><p>自治系统之间的路由选择也叫做域间路由选择，在自治系统内部的路由选择叫作域内路由选择。</p>
</li>
</ul>
<h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3><ul>
<li><p>RIP（Routing Information Protocol）：是一种分布式的、基于距离向量的协议，用于在小型网络中进行路由选择。</p>
</li>
<li><p>RIP将路由器之间的距离（最短距离）表示为跳数，即经过的路由器数量。</p>
</li>
</ul>
<p>RIP要求网络中每个路由器都要维护从它自己到其他每一个目的网络的距离记录，即距离向量，具体定义距离如下：从一个路由器到直接连接的网络的距离为1，到非直接连接的网络的距离则定义为所经过的路由器数+1。例如，路由器R1与网1直接相连，路由器R1到网1的距离是1；但到不直接相连的网2的距离是所经过的路由器数+1。</p>
<p>RIP允许一条路径最多只能包含15个路由器。“距离”的最大值为16时即相对于不可达，所以适用于小型网络。</p>
<p>当网络中出现环路时，可能会导致路由收敛失败，即路由不断地振荡，无法收敛。此时需要借助于拓扑改进，如Split-Horizon、Route-Poisoning等技术来解决。此处“收敛”就是在自治系统AS中所有的结点都得到正确的路由选择信息的过程。</p>
<ul>
<li><p>RIP认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p>
</li>
<li><p>RIP协议的三个特点</p>
</li>
</ul>
<ol>
<li><p>仅和相邻路由器交换信息；</p>
</li>
<li><p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表；</p>
</li>
<li><p>按固定的时间间隔交换路由信息。如RIP每30秒发送一次路由更新信息，以保持网络拓扑的最新状态。</p>
</li>
</ol>
<ul>
<li>RIP“好消息”传得快，“坏消息”传得慢，当出现故障时，更新时间的收敛时间较长，传播信息时间往往花费较多。</li>
</ul>
<h4 id="路由表的建立"><a href="#路由表的建立" class="headerlink" title="路由表的建立"></a>路由表的建立</h4><ol>
<li>邻居发现</li>
</ol>
<p>在建立路由表之前，路由器首先要发现相邻的路由器，以便向它们传递路由信息。这个过程叫做邻居发现。</p>
<p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1)。它的路由表是空的。</p>
<p>路由器可以通过以下两种方式来发现相邻的路由器：静态配置：手动在路由器上进行配置。这种方法适用于小型网络，但当网络规模扩大时，手动配置就变得繁琐且容易出错。<br>动态发现：路由器之间通过路由协议（如OSPF、BGP、RIP等）进行交互，自动发现邻居。</p>
<ol start="2">
<li>路由计算</li>
</ol>
<p>当路由器发现相邻的路由器后，需要开始路由计算，计算出最佳的路径和下一跳信息。路由计算根据不同的路由选择协议有不同的计算方法和指标。常用的指标有：距离（Metric）：比如RIP协议中的跳数；带宽（Bandwidth）：比如OSPF协议中的链路带宽；延迟（Delay）：比如OSPF协议中的链路延迟；可靠性（Reliability）：比如EIGRP协议中的链路可靠性。</p>
<p>在路由计算中，路由器首先需要确定到达目标网络的可能路径，然后通过路由选择协议计算每条路径的指标值，最后选择指标最优的路径作为最终路径，并将该路径和下一跳信息加入到路由表中。</p>
<p>以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</p>
<ul>
<li><p>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</p>
</li>
<li><p>RIP 协议的收敛(convergence）过程较快。</p>
</li>
</ul>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><ul>
<li><p>距离向量算法的基础就是Bellman-Ford算法（或Ford-Fulkerson算法）。</p>
</li>
<li><p>路由器收到相邻路由器（其地址为X）的一个RIP报文：</p>
</li>
</ul>
<ol>
<li><p>先修改此RIP报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。</p>
</li>
<li><p>对修改后的RIP报文中的每一个项目，重复以下步骤：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">若项目中的目的网络不在路由表中</span><br><span class="line">    则把该项目加到路由表中。</span><br><span class="line">否则</span><br><span class="line">    若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。</span><br><span class="line">否则</span><br><span class="line">    若收到项目中的距离小于路由表中的距离，则进行更新，</span><br><span class="line">否则</span><br><span class="line">    什么也不做。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（表示不可达）。</p>
</li>
<li><p>返回。</p>
</li>
</ol>
<h4 id="RIP2协议的报文格式"><a href="#RIP2协议的报文格式" class="headerlink" title="RIP2协议的报文格式"></a>RIP2协议的报文格式</h4><p><img src="/.io//RIP2%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg"></p>
<ul>
<li>RIP2消息头：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">长度（字节）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">命令</td>
<td align="center">1</td>
<td align="center">请求（1）&#x2F;响应（2）</td>
</tr>
<tr>
<td align="center">版本</td>
<td align="center">1</td>
<td align="center">RIP2协议版本（2）</td>
</tr>
<tr>
<td align="center">保留</td>
<td align="center">2</td>
<td align="center">保留字段，必须为0</td>
</tr>
</tbody></table>
<ul>
<li>RIP2路由项：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">长度（字节）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">地址族</td>
<td align="center">2</td>
<td align="center">地址族，IPv4（2）</td>
</tr>
<tr>
<td align="center">标记</td>
<td align="center">2</td>
<td align="center">路由标记，必须为0</td>
</tr>
<tr>
<td align="center">IPv4地址</td>
<td align="center">4</td>
<td align="center">目的网络的IPv4地址</td>
</tr>
<tr>
<td align="center">子网掩码</td>
<td align="center">4</td>
<td align="center">目的网络的子网掩码</td>
</tr>
<tr>
<td align="center">下一跳</td>
<td align="center">4</td>
<td align="center">下一跳的IPv4地址</td>
</tr>
<tr>
<td align="center">距离</td>
<td align="center">4</td>
<td align="center">路由距离，最大为15</td>
</tr>
<tr>
<td align="center">标签</td>
<td align="center">4</td>
<td align="center">路由标签，可选项</td>
</tr>
</tbody></table>
<p>RIP2协议的报文格式与RIP1协议的报文格式类似，但RIP2协议支持VLSM（可变长度子网掩码）和CIDR（无类域间路由），可以在同一个网络上使用不同的子网掩码。同时，RIP2协议还支持多播路由，可以将多个路由项封装在同一个消息中发送。</p>
<ul>
<li>一个RIP报文最多可包括25个路由，因而RIP报文最大长度是$4+20×25&#x3D;504$字节。</li>
</ul>
<h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3><ul>
<li><p>OSPF（Open Shortest Path First）：OSPF是一种链路状态协议，用于在大规模网络中进行路由选择，具有更快的收敛性、更佳的稳定性和更广泛的可扩展性。</p>
</li>
<li><p>OSPF通过交换链路状态信息来计算最短路径。OSPF使用Dijkstra算法来计算最短路径。OSPF还支持分层网络结构和多个路由器之间的负载平衡。</p>
</li>
<li><p>OSPF通过在路由器之间通告网络接口的状态来建立链路状态数据库（LSDB），生成最短路径树，并由每个OSPF路由器使用这些最短路径构造它的路由表。主要特点如下：使用分布式的链路状态协议；支持类别路由和可变长度子网掩码（VLSM）；支持多种类型的服务和路由器类型；支持大型网络的可扩展性。</p>
</li>
<li><p>OSPF协议中，所有的路由器都知道网络的全局拓扑结构，且具备向其它路由器传递链路状态信息的能力。当出现路由变化时，只需要把改变的信息通告给整个网络，让每个路由器根据链路状态更新与之相关的信息即可。这样，整个网络只需数秒或数十秒即可完成从原最短路径到新最短路径的转移，从而实现网络的快速收敛。</p>
</li>
<li><p>OSPF支持基于区域的设计，可以将整个网络划分成若干个区域，每个区域内部使用独立的SPF计算，从而降低计算负担并提高网络的可扩展性。同时，OSPF支持路由器的多线接口和多地址，可以自动发现邻居路由器并建立邻居关系，实现更加灵活的网络设计。</p>
</li>
<li><p>OSPF还具有下列的一些特点：</p>
</li>
</ul>
<ol>
<li><p>OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF对于不同类型的业务可计算出不同的路由。链路的代价可以是1至65535中的任何一个无量纲的数，因此十分灵活。商用的网络在使用OSPF时，通常根据链路带宽来计算链路的代价。这种灵活性是RIP所没有的。</p>
</li>
<li><p>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的负载平衡(load balancing)。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP只能找出到某个网络的一条路径。</p>
</li>
<li><p>所有在OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</p>
</li>
<li><p>OSPF 支持可变长度的子网划分和无分类的编址CIDR。</p>
</li>
<li><p>由于网络中的链路状态可能经常发生变化，因此OSPF让每一个链路状态都带上一个32位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每5秒钟1 次。这样，全部序号空间在600年内不会产生重复号。</p>
</li>
</ol>
<h4 id="OSPF分组首部"><a href="#OSPF分组首部" class="headerlink" title="OSPF分组首部"></a>OSPF分组首部</h4><p><img src="/.io//OSPF%E5%88%86%E7%BB%84%E7%94%A8IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E9%80%81.jpg"></p>
<ol>
<li><p>版本号：表示OSPF协议的版本，通常为2；</p>
</li>
<li><p>分组类型：表示该分组是Hello、DDP（Database Description Packets）、LSR（Link-state Request）、LSU（Link-state Update）还是LSAck（Link-state Acknowledgment）中的哪一种；</p>
</li>
<li><p>分组长度：表示该OSPF分组的总长度，以字节为单位；</p>
</li>
<li><p>路由器ID：表示发送该分组的OSPF路由器的ID；</p>
</li>
<li><p>区域ID：表示发送该分组的OSPF路由器所在的区域的ID；</p>
</li>
<li><p>分组检验和：校验整个OSPF分组是否出错或损坏。</p>
</li>
<li><p>鉴别类型：0（不用）和1（口令）；</p>
</li>
<li><p>鉴别：鉴别类型为60时填入0，鉴别类型为1则填入8个字符的口令。</p>
</li>
</ol>
<h4 id="OSPF的五种分组类型"><a href="#OSPF的五种分组类型" class="headerlink" title="OSPF的五种分组类型"></a>OSPF的五种分组类型</h4><ol>
<li>Hello报文，问候分组</li>
</ol>
<p>Hello报文是OSPF中最基本的报文类型，用于邻居关系的建立和维护。通过发送Hello报文，路由器之间可以确认是否处于同一网络，以及确定对方的IP地址和路由器ID等信息。</p>
<ol start="2">
<li><p>DDP（Database Description Packet）报文，数据库描述分组</p>
</li>
<li><p>LSR（Link State Request）报文，链路状态请求分组</p>
</li>
</ol>
<p>LSR报文用于请求邻居路由器的链路状态信息。当某个路由器需要更新自己的LSDB时，会向邻居路由器发送LSR报文，请求其链路状态信息。</p>
<ol start="4">
<li>LSU（Link State Update）报文，链路状态更新分组</li>
</ol>
<p>LSU报文用于向邻居路由器通告本地路由器的链路状态信息。当某个路由器更新了自己的LSDB，并生成新的链路状态信息时，会向邻居路由器发送LSU报文，通告其链路状态信息。</p>
<ol start="5">
<li>LSAck（Link State Acknowledgment）报文，链路状态确认分组</li>
</ol>
<p>LSAck报文用于确认收到LSU报文或LSR报文。当某个路由器接收到LSU或LSR报文后，会向对方发送LSAck报文，表示已经正确接收到了对方发来的报文。</p>
<h4 id="OPSF的基本操作"><a href="#OPSF的基本操作" class="headerlink" title="OPSF的基本操作"></a>OPSF的基本操作</h4><p><img src="/.io//OSPF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.jpg"></p>
<ul>
<li>工作流程</li>
</ul>
<ol>
<li><p>发现邻居：当OSPF路由器与相邻路由器建立连接时，会向对方发送Hello分组。如果对方回复了Hello分组，则可以建立邻居关系，否则说明有故障发生。</p>
</li>
<li><p>同步LSDB：当邻居之间建立连接后，它们会通过DDP（Database Description Packets）分组交换各自的LSDB（Link State Database）摘要信息，并比对更新对方的LSDB，使得两边的LSDB相同。</p>
</li>
<li><p>计算最短路径：在LSDB同步完成后，每个路由器都会计算出网络的最短路径。具体地，每个路由器将自身所在的区域视为一个独立的自治系统，进行SPF（Shortest Path First）算法运算，选出到达目标网段的最短路径，并保存在路由表中。</p>
</li>
<li><p>分发路由：每个路由器将自己的路由表发送给它的邻居，以便邻居更新自己的路由表。这个过程中，会以LSU（Link-state Update）分组的形式将更新的部分发送给所有邻居，并通过LSAck（Link-state Acknowledgment）分组确认收到的数据。</p>
</li>
<li><p>监控网络：OSPF协议能够动态地感知网络拓扑的变化，如果路由器发现某个邻居失效，则它会重新计算网络的最短路径，并将更新的信息发送给其他邻居，保证网络的连通性。</p>
</li>
</ol>
<ul>
<li>可靠的洪泛法保证LSA信息在网络中可靠传输的方法</li>
</ul>
<ol>
<li><p>链路状态更新数据的可靠性: OSPF协议确保可靠地通过持续的发送和接收确认报文来保障链路状态数据库的最新状态。当一个路由器将自己的LSA信息广播出去后，其他路由器会发送LSAck确认报文，表明已经收到该LSA信息。</p>
</li>
<li><p>序列号机制: OSPF中，每个LSA信息都有一个唯一的序列号。当某个LSA信息需要更新时，其序列号也必须更新。这样，在广播LSA信息时，接收方可以通过比对序列号来判断是否需要更新自己的LSDB。</p>
</li>
<li><p>路由器发现邻居的可靠性: OSPF协议通过Hello消息实现邻居关系的发现，并在每个LSA信息中加入“源路由器”字段，表明该LSA信息的来源路由器。这样，当某个路由器发现邻居失效时，它可以更新自己的LSDB并广播LSA信息，以保证整个网络拓扑的正确性。</p>
</li>
</ol>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3><ul>
<li><p>BGP（Border Gateway Protocol）：BGP是一种路径矢量协议，用于在互联网中进行路由选择。</p>
</li>
<li><p>BGP用于在不同自治系统之间交换路由信息。BGP使用路径属性来选择最佳路径。BGP还支持策略控制和路由聚合。</p>
</li>
<li><p>BGP协议特点</p>
</li>
<li><p>BGP-4共使用四种报文</p>
</li>
</ul>
<ol>
<li><p>打开（OPEN）报文，用来与相邻的另一个BGP发言人建立关系。</p>
</li>
<li><p>更新（UPDATE）报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</p>
</li>
<li><p>保活（KEEPALIVE）报文，用来确认打开报文和周期性地证实邻站关系。</p>
</li>
<li><p>通知（NOTIFICATION）报文，用来发送检测到的差错。</p>
</li>
</ol>
<ul>
<li>BGP报文具有通用首部</li>
</ul>
<p><img src="/.io//BGP%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8.jpg"></p>
<p>Marker（16字节）：用于同步BGP邻居之间的连接状态，由16个全为1的字节构成。Marker字段的存在是为了在连接建立时确保BGP邻居之间的状态同步，以及在连接中断后重新建立连接时，能够快速恢复连接状态。</p>
<p>Length（2字节）：表示整个BGP消息的长度，包括报文首部和消息体。</p>
<p>Type（1字节）：表示BGP消息的类型，包括OPEN、UPDATE、NOTIFICATION和KEEPALIVE四种类型。</p>
<h3 id="路由器的构成"><a href="#路由器的构成" class="headerlink" title="路由器的构成"></a>路由器的构成</h3><ul>
<li><p>路由器是一种典型的网络层设备，是互联网中的关键设备，是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。</p>
</li>
<li><p>路由器的主要作用是：连通不同的网络。选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。</p>
</li>
</ul>
<h4 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h4><ul>
<li><p>路由器的转发分组正是网络层的主要工作。</p>
</li>
<li><p>整个路由器结构可分为：路由选择部分和分组转发部分。</p>
</li>
</ul>
<h4 id="路由选择部分"><a href="#路由选择部分" class="headerlink" title="路由选择部分"></a>路由选择部分</h4><ul>
<li>路由选择部分是路由器最核心的部分，它的任务是根据路由选择协议（例如OSPF或BGP）选择一条最佳的路径进行数据包转发。在这个过程中，路由器需要维护一个路由表，其中包含了网络中每个节点的地址和相互之间的距离等信息。路由器会根据路由表进行查找，以确定数据包应该被转发到哪个下一跳路由器。</li>
</ul>
<h4 id="分组转发部分"><a href="#分组转发部分" class="headerlink" title="分组转发部分"></a>分组转发部分</h4><ul>
<li>分组转发部分是路由器中负责处理接收到的数据包，并将其转发到正确的下一跳路由器的部分。在转发数据包之前，交换结构会对数据包进行一些处理，例如去除冗余数据、修改目的地址等。</li>
</ul>
<h4 id="交换系统"><a href="#交换系统" class="headerlink" title="交换系统"></a>交换系统</h4><ul>
<li>交换系统是路由器中用于数据包转发的硬件设备，它包括一组输入端口和一组输出端口。输入端口用于接收输入数据包，而输出端口用于发送输出数据包。交换结构本身也可以看作是一种网络，因此交换系统可以被视为“在路由器中的网络”。</li>
</ul>
<h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h3 id="IP多播的基本概念"><a href="#IP多播的基本概念" class="headerlink" title="IP多播的基本概念"></a>IP多播的基本概念</h3><ul>
<li>IP多播是指一种在互联网中，将数据报文发送给一组目的地址的通信方式。</li>
</ul>
<p>IP多播为了更好地支持一对多通信（一个源点发送到许多个终点）。适用于需要向多个主机传输相同数据的应用程序，如视频&#x2F;音频流媒体、在线游戏、IP电话等。</p>
<p>与单播和广播不同，单播是一对一的通信方式，广播是一对多的通信方式，IP多播是一对多或一对多个的通信方式。</p>
<h4 id="多播IP地址"><a href="#多播IP地址" class="headerlink" title="多播IP地址"></a>多播IP地址</h4><ul>
<li>在IP多播中，发送方使用一个专门的IP地址（称为多播组地址）标识多个接收方。接收方可以通过加入相应的多播组地址来参与到IP多播中。当一个数据包发送到某个多播组地址时，所有加入该组的主机都可以接收到该数据包。这样就可以节省带宽，减少网络拥塞问题。</li>
</ul>
<h3 id="在局域网上进行硬件多播"><a href="#在局域网上进行硬件多播" class="headerlink" title="在局域网上进行硬件多播"></a>在局域网上进行硬件多播</h3><ul>
<li>D类IP地址与以太网多播地址的映射关系</li>
</ul>
<p><img src="/.io//D%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E4%B8%8E%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.jpg"></p>
<h3 id="网际组管理协议IGMP和多播路由选择协议"><a href="#网际组管理协议IGMP和多播路由选择协议" class="headerlink" title="网际组管理协议IGMP和多播路由选择协议"></a>网际组管理协议IGMP和多播路由选择协议</h3><ul>
<li>IP多播需要两种协议：IGMP协议和多播路由选择协议。</li>
</ul>
<h4 id="网际组管理协议"><a href="#网际组管理协议" class="headerlink" title="网际组管理协议"></a>网际组管理协议</h4><ul>
<li><p>网际组管理协议（Internet Group Management Protocol，简称IGMP）用于在IP网络中通知路由器主机加入或离开特定的多播组。IGMP 工作在 IP 协议的高层，是一种基于主机组的协议，旨在允许主机通告加入或离开一个多播组。</p>
</li>
<li><p>IGMP 协议通过如下三种类型的报文实现通信：</p>
</li>
</ul>
<ol>
<li><p>成员查询报文（Membership Query Messages）：用于询问某个多播组是否有主机成员参与。IGMP 规范定义了两种成员查询报文，包括通用查询报文（General Query Messages）和特定查询报文（Group-Specific Query Messages）。</p>
</li>
<li><p>成员报告报文（Membership Report Messages）：用于向路由器通报加入了哪个多播组。</p>
</li>
<li><p>离开组报文（Leave Group Messages）：用于通知路由器成员已经离开。</p>
</li>
</ol>
<ul>
<li>IGMP工作流程如下：</li>
</ul>
<ol>
<li><p>主机加入多播组：主机要加入某个多播组时，会向路由器发送成员报告报文（Membership Report Messages），报文中包括了主机的 IP 地址和加入的多播组地址。</p>
</li>
<li><p>路由器处理请求：当路由器收到主机发送的成员报告报文后，就会判断该多播组是否已经存在于缓存中。如果不存在，则将该组添加到缓存中，并加入到相应的树状结构中。</p>
</li>
<li><p>路由器通告：路由器会向网络中其他主机广播成员查询报文（Membership Query Messages），以确定哪些主机加入了该多播组。</p>
</li>
<li><p>主机回复：当其他主机得到成员查询报文后，如果其也加入了该多播组，就会通过成员报告报文回复路由器，否则，不做出任何回应。</p>
</li>
<li><p>路由器维护缓存：路由器在接收到成员报告报文时，会更新相应的缓存记录，并通过发送查询报文来维护多播组的状态。对于长时间没有回应的主机，路由器会将其从缓存中删除。</p>
</li>
<li><p>主机离开多播组：当主机要离开多播组时，会发送离开组报文（Leave Group Messages），路由器收到报文后将该主机从多播组中删除，并更新缓存记录。</p>
</li>
</ol>
<h4 id="多播路由选择协议"><a href="#多播路由选择协议" class="headerlink" title="多播路由选择协议"></a>多播路由选择协议</h4><ul>
<li><p>多播路由选择协议（Multicast Routing Protocol）是一种用于在网络中进行多播数据传输的协议。它主要用于将一个多播组的数据包从源节点传输到所有接收该组信息的目的节点。</p>
</li>
<li><p>多播路由选择协议在转发多播数据报时使用的方法：</p>
</li>
</ul>
<ol>
<li>洪泛与剪除</li>
</ol>
<p>洪泛是一种简单而可靠的多播路由选择协议，其中路由器在收到多播数据包后，会将该数据包广播到所有邻居路由器。这样做的问题是可能会导致网络流量过大，并且数据包很可能会被多次重复传输。为了解决这个问题，洪泛与剪除技术被提出，它使用了一些优化策略来减少冗余的数据包传输。例如，每个路由器只发送一份数据包，而不是向所有邻居广播；并在不需要转发数据包的路由器上进行剪除操作，以减少网络流量。</p>
<ol start="2">
<li>隧道技术</li>
</ol>
<p>隧道技术是一种将多播数据包封装在单播数据包中进行传输的方法。在使用隧道技术时，源节点先把多播数据包封装在一个单播数据包中，并将其发送给特定目标地址的路由器。然后，目标路由器根据多播数据包的目的地址将其解包，并将其转发到所需的网络中。隧道技术可以在网络间安全地传输多播数据包，同时可以实现跨越无法直接连接的子网的多播传输。</p>
<ol start="3">
<li>基于核心的发现技术</li>
</ol>
<p>基于核心的发现技术是一种基于网络拓扑结构的多播路由选择协议。该协议使用核心路由器来维护多播路由信息，而不是每个路由器都存储完整的多播路由表。核心路由器是一个专用的路由器，它对多播数据包进行缓存和转发，并负责将数据包发送到正确的目标节点。基于核心的发现技术可以减少存储和计算开销，并且具有更高的可靠性和可扩展性。</p>
<ul>
<li>建议使用的多播路由选择协议：</li>
</ul>
<ol>
<li><p>DVMRP（Distance Vector Multicast Routing Protocol）：DVMRP是一种基于距离向量的多播路由选择协议。它使用类似于RIP（Routing Information Protocol）的算法来选择最佳路径。在DVMRP中，每个路由器会定期广播其到达其他路由器的距离向量信息。通过这种方式，每个路由器都能了解到整个网络的拓扑结构和距离，并选择最短路径来转发多播数据包。DVMRP适用于小型网络。</p>
</li>
<li><p>PIM-DM（Protocol Independent Multicast-Dense Mode）：PIM-DM是一种密集模式的多播路由选择协议。在PIM-DM中，路由器会向所有邻居广播多播数据包。然后，每个路由器会选择最短路径将数据包转发到目标网络。PIM-DM适用于网络密度较高的场景。</p>
</li>
<li><p>PIM-SM（Protocol Independent Multicast-Sparse Mode）：PIM-SM是一种稀疏模式的多播路由选择协议。在PIM-SM中，路由器只会将数据包发送到属于多播组的主机所在的网络。PIM-SM使用Rendezvous Point（RP）来确定多播组的根源和主机所在的网络。当有新的主机加入多播组时，它会向RP发送请求，RP会将其加入到多播组中。然后，PIM-SM会使用最短路径算法选择最佳路径将数据包转发到目标网络。PIM-SM适用于网络稀疏的场景。</p>
</li>
<li><p>MOSPF（Multicast OSPF）：MOSPF是一种基于OSPF（Open Shortest Path First）的多播路由选择协议。在MOSPF中，路由器会使用OSPF算法来计算网络的拓扑结构和距离，并选择最短路径将数据包转发到目标网络。MOSPF适用于大型网络。</p>
</li>
<li><p>CBT（Core Based Tree）：CBT也是基于构建点对节点树来进行多播转发的路由协议，属于核心支持型路由协议。</p>
</li>
</ol>
<h2 id="虚拟专用网VPN和网络地址转换NAT"><a href="#虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="虚拟专用网VPN和网络地址转换NAT"></a>虚拟专用网VPN和网络地址转换NAT</h2><h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><ul>
<li><p>虚拟专用网（Virtual Private Network，VPN）是一种通过公共网络建立安全连接的加密隧道。它可以在不同的地理位置之间建立一个私有网络，让用户相互之间可以安全、便捷地分享数据和资源。</p>
</li>
<li><p>VPN使用隧道技术，通过公共网络（如Internet）将通信数据封装成加密数据包，以保护数据的隐私性。当远程客户端连接到VPN服务器时，客户端和服务端之间建立一条虚拟链路，构成通向目标网络的加密隧道，这些数据被加密后通过公共网络进行传输，其中采用了多重认证和加密方法来确保私密数据的保密性，安全性。</p>
</li>
</ul>
<p><img src="/.io//%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0VPN.jpg"></p>
<ul>
<li>常见的VPN协议包括PPTP（Point-to-Point Tunneling Protocol）、L2TP（Layer Two Tunneling Protocol）、SSTP、IPSec（Internet Protocol Security）等。其中，PPTP和L2TP是较为简单的协议，通常用于家庭和小型企业；而SSTP和IPSec是较为复杂和安全的协议，通常用于大型企业和政府机构。</li>
</ul>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><ul>
<li><p>网络地址转换（Network Address Translation，NAT）是一种将私有IP地址映射为公共IP地址的技术。当企业或组织网络内部使用私有IP地址时，需要通过网络地址转换功能来实现与公网连接通信，以使本地设备可以访问公网或被公网访问。</p>
</li>
<li><p>NAT技术的实现基于一个称为NAT路由器的设备，这个设备拥有一个公共IP地址和一个内部的私有IP地址。当内部主机向公共网络发送数据包时，NAT路由器会自动扫描数据包的源IP地址，并将其替换成NAT路由器的公共IP地址。相反，当外部主机回复该数据包时，NAT路由器会将公共IP地址还原回原始内部主机的私有IP地址。</p>
</li>
</ul>
<p><img src="/.io//NAT%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="NAT路由器工作原理"></p>
<ul>
<li>常见的NAT类型包括以下四种：</li>
</ul>
<ol>
<li><p>静态NAT：静态NAT固定分配一个公网IP地址到内部网络的特定主机或服务，从而使对应的服务在互联网上可达。</p>
</li>
<li><p>动态NAT：动态NAT是动态分配公网IP地址，在内网用户向Internet提交请求时临时出现，提高了安全性同时也保持了网络的稳定性。</p>
</li>
<li><p>端口映射（Port Mapping，PAT）：用于多个主机共享同一个公网IP地址的方式，通过将不同端口的访问映射到不同内部主机和服务上，从而使得内网用户可以同时使用公网地址进行访问。</p>
</li>
<li><p>双重NAT：双重NAT是在一个NAT路由器后面再次添加另外一个NAT路由器。这种方法能够防范暴力攻击、嗅探、端口扫描等危险活动，并提高了局域网内部设备与互联网之间的安全性，但也可能导致信号延迟、数据传输速度下降等问题。</p>
</li>
</ol>
<ul>
<li>NAT技术也会导致一些问题，例如：</li>
</ul>
<ol>
<li><p>NAT使得局域网内的多个设备共享同一个公共IP地址，因此不便于协议和端口的过滤等安全控制。</p>
</li>
<li><p>NAT会影响通信质量和可靠性，因为它增加了路由器的负载并可能丢失或重排数据包。</p>
</li>
<li><p>在某些应用程序中，如IP电话、视频会议、P2P等，NAT可能会对数据传输造成影响，导致无法正常连接或者丢失数据。</p>
</li>
</ol>
<h2 id="多协议标签交换MPLS"><a href="#多协议标签交换MPLS" class="headerlink" title="多协议标签交换MPLS"></a>多协议标签交换MPLS</h2><ul>
<li><p>多协议标记交换（Multiprotocol Label Switching，MPLS）是一种用于建立高效路由的技术，它可以在传输数据包时，根据数据包的标记直接转发数据包，而不需要重复地进行IP地址查找。MPLS技术在网络中将数据分成以标记（Label）为基础的流进行转发和处理，可以实现高效的数据传输和负载均衡，提高了网络的性能和可靠性。</p>
</li>
<li><p>MPLS技术的优点如下：</p>
</li>
</ul>
<ol>
<li><p>高效的转发机制：由于MPLS是基于标记进行转发，避免了重复查找IP地址和路由信息的过程，使得网络转发效率更高。</p>
</li>
<li><p>灵活的QoS保证：MPLS可以基于标记进行数据流分类和服务质量保证，支持多种差别化服务的实现。</p>
</li>
<li><p>网络可扩展性好：由于MPLS是基于标记而不是IP地址进行数据转发，因此避免了IP地址的诸多限制，使网络架构更加灵活和可扩展。</p>
</li>
<li><p>安全性高：在MPLS网络中，数据流只能沿着预定的路径传输，从而增强了数据传输的安全性。</p>
</li>
</ol>
<h3 id="MPLS的工作原理"><a href="#MPLS的工作原理" class="headerlink" title="MPLS的工作原理"></a>MPLS的工作原理</h3><p><img src="/.io//MPLS%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.jpg"></p>
<ul>
<li>在MPLS中，数据包被分为两个部分：标签和数据。标签用于确定数据包的转发路径或服务质量，而数据则代表着应用程序所要求传输的数据。MPLS由以下组成部分：</li>
</ul>
<ol>
<li><p>标签：标识数据包的路径、转发端口和服务质量等信息。</p>
</li>
<li><p>路由器：采用MPLS技术的网络设备，包括核心路由器和边缘路由器。</p>
</li>
<li><p>LSR（Label Switch Router）：即标签交换路由器，主要完成标记的交换转发和路径选择等操作。</p>
</li>
<li><p>LSP（Label Switch Path）：根据标签串联在一起的一条数据包转发路径，LSP可以是一个单独的物理链路、也可以是多条链路的组合形式。</p>
</li>
<li><p>FEC（Forwarding Equivalence Class）：表示一组具有相同路由逻辑规则和处理代码的数据流，通常映射为固定字段头和有效载荷的特定组合，对应着应用层中的各种协议和业务流量。</p>
</li>
</ol>
<p>FEC就是路由器按照同样方式对待的IP数据包集合。例如，在一个企业网络中有两个部门A和B，每个部门都需要使用不同的服务质量QoS优先级来传输流量。此时可以将部门A和B各自的流量划分到不同的FEC中，并为它们分别指定唯一的标签（Label）值来进行标记。接着，在路由器上配置FEC信息和转发策略，使得传输该FEC的数据流能够按照相应的FEC进行标记和转发，从而实现不同服务质量的保障。</p>
<ul>
<li>MPLS的工作原理是在数据包头部加入短标签（20位左右），该标签唯一地标识了这个流量的路径，并将数据包传输到下一个MPLS节点。转发节点仅需要根据标签来决定下一跳地址和出口端口即可快速转发数据，并将标记替换成下一个节点的标记。</li>
</ul>
<ol>
<li><p>标记分类：在发送端的边界路由器上，根据不同的VPN、服务质量等分类标记，对数据进行标记。</p>
</li>
<li><p>标记交换：在标记交换路由器（LSR）上，根据标记进行转发决策，并且可以根据标记对数据包进行QoS管理。</p>
</li>
<li><p>标记删除：在接收端的边界路由器上，将标记从数据包中去除，并将数据包交付到相应的目的地。</p>
</li>
</ol>
<h3 id="MPLS首部的位置与格式"><a href="#MPLS首部的位置与格式" class="headerlink" title="MPLS首部的位置与格式"></a>MPLS首部的位置与格式</h3><h4 id="MPLS首部的位置"><a href="#MPLS首部的位置" class="headerlink" title="MPLS首部的位置"></a>MPLS首部的位置</h4><ul>
<li>MPLS首部位于数据包头部，紧接着IPv4或IPv6首部。在数据包传输过程中，MPLS首部会一直跟随数据包，直到数据包到达目的地。MPLS首部位于网络层和数据链路层之间</li>
</ul>
<table>
<thead>
<tr>
<th align="center">网络层</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">MPLS首部</td>
<td align="center">←插入</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="MPLS首部的格式"><a href="#MPLS首部的格式" class="headerlink" title="MPLS首部的格式"></a>MPLS首部的格式</h4><p><img src="/.io//MPLS%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg"></p>
<ul>
<li>MPLS首部包含四个字段，分别为标签（Label）、实验位（Experimental）、堆叠位（Stack）、时间戳（TTL）。</li>
</ul>
<ol>
<li><p>标签（Label）：通常是20位长。MPLS首部中最重要的字段，用于唯一标识一个特定的FEC。标签是MPLS路由器进行数据包路由的依据，也可以用于提供服务质量保证以及安全性保护。</p>
</li>
<li><p>试验位（Experimental）：通常为3位长，用于提供服务质量的相关信息，例如优先级、延迟等。实验位可以支持8个不同的优先级，用于实现差别化服务，提高网络的性能和可靠性。</p>
</li>
<li><p>堆叠位（Stack）：1位长，用来指示MPLS路由器是否需要将当前标签压入一个新的MPLS头部中，并在数据包中添加一个新的标签。当堆叠位为0时，表示当前标签是最后一个标签，数据包将被转发到目的地，否则会根据新的标签进行继续路由。</p>
</li>
<li><p>时间戳（TTL）：8位长，与IPv4和IPv6首部的TTL作用类似，用于控制数据包在网络中的生存周期，防止数据包无限循环。每经过一个MPLS路由器，TTL值减少1，当TTL值为0时，数据包将被自动丢弃。</p>
</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/">
    <time datetime="2023-05-28T16:00:00.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-运输层" class="post-运输层 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/">运输层</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/" data-id="cli8zk3o7000c24do3pkk5oz1" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ul>
<li><p>运输层向它上面的应用层提供通信服务。</p>
</li>
<li><p>两台主机进行通信就是两台主机中的应用进程互相通信。通信的两端应当是两个主机中的<strong>应用进程</strong>。</p>
</li>
<li><p>端到端的通信时应用进程之间的通信。</p>
</li>
</ul>
<p><img src="/.io//%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%BA%E8%BF%9B%E7%A8%8B%E6%8F%90%E4%BE%9B%E9%80%9A%E4%BF%A1.jpg" alt="运输层对应用进程提供的逻辑通信"></p>
<h3 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h3><ul>
<li><p>用户数据报协议UDP（User Datagram Protocol）和传输控制协议TCP（Transmission Control Protocol）。</p>
</li>
<li><p>当使用<strong>面向连接</strong>的TCP协议时，逻辑通信通道相当于一条全双工的可靠信道。当使用<strong>无连接</strong>的UDP协议时，逻辑通信通道是不可靠通道。</p>
</li>
<li><p>UDP和TCP的例子</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用层协议</th>
<th align="center">运输层协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">名字转换</td>
<td align="center">DNS（域名系统）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">文件传送</td>
<td align="center">TFTP（简单文件传送协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">路由选择协议</td>
<td align="center">RIP（路由信息协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">IP地址配置</td>
<td align="center">DHCP（动态主机配置协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">网络管理</td>
<td align="center">SNMP（简单网络管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">远程文件服务器</td>
<td align="center">NFS（网络文件系统）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">IP电话</td>
<td align="center">专用协议</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">流式多媒体通信</td>
<td align="center">专用协议</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">多播</td>
<td align="center">IGMP（网际组管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">电子邮件</td>
<td align="center">SMTP（简单邮件传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程终端接入</td>
<td align="center">TELNET（远程终端协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">万维网</td>
<td align="center">HTTP（超文本传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">文件传送</td>
<td align="center">FTP（文件传送协议）</td>
<td align="center">TCP</td>
</tr>
</tbody></table>
<h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ul>
<li><p>虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（即最后交付目的进程）就由TCP或UDP来完成。</p>
</li>
<li><p>运行在计算机中的<strong>进程</strong>是用<strong>进程标识符</strong>来标志的。</p>
</li>
<li><p>应用层和运输层的通信的抽象终点称为协议端口，简称为端口。每一个端口用一个称为端口号的正整数来标志。</p>
</li>
</ul>
<p>TCP&#x2F;IP运输层中，端口号只具有本地意义，端口号为了标志本计算机应用层中各个进程和运输层交互时的层间接口。</p>
<ul>
<li><p><strong>在协议栈层间的抽象的协议端口是软件端口</strong>，<strong>路由器或交换机上的端口是硬件端口</strong>。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的地点。</p>
</li>
<li><p>端口只有本地意义，不同主机的相同端口其实并没有联系。</p>
</li>
<li><p>端口分为服务器端使用的端口号和客户端使用的端口号。</p>
</li>
</ul>
<h4 id="服务器端使用的端口"><a href="#服务器端使用的端口" class="headerlink" title="服务器端使用的端口"></a>服务器端使用的端口</h4><ul>
<li><p>熟知端口号（系统端口号），数值一般为0~1023。</p>
</li>
<li><p>登记端口号，数值为1024~49151。使用这个范围的端口号必须在IANA登记，避免重复。</p>
</li>
</ul>
<h4 id="客户端使用的端口号"><a href="#客户端使用的端口号" class="headerlink" title="客户端使用的端口号"></a>客户端使用的端口号</h4><ul>
<li>又称为短暂端口号，数值为49152~65535。仅在客户进程运行时才动态选择。</li>
</ul>
<h4 id="常用熟知端口号"><a href="#常用熟知端口号" class="headerlink" title="常用熟知端口号"></a>常用熟知端口号</h4><table>
<thead>
<tr>
<th align="center">应用程序</th>
<th align="center">FTP</th>
<th align="center">TELNET</th>
<th align="center">SMTP</th>
<th align="center">DNS</th>
<th align="center">TFTP</th>
<th align="center">HTTP</th>
<th align="center">SNMP</th>
<th align="center">SNMP(trap)</th>
<th align="center">HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">熟知端口号</td>
<td align="center">21</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">53</td>
<td align="center">69</td>
<td align="center">80</td>
<td align="center">161</td>
<td align="center">162</td>
<td align="center">443</td>
</tr>
</tbody></table>
<h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><h3 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h3><h4 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h4><ol>
<li><p><strong>UDP 是无连接的</strong>，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p>
</li>
<li><p><strong>UDP使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p>
</li>
<li><p><strong>UDP 是面向报文的</strong>。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP一次交付一个完整的报文。</p>
</li>
<li><p><strong>UDP没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。</p>
</li>
<li><p><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。</p>
</li>
<li><p><strong>UDP的首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</p>
</li>
</ol>
<h4 id="面向报文的UDP"><a href="#面向报文的UDP" class="headerlink" title="面向报文的UDP"></a>面向报文的UDP</h4><ul>
<li><p>发送方UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
</li>
<li><p>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。</p>
</li>
<li><p>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p>
</li>
<li><p>应用程序必须选择合适大小的报文。</p>
</li>
</ul>
<p>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。</p>
<p>若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。</p>
<h3 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h3><p><img src="/.io//UDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.jpg"></p>
<ul>
<li>UDP的首部字段包括4个字段，如下：</li>
</ul>
<ol>
<li><p>源端口（Source Port）：2个字节，源端口号是发送端的端口号，用于接收端确定接收数据的应用程序。</p>
</li>
<li><p>目的端口（Destination Port）：2个字节，目的端口号是接收端的端口号，用于接收数据的应用程序。</p>
</li>
<li><p>长度（Length）：2个字节，指的是UDP数据报的长度，包括首部和数据，单位是字节。</p>
</li>
<li><p>校验和（Checksum）：2个字节，UDP数据报的校验和，包括UDP首部和数据，校验和可以用来检测数据是否在传输过程中被损坏。</p>
</li>
</ol>
<ul>
<li>UDP的<strong>伪首部</strong>是在计算UDP校验和时使用的。由于UDP数据报的校验和只检测UDP数据报本身的完整性，而不检测IP数据报头部的完整性，因此在计算UDP校验和时需要加入IP首部的某些字段，这些字段被称为UDP伪首部。UDP伪首部的格式如下：</li>
</ul>
<ol>
<li><p>源IP地址（Source IP Address）：4个字节，指的是发送端的IP地址。</p>
</li>
<li><p>目的IP地址（Destination IP Address）：4个字节，指的是接收端的IP地址。</p>
</li>
<li><p>零（Zero）：1个字节，保留字段，值为0。</p>
</li>
<li><p>协议（Protocol）：1个字节，指的是上层协议的类型，UDP协议的值为17。</p>
</li>
<li><p>UDP长度（UDP Length）：2个字节，指的是UDP数据报的长度，包括UDP首部和数据，单位是字节。</p>
</li>
</ol>
<ul>
<li>加入UDP伪首部后，计算校验和的方法如下：</li>
</ul>
<ol>
<li><p>将UDP伪首部的各字段和UDP数据报的首部和数据按16位字进行分组。</p>
</li>
<li><p>对于最后一个不足16位的分组，用0来填充。</p>
</li>
<li><p>将各分组按位求和，如果溢出则回卷到低位。</p>
</li>
<li><p>对结果按位取反，得到的就是UDP校验和。</p>
</li>
</ol>
<h2 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h2><h3 id="TCP最主要的特点"><a href="#TCP最主要的特点" class="headerlink" title="TCP最主要的特点"></a>TCP最主要的特点</h3><ol>
<li><strong>TCP是面向连接的运输层协议</strong>。</li>
</ol>
<p>为虚连接，逻辑连接。</p>
<ol start="2">
<li><p>每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的（一对一）。</p>
</li>
<li><p>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p>
</li>
<li><p>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。</p>
</li>
<li><p>面向字节流。</p>
</li>
</ol>
<p>TCP中的“流”(stream)指的是流入或流出进程的字节序列。“面向字节流”的含义是：虽然应用程序和TCP 的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p>
<p>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</p>
<p>TCP对连续的数据进行分段传输。</p>
<p><img src="/.io//TCP%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5.jpg"></p>
<h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><ul>
<li><p>把连接作为最基本的抽象。</p>
</li>
<li><p>每一条TCP连接有2个端点。TCP连接的端点叫做套接字(socket)或插口。端口号拼接到(contatenated with) IP 地址即构成了套接字。</p>
</li>
</ul>
<p><code>套接字socket=(IP地址:端口号)</code>，IP地址取点分十进制记法。</p>
<p>每一条TCP连接唯一地被通信两端的两个端点（两个套接字）所确定。</p>
<p><code>TCP连接 ::= &#123;socket1, socket2&#125; = &#123;(IP1:port1), (IP2:port2)&#125;</code></p>
<ul>
<li>TCP连接就是由协议软件所提供的一种抽象。同一个IP地址可以有多个不同的TCP连接。一同一个端口号也可以出现在多个不同的TCP连接中。</li>
</ul>
<h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p><img src="/.io//TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg"></p>
<ol>
<li><p>源端口号（Source Port）：占用2个字节，表示发送方使用的端口号；</p>
</li>
<li><p>目的端口号（Destination Port）：占用2个字节，表示接收方使用的端口号；</p>
</li>
<li><p>序号（Sequence Number）：占用4个字节，表示本报文段数据的第一个字节的序号；</p>
</li>
</ol>
<p>TCP协议是面向连接的可靠传输协议，因此每个TCP报文段都有一个序号，用于标识该报文段中第一个字节的位置。序号是一个32位的无符号整数，因此最大可表示$2^{32}-1$个字节，即4GB。序号的作用是使接收方能够按正确的顺序重新组装收到的数据，以及检测是否有丢失的数据。</p>
<ol start="4">
<li>确认号（Acknowledgement Number）：占用4个字节，表示期望收到对方下一个报文段的第一个字节的序号；</li>
</ol>
<p>TCP协议使用确认号机制来实现可靠传输。每个TCP报文段都包含一个确认号，用于告知发送方已经成功接收到了哪些数据。确认号是一个32位的无符号整数，表示期望收到对方下一个报文段的第一个字节的序号。例如，如果确认号为1000，则表示期望收到对方下一个报文段中的第1000个字节开始的数据。</p>
<ol start="5">
<li>数据偏移（Data Offset）：占用4个比特，表示TCP报文段首部的长度，以4字节为单位。最小值为5，最大值为15；</li>
</ol>
<p>表示TCP报文段首部的长度，以4字节为单位。由于TCP报文段首部中的选项字段长度是可变的，因此需要使用数据偏移字段来确定首部的长度。最小值为5，表示没有选项字段；最大值为15，表示选项字段占据了整个首部。</p>
<ol start="6">
<li><p>保留（Reserved）：占用6个比特，保留为0；</p>
</li>
<li><p>控制位（Flags）：占用6个比特，用于控制TCP的连接建立、维护和中断等功能。常用的标志位有URG、ACK、PSH、RST、SYN和FIN，具体含义如下：</p>
</li>
</ol>
<ul>
<li><p>URG：表示紧急指针是否有效；</p>
</li>
<li><p>ACK：表示确认号是否有效；</p>
</li>
<li><p>PSH：表示接收方应该尽快将数据交给应用层；</p>
</li>
<li><p>RST：表示连接复位；</p>
</li>
<li><p>SYN：表示连接建立请求；</p>
</li>
<li><p>FIN：表示连接中断请求。</p>
</li>
</ul>
<ol start="8">
<li>窗口大小（Window）：占用2个字节，表示发送方的缓冲区大小；</li>
</ol>
<p>用于告知对方自己的缓冲区大小。窗口大小是一个16位的无符号整数，表示接收方还能够接收多少字节的数据。发送方应该根据接收方的窗口大小来控制发送速度，以避免发送过多的数据导致接收方缓冲区溢出。</p>
<ol start="9">
<li>校验和（Checksum）：占用2个字节，用于检验TCP报文段的正确性；</li>
</ol>
<p>用于检验TCP报文段的正确性。校验和是一个16位的无符号整数，由发送方计算，并由接收方进行验证。计算校验和时，需要将TCP报文段的首部和数据部分一起进行校验。如果校验和不匹配，接收方会丢弃该报文段，并向发送方发送一个重传请求。</p>
<ol start="10">
<li>紧急指针（Urgent Pointer）：占用2个字节，表示紧急数据的最后一个字节的序号。该字段只有在URG标志为1时才有效；</li>
</ol>
<p>用于标识紧急数据的位置。紧急指针是一个16位的无符号整数，表示紧急数据的最后一个字节的序号。当发送方需要发送紧急数据时，可以设置URG标志，并在紧急指针字段中指定紧急数据的位置。接收方在接收到紧急数据时，应该立即将其交给应用层处理。</p>
<ol start="11">
<li><p>选项（Options）：长度可变，用于支持TCP的各种选项功能，如最大报文段长度、时间戳等。</p>
</li>
<li><p>填充（Fill up）：长度可变，用于满足首部格式。</p>
</li>
</ol>
<p>填充字段的长度为0到3个字节，具体长度取决于选项字段的长度。如果选项字段的长度已经使整个首部的长度为4的倍数，那么填充字段的长度就为0。否则，填充字段的长度等于使整个首部长度为4的倍数的最小字节数减去首部长度。填充字段的值全部为0。</p>
<h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><ul>
<li>理想的传输条件应该满足：传输信道不产生差错；不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li>
</ul>
<h4 id="停止等待协议（基于自动重传请求ARQ）"><a href="#停止等待协议（基于自动重传请求ARQ）" class="headerlink" title="停止等待协议（基于自动重传请求ARQ）"></a>停止等待协议（基于自动重传请求ARQ）</h4><ul>
<li>“停止等待”就是每发送完一个分组（即传送的数据单元）就停止发送，等待对方的确认。在收到确认后再发送下一个分组。全双工通信的双方既是发送方也是接收方。</li>
</ul>
<ol>
<li>无差错情况</li>
</ol>
<p><img src="/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.jpg"></p>
<ol start="2">
<li>出现差错</li>
</ol>
<p><img src="/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99.jpg"></p>
<p>发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。发送方只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器。</p>
<p>注意：发送方发送一个分组后，必须暂时保留已发送的分组副本。分组和确认分组进行编号，明确哪个分组被确认。超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些，避免不必要的重传。</p>
<ol start="3">
<li>确认丢失和确认迟到</li>
</ol>
<p><img src="/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpg"></p>
<ul>
<li>信道利用率$U$</li>
</ul>
<p>假设发送方发送分组需要的时间是$T_D$。显然，$T_D&#x3D;\frac {分组长度}{数据率}$。再假定分组正确到达接收方后，接收方处理分组时间可以忽略不计，同时立即发回确认。假定接收方发送确认分组需要时间$T_A$。如果发送方处理确认分组的时间也可以忽略不计，那么发送方在经过时间$(T_D+RTT+T_A)$后就可以再发送下一个分组，$RTT$是往返时间。所以粗略计算下：</p>
<p>$$<br>U&#x3D;\frac {T_D}{T_D+RTT+T_A}<br>$$</p>
<ul>
<li>实际上，停止等待协议的信道利用率极低。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p><img src="/.io//%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg"></p>
<ul>
<li><p>发送方可以连续发送分组，每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
</li>
<li><p>接收方采用累积确认，在接收到几个分组后，对按序到达的最后一个分组发送确认。</p>
</li>
<li><p>优点：容易实现，即使确认丢失也不必重传。</p>
</li>
<li><p>缺点：不能向发送方反应出接收方已经正确收到的所有分组的信息。</p>
</li>
</ul>
<h3 id="可靠传输的具体实现"><a href="#可靠传输的具体实现" class="headerlink" title="可靠传输的具体实现"></a>可靠传输的具体实现</h3><h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><ul>
<li>TCP的滑动窗口是以字节为单位的。</li>
</ul>
<p>假定A收到B发来的确认报文段，其中窗口是20字节，而确认号是31（表明B期望收到的下一个序号是31，而序号30为止的数据已经收到）。根据收到的确认报文段，A可以构造出自己的发送窗口，如下：<br><img src="/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31.jpg"></p>
<p>发送窗口的位置由前沿和后沿的位置共同决定，要么不动，要么前移。在发送窗口大小发生变化时，后沿前移，前沿不动。假定A发送了序号为31~41的数据，此时发送位置并未改变，但发送窗口内靠后面有11个字节表示已发送但未收到确认。而发送窗口靠前面的9个字节是允许发送但未发送的。<br><img src="/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.jpg"><br>由图可以确定发送窗口状态的三个指针：$P_1$、$P_2$、$P_3$，$P_3-P_1$为A的发送窗口，$P_2-P_1$为已发送但未收到确认的字节数，$P_3-P_2$为允许发生但当前未发送的字节数（有用窗口或有效窗口）。</p>
<p>再看一下B的接收窗口。B的接收窗口大小是20。在接收窗口外面，到30号为止的数据是已经发送过确认并且已经交付主机了。因此在B 可以不再保留这些数据。接收窗口内的序号（31~50）是允许接收的。如上图，假定B收到了序号为32和33的数据。但这些数据没有按序到达，因为序号为31的数据没有收到（也许丢失了，也许滞留在网络中的某处）。请注意，B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31（即期望收到的序号），而不能是32或33。</p>
<p>现在假定B收到了序号为31的数据，并把序号为31<del>33的数据交付主机，然后B删除这些数据。接着把接收窗口向前移动3个序号，同时给A发送确认，其中窗口值仍为20，但确认号是34。这表明B已经收到了到序号33 为止的数据。B还收到了序号为37、38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中。A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了，可发送的序号范围是42</del>53。<br><img src="/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A33.jpg"></p>
<p>当A的发送窗口已满，可用窗口减小为0，便停止发送。</p>
<p>存在一种可能性：发送窗口的所有数据正确到达B，B也发出了确认，可这些确认滞留在网络中。于是A在超时计时器控制下重传部分数据，直到收到B的确认。</p>
<ul>
<li>发送缓存与发送窗口</li>
</ul>
<p><strong>发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程从TCP的接收缓存中读取字节流。</strong></p>
<p><img src="/.io//TCP-%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AA%97%E5%8F%A3.jpg"></p>
<p>缓存空间和序号空间是有限的且循环使用的。实际上缓存或窗口中的字节数非常之大。</p>
<p>发送缓存用来暂时存放：（1）发送应用程序传送给发送方TCP准备发送的数据；（2）TCP已发送出但未收到确认的数据。发送窗口通常是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确认的字节，就是还保留在发送缓存中的被写入的字节数。发送应用程序必须控制写入缓存的速率，否则会因为太快而发送缓存没有存放数据的空间。</p>
<p>接收缓存用来暂时存放：（1）按序到达的、但未被接收应用程序读取的数据；（2）未按序到达的数据。如果收到的分组被检测出有差错，就要丢弃。如果接受应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时从接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。</p>
<p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大，因为有一定的时间滞后。对于不按序到达的数据如何处理是没有明确规定。TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。</p>
<h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><ul>
<li>一个报文段发出时间和收到确认时间之差称为报文段的往返时间$RTT$。TCP保留了RTT的一个加权平均往返时间$RTT_S$（又称为平滑的往返时间，S表示Smoothed）。每当第一次测量到$RTT$样本时，$RTT_S$值就取为所测量到的$RTT$样本值，但以后每测量到一个新的$RTT$样本，就计算一次$RTT_S$：</li>
</ul>
<p>$$<br>新的RTT_S&#x3D;(1-α)×(旧的RTT_S)+α×(新的RTT样本)<br>$$</p>
<p>$0\leq α&lt;1$，$α$在标准RFC 6298推荐为0.125。</p>
<ul>
<li>超时计时器设置的超时重传时间RTO（Retransmission Time-Out）应略大于$RTT_S$，RFC 6298建议计算：</li>
</ul>
<p>$$<br>RTO&#x3D;RTT_S+4×RTT_D<br>$$</p>
<p>$RTT_D$是$RTT$的偏差的加权平均值，RFC 6298建议计算：第一次测量时，$RTT_D$取$RTT$样本值的一半，之后$新的RTT_D&#x3D;(1-β)×(旧的RTT_D)+β×\vert RTT_S-新的RTT样本\vert$，此处$β$是个小于1的系数，推荐值为0.25。</p>
<ul>
<li>为了避免因重传报文段被误认为原报文段而反复确认导致$RTT_S$和$RTO$变大，甚至越来越大，提出一种算法：<strong>报文段每重传一次，就把超时重传时间RTO增大一些。典型做法是取新的重传时间为旧的重传时间的两倍</strong>。</li>
</ul>
<h4 id="选择确认SACK（Selective-ACK）"><a href="#选择确认SACK（Selective-ACK）" class="headerlink" title="选择确认SACK（Selective ACK）"></a>选择确认SACK（Selective ACK）</h4><p>TCP的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块。可以看出，序号1<del>1000收到了，但序号1001</del>1500没有收到。接下来的字节流又收到了，可是又缺少了3001～3500。再后面从序号4501起又没有收到。也就是说，接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。因此在图中用四个指针标记这些边界。请注意，第一个字节块的左边界$L_1$&#x3D;1501，但右边界$R_1$&#x3D;3001 而不是3000。这就是说，左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号。同理，第二个字节块的左边界$L_2$&#x3D;3501，而右边界$R_2$&#x3D;4501。</p>
<p>TCP的首部没有哪个字段能够提供上述这些字节块的边界信息。RFC 2018规定，如果要使用选择确认SACK，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界。由于首部选项的长度最多只有40字节，而指明一个边界就要用掉4字节（因为序号有32位，需要使用4个字节表示），因此在选项中最多只能指明4个字节块的边界信息。这是因为4个字节块共有8个边界，因而需要用32个字节来描述。另外还需要两个字节。一个字节用来指明是 SACK 选项，另一个字节是指明这个选项要占用多少字节。如果要报告五个字节块的边界信息，那么至少需要42个字节。这就超过了选项长度的40 字节的上限。</p>
<p><img src="/.io//SACK.jpg"><br><em>其实SACK文档并未指明发送方如何响应SACK，所以还是重传所有未被确认的数据块。</em></p>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><ul>
<li>流量控制（flow control）一般是指让发送方的发送速率不要太快，让接收方来得及接收。</li>
</ul>
<h4 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h4><h4 id="TCP的传输效率"><a href="#TCP的传输效率" class="headerlink" title="TCP的传输效率"></a>TCP的传输效率</h4><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><h4 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h4><ul>
<li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞(congestion)。</li>
</ul>
<p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<p>出现拥塞的原因：$\sum {对资源需求}&gt;可用资源$</p>
<ul>
<li><p>拥塞常常趋于恶化。</p>
</li>
<li><p>拥塞控制和流量控制的区别</p>
</li>
</ul>
<p>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程。</p>
<p>流量控制往往是指点对点通信量的控制，是个端到端的问题。</p>
<p>简单的例子，设某光纤网络链路传输速率为1000Gbit&#x2F;s，有一台巨型计算机向一台个人电脑以1Gbit&#x2F;s的速率传输文件。网络带宽足够，不存在拥塞问题。但需要流量控制，使得个人电脑来得及接收。而如果有另一个网络，链路传输速率为1Mbit&#x2F;s，而有1000台大型计算机连接在此网络，假定有500台计算机分别向其余500台计算机以100kbit&#x2F;s的速率发送文件，那么整个网络的输入负载超过网络所能承受的。</p>
<ul>
<li>分组的丢失作为一个拥塞的标志。</li>
</ul>
<p><img src="/.io//TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg"></p>
<ul>
<li>拥塞控制可分为开环控制和闭环控制。</li>
</ul>
<p>开环控制就是在设计网络时事先将有关发生拥塞的因素考虑到，力求网络在工作时不产生拥塞。一旦整个系统运行起来，不再中途改正。</p>
<p>闭环控制是基于反馈环路的概念：（1）检测网络系统以便检测到拥塞在何时、何处发生；（2）把拥塞发生的信息传送到可采取行动的地方；（3）调整网络系统的运行以解决出现的问题。</p>
<ul>
<li>检测网络的拥塞的指标。</li>
</ul>
<p>由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差等等。</p>
<h4 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h4><ul>
<li><p>拥塞的判断：重传定时器超时、收到三个相同的ACK。</p>
</li>
<li><p>TCP拥塞控制算法：慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）、快恢复（fast recovery）。</p>
</li>
</ul>
<h5 id="慢开始（Slow-start）"><a href="#慢开始（Slow-start）" class="headerlink" title="慢开始（Slow start）"></a>慢开始（Slow start）</h5><ul>
<li>基于窗口的拥塞控制，发送方维持拥塞窗口cwnd（congestion window），拥塞窗口的大小取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。</li>
</ul>
<p>慢开始的“慢”是因为一开始cwnd&#x3D;1，只发送一个报文段试探。比设置cwnd为大值，将大量报文段注入网络中要慢得多。慢开始的cwnd的增长速率并不慢。</p>
<ul>
<li>算法的思路：让TCP发送方从发送一个 MSS (Maximum Segment Size，最大分段大小) 开始，每收到一个 ACK 就将窗口大小加倍，直到达到一个阈值（ssthresh），这个阈值通常被设置为网络容量的一半。一旦窗口大小达到了 ssthresh，就进入拥塞避免状态，此时窗口大小每次只能增加 1&#x2F;MSS。</li>
</ul>
<p>慢开始门限（阈值）ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。</p>
<ul>
<li><p>在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值。$拥塞窗口cwnd每次的增加量&#x3D;min(N,SMSS)$，其中 N是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。当$N&lt;SMSS$时，拥塞窗口每次的增加量要小于SMSS。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。</p>
</li>
<li><p>初始拥塞窗口cwnd</p>
</li>
</ul>
<p>旧的规定下，在刚刚开始发送报文段时，先把初始拥塞窗口cwnd设置为1至2个发送方的最大报文段SMSS（Sender Maximum Segment Size）的数值；</p>
<p>新的RFC5681 把初始拥塞窗口cwnd设置为不超过2至4个SMSS的数值。</p>
<p>当$cwnd &lt; ssthresh$，使用慢开始算法。</p>
<p>当$cwnd &gt; ssthresh$，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当$cwnd &#x3D; ssthresh$，慢开始算法和拥塞避免算法皆可。</p>
<h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><ul>
<li>算法的思路：让拥塞窗口cwnd 缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。</li>
</ul>
<p>因此在拥塞避免阶段就有“加法增大”(Additive Increase)的特点。这表明在拥塞避免阶段，拥塞窗口cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<ul>
<li>当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：$ssthresh&#x3D; max(cwnd&#x2F;2, 2)$，$cwnd&#x3D;1$，执行慢开始算法</li>
</ul>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<h5 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h5><h5 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h5><h4 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h4><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><ul>
<li><p>运输链接有三个阶段：连接建立、数据传送、连接释放。</p>
</li>
<li><p>TCP的连接建立：采用三报文握手。</p>
</li>
<li><p>TCP的连接释放：采用四报文握手。</p>
</li>
<li><p>TCP的有限状态机。</p>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/">
    <time datetime="2023-05-28T16:00:00.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

    
    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">5</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/articles/1/">记第一次成功创建博客</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2023 Fingsinz
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>