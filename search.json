[{"title":"关于 C++ 中结构体内存对齐的讨论","path":"/2024/24/","content":"关键词：C++ 在 C++ 的实际代码编写中，结构体（类）的内存大小会进行对齐。 内存对齐的测试代码 定义若干个结构体，测试代码： #include iostreamusing namespace std;// 示例结构体struct DataX {\tint a;\tint b;\tint c;\tint d;};#define INFOSTRUCT(STRUCT) \\\tcout #STRUCT \"\\t\" sizeof(STRUCT) \"\\t\" offsetof(STRUCT, a) \"\\t\" offsetof(STRUCT, b) \"\\t\" offsetof(STRUCT, c) \"\\t\" offsetof(STRUCT, d) endlint main() {\tINFOSTRUCT(DataX);\treturn 0;} offsetof 是一个宏，可以计算成员的偏移量。 理解例子 Data0 Data1 Data2 先来看这三个结构体： struct Data0 {\tchar a;\tchar b;\tshort c;\tint d;};struct Data1 {\tshort a;\tchar b;\tint c;\tchar d;};struct Data2 {\tchar a;\tshort b;\tchar c;\tint d;}; 代码在 VS 中输出是： Data0 8 0 1 2 4Data1 12 0 2 4 8Data2 12 0 2 4 8 在 Ubuntu-18.04 Clang++ 编译后是： fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o testfingsinz@FingsinzStudio:~/playground$ ./testData0 8 0 1 2 4Data1 12 0 2 4 8Data2 12 0 2 4 8 这三个结构体的成员变量都有两个 char、一个 short 和一个 int，因为声明位置不同，导致了内存大小分别为8、12、12。 根据已知的内存大小和成员偏移量，尝试表示出其内存布局： Data0 Data1 Data2 结构体 Data0 的内存大小最小，排布最紧凑，空间利用最合理。 内存对齐为 4 字节，内存大小为 8 字节。 结构体 Data1 和 Data2 的内存布局中因为对齐机制，所以存在空的补位。 内存对齐为 4 字节，内存大小为 12 字节。 Data3 Data4 struct Data3 {\tint a;\tdouble b;\tchar c;\tshort d;};struct Data4 {\tint a;\tdouble b;\tchar c;\tshort d;\tint e;}; 代码在 VS 中输出是： Data3 24 0 8 16 18Data4 24 0 8 16 18 在 Ubuntu-18.04 Clang++ 编译后是： fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o testfingsinz@FingsinzStudio:~/playground$ ./testData3 24 0 8 16 18Data4 24 0 8 16 18 这两个结构体， Data4 是在 Data3 的基础上增加了一些新的成员变量形成的，但是内存大小都为 24。 根据已知的内存大小和成员偏移量，尝试表示出其内存布局： Data3 Data4 在内存对齐下，Data3 的最后几个字节浪费了，而 Data4 增加的新成员正好利用上了，而且还不会额外增加内存大小。 内存对齐为 8 字节，内存大小为 24 字节。 Data5 Data6 #pragma pack(2)struct Data5 {\tshort a;\tchar b;\tint c;\tchar d;};#pragma pack()struct alignas(8) Data6 {\tshort a;\tchar b;\tint c;\tchar d;}; 代码在 VS 中输出是： Data5 10 0 2 4 8Data6 16 0 2 4 8 在 Ubuntu-18.04 Clang++ 编译后是： fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o testfingsinz@FingsinzStudio:~/playground$ ./testData5 10 0 2 4 8Data6 16 0 2 4 8 结构体 Data5 使用了 #pragma pack() 的方式规定了内存对齐的大小；而结构体 Data6 使用 C++11 的关键字 alignas() 规定内存对齐的大小。 根据已知的内存大小和成员偏移量，尝试表示出其内存布局： Data5 Data6 Data5 规定了内存对齐为 2，所以在 10 个字节的时候就停下。如果把两个 char 连在一起声明，会更省空间，达到大小为 8。 内存对齐为 2 字节，内存大小为 10 字节。 Data6 规定了内存对齐为 8，所以比内存对齐为 4 的布局多出更多空间。 内存对齐为 8 字节，内存大小为 16 字节。 Data7 Data8 Data9 Data10 对于复杂结构体： struct Data7 {\tchar a;\tstruct _Data { char _a[5];\t} b;\tint c;\tshort d;};struct Data8 {\tchar a;\tstruct _Data { int _a; char _b;\t} b;\tint c;\tshort d;};struct Data9 {\tchar a;\tstruct _Data { char _a; int _b;\t} b;\tint c;\tshort d;};struct Data10 {\tchar a;\tstruct alignas(8) _Data { char _a; int _b;\t} b;\tint c;\tshort d;}; 代码在 VS 中输出是： Data7 16 0 1 8 12Data8 20 0 4 12 16Data9 20 0 4 12 16Data10 24 0 8 16 20 在 Ubuntu-18.04 Clang++ 编译后是： fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o testfingsinz@FingsinzStudio:~/playground$ ./testData7 16 0 1 8 12Data8 20 0 4 12 16Data9 20 0 4 12 16Data10 24 0 8 16 20 尝试画出内存布局图： Data7 Data8 Data9 Data10 Data7： 内嵌结构体内存对齐为 1 字节，内存大小为 5 字节。 外部结构体内存对齐为 4 字节，内存大小为 16 字节。 Data8： 内嵌结构体内存对齐为 4 字节，内存大小为 8 字节。 外部结构体内存对齐为 4 字节，内存大小为 20 字节。 Data9： 内嵌结构体内存对齐为 4 字节，内存大小为 8 字节。 外部结构体内存对齐为 4 字节， 内存大小为 20 字节。 Data10： 内嵌结构体内存对齐为 8 字节，内存大小为 8 字节。 外部结构体内存对齐为 8 字节， 内存大小为 24 字节。 Data11 Data12 Data13 struct Data11 {\tchar a;\tstruct _Data { double _a;\t} b;\tint c;\tshort d;};struct Data12 {\tchar a;\tstruct _Data { char _a[8];\t} b;\tint c;\tshort d;};struct Data13 {\tchar a;\tstruct _Data { int _a[2];\t} b;\tint c;\tshort d;}; 代码在 VS 中输出是： Data11 24 0 8 16 20Data12 20 0 1 12 16Data13 20 0 4 12 16 在 Ubuntu-18.04 Clang++ 编译后是： fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o testfingsinz@FingsinzStudio:~/playground$ ./testData11 24 0 8 16 20Data12 20 0 1 12 16Data13 20 0 4 12 16 尝试画出内存布局图： Data11 Data12 Data13 Data11： 内嵌结构体内存对齐为 8 字节，内存大小为 8 字节。 外部结构体内存对齐为 8 字节，内存大小为 24 字节。 Data12： 内嵌结构体成员为 char 数组，比较特殊，内存对齐为 1 字节，内存大小为 8 字节。 外部结构体内存对齐为 4 字节，内存大小为 20 字节。 Data13： 内嵌结构体内存对齐为 4 字节，内存大小为 8 字节。 外部结构体内存对齐为 4 字节， 内存大小为 20 字节。 总结 一般情况下，默认最小对齐单位为 2 字节， 对齐最宽的基本类型 （ 如内存最大成员为 int，则内存对齐为 4 ）。 结构体的总大小为结构体最宽基本类型成员大小的整数倍。 嵌套成员的情况下（ 如结构体成员包含结构体，结构体成员包含类等情况 ）， 内部结构体对齐后视作整体再参与外部对齐，内存对齐等于成员的最大内存对齐。 char 类型比较特殊，趋向紧密。","tags":["CPP"],"categories":["日常"]},{"title":"关于C++继承中的virtual以及虚指针、虚表","path":"/2024/23/","content":"关键词：C++ 在使用 C++ 类的继承时，经常会使用到 virtual 关键字，无论是声明 虚函数 还是 虚继承。 基础概念 virtual 说明符指定非静态成员函数为虚函数并支持动态调用派发。 虚函数 虚函数是可在派生类中覆盖其行为的成员函数，解决函数重名（重写）的调用问题。 与非虚函数相反，即使没有关于该类实际类型的编译时信息，仍然保留被覆盖的行为。 当使用到基类的指针或引用来处理派生类时，对被覆盖的虚函数的调用，将会调用定义于派生类中（重写）的函数版本。 当使用有限定名字查找（即函数名出现在作用域解析运算符 :: 的右侧）时，使用的是限定查找的函数版本。 如： #include iostreamclass Base {public:\tvirtual void f() { std::cout \"base \";\t}};class Derived : public Base {public:\tvoid f() override { std::cout \"derived \";\t}};int main() {\tBase b;\tDerived d;\t// 通过引用调用虚函数\tBase br = b;\tBase dr = d;\tbr.f(); // base\tdr.f(); // derived\t// 通过指针调用虚函数\tBase *bp = b;\tBase *dp = d;\tbp-f(); // base\tdp-f(); // derived\t// 非虚函数调用\tbr.Base::f(); // base\tdr.Base::f(); // base\treturn 0;} 注意要把父类的析构函数声明为虚函数，这样子类析构时会正确调用子类的析构函数，避免了内存泄漏的风险。 虚函数指针和虚函数表 虚函数指针（vfptr）指向一个虚函数表（vftable），虚函数表记录了虚函数的地址。 虚表是属于类的，一个类只需要一个虚表即可，同一个类的所有对象都使用同一个虚表。 虚继承 虚继承解决的是 C++ 多重继承带来的问题。 从不同途径继承来的同一基类，会在子类中存在多份拷贝，既浪费存储空间，也存在二义性。 虚继承底层实现与编译器相关，一般通过虚基指针和虚基表实现。 每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间）。 虚基指针和虚基表 虚基指针（vbptr）指向一个虚基表（vbtable），虚基表记录了虚基类与本类的偏移地址，通过偏移地址找到虚基类成员，而不用持有拷贝浪费空间。 与虚函数指针和虚函数表相比： 虚基类依旧存在继承类中，占用存储空间；虚函数不占用存储空间。 虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。 从内存布局看 无继承 单纯一个类时： class A {public:\tvoid f() { std::cout \"A \";\t}private:\tint m_a;}; VS 所输出内存布局为： class A\tsize(4):\t+--- 0\t| m_a\t+--- 内存大小为一个 int 变量的大小。 单继承 1.非虚继承无虚函数 情况如下： class A {public:\tvirtual void f() { std::cout \"A \";\t}};class B : public A {public:\tvoid f() override { std::cout \"B \";\t}}; 基类 A 的内存布局： class A\tsize(4):\t+--- 0\t| m_a\t+--- 在数据区域，不存在 {vfptr} 虚函数指针，只存在 m_a 变量（4 字节）。所以占内存 4 字节。 派生类 B 的内存布局： class B\tsize(8):\t+--- 0\t| +--- (base class A) 0\t| | m_a 基类数据成员\t| +--- 4\t| m_b 子类数据成员\t+--- 在数据区域，不存在 {vfptr} 虚函数指针，只存在 m_b 变量（4 字节）和继承得到的 m_a 变量，所以占内存 8 字节。 结果： 由于不存在虚函数表，故并不会调用定义于派生类中（重写）的函数版本。 2.非虚继承有虚函数 情况如下： class A {public:\tvirtual void f() { std::cout \"A \";\t}private:\tint m_a;};class B : public A {public:\tvoid f() override { std::cout \"B \";\t}private:\tint m_b;}; 基类 A 的内存布局： class A\tsize(16):\t+--- 0\t| {vfptr} 8\t| m_a | alignment member (size=4)\t+---A::$vftable@:\t| A_meta\t| 0 0\t| A::f 在数据区域，存在 {vfptr} 虚函数指针（8 字节，64位系统）、 m_a 变量（4 字节）。同时进行内存对齐（+4 字节），所以占内存 16 字节。 在虚函数表中，存在虚函数 f。 子类 B 的内存布局： class B\tsize(24):\t+--- 0\t| +--- (base class A) 0\t| | {vfptr} 虚函数指针 8\t| | m_a 基类数据成员 | | alignment member (size=4)\t| +---16\t| m_b 子类数据成员 | alignment member (size=4)\t+---B::$vftable@: 虚函数表\t| B_meta\t| 0 0\t| B::f 在数据区域，存在 {vfptr} 虚函数指针（8 字节，64位系统）、 m_a 变量（4 字节），同样进行内存对齐（+4 字节），再加上子类自身的成员变量 m_b （4 字节），再加以内存对齐（+4 字节），所以占内存 24 字节。 在虚函数表中，存在虚函数 f，指明了函数版本。 结果： 虚函数表指明了函数版本，调用定义于派生类中（重写）的函数版本。 3.虚继承无虚函数 情况如下： class A {public:\tvoid f() { std::cout \"A \";\t}private:\tint m_a;};class B : virtual public A {public:\tvoid f() { std::cout \"B \";\t}private:\tint m_b;}; 父类 A 的内存布局如下： class A\tsize(4):\t+--- 0\t| m_a\t+--- 只有数据区域的变量。 子类 B 的内存布局如下： class B\tsize(24):\t+--- 0\t| {vbptr} 虚基指针 8\t| m_b 子类数据成员 | alignment member (size=4) | alignment member (size=4)\t+---\t+--- (virtual base A)16\t| m_a 基类数据成员\t+---B::$vbtable@: 0\t| 0 1\t| 16 (Bd(B+0)A) 表示类 B 的虚基类 A 位于偏移 16 + 0 = 16 处vbi: class offset o.vbptr o.vbte fVtorDisp A 16 0 4 0 在数据区域，存在虚基指针 {vbptr}，且虚基类位于子类存储空间的末尾。 存在虚基表 {vbtable}。 结果： 由于不存在虚函数表，不会调用定义于派生类中（重写）的函数版本。 4.虚继承有虚函数 情况如下： class A {public:\tvirtual void f() { std::cout \"A \";\t}private:\tint m_a;};class B : virtual public A {public:\tvoid f() override { std::cout \"B \";\t}private:\tint m_b;}; 父类 A 的内存布局如下： class A\tsize(16):\t+--- 0\t| {vfptr} 8\t| m_a | alignment member (size=4)\t+---A::$vftable@:\t| A_meta\t| 0 0\t| A::f 在数据区域，存在 {vfptr} 虚函数指针（8 字节，64位系统）、 m_a 变量（4 字节）。同时进行内存对齐（+4 字节），所以占内存 16 字节。 在虚函数表中，存在虚函数 f。 子类 B 的内存布局如下： class B\tsize(32):\t+--- 0\t| {vbptr} 虚基指针 8\t| m_b 子类数据成员 | alignment member (size=4)\t+---\t+--- (virtual base A)16\t| {vfptr} 虚基类虚函数指针24\t| m_a 虚基类数据成员 | alignment member (size=4)\t+---B::$vbtable@: 0\t| 0 1\t| 16 (Bd(B+0)A) 表示类 B 的虚基类 A 位于偏移 16 + 0 = 16 处B::$vftable@:\t| -16 0\t| B::fB::f this adjustor: 16vbi: class offset o.vbptr o.vbte fVtorDisp A 16 0 4 0 在数据区域，存在 {vbptr} 虚基指针 和 {vfptr} 虚函数指针。 在虚函数表中，存在虚函数 f，指明了函数版本。 如果派生类没有独立的虚函数，此时派生类对象不会产生虚函数指针。 若派生类中有独立的虚函数，会产生虚函数指针： 如下情形： class B : virtual public A {public:\tvoid f() override { std::cout \"B \";\t}\tvirtual void f1() {\t// 派生类中独立的虚函数 std::cout \"tmp \";\t}private:\tint m_b;}; 导致内存布局为： class B\tsize(40):\t+--- 0\t| {vfptr} 虚函数指针 8\t| {vbptr} 虚基指针16\t| m_b 子类数据成员 | alignment member (size=4)\t+---\t+--- (virtual base A)24\t| {vfptr} 虚基类虚函数指针32\t| m_a 虚基类数据成员 | alignment member (size=4)\t+---B::$vftable@B@: 类 B 的虚函数表\t| B_meta\t| 0 0\t| B::f1B::$vbtable@: 0\t| -8 1\t| 16 (Bd(B+8)A) 表示类 B 的虚基类 A 位于偏移 16 + 8 = 24 处B::$vftable@A@: 类 A 的虚函数表\t| -24 0\t| B::fB::f this adjustor: 24B::f1 this adjustor: 0vbi: class offset o.vbptr o.vbte fVtorDisp A 24 8 4 0 如果派生类拥有自己的虚函数，此时派生类对象就会产生自己本身的虚函数指针 {vfptr}，并且该虚函数指针位于派生类对象存储空间的最开始位置。 虚函数指针 {vfptr} 放在了虚基指针 {vbptr} 的前面，为了加快虚函数的查找速度。 结果： 虚函数表指明了函数版本，调用定义于派生类中（重写）的函数版本。 多继承 1.简单多继承 情况如下： class A {public:\tvirtual void f1() { std::cout \"A \";\t}\tvirtual void f2() { std::cout \"A \";\t}private:\tint m_a;};class B {public:\tvirtual void f1() { std::cout \"B \";\t}\tvirtual void f2() { std::cout \"B \";\t}private:\tint m_b;};class C : virtual public A, virtual public B {public:\tvirtual void myVirtual() {}\tvirtual void f1() override { std::cout \"C \";\t}\tvirtual void f2() override { std::cout \"C \";\t}private:\tint m_c;}; 此时基类 A 和 B 的内存布局为： class A\tsize(16):\t+--- 0\t| {vfptr} 8\t| m_a | alignment member (size=4)\t+---A::$vftable@:\t| A_meta\t| 0 0\t| A::f1 1\t| A::f2class B\tsize(16):\t+--- 0\t| {vfptr} 8\t| m_b | alignment member (size=4)\t+---B::$vftable@:\t| B_meta\t| 0 0\t| B::f1 1\t| B::f2 子类 C 的内存布局为： class C\tsize(56):\t+--- 0\t| {vfptr} 虚函数指针 8\t| {vbptr} 虚基指针16\t| m_c | alignment member (size=4)\t+---\t+--- (virtual base A)24\t| {vfptr} 虚基类虚函数指针32\t| m_a 虚基类数据成员 | alignment member (size=4)\t+---\t+--- (virtual base B)40\t| {vfptr} 虚基类虚函数指针48\t| m_b 虚基类数据成员 | alignment member (size=4)\t+---C::$vftable@C@: 类 C 的虚函数表\t| C_meta\t| 0 0\t| C::myVirtualC::$vbtable@: 0\t| -8 1\t| 16 (Cd(C+8)A) 表示类 C 的虚基类 A 位于偏移 16 + 8 = 24 处 2\t| 32 (Cd(C+8)B) 表示类 C 的虚基类 A 位于偏移 32 + 8 = 40 处C::$vftable@A@: 类 A 的虚函数表\t| -24 0\t| C::f1 1\t| C::f2C::$vftable@B@:\t| -40 0\t| thunk: this-=16; goto C::f1 1\t| thunk: this-=16; goto C::f2C::myVirtual this adjustor: 0C::f1 this adjustor: 24C::f2 this adjustor: 24vbi: class offset o.vbptr o.vbte fVtorDisp A 24 8 4 0 B 40 8 8 0 数据区域照常继承。 虚函数表区域中存在三个虚函数表， vftable@C@、 vftable@A@、 vftable@B@；存在一个虚基表 $vbtable@。 派生类会覆盖基类的虚函数，只有第一个虚函数表（此处为 vftable@A@ ）中存放的是真实的被覆盖的函数的地址；其它的虚函数表中（如 vftable@B@ ）存放的并不是真实的对应的虚函数的地址，而只是一条跳转指令。 2.棱形继承（钻石继承） 情况如下： class A {public:\tvirtual void f() { std::cout \"A \";\t}private:\tint m_a;};class B : virtual public A {public:\tvirtual void f() override { std::cout \"B \";\t}private:\tint m_b;};class C : virtual public A {public:\tvirtual void f() override { std::cout \"C \";\t}private:\tint m_c;};class D : public B, public C {public:\tvirtual void myVirtual() {}\tvirtual void f() override { std::cout \"D \";\t}private:\tint m_d;}; 此时 A 类的内存布局如下： class A\tsize(16):\t+--- 0\t| {vfptr} 8\t| m_a | alignment member (size=4)\t+---A::$vftable@:\t| A_meta\t| 0 0\t| A::f B 类和 C 类内存布局如下： class B\tsize(32):\t+--- 0\t| {vbptr} 8\t| m_b | alignment member (size=4)\t+---\t+--- (virtual base A)16\t| {vfptr}24\t| m_a | alignment member (size=4)\t+---B::$vbtable@: 0\t| 0 1\t| 16 (Bd(B+0)A)B::$vftable@:\t| -16 0\t| B::fB::f this adjustor: 16vbi: class offset o.vbptr o.vbte fVtorDisp A 16 0 4 0class C\tsize(32):\t+--- 0\t| {vbptr} 8\t| m_c | alignment member (size=4)\t+---\t+--- (virtual base A)16\t| {vfptr}24\t| m_a | alignment member (size=4)\t+---C::$vbtable@: 0\t| 0 1\t| 16 (Cd(C+0)A)C::$vftable@:\t| -16 0\t| C::fC::f this adjustor: 16vbi: class offset o.vbptr o.vbte fVtorDisp A 16 0 4 0 子类 D 的内存布局如下： class D\tsize(64):\t+--- 0\t| {vfptr} 虚函数指针 8\t| +--- (base class B) 8\t| | {vbptr} 基类虚基指针16\t| | m_b 基类数据成员 | | alignment member (size=4)\t| +---24\t| +--- (base class C)24\t| | {vbptr} 基类虚基指针32\t| | m_c 基类数据成员 | | alignment member (size=4)\t| +---40\t| m_d 子类数据成员 | alignment member (size=4)\t+---\t+--- (virtual base A)48\t| {vfptr} 虚基类虚函数指针56\t| m_a 虚基类数据成员 | alignment member (size=4)\t+---D::$vftable@D@: 类 D 的虚函数表\t| D_meta\t| 0 0\t| D::myVirtualD::$vbtable@B@: 0\t| 0 1\t| 40 (Dd(B+0)A) 表示类 B 的虚基类 A 位于偏移 40 + 0 = 24 处D::$vbtable@C@: 0\t| 0 1\t| 24 (Dd(C+0)A) 表示类 C 的虚基类 A 位于偏移 24 + 0 = 24 处D::$vftable@B@: 类 B 的虚函数表（因为类 B 和类 C 都有一样的函数，虚继承时只保留类 B 的虚函数表）\t| -48 0\t| D::fD::myVirtual this adjustor: 0D::f this adjustor: 48vbi: class offset o.vbptr o.vbte fVtorDisp A 48 8 4 0 再来一个棱形继承： class A {public:\tvirtual void f() { std::cout \"A \";\t}private:\tint val;};class B : virtual public A {public:\tvirtual void f() override { std::cout \"B \";\t}\tvirtual void g() {}private:\tint m_b;};class C : virtual public A {public:\tvirtual void f() override { std::cout \"C \";\t}\tvirtual void h() {}private:\tint m_c;};class D : public B, public C {public:\tvirtual void myVirtual() {}\tvirtual void f() override {}\tvoid g() override {}\tvoid h() override {}private:\tint m_d;}; 针对类 D 的内存布局如下： class D\tsize(72):\t+--- 0\t| +--- (base class B) 0\t| | {vfptr} 基类虚函数指针 8\t| | {vbptr} 基类虚基指针16\t| | m_b 基类数据成员 | | alignment member (size=4)\t| +---24\t| +--- (base class C)24\t| | {vfptr} 基类虚函数指针32\t| | {vbptr} 基类虚基指针40\t| | m_c 基类数据成员 | | alignment member (size=4)\t| +---48\t| m_d 子类数据成员 | alignment member (size=4)\t+---\t+--- (virtual base A)56\t| {vfptr} 虚基类虚函数指针64\t| val 虚基类数据成员 | alignment member (size=4)\t+---D::$vftable@B@: 类 B 的虚函数表\t| D_meta\t| 0 0\t| D::g 1\t| D::myVirtualD::$vftable@C@: 类 C 的虚函数表\t| -24 0\t| D::hD::$vbtable@B@: 0\t| -8 1\t| 48 (Dd(B+8)A) 表示类 B 的虚基类 A 位于偏移 48 + 8 = 56 处D::$vbtable@C@: 0\t| -8 1\t| 24 (Dd(C+8)A) 表示类 C 的虚基类 A 位于偏移 24 + 8 = 32 处D::$vftable@A@: 类 A 的虚函数表\t| -56 0\t| D::fD::myVirtual this adjustor: 0D::f this adjustor: 56D::g this adjustor: 0D::h this adjustor: 24vbi: class offset o.vbptr o.vbte fVtorDisp A 56 8 4 0 如果不使用虚继承，出现的问题是： class D\tsize(56):\t+--- 0\t| +--- (base class B) 0\t| | +--- (base class A) 0\t| | | {vfptr} 8\t| | | val | | | alignment member (size=4)\t| | +---16\t| | m_b | | alignment member (size=4)\t| +---24\t| +--- (base class C)24\t| | +--- (base class A)24\t| | | {vfptr}32\t| | | val 存在两次 val | | | alignment member (size=4)\t| | +---40\t| | m_c | | alignment member (size=4)\t| +---48\t| m_d | alignment member (size=4)\t+---","tags":["CPP"],"categories":["日常"]},{"title":"读《快乐的Linux命令行》记录","path":"/2024/linux-command-line/","content":"关键词： Linux Reference：TLCL (billie66.github.io) 引言 图形用户界面（Graphical User Interface，GUI）让简单的任务更容易完成，而命令行界面（Command Line Interface，CLI）使完成复杂的任务成为可能。 《快乐的Linux命令行》一书面向现代 Linux 命令行用户，传授如何与命令行界面友好相处，如何工作？能做什么？使用命令行最好的方法是什么？ 前提条件： 安装 Linux 系统 可使用 WSL，WSL安装记录 学习 shell 一、什么是shell 1.1 初次接触 shell 是一个程序，能够接受命令并且传递给操作系统执行。Linux 发行版都提供一个名为 bash 的shell 程序。bash 全称为 Bourne Again Shell。 同时，终端（Terminal）也能访问 shell。启动终端时，提示如下： fingsinz@FingsinzStudio:~$ 其解释如下：当前用户名@主机名:工作目录$。 其中 $ 表示这个终端具有 root（超级管理员）权限； 如果是 # 则表示当前权限是普通用户权限。 可以尝试输入一些命令： fingsinz@FingsinzStudio:~$ abcd 上面的命令并不是一条有效命令，只是举例。 还有，可以通过 ↑ 按键获取上次输入的命令，也可以通过 ← 或 → 按键移动光标从而编辑命令。 不要尝试在终端里使用 ctrl + c 和 ctrl + v 进行拷贝粘贴操作，这两个控制代码有着不同的含义。 1.2 简单命令 现在尝试运行一些简单的命令： date，显示系统当前时间和日期。 fingsinz@FingsinzStudio:~$ dateTue Jul 9 13:53:43 CST 2024 cal，显示当前月份日历。 fingsinz@FingsinzStudio:~$ cal July 2024Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31 df，查看磁盘剩余空间数量。 fingsinz@FingsinzStudio:~$ dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/sdb 263174212 1673872 248062184 1% /tmpfs 6499788 0 6499788 0% /mnt/wsltools 124064548 105175296 18889252 85% /initnone 6497704 0 6497704 0% /devnone 6499788 16 6499772 1% /runnone 6499788 0 6499788 0% /run/locknone 6499788 0 6499788 0% /run/shmnone 6499788 0 6499788 0% /run/usertmpfs 6499788 0 6499788 0% /sys/fs/cgroupdrivers 124064548 105175296 18889252 85% /usr/lib/wsl/driverslib 124064548 105175296 18889252 85% /usr/lib/wsl/libC:\\ 124064548 105175296 18889252 85% /mnt/cD:\\ 124708860 102747776 21961084 83% /mnt/dE:\\ 488372220 367103492 121268728 76% /mnt/eF:\\ 488372220 416662024 71710196 86% /mnt/f free，显示空闲内存的数量。 fingsinz@FingsinzStudio:~$ free total used free shared buff/cache availableMem: 12999576 86816 11784240 80 1128520 12640980Swap: 4194304 0 4194304 exit，关闭终端。 1.3 幕后控制台 在完全的 Linux 系统下，即使终端仿真器没有运行，在后台仍然有几个终端运行着。它们叫做虚拟终端或者是虚拟控制台。这些终端会话都可以通过按下 Ctrl + Alt + F1 到 Ctrl + Alt + F6 访问。当一个会话被访问的时候，它会显示登录提示框，需要输入用户名和密码。要从一个虚拟控制台转换到另一个，按下 Alt 和 F1-F6 （中的一个）。返回图形桌面，按下 Alt + F7。 二、文件系统中跳转 2.1 理解文件系统树 Linux 以分层目录结构来组织所有文件，将所有文件组成了一棵树型目录。文件系统中的第一级目录称为根目录（/）。根目录包含文件和子目录， 子目录包含更多的文件和子目录。 当首次登录系统（或者启动终端仿真器会话）后，当前工作目录是家目录（~）。每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入文件的地方。 2.2 文件目录的相关命令 命令 ls 可以列出（一个或多个）目录（默认是工作目录）的内容： fingsinz@FingsinzStudio:~$ ls /bin dev home lib lib64 media opt root sbin srv tmp varboot etc init lib32 lost+found mnt proc run snap sys usr 命令 pwd （print working directory）可以显示当前工作目录： fingsinz@FingsinzStudio:~$ pwd/home/fingsinz 命令 cd 可以进入某个目录，把某个目录作为工作目录： fingsinz@FingsinzStudio:~$ cd /fingsinz@FingsinzStudio:/$ lsbin dev home lib lib64 media opt root sbin srv tmp varboot etc init lib32 lost+found mnt proc run snap sys usr cd 的目录可用绝对路径或相对路径。 绝对路径是以根目录 / 开始。 相对路径中，. 表示当前工作目录，.. 表示当前工作目录的上一级目录（父目录）。 cd 有一些快捷的输入： cd 可以更改工作目录到家目录 cd - 可以更改工作目录到先前的工作目录。 cd ~user_name 可以更改工作目录到用户家目录。 2.3 文件名的相关规则 关于文件名的重要规则 以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们，需要用 ls -a 命令。当创建帐号后，几个配置帐号的隐藏文件被放置在家目录下。另外，一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。 文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的 文件名。 Linux 没有“文件扩展名”的概念。可以用你喜欢的任何名字来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统，不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。 虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限“.”、“－”、下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与词间的空格，用下划线字符来代替。 三、探究操作系统 3.1 查询命令帮助 命令通常会有一些选项，选项通过一些参数设定，如： command -options arguments 当不清楚命令的用法时，可以使用 man 进行查询，了解其功能以及参数，如： man ls 3.2 ls 的乐趣 对于 ls 比较常用的估计是 ls -l： fingsinz@FingsinzStudio:/$ ls -ltotal 420drwxr-xr-x 2 root root 4096 Jul 9 12:04 bindrwxr-xr-x 2 root root 4096 May 21 2019 bootdrwxr-xr-x 8 root root 2740 Jul 9 12:12 devdrwxr-xr-x 91 root root 4096 Jul 9 12:44 etcdrwxr-xr-x 3 root root 4096 Jul 9 12:05 home-rwxr-xr-x 2 root root 644432 Aug 1 2023 initdrwxr-xr-x 20 root root 4096 Jul 9 12:42 libdrwxr-xr-x 2 root root 4096 Jul 9 12:42 lib32drwxr-xr-x 2 root root 4096 Jul 9 12:23 lib64drwx------ 2 root root 16384 Apr 11 2019 lost+founddrwxr-xr-x 2 root root 4096 May 21 2019 mediadrwxr-xr-x 7 root root 4096 Jul 9 12:04 mntdrwxr-xr-x 2 root root 4096 May 21 2019 optdr-xr-xr-x 153 root root 0 Jul 9 12:12 procdrwx------ 2 root root 4096 May 21 2019 rootdrwxr-xr-x 9 root root 220 Jul 9 12:23 rundrwxr-xr-x 2 root root 4096 Jul 9 12:04 sbindrwxr-xr-x 2 root root 4096 Mar 21 2019 snapdrwxr-xr-x 2 root root 4096 May 21 2019 srvdr-xr-xr-x 11 root root 0 Jul 9 12:12 sysdrwxrwxrwt 2 root root 4096 Jul 9 12:47 tmpdrwxr-xr-x 11 root root 4096 Jul 9 12:42 usrdrwxr-xr-x 13 root root 4096 May 21 2019 var 对于上面输出的第一行 drwxr-xr-x 2 root root 4096 Jul 9 12:04 bin，含义依次如下： drwxr-xr-x 表示文件访问权限。第一个字符表示文件类型，“-”表示普通文件，“d”表示目录；后三个字符是文件所有者的访问权限；再后三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限。完整含义后面讨论。 2 表示文件硬链接数目。 root 表示文件所有者用户名。 root 表示文件所属用户组名字。 4096 表示文件字节数大小。 Jul 9 12:06 表示上次修改文件的时间和日期。 bin 表示文件名。 3.4 确定文件类型 命令 file 可以输出文件内容的简单描述。 fingsinz@FingsinzStudio:~$ file man.pngman.png: PNG image data, 1175 x 731, 8-bit/color RGBA, non-interlaced 3.5 less浏览文件内容 命令 less 可以查看文本文件。 fingsinz@FingsinzStudio:~$ less hello.cpp less 运行起来后，如果文件内容多于一页，那么可以上下滚动文件。按下“q”键，退出 less 程序。下面还有一些常用的键盘命令： 命令 行为 PageUp 或 b 向上翻滚一页 PageDown 或 空格 向下翻滚一页 上箭头 向上翻滚一行 下箭头 向下翻滚一行 G 移到最后一行 1G 或 g 移动到开头1行 /字符 查找指定字符串 n 向前查找下一个出现的字符串 h 显示帮助 3.6 符号链接和硬链接 运行命令： fingsinz@FingsinzStudio:~$ ls -l /bin/total 15320-rwxr-xr-x 1 root root 1113504 May 3 2019 bash...-rwsr-xr-x 1 root root 64424 Mar 10 2017 pinglrwxrwxrwx 1 root root 4 Mar 10 2017 ping4 - pinglrwxrwxrwx 1 root root 4 Mar 10 2017 ping6 - ping... 可以看到，ping4 和 ping6 都有 - ping，其含义是符号链接（也称为软链接或者 symlink ）。在大多数“类Unix”系统中，有可能一个文件被多个文件名所指向。在这种链接下，当使用 ping4 时，实际上是使用 ping。 还有一种链接类型，叫做硬链接。硬链接同样允许文件有多个名字，但是硬链接以不同的方法来创建多个文件名。更多见后面章节。 3.7 部分目录含义 目录 含义 / 根目录，一切起源 /bin 包含系统启动和运行所必需的可执行二进制程序 /boot Linux 内核、初始 RAM 磁盘映像和启动加载程序 /dev 设备结点目录，内核维护着所有设备的列表 /etc 系统层面的配置文件 /home 给每个用户在此分配家目录 /lib 核心系统查询所使用的共享库文件，类似于 Windows 中的 DLL /lost+found 当部分恢复一个损坏的文件系统时会用到 /media 可移动介质挂载的地方 /mnt 可移动介质（存储空间）挂载的地方 /opt 用来安装可选的软件。这个主要用来存储可能安装在系统中的商业软件产品 /proc 由内核维护的虚拟文件系统，它所包含的文件是内核的窥视孔 /root 超级管理员的家目录 /sbin 包含系统二进制文件，通常为超级用户保留。 /tmp 存储由各种程序创建的临时文件的地方 /usr 包含普通用户所需要的所有程序和文件 /usr/bin 包含系统安装的可执行程序 /usr/lib 包含由 /usr/bin 目录中的程序所用的共享库 /usr/local 是非系统发行版自带程序的安装目录 /usr/sbin 包含许多系统管理程序 /usr/share 包含许多由 /usr/bin 目录中的程序使用的共享数据。 /usr/share/doc 大多数安装在系统中的软件包会包含一些文档 /var 存放动态文件。各种数据库，假脱机文件，用户邮件等等 /var/log 包含日志文件、各种系统活动的记录 四、操作文件和目录 4.1 通配符 通配符，一些特殊字符帮助快速指定一组文件名。 通配符 意义 * 匹配任意多个字符（包括零个或一个） ? 匹配任意一个字符（不包括零个） [字符] 匹配任意一个属于字符集中的字符 [!字符] 匹配任意一个不是字符集中的字符 [[:class:]] 匹配任意一个属于指定字符集类中的字符 字符类有： 字符类 意义 [:alnum:] 匹配任意一个字母或数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 举一些例子： *：匹配所有文件。 g*：匹配文件名以“g”开头的文件。 b*.txt：匹配文件名以“b”开头，中间可以有零个或任意多个字符，且以“.txt”结尾的文件。 Data???：匹配以“Data”开头，其后接着3个字符的文件。 [abc]*：匹配文件名以“a”或“b”或“c”开头的文件。 BACKUP.[0-9][0-9][0-9]：匹配以“BACKUP.”开头，后接三个数字的文件。 [[:upper:]]*：匹配以大写字母开头的文件。 *[[:lower:]123]：匹配文件名以小写字母结尾，或以“1”、“2”、“3”结尾的文件。 4.2 创建目录 创建目录命令： mkdir directory... 如： fingsinz@FingsinzStudio:~$ mkdir testsfingsinz@FingsinzStudio:~$ lshello.cpp man.png tests 可以一次性创建多个目录。 4.3 复制文件和目录 复制文件或者目录命令： cp item1 item2 意思是复制文件或目录 item1 到 文件或目录 item2。 cp item... directory 意思是复制多个文件或目录到 directory 中。 cp 命令有一些常用选项： 选项 意义 -a，--archive 复制文件和目录，以及它们的属性，包括所有权和权限。通常副本具有用户所操作文件的默认属性 -i，--interactive 重写已存在文件之前，提示用户确认。如果不指定该选项，则默认重写文件 -r ，--recursive 递归复制目录以及目录中的内容 -u，--update 当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在 的文件 -v，--verbose 显示翔实的命令操作信息 举例： cp file1 file2：复制文件 file1 内容到文件 file2。如果 file2 已经存在，file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。 cp -i file1 file2：这条命令和上面的命令一样，但是如果文件 file2 存在的话， 在文件 file2 被重写之前，会提示用户确认信息。 cp file1 file2 dir1：复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 cp dir1/* dir2：使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。dir2 必须已经存在。 cp -r dir1 dir2：复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中 的一样。如果目录 dir2 存在，则目录 dir1 （和目录中的内 容）将会被复制到 dir2 中。 4.4 移动和重命名文件 mv 命令可以执行文件的移动和文件的命名。使用与 cp 命令类似： mv item1 item2 意思是文件或目录 item1 移动或重命名为 item2。 mv item... directory 意思是移动多个文件或目录到 directory 中。 mv 命令有一些常用选项： 选项 意义 -i，--interactive 重写已存在文件之前，提示用户确认。如果不指定该选项，则默认重写文件 -u，--update 当把文件从一个目录移动到另一个目录时，仅移动目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在 的文件 -v，--verbose 显示翔实的命令操作信息 举例： mv file1 file2：移动文件 file1 到文件 file2。如果 file2 已经存在，file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。之后 file1 不再存在。 mv -i file1 file2：这条命令和上面的命令一样，但是如果文件 file2 存在的话， 在文件 file2 被重写之前，会提示用户确认信息。 mv file1 file2 dir1：移动 file1 和 file2 到目录 dir1。目录 dir1 必须存在。 mv dir1 dir2：如果 dir2 不存在则创建，并且移动目录 dir1 的内容到目录 dir2 中，同时删除目录 dir1。如果 dir2 存在，则移动 dir1 以及它的内容到目录 dir2。 4.5 删除文件和目录 删除文件和目录： rm item.. rm 有一些常用选项： 选项 意义 -i，--interactive 在删除已存在文件前，提示确认信息。 -r，–recursive` 递归删除文件。当删除一整个目录时，需要该选项 -f，--force 忽视不存在的文件，强力删除 -v，--verbose 显示翔实的命令操作信息 举例： rm file1：删除文件 file1。 rm -i file1：删除之前提示确定。 rm -r file dir1：递归删除文件 file1、目录 dir1 以及里面的内容。 rm -rf file1 dir1：强制删除文件 file1 和 目录 dir1 以及里面的内容。 注意：rm 命令一旦删除没有复原，你需要知道你删的是什么，特别是与通配符一起用的情况，很容易删完所有文件。 4.6 链接 硬链接时最初 Unix 创建链接的方式，每个文件默认会有一个硬链接，这个硬链接给予文件名字。每创建一个硬链接，就为一个文件创建了一个额外的目录下。硬链接的局限性如下： 一个硬链接不能关联它所在文件系统之外的文件，即一个链接不能关联与链接本身不在同一个磁盘分区上的文件。 一个硬链接不能关联一个目录。 一个硬链接和文件本身没有什么区别。当列出一个包含硬链接的目录内容时，会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的链接都删除掉。 符号链接克服了硬链接的局限性。符号链接生效是通过创建一个特殊类型的文件， 这个文件包含一个关联文件或目录的文本指针。在这一方面，和 Windows 的快捷方式差不多。 一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例如，如果往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。 ln 命令可以创建硬链接或者符号链接。 创建硬链接： ln file link 创建符号链接： ln -s item link 4.7 实操命令 首先在家目录中创建一个 playground 目录： fingsinz@FingsinzStudio:~$ mkdir playgroundfingsinz@FingsinzStudio:~$ lsplayground 进入 playground 目录，同时创建两个子目录： fingsinz@FingsinzStudio:~/playground$ mkdir dir1 dir2fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2 复制一些数据到 playground 中： fingsinz@FingsinzStudio:~/playground$ cp /etc/passwd .fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2 passwd 尝试一下 cp 的选项： fingsinz@FingsinzStudio:~/playground$ cp -iv /etc/passwd .cp: overwrite './passwd'? y'/etc/passwd' - './passwd' 感受一下 mv 文件移动，尝试理解下面的操作： fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2 passwdfingsinz@FingsinzStudio:~/playground$ mv passwd dir1/fingsinz@FingsinzStudio:~/playground$ ls dir1passwdfingsinz@FingsinzStudio:~/playground$ cd dir1fingsinz@FingsinzStudio:~/playground/dir1$ mv -v passwd ../dir2/renamed 'passwd' - '../dir2/passwd'fingsinz@FingsinzStudio:~/playground/dir1$ ls ../dir2passwdfingsinz@FingsinzStudio:~/playground$fingsinz@FingsinzStudio:~/playground$ rm -r dir2fingsinz@FingsinzStudio:~/playground$ lsdir1fingsinz@FingsinzStudio:~/playground$ mv dir1/passwd dir2fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2fingsinz@FingsinzStudio:~/playground$ ls dir2dir2fingsinz@FingsinzStudio:~/playground$ ls dir1fingsinz@FingsinzStudio:~/playground$ ls dir1/ 注意17行处，此时的 dir2 是一个文件，是 passwd 文件改名后，并不是一个目录。 好的现在恢复原样： fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2fingsinz@FingsinzStudio:~/playground$ mv dir2 passwdfingsinz@FingsinzStudio:~/playground$ mkdir dir2fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2 passwd 再试试创建硬链接： fingsinz@FingsinzStudio:~/playground$ ln passwd testfingsinz@FingsinzStudio:~/playground$ ln passwd dir1/testfingsinz@FingsinzStudio:~/playground$ ln passwd dir2/testfingsinz@FingsinzStudio:~/playground$ ls -l . dir1 dir2.:total 16drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir1drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir2-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 passwd-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 testdir1:total 4-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 testdir2:total 4-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 test 可以看到 passwd 和 test 文件的硬链接数目都是 4。文件至少有一个硬链接，因为文件名就是由链接创建的。 通过 ls -li 展示文件索引节点信息： fingsinz@FingsinzStudio:~/playground$ ls -li . dir1 dir2.:total 162261 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir12285 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir22307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 passwd2307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 testdir1:total 42307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 testdir2:total 42307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 test 可知所有的 test 和 passwd 的索引号都是一样的，这就证实这些文件是同一个文件。 先把之前的硬链接简单删掉，然后创建符号链接玩玩： fingsinz@FingsinzStudio:~/playground$ rm test dir1/test dir2/testfingsinz@FingsinzStudio:~/playground$ ln -s passwd testfingsinz@FingsinzStudio:~/playground$ ln -s passwd dir1/testfingsinz@FingsinzStudio:~/playground$ ls -li . dir1.:total 122261 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:13 dir12285 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:12 dir22307 -rw-r--r-- 1 fingsinz fingsinz 1562 Jul 10 13:51 passwd2364 lrwxrwxrwx 1 fingsinz fingsinz 6 Jul 10 14:13 test - passwddir1:total 02366 lrwxrwxrwx 1 fingsinz fingsinz 6 Jul 10 14:13 test - passwd 需要注意，此处第14行的 test 应该是红色名字的，这表示是一个坏链接，找不到文件 passwd。 删掉这个坏链接，然后进入到 dir1 目录重新建立符号链接： fingsinz@FingsinzStudio:~/playground/dir1$ lstestfingsinz@FingsinzStudio:~/playground/dir1$ rm testfingsinz@FingsinzStudio:~/playground/dir1$ ln -s ../passwd testfingsinz@FingsinzStudio:~/playground/dir1$ ls -litotal 02366 lrwxrwxrwx 1 fingsinz fingsinz 9 Jul 10 14:17 test - ../passwd 此时第7行的链接应该不是红色的了，是有效链接。 符号链接的文件索引并不一样，但是 ls 命令会提示链接的是什么。 建立符号链接时应当注意目录，符号链接的目录是目标文件的相对目录。建立符号链接时，可以使用绝对路径名，这样万无一失。 最后，删掉 playground/passwd，观察链接情况： fingsinz@FingsinzStudio:~/playground$ lsdir1 dir2 passwd testfingsinz@FingsinzStudio:~/playground$ rm passwdfingsinz@FingsinzStudio:~/playground$ ls -li . dir1.:total 82261 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:17 dir12285 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:19 dir22364 lrwxrwxrwx 1 fingsinz fingsinz 6 Jul 10 14:13 test - passwddir1:total 02366 lrwxrwxrwx 1 fingsinz fingsinz 9 Jul 10 14:17 test - ../passwd 此时所有的链接都已失效，名字呈红色。 最后的最后，恢复现场，把 playground 一并删了，记得 -r 递归： fingsinz@FingsinzStudio:~/playground$ cd ..fingsinz@FingsinzStudio:~$ rm -r playground/fingsinz@FingsinzStudio:~$ ls -litotal 0 五、使用命令 命令可以是： 一个可执行程序，是诸如 C 和 C++ 语言写成的程序编译的二进制文件，也可以是由诸如 shell，perl， python，ruby 等等脚本语言写成的程序。 一个 shell 自身的命令。bash 支持若干命令， 例如 cd 命令。 一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 一个命令别名。可以定义自己的命令，建立在其它命令之上。 5.1 显示命令类型 type 命令是 shell 内部的命令，会显示命令的类型： type command 一些使用例子： fingsinz@FingsinzStudio:~$ type lsls is aliased to `ls --color=auto'fingsinz@FingsinzStudio:~$ type cpcp is /bin/cpfingsinz@FingsinzStudio:~$ type cdcd is a shell builtin shell builtin：表示是 shell 自身的命令，内建于 shell 的命令。 5.2 显示可执行程序的位置 为了确定所给定的执行程序的准确位置，使用 which 命令： which exe 由前面可以知道，/bin 目录下存放的是一些二进制文件，所以可以试试： fingsinz@FingsinzStudio:~$ which cp/bin/cpfingsinz@FingsinzStudio:~$ which cdfingsinz@FingsinzStudio:~$ which 只能用于显示可执行程序的位置，上面操作中， cd 并不是一个可执行程序，故没有输出。 5.3 获取shell内建命令的帮助文档 有时候我们并不能完全记住每个命令的用法，这个时候需要查阅帮助文档。 help 命令可以获取 shell 内建命令的帮助文档。 man 命令可以获取程序的帮助文档（手册）。 fingsinz@FingsinzStudio:~$ help cdcd: cd [-L|[-P [-e]] [-@]] [dir] Change ...(省略)fingsinz@FingsinzStudio:~$ cd --helpcd: cd [-L|[-P [-e]] [-@]] [dir] Change ...(省略)fingsinz@FingsinzStudio:~$ man cp# 省略 man cp 的输出 在大多数Linux 系统中，man 使用 less 工具来显示参考手册。所显示的参考手册，被分成几个章节，它们不仅仅包括用户命令，也包括系统管理员 命令、程序接口、文件格式等等： 章节 内容 1 用户命令 2 程序接口内核系统调用 3 C库函数程序接口 4 特殊文件，比如设备结点和驱动程序 5 文件格式 6 游戏娱乐 7 其他方面 8 系统管理员命令 默认情况下，会自动匹配 man 的对象属于什么内容显示。但如果要查找一 种文件格式，而同时它也是一个命令名时，这种情况没有指定章节号，总是得到第一个匹配项。具体使用： man section xxx 5.4 显示命令说明 手册只是参考，阅读起来很困难。使用 whatis 程序可以显示匹配特定关键字的手册的名字和一行命令说明： fingsinz@FingsinzStudio:~$ whatis rmrm (1) - remove files or directoriesfingsinz@FingsinzStudio:~$ whatis lsls (1) - list directory contents 5.5 给命令起别名 使用 alias 命令可以创建自己的命令： alias name='string' 首先，多个命令可以通过 ; 连接在一行使用，比如： fingsinz@FingsinzStudio:~$ mkdir playground; cd playground; ls -liha; cd ..; rm playground -r;total 8.0K 509 drwxr-xr-x 2 fingsinz fingsinz 4.0K Jul 18 11:20 .1396 drwxr-xr-x 11 fingsinz fingsinz 4.0K Jul 18 11:20 ..fingsinz@FingsinzStudio:~$ 一番操作下来，创建并进入 playground 文件夹，然后列出目录文件，最后退出目录并删除。 在起别名之前最好用 type 命令看看是否已经被用了： fingsinz@FingsinzStudio:~$ type testtest is a shell builtin 然后再起别名： fingsinz@FingsinzStudio:~$ alias foo='mkdir playground; cd playground; ls -liha; cd ..; rm playground -r;'fingsinz@FingsinzStudio:~$ foototal 8.0K 509 drwxr-xr-x 2 fingsinz fingsinz 4.0K Jul 18 11:22 .1396 drwxr-xr-x 11 fingsinz fingsinz 4.0K Jul 18 11:22 ..fingsinz@FingsinzStudio:~$ type foofoo is aliased to `mkdir playground; cd playground; ls -liha; cd ..; rm playground -r;' 删除别名使用 unalias 命令： fingsinz@FingsinzStudio:~$ unalias foofingsinz@FingsinzStudio:~$ type foo-bash: type: foo: not found 在此章节介绍中，建立的别名会在 shell 会话结束时会消失。随后的章节里， 会了解怎样把自己的别名添加到文件中去，每次登录系统，这些文件会建立系统环境。 六、重定向 6.1 标准输入、输出和错误 命令运行结果会输送到一个叫做标准输出的特殊文件（经常用stdout表示），而它们的状态信息则送到另 一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下，标准输入连接到键盘。 I/O 重定向允许更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但 是通过 I/O 重定向，可以做出改变。 6.2 标准输出重定向 重定向符 ，比如： fingsinz@FingsinzStudio:~$ ls / ls-output.txtfingsinz@FingsinzStudio:~$ ls -lhtotal 12K-rw-r--r-- 1 fingsinz fingsinz 112 Jul 18 11:51 ls-output.txt 重定向符输出的文件如果不存在，会自动创建。 再比如： fingsinz@FingsinzStudio:~$ ls /aaaaa ls-output.txtls: cannot access '/aaaaa': No such file or directoryfingsinz@FingsinzStudio:~$ ls -lh ls-output.txt-rw-r--r-- 1 fingsinz fingsinz 0 Jul 18 11:53 ls-output.txt 尝试将一个不存在的目录 ls 出来。 错误信息显示在屏幕，并没有输出到文件中，因为 ls 程序不把它的错误信息输送到标准输出，而是输送到标准错误。 每次重定向输出是，文件重视从头开始重写。 这有一个技巧，简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是创建一个新的空文件： fingsinz@FingsinzStudio:~$ ls-output.txt 如果想要追加输出，使用 ： fingsinz@FingsinzStudio:~$ ls -lh ls-output.txt-rw-r--r-- 1 fingsinz fingsinz 0 Jul 18 11:58 ls-output.txtfingsinz@FingsinzStudio:~$ ls / ls-output.txtfingsinz@FingsinzStudio:~$ ls -lh ls-output.txt-rw-r--r-- 1 fingsinz fingsinz 112 Jul 18 11:58 ls-output.txtfingsinz@FingsinzStudio:~$ ls / ls-output.txtfingsinz@FingsinzStudio:~$ ls -lh ls-output.txt-rw-r--r-- 1 fingsinz fingsinz 224 Jul 18 11:58 ls-output.txt 6.3 标准错误重定向 文件流的标准输入、标准输出和标准错误分别对应 shell 内部的文件描述符0、1、2。。shell 使用件描述符提供了一种表示法来重定向文件。标准错误和文件描述符 2 一样： fingsinz@FingsinzStudio:~$ ls /aaaa 2 ls-error.txtfingsinz@FingsinzStudio:~$ ls -lh ls-error.txt-rw-r--r-- 1 fingsinz fingsinz 53 Jul 18 16:52 ls-error.txtfingsinz@FingsinzStudio:~$ 6.4 标准输出和错误到同一个文件 使用 ： fingsinz@FingsinzStudio:~$ ls -l /aaa ls-output.txtfingsinz@FingsinzStudio:~$ ls -lh ls-output.txt-rw-r--r-- 1 fingsinz fingsinz 52 Jul 18 16:54 ls-output.txt 6.5 处理不需要的输出 如果不需要命令的输出结果，可以重定向到 /dev/null。 /dev/null 是系统的一个设备，叫做位存储桶，可以接受输入且不对输入做处理。 fingsinz@FingsinzStudio:~$ ls -l /aaa 2 /dev/null 6.6 cat命令 cat 命令可以读取一个或多个文件，然后复制到标准输出： cat [file] 当 cat 的对象只有一个文件时，可以用来显示文件里面的内容： fingsinz@FingsinzStudio:~$ ls -l /aaa 2 ls-output.txtfingsinz@FingsinzStudio:~$ cat ls-output.txtls: cannot access '/aaa': No such file or directory 当 cat 的对象有多个文件时，可以用来拼接文件： fingsinz@FingsinzStudio:~$ cat ls-output.txt ls-output.txtls: cannot access '/aaa': No such file or directoryls: cannot access '/aaa': No such file or directoryfingsinz@FingsinzStudio:~$ cat ls-output.txt ls-output.txt ls-output2.txtfingsinz@FingsinzStudio:~$ cat ls-output2.txtls: cannot access '/aaa': No such file or directoryls: cannot access '/aaa': No such file or directory 当 cat 不带参数时，它会从标准输入读入数据并输出到标准输出： fingsinz@FingsinzStudio:~$ catHello WorldHello Worldfingsinz@FingsinzStudio:~$ 使用 ctrl + d 告诉 cat 从标准输入的读取结束。 6.7 标准输入重定向 使用符号： fingsinz@FingsinzStudio:~$ cat ls-output.txtls: cannot access '/aaa': No such file or directory 虽然不使用 ，单靠 cat 也可以完成，但是 就是一个重定向标准输入符号，后面会有更好的例子。 6.8 管道线 使用管道操作符 |（竖杠），可以让一个命令的标准输出通过管道送至另一个命令的标准输入： command1 | command2 管道符前面的命令需要有标准输出，后面的命令需要接受标准输入。 如： fingsinz@FingsinzStudio:~$ ls / | less 6.9 过滤器 有可能会把几个命令放在一起组成一个管道线。 以这种方式使用的命令被称为过滤器。 比如： fingsinz@FingsinzStudio:~$ ls / | sort | less sort 具有排序的作用。 6.10 报道或忽略重复行 uniq 从标准输入或单个文件名参数接受数据有序列表（详情查看uniq 手册页），默认情况下，从数据列表中删除任何重复行。 如果想看到重复的数据列表，让 uniq 命令带上 -d 选项。 比如： fingsinz@FingsinzStudio:~$ mkdir playgroundfingsinz@FingsinzStudio:~$ cd playground/fingsinz@FingsinzStudio:~/playground$ lsfingsinz@FingsinzStudio:~/playground$ a; bfingsinz@FingsinzStudio:~/playground$ mkdir testfingsinz@FingsinzStudio:~/playground$ test/afingsinz@FingsinzStudio:~/playground$ ls . test/.:a b testtest/:afingsinz@FingsinzStudio:~/playground$ ls . test/ | sort | uniq | cat.:abtesttest/:fingsinz@FingsinzStudio:~/playground$ ls . test/ | sort | uniq -d | cata 先创建一个演示环境，在 playground 里面创建文件 a、b和文件夹 test，在文件夹 test 内创建文件 a。 使用管道符和 uniq 连接并重定向到 cat 中，输出并没有出现重复的文件 a。 第一行是空格是因为，ls 两个目录时中间会空一行，经过 sort 后排序到第一位。 6.11 wc命令 wc（字计数）命令是用来显示文件所包含的行数、字数和字节数： fingsinz@FingsinzStudio:~$ wc ls-output.txt 1 9 52 ls-output.txt 输出的三个数字分别是：行数、单词数和字节数。 -l 选项可以限制只输出行数。 同样可以通过管道线进行统计数据： fingsinz@FingsinzStudio:~/playground$ ls ./ test/ | sort | uniq | wc -l 6 表示输出有6行。 6.12 grep命令 grep 用来找到文件中的匹配文本： grep pattern [file...] 匹配的模式支持正则表达式。 比如现在要从系统安装的程序中找到包含 zip 的文件： fingsinz@FingsinzStudio:~$ ls /bin /usr/bin | uniq | grep zipbunzip2bzip2bzip2recovergunzipgzipgpg-zipzipdetails grep 有一些方便的选项：-i 使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写敏感的）；-v 选项会告诉 grep 只打印不匹配的行。 6.13 head和tail命令 head 命令可以输出文件的前几行，tail 命令可以输出文件的后几行。 默认输出十行，可以通过 -n 调整打印的行数。 也可以用到管道线中。 fingsinz@FingsinzStudio:~$ ls /bin | headbashbtrfsbtrfs-debug-treebtrfs-find-rootbtrfs-imagebtrfs-map-logicalbtrfs-select-superbtrfs-zero-logbtrfsckbtrfstunefingsinz@FingsinzStudio:~$ ls /bin | tail -n 2zmoreznew tail 命令的 -f 选项可以持续检测文件，当新内容添加后会立即出现，直至 ctrl + c。 6.14 tee命令 tee 命令制造了一个 “tee”安装到管道上。tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）。 当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助，如： fingsinz@FingsinzStudio:~$ ls /bin /usr/bin | sort | tee bin.txt | grep zipbunzip2bzip2bzip2recovergpg-zipgunzipgzipzipdetailsfingsinz@FingsinzStudio:~$ ls -lh bin.txt-rw-r--r-- 1 fingsinz fingsinz 14K Jul 18 18:18 bin.txt 配置文件和shell环境 常见任务和基本工具 编写 shell脚本","tags":["Linux"],"categories":["笔记"]},{"title":"给大二的你","path":"/2024/tosophomore/","content":"如今大三将完，给大二朋友的一些话。 关键词：经验 相信经过大一一年的学习生活，你对学校、课程以及你自身有了一定的认识。你是适合卷的还是适合躺的，还是半躺半卷的，相信你也知道了。 比如我是不爱卷的，顺其自然，爱啥啥，绩点也不高。 在接下来的大二学年，希望你能再次做出一个选择： 考研？保研？ 就业？ 考公？考编？ 如果你是记住了我去年提过的小小建议——提高广度，那么你对于你的求学生涯乃至职业生涯估计是有所了解的，对你做出上面的选择也是有帮助的。 另外你可能会问，为什么大二甚至还没踏入大二就要决定我未来的路？ 其实这也就是两三年后的事情，说慢不慢的。 如果你要考研，你现在可就轻松多了，把你的课过了、学分到手了，继续坚持你喜欢的兴趣爱好，等到大三再准备考研即可（不至于大二就复习考研吧，有点过于紧张了）； 如果你要保研，可能现在触发稍迟了，保研看的是你前三年的绩点，以及有的学校会看你的创新得分，所以志向保研的你在大二就需要多去打比赛，去满足保研的条件，必然是辛苦的； 如果你要就业，你就要审视你学习的课程与实际企业需求的技能之间的匹配度了，大学教的课程与时代脱节是正常的，与企业招聘岗位需求存在差别，此时你需要面向你的就业方向，强化你的技术。 下面还是一些关于计算机方面在大二时的建议： 相信你也会有关于计算机专业方面更广泛的认识，你也应该知道计算机专业很庞大，远远不只是计算机。此时的你对计算机（笔记本电脑）的操作应该是娴熟的，而不只是玩游戏和看视频的工具。 计算机专业的你在大二期间，不仅需要保持对计算机的兴趣，继续扩宽计算机视野，还要多操作多动手。 关于如何过好大二学年，以下是我的拙见： 计算机基础能力方面： 编程语言：这个不用多说，需要熟悉一门编程语言，且了解其他编程语言，这是你的计算机表达能力。 数据结构、计算机网络、计算机组成原理、操作系统：这个我在之前就提及过的知识方向，大一可能来不及或者忘了开始，现在还不迟，你依然可以从这些方面入手。 Linux系统：建议开始熟悉 Linux 系统，使用 Linux 系统，上手方法可以是下载虚拟机软件，或者是 WSL，或者是实装系统。 Git 工具：更多是代码管理方面，你需要养成代码的管理能力，包括但不限于代码迭代的变化记录、代码的提交保存和代码格式的控制等等。 计算机专业的你在大二更应该明确好方向，做好对保研、考研、就业等方向的选择。 保研方面： 保证你具备高绩点，学院排名靠前； 了解并尽量满足你的学校学院保研条件，针对性卷技术，多参加比赛； 保研的过程很累很辛苦，做好心理准备。专心走保研的路，下面的 2、3 条建议可以忽略。 考研方面： 你还可以玩一年，或者一如既往的卷绩点、参加比赛、参加实验室项目，增加你的项目经历，这并不紧要； 可以谈个恋爱、发展兴趣爱好等等，你这一年比较轻松； 适时挑选考研目标院校，了解目标学校考研政策、招生简章之类的； 可以忽略第 3 条建议，也可听从。 就业方面：这是一些关于专业技能实践上的一些建议 选择好你的发展方向，选择好你的角色，也建议选择好你的主语言（语言只是工具，但最好熟悉一门），据 roadmap 发展路线 上的分类，具有：前端、后端、运维、全站、AI 工程师、数据分析师、安卓 / IOS 方向、数据库方向、区块链方向、质量保证工程师（QA）、软件架构师、网络空间安全、UX 设计、游戏开发、机器人开发等角色。 确定好你的方向，在 https://roadmap.sh/ 或其他地方了解你的方向的发展路线，顺着发展路线学习。 了解、熟悉并使用你的角色上的一个或多个框架（或技术）。比如 C++ 方向上的 boost 框架、Java 方向上的 Spring Boot 框架、测试工程师方向上的测试框架、网络安全方向上的渗透、前端框架 Vue 等。 阅读关于你的方向上的一些开源项目，将其代码跑起来，并尝试做出些许修改，最后做出自己的项目。大二的时候可以尝试准备自己简历上的项目经历。 刷题还是要坚持，刷题网站有牛客竞赛、洛谷、力扣、Acwing 等等。 计算机专业一定要注重自学，要学会学习，不要盲目上课，真正重要的是你是否学习到了知识。 以上可能有遗漏没提及的点，仅提供方向，望多方听取建议，选择适合自己的。 如果想和我交流，或者是想要资料，建议发送到邮箱：fingsinz@foxmail.com。 希望大二有所收获。","tags":["经验"],"categories":["经验之谈"]},{"title":"使用clang-format给你代码格式化","path":"/2024/22/","content":"关键词：C++ clang-format 简介 Clang 本身是一个 C++ 的编译器。而 Clang-Format 是其中的一个格式化工具，可用于格式化（排版）多种不同语言的代码。 clang-format 安装 安装 clang-format 十分简单： 对于 Ubuntu： sudo apt install clang-format 对于 Windows： 从 Github 的 Release 中下载安装包 LLVM-xx.x.xx-winxx.exe； 下载链接：https://github.com/llvm/llvm-project/releases clang-format 使用 Windows OS 记得将clang路径下的bin目录添加到环境变量。 通过以下命令获取帮助： clang-format --help 基本的使用： // 以LLVM代码风格格式化main.cpp, 结果直接写到main.cppclang-format -style=LLVM -i main.cpp 但是更多情况下，是使用 .clang-format 文件进行格式的规定。 我自己暂时使用的格式定义如下： # 风格：Google, LLVM, Chromium, Mozilla, WebKit, Microsoft, GUNBasedOnStyle: LLVM# 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProtoLanguage: Cpp# 标准: Cpp03, Cpp11, AutoStandard: Auto# 去除C++11的列表初始化的大括号{后和}前的空格Cpp11BracedListStyle: true# 访问说明符(public、private等)的偏移AccessModifierOffset: -4# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)AlignAfterOpenBracket: AlwaysBreak# 水平对齐二元和三元表达式的操作数AlignOperands: false# 允许函数声明的所有参数在放在下一行AllowAllParametersOfDeclarationOnNextLine: false# 允许短的块放在同一行AllowShortBlocksOnASingleLine: false# 允许短的case标签放在同一行AllowShortCaseLabelsOnASingleLine: false# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), AllAllowShortFunctionsOnASingleLine: Empty# 允许短的if语句保持在同一行AllowShortIfStatementsOnASingleLine: false# 允许短的循环保持在同一行AllowShortLoopsOnASingleLine: false# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), # AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)AlwaysBreakAfterReturnType: None# 总是在template声明后换行AlwaysBreakTemplateDeclarations: true# false表示函数实参要么都在同一行，要么都各自一行BinPackArguments: false# false表示所有形参要么都在同一行，要么都各自一行BinPackParameters: false# 在构造函数的初始化列表的逗号前换行BreakConstructorInitializersBeforeComma: true# 每行字符的限制，0表示没有限制ColumnLimit: 120# 构造函数的初始化列表的缩进宽度ConstructorInitializerIndentWidth: 8# 延续的行的缩进宽度ContinuationIndentWidth: 4# 继承最常用的指针和引用的对齐方式DerivePointerAlignment: true# 为命名空间添加缺失的命名空间结束注释FixNamespaceComments: true# 缩进case标签IndentCaseLabels: false# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, AlwaysUseTab: Never# 缩进宽度IndentWidth: 4# 连续空行的最大数量MaxEmptyLinesToKeep: 1# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), AllNamespaceIndentation: NonePenaltyBreakAssignment: 2# 在call(后对函数调用换行的penaltyPenaltyBreakBeforeFirstCallParameter: 1# 在一个注释中引入换行的penaltyPenaltyBreakComment: 500# 第一次在前换行的penaltyPenaltyBreakFirstLessLess: 120# 在一个字符串字面量中引入换行的penaltyPenaltyBreakString: 1000# 对于每个在行字符数限制之外的字符的penaltyPenaltyExcessCharacter: 1000000# 将函数的返回类型放到它自己的行的penaltyPenaltyReturnTypeOnItsOwnLine: 400# 指针和引用的对齐: Left, Right, MiddlePointerAlignment: Right# 允许排序#includeSortIncludes: true# 连续宏定义的值对齐AlignConsecutiveMacros: true 更多的格式定义如下： 展开 # 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProtoLanguage: Cpp# 基于风格：Google, LLVM, Chromium, Mozilla, WebKit, Microsoft, GUNBasedOnStyle: LLVM# 访问说明符(public、private等)的偏移AccessModifierOffset: -4# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)AlignAfterOpenBracket: Align# 连续赋值时，对齐所有等号AlignConsecutiveAssignments: true# 连续声明时，对齐所有声明的变量名AlignConsecutiveDeclarations: true# 左对齐逃脱换行(使用反斜杠换行)的反斜杠AlignEscapedNewlinesLeft: true# 水平对齐二元和三元表达式的操作数AlignOperands: true# 对齐连续的尾随的注释AlignTrailingComments: true# 允许函数声明的所有参数在放在下一行AllowAllParametersOfDeclarationOnNextLine: true# 允许短的块放在同一行AllowShortBlocksOnASingleLine: false# 允许短的case标签放在同一行AllowShortCaseLabelsOnASingleLine: false# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), AllAllowShortFunctionsOnASingleLine: Empty# 允许短的if语句保持在同一行AllowShortIfStatementsOnASingleLine: false# 允许短的循环保持在同一行AllowShortLoopsOnASingleLine: false# 总是在定义返回类型后换行(deprecated)AlwaysBreakAfterDefinitionReturnType: None# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), # AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)AlwaysBreakAfterReturnType:\tNone# 总是在多行string字面量前换行AlwaysBreakBeforeMultilineStrings: false# 总是在template声明后换行AlwaysBreakTemplateDeclarations: false# false表示函数实参要么都在同一行，要么都各自一行BinPackArguments: true# false表示所有形参要么都在同一行，要么都各自一行BinPackParameters: true# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效BraceWrapping: # class定义后面 AfterClass: false # 控制语句后面 AfterControlStatement: false # enum定义后面 AfterEnum: false # 函数定义后面 AfterFunction: false # 命名空间定义后面 AfterNamespace: false # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct: false # union定义后面 AfterUnion: false # catch之前 BeforeCatch: true # else之前 BeforeElse: true # 缩进大括号 IndentBraces:\tfalse # 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)BreakBeforeBinaryOperators:\tNonAssignment# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), # Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), # Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom# 注：这里认为语句块也属于函数BreakBeforeBraces:\tCustom# 在三元运算符前换行BreakBeforeTernaryOperators: true# 在构造函数的初始化列表的逗号前换行BreakConstructorInitializersBeforeComma: false# 每行字符的限制，0表示没有限制ColumnLimit: 200# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变CommentPragmas:\t'^ IWYU pragma:'# 构造函数的初始化列表要么都在同一行，要么都各自一行ConstructorInitializerAllOnOneLineOrOnePerLine:\tfalse# 构造函数的初始化列表的缩进宽度ConstructorInitializerIndentWidth: 4# 延续的行的缩进宽度ContinuationIndentWidth: 4# 去除C++11的列表初始化的大括号{后和}前的空格Cpp11BracedListStyle:\tfalse# 继承最常用的指针和引用的对齐方式DerivePointerAlignment:\tfalse# 关闭格式化DisableFormat: false# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)ExperimentalAutoDetectBinPacking: false# 需要被解读为foreach循环而不是函数调用的宏ForEachMacros:\t[ foreach, Q_FOREACH, BOOST_FOREACH ]# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，# 可以定义负数优先级从而保证某些#include永远在最前面IncludeCategories: - Regex:\t'^\"(llvm|llvm-c|clang|clang-c)/' Priority:\t2 - Regex:\t'^(|\"(gtest|isl|json)/)' Priority:\t3 - Regex:\t'.*' Priority:\t1 # 缩进case标签IndentCaseLabels: false# 缩进宽度IndentWidth: 4# 函数返回类型换行时，缩进函数声明或函数定义的函数名IndentWrappedFunctionNames:\tfalse# 保留在块开始处的空行KeepEmptyLinesAtTheStartOfBlocks: true# 开始一个块的宏的正则表达式MacroBlockBegin: ''# 结束一个块的宏的正则表达式MacroBlockEnd: ''# 连续空行的最大数量MaxEmptyLinesToKeep: 1# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), AllNamespaceIndentation: Inner# 使用ObjC块时缩进宽度ObjCBlockIndentWidth: 4# 在ObjC的@property后添加一个空格ObjCSpaceAfterProperty:\tfalse# 在ObjC的protocol列表前添加一个空格ObjCSpaceBeforeProtocolList: true# 在call(后对函数调用换行的penaltyPenaltyBreakBeforeFirstCallParameter: 19# 在一个注释中引入换行的penaltyPenaltyBreakComment: 300# 第一次在前换行的penaltyPenaltyBreakFirstLessLess: 120# 在一个字符串字面量中引入换行的penaltyPenaltyBreakString:\t1000# 对于每个在行字符数限制之外的字符的penaltyPenaltyExcessCharacter:\t1000000# 将函数的返回类型放到它自己的行的penaltyPenaltyReturnTypeOnItsOwnLine: 60# 指针和引用的对齐: Left, Right, MiddlePointerAlignment: Left# 允许重新排版注释ReflowComments:\ttrue# 允许排序#includeSortIncludes: true# 在C风格类型转换后添加空格SpaceAfterCStyleCast: false# 在赋值运算符之前添加空格SpaceBeforeAssignmentOperators:\ttrue# 开圆括号之前添加一个空格: Never, ControlStatements, AlwaysSpaceBeforeParens: ControlStatements# 在空的圆括号中添加空格SpaceInEmptyParentheses: false# 在尾随的评论前添加的空格数(只适用于//)SpacesBeforeTrailingComments: 2# 在尖括号的后和前添加空格SpacesInAngles:\ttrue# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格SpacesInContainerLiterals: true# 在C风格类型转换的括号中添加空格SpacesInCStyleCastParentheses: true# 在圆括号的(后和)前添加空格SpacesInParentheses: true# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响SpacesInSquareBrackets:\ttrue# 标准: Cpp03, Cpp11, AutoStandard: Cpp11# tab宽度TabWidth: 4# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, AlwaysUseTab: Never... VSCode 中使用 VSCode 中需要安装插件 Clang-Format，安装后需要把 .clang-format 文件放到 VSCode 的工程目录下。 Windows 下如果没把 clang 的 bin 目录放置到环境变量中，需要在设置中设置 clang-format 路径。 格式化快捷键：shift + alt + f","tags":["CPP"],"categories":["日常"]},{"title":"Windows下保持SSH长时间挂起","path":"/2024/21/","content":"关键词：SSH 问题描述 实际上，终端 SSH 连接在长时间不操作会出现自动中断，需要再次连接，十分麻烦。 问题解决 更改自己客户端 ssh 配置： 用记事本打开 C:/Users/用户名/.ssh/config。 添加一行： ServerAliveInterval 60 该行意思是：每隔60秒自动发送一个空的请求以保持连接。 秒数可以根据自己实际调整。 Reference： 解决ssh连接长时间不操作断开连接的问题（client_loop/ send disconnect/ Broken pipe） - KelvinF97的文章 - 知乎","tags":["SSH"],"categories":["日常"]},{"title":"WSL安装记录","path":"/2024/20/","content":"关键词：Linux WSL 简介 开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。 通过适用于 Linux 的 Windows 子系统 (WSL)，开发人员可以安装 Linux 发行版，并直接在 Windows 上使用 Linux 应用程序、实用程序和 Bash 命令行工具，不用进行任何修改，也无需承担传统虚拟机或双启动设置的费用。 WSL 目前已发布两代产品：WSL 1 和 WSL 2。 WSL 1 实现了 Linux 兼容层，将 Linux 系统调用转换为 Windows NT 系统调用； WSL 2 则利用 Windows 的 Hyper-V 功能，通过虚拟化技术直接运行 Linux 虚拟机，更接近原生 Linux 操作系统体验。 WSL 的前提条件 检查 Windows 版本，WSL 需要 Windows 10 1903 （内部版本 18362）或更高版本（x64）。如果版本较低，请更新 Windows 10 系统。（设置 → 关于可以看） 检查 BIOS 是否开启了虚拟化。（打开任务管理器 → 性能 → CPU处）如果没有开启虚拟化，需要进入 BIOS 的 Configuration 处设置。 启用 WSL 功能。（搜索打开“启用或关闭 Windows 功能”，滑到最下面，启用“媒体功能”、“适用于 Linux 的 Windows 子系统”、“虚拟机平台”和“远程差分压缩 API 支持”） 安装 Linux 在 此处 下载自己需要的 Linux 发行版本。（此处下载 Ubuntu 20.04 为例） 下载得到的是一个 .AppxBundle 文件，将其重命名为 .zip 并解压。 选择自己电脑架构的 .appx 文件，再将其命名为 .zip 并解压。 运行 ubuntu.exe，过程中需要注册账号名和密码。 运行并配置 WSL 直接使用 cmd 输入 wsl 可进入默认 WSL，输入 wsl --list 查看安装了的 Linux 版本。 更改 Ubuntu 的 apt 下载镜像： 使用以下命令确定 Ubuntu 的 codename： lsb_release -a 此处我为 focal。 sudo vim /etc/apt/sources.list 将里面的内容替换为： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 如果你的 codename 为其他，需要将上面的内容中的 focal 修改为你自己的 codename。 要是不习惯 vim 操作，可以偷懒使用 Windows 的文件管理器，打开你的 Ubuntu 文件夹，找到里面的 rootfs\\etc\\apt\\，然后用记事本打开 sources.list 进行修改。 修改后运行下面的命令进行更新： sudo apt-get update 配置 DNS 网关： sudo vim /etc/resolv.conf 添加阿里 DNS： nameserver 127.0.0.53 此处好像记事本打不开… 保存后再运行一次下面命令进行更新： sudo apt-get update 添加 gcc/g++ 环境 sudo apt updatesudo apt install build-essential 升级到 WSL 2 先使用下面的命令检查自己的 WSL： wsl -l --v 如果版本不是 2 而想升级到 2 的步骤如下： 下载 Linux 内核更新包：下载地址 接着运行下载到的更新包。 在升级后，我再进入 WSL 时出现了“参考的对象类型不支持尝试的操作”的情况，解决方式参考：CSDN 注销 WSL 在 cmd 中输入 wsl --unregister Linux 进行删除 WSL。 另外如果忘记了 root 账户密码的话，可以修改： 打开 powershell 或 cmd，输入 wsl -u root 会直接进入 root 模式，在改模式下直接修改 root 密码； 输入 passwd root，终端会提示让你输入新的密码。 References WSL 安装与使用 如何使用 WSL 在 Windows 上安装 Linux Ubuntu18.04…5 配置国内镜像源：解决E: Failed to fetch 下载 Linux 内核更新包 Windows下WSL的root密码忘记解决办法","tags":["Linux"],"categories":["日常"]},{"title":"设计模式 - C++","path":"/2024/cpp-patterns/","content":"关键词：C++、设计模式 Reference：卡码网KamaCoder - 设计模式精讲 - https://kamacoder.com/designpattern.php 创建型设计模式 单例模式 单例模式是创建型设计模式，保证一个类只有一个实例，并提供全局访问方法实现这个实例。 单例模式的使用情形 资源共享：多个模块共享某个资源的时候，比如需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。 只有一个实例。 懒加载：对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用。 单例模式的优点 全局控制：保证只有一个实例，这样就可以严格的控制怎样访问它以及何时访问它。 节省资源：避免多次创建了相同的对象，从⽽节省了系统资源，⽽且多个模块还可以通过单例实例共享数据。 懒加载：可以实现懒加载，需要时才实例化。 单例模式的基本原则 不允许外部代码创建实例。 唯一实例保存在私有静态变量中。 通过公有静态方法获取唯一实例。 单例模式的实现 饿汉式：类加载时就完成了实例创建。 懒汉式：需要使用实例时在创建。 多个线程同时获取实例时，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建。这个时候需要使用同步机制。 单例模式参考代码： class Singleton {private: Singleton() = default;public: static Singleton *GetInstance() { static Singleton instance; return instance; } Singleton(Singleton const other) = delete; Singleton(Singleton const other) = delete; Singleton operator=(Singleton const other) = delete; Singleton operator=(Singleton const other) = delete;}; 单例模式设计题 【设计模式专题之单例模式】1.小明的购物车 (kamacoder.com)： 小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。 输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。 输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 “商品名称 购买数量”。 参考代码： Singleton/main.cpp(github.com) Singleton/main.cpp (gitee.com) 工厂方法模式 简单工厂模式：将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。 三个主要角色，工厂类、抽象产品、具体产品。 工厂方法模式是创建型设计模式。 简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。 工厂方法模式引⼊了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码。 工厂方法模式的角色： 抽象工厂：一个接口，包含一个抽象的工厂方法。 具体工厂：创建具体产品。 抽象产品：产品的接口。 具体产品：实现抽象产品接口，是工厂创建的对象。 工厂方法模式的使用情形 工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品。当创建对象涉及一系列复杂的初始化逻 辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。 工厂方法模式的实现 参考代码： #pragma once#include iostreamclass Product {public: Product() = default; virtual ~Product() {}; virtual void use() = 0;};class ConcreteProductA : public Product {public: virtual ~ConcreteProductA() {} virtual void use() { std::cout \"use ConcreteProductA \"; }};class ConcreteProductB : public Product {public: virtual ~ConcreteProductB() {}; virtual void use() { std::cout \"use ConcreteProductB \"; }};class Factory {public: Factory() = default; virtual ~Factory() {}; virtual Product *createProduct() = 0;};class ConcreteFactoryA : public Factory {public: ConcreteFactoryA() = default; virtual ~ConcreteFactoryA() {} virtual Product *createProduct() { return new ConcreteProductA(); }};class ConcreteFactoryB : public Factory {public: ConcreteFactoryB() = default; virtual ~ConcreteFactoryB() {}; virtual Product *createProduct() { return new ConcreteProductB(); }}; 工厂方法模式设计题 【设计模式专题之工厂方法模式】2.积木工厂 (kamacoder.com)： 小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。 输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。 接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 “Circle” 和 “Square” 两种。整数表示该积木生产的数量。 对于每个积木，输出一行字符串表示该积木的信息。 参考代码： FactoryMethod/main.cpp(github.com) FactoryMethod/main.cpp(gitee.com) 抽象工厂模式 抽象工厂模式是创建型设计模式。抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用。 在工厂方法模式中，每个具体工厂只负责创建单一的产品。但是如果有多类产品呢，比如说“手机”，一个品牌的手机有高端机、中低端机之分，这些具体的产品都需要建立一个单独的工厂类，但是它们都是相互关联的，都共同属于同一个品牌，这就可以使用到抽象工厂模式。 抽象工厂模式包括多个抽象产品、多个具体产品、一个抽象工厂和多个具体工厂，每个具体工厂负责创建一组相关产品。 简单工厂、工厂方法、抽象工厂的区别 简单工厂模式：一个工厂方法创建所有具体产品； 工厂方法模式：一个工厂方法创建一个具体产品； 抽象工厂模式：一个工厂方法可以创建一类具体产品。 工厂方法模式的使用情形 抽象工厂模式能够保证一系列相关的产品一起使⽤，并且在不修改客户端代码的情况下，可以方便地替换整个产品系列。但是当需要增加新的产品类时，除了要增加新的具体产品类，还需要修改抽象工厂及其所有的具体工厂类，扩展性相对较差。 典型的应用场景是使用抽象工厂模式来创建与不同数据库的连接对象。 抽象工厂模式的实现 遵循以下步骤： 定义（一个或多个）抽象产品，声明产品的公共方法。 实现具体产品类。 定义抽象工厂，声明一组可用于创建产品的方法。 实现具体工厂。 客户端中使用抽象工厂和抽象产品。 参考代码： #pragma once#include iostreamclass AbstractProductA {public: AbstractProductA() = default; virtual ~AbstractProductA() = default; virtual void use() = 0;};class AbstractProductB {public: AbstractProductB() = default; ~AbstractProductB() = default; virtual void eat() = 0;};class ProductA1 : public ::AbstractProductA {public: ProductA1() = default; virtual ~ProductA1() = default; void use() override { std::cout \"use ProductA1 \"; }};class ProductA2 : public AbstractProductA {public: ProductA2() = default; virtual ~ProductA2() = default; void use() override { std::cout \"use ProductA2 \"; }};class ProductB1 : public AbstractProductB {public: ProductB1() = default; virtual ~ProductB1() = default; void eat() override { std::cout \"eat ProductB1 \"; }};class ProductB2 : public AbstractProductB {public: ProductB2() = default; virtual ~ProductB2() = default; void eat() override { std::cout \"eat ProductB2 \"; }};class AbstractFactory {public: AbstractFactory() = default; virtual ~AbstractFactory() = default; virtual AbstractProductA *createProductA() = 0; virtual AbstractProductB *createProductB() = 0;};class ConcreteFactory1 : public AbstractFactory {public: ConcreteFactory1() = default; virtual ~ConcreteFactory1() = default; AbstractProductA *createProductA() override { return new ProductA1(); } AbstractProductB *createProductB() override { return new ProductB1(); }};class ConcreteFactory2 : public AbstractFactory {public: ConcreteFactory2() = default; virtual ~ConcreteFactory2() = default; AbstractProductA *createProductA() override { return new ProductA2(); } AbstractProductB *createProductB() override { return new ProductB2(); }}; 抽象工厂模式设计题 【设计模式专题之抽象工厂模式】3. 家具工厂 (kamacoder.com)： 小明家新开了两个工厂用来生产家具，一个生产现代风格的沙发和椅子，一个生产古典风格的沙发和椅子，现在工厂收到了一笔订单，请你帮他设计一个系统，描述订单需要生产家具的信息。 输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示家具的类型。家具类型分为 “modern” 和 “classical” 两种。 对于每笔订单，输出字符串表示该订单需要生产家具的信息。 modern订单会输出下面两行字符串 modern chair modern sofa classical订单会输出下面两行字符串 classical chair classical soft 参考代码： AbstractFactory/main.cpp(github.com) AbstractFactory/main.cpp(gitee.com) 建造者模式 建造者（生成器）模式是创建型设计模式。主要思想是将对象的构建过程分为多个步骤，每个步骤定义一个抽象接口，具体构建过程有具体建造者类完成，同时有一个指导者类负责协调建造者的工作。 建造者模式有以下角色： 产品：被构建的负责对象，包含多个组成部分。 抽象建造者：定义构建产品各部分的抽象类和一个返回复杂产品的方法。 具体建造者：实现抽象类的方法，构建产品各部分。 指导者：调用具体建造者的方法，按照一定顺序或逻辑构建。 建造者模式的使用情形 比如 Junit 中的测试构建器 TestBuilder，构建测试对象。 建造者模式的优点和缺点 将一个复杂对象的构建与其表示分离。 同样的构建过程可以创建不同的表示。 适用于复杂对象的创建。 当产品的构建过程发⽣变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难。 建造者模式的实现 参考代码： #pragma once#include iostreamclass Product {public: void setPart1(const std::string part1) { this-part1 = part1; } void setPart2(const std::string part2) { this-part2 = part2; } std::string getProduct() const { return part1 + \" \" + part2; }private: std::string part1; std::string part2;};class Builder {public: virtual ~Builder() = default; virtual void buildPart1() = 0; virtual void buildPart2() = 0; virtual Product* getProduct() = 0;};class ConcreteBuilder : public Builder {public: ConcreteBuilder() { product = new Product(); } ~ConcreteBuilder() { delete product; } void buildPart1() override { product-setPart1(\"Part1\"); } void buildPart2() override { product-setPart2(\"Part2\"); } Product* getProduct() override { return product; }private: Product* product = nullptr;};class Director {public: void construct(Builder* builder) { builder-buildPart1(); builder-buildPart2(); }}; 建造者模式设计题 【设计模式专题之建造者模式】4. 自行车加工 (kamacoder.com)： 小明家新开了一家自行车工厂，用于使用自行车配件（车架 frame 和车轮 tires ）进行组装定制不同的自行车，包括山地车和公路车。 山地车使用的是Aluminum Frame（铝制车架）和 Knobby Tires（可抓地轮胎），公路车使用的是 Carbon Frame （碳车架）和 Slim Tries。 现在它收到了一笔订单，要求定制一批自行车，请你使用【建造者模式】告诉小明这笔订单需要使用那些自行车配置吧。 输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示客户的自行车需求。 字符串可以包含关键词 “mountain” 或 “road”，表示客户需要山地自行车或公路自行车。 对于每笔订单，输出该订单定制的自行车配置。 参考代码： Builder/main.cpp(github.com) Builder/main.cpp(gitee.com) 原型模式 原型模式是创建型设计模式。核心思想是基于现有的对象创建新的对象。 原型模式包含两个重点模块： 抽象原型类，且具有克隆自身的方法。 具体原型类，实现克隆方法，复制当前对象并返回一个新对象。 原型模式的使用情形 通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。 当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式。 在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。 原型模式的例子： Java 提供了 Object 类的 clone() 方法，可以实现对象的浅拷贝。类需要实现 Cloneable 接口并重写 clone() 方法。 在 .NET 中，ICloneable 接口提供了 Cloneable 接口并重写 Clone 方法，可以用于实现对象的克隆。 Spring 框架中的 Bean 的作用域之一是原型作用域（Prototype Scope），在这个作用域下，Spring 框架会为每次请求创建⼀个新的 Bean 实例，类似于原型模式。 原型模式的实现 参考代码： class Prototype {public:\tvirtual ~Prototype() = default;\tvirtual Prototype *clone() = 0;};class ConcretePrototype : public Prototype {public:\tConcretePrototype(std::string const data) : m_data(data) {}\tvirtual ~ConcretePrototype() = default;\tPrototype *clone() override { return new ConcretePrototype(this-m_data);\t}\tstd::string getData() const { return m_data;\t}private:\tstd::string m_data;} 原型模式设计题 【设计模式专题之原型模式】5. 矩形原型 (kamacoder.com)： 公司正在开发一个图形设计软件，其中有一个常用的图形元素是矩形。设计师在工作时可能需要频繁地创建相似的矩形，而这些矩形的基本属性是相同的（颜色、宽度、高度），为了提高设计师的工作效率，请你使用原型模式设计一个矩形对象的原型。使用该原型可以快速克隆生成新的矩形对象。 首先输入一个字符串，表示矩形的基本属性信息，包括颜色、长度和宽度，用空格分隔，例如 “Red 10 5”。 然后输入一个整数 N（1 ≤ N ≤ 100），表示使用原型创建的矩形数量。 对于每个矩形，输出一行字符串表示矩形的详细信息，如 “Color: Red, Width: 10,Height: 5”。 参考代码： Prototype/main.cpp(github.com) Prototype/main.cpp(gitee.com) 结构型设计模式 适配器模式 适配器模式是结构型设计模式。它将一个类的接口转换成客户希望的另一个接口，充当两个不同接口的桥梁，让不兼容的类一起工作。 适配器模式的基本角色有： 目标接口：客户端希望使用的接口。 适配器类：实现客户端使用的接口，包含一个需要适配的类实例，起到转接扩展的作用。 被适配者：需要被适配的类。 适配器模式的使用情形 扮演着补救和扩展角色。 不同的项目和库可能使用不同的日志框架，不同的日志框架提供的 API 也不同，因此引⼊了适配器模式使得不同的 API 适配为统一接口。 Spring MVC 中，HandlerAdapter 接口就是适配器模式，将处理器适配到框架中，使得不同类型的处理器能够统一处理请求。 适配器模式的实现 // 目标接口class Target {public:\tvirtual void request() = 0;};// 被适配者class Adaptee {public:\tvoid specificRequest() { std::cout \"specificRequest\" std::endl;\t}};// 适配器类class Adapter : public Target {public:\tAdapter(Adaptee *adaptee) { m_adaptee = adaptee;\t}\tvoid request() override { m_adaptee-specificRequest();\t}private:\tAdaptee *m_adaptee;}; 适配器模式设计题 【设计模式专题之适配器模式】6. 扩展坞 (kamacoder.com)： 小明购买了一台新电脑，该电脑使用 TypeC 接口，为了确保新电脑可以使用现有的USB接口充电器和数据线，他购买了一个TypeC到USB的扩展坞。 请你使用适配器模式设计并实现这个扩展坞系统，确保小明的新电脑既可以通过扩展坞使用现有的USB接口充电线和数据线，也可以使用TypeC接口充电。 题目包含多行输入，第一行输入一个数字 N （1 N = 20)，表示后面有N组测试数据。 之后N行都是一个整数，1表示使用电脑本身的TypeC接口，2表示使用扩展坞的USB接口充电。 根据每行输入，输出相应的充电信息。 参考代码： Adapter/main.cpp(github.com) Adapter/main.cpp(gitee.com) 代理模式 代理模式是结构型设计模式，用于控制对其他对象的访问。 代理模式允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。 通常用于在访问某对象时引入间接层（中介作用），可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。 比如进行文件加载，为了避免直接访问“文件\"对象，可以新增一个代理对象，代理对象中有一个对“文件对象\"的引用，在代理对象的 1oad 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查， 然后调用真实文件对象的 1oad 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。 代理模式的角色有： 抽象主题：抽象类，声明真实主题和代理对象实现的业务方法。 真实主题：定义了代理类所代表的真实对象。 代理类。 代理模式的使用情形 代理模式可以在实际操作的前后添加一些额外的操作，但在多个对象交互之间可能会增加复杂性且降低性能。 代理模式在许多工具和库中也有应用： Spring 框架的 AOP 模块； Java 提供动态代理机制； Android 的 Glide 框架 使用代理模式实现图片的延迟加载。 代理模式的实现 // 抽象对象类class Subject {public:\tvirtual void request() = 0;};// 具体对象类class RealSubject : public Subject {public:\tvoid request() override { std::cout \"RealSubject: Handling request. \";\t}};// 代理类class Proxy : public Subject {public:\tvoid request() override { realSubject.request();\t}private:\tRealSubject realSubject;}; 代理模式目的是控制对对象的访问，同时还可以加入一些额外的逻辑； 适配器模式目的是使不兼容的对象能够协同工作，将一个类的接口转换成另一个类的接口。 代理模式的设计题 【设计模式专题之代理模式】7-小明买房子 (kamacoder.com)： 小明想要购买一套房子，他决定寻求一家房屋中介来帮助他找到一个面积超过100平方米的房子，只有符合条件的房子才会被传递给小明查看。 第一行是一个整数 N（1 ≤ N ≤ 100），表示可供查看的房子的数量。 接下来的 N 行，每行包含一个整数，表示对应房子的房屋面积。 对于每个房子，输出一行，表示是否符合购房条件。如果房屋面积超过100平方米，输出 “YES”；否则输出 “NO”。 参考代码： Proxy/main.cpp(github.com) Proxy/main.cpp(gitee.com) 装饰模式 装饰模式是结构型设计模式。 在不定义子类的情况下动态的给对象添加⼀些额外的功能。 举个例子，假设有一个基础的图形类，想要为图形类添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类。这时就可以考虑使用装饰模式来动态地添加，而不需要修改图形类本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。 装饰模式包含四个角色： 组件：抽象类，是具体组件和装饰者的父类，定义了具体组件需要实现的方法。 具体组件：实现组件的具体方法，是被装饰的对象。 装饰类：一个抽象类，给具体组件添加功能，但具体功能由具体装饰者完成，包含一个组件对象引用。 具体装饰类：扩展实现装饰类，负责向组件对象添加新的行为。 装饰模式的使用情形 不希望使用继承生成子类，给现有的类添加附加功能时； 动态的添加和覆盖功能。 Java 的 I/O 库 中，装饰模式用于增强 I/O 的功能。 装饰模式的实现 class Component {public:\tvirtual ~Component() = default;\tvirtual void operation() = 0;};class ConcreteComponent : public Component {public:\tvoid operation() override { std::cout \"ConcreteComponent operation\" std::endl;\t}};class Decorator : public Component {public:\tDecorator(Component *component) : m_component(component) {}\tvoid operation() override { m_component-operation();\t}protected:\tComponent *m_component;};class ConcreteDecorator : public Decorator {public:\tConcreteDecorator(Component *component) : Decorator(component) {}\tvoid operation() override { Decorator::operation(); std::cout \"ConcreteDecorator operation\" std::endl;\t}}; 装饰模式的设计题 【设计模式专题装饰模式】8-咖啡加糖 (kamacoder.com)： 小明喜欢品尝不同口味的咖啡，他发现每种咖啡都可以加入不同的调料，比如牛奶、糖和巧克力。他决定使用装饰者模式制作自己喜欢的咖啡。 请设计一个简单的咖啡制作系统，使用装饰者模式为咖啡添加不同的调料。系统支持两种咖啡类型：黑咖啡（Black Coffee）和拿铁（Latte）。 多行输入，每行包含两个数字。第一个数字表示咖啡的选择（1 表示黑咖啡，2 表示拿铁），第二个数字表示要添加的调料类型（1 表示牛奶，2 表示糖）。 根据每行输入，输出制作咖啡的过程，包括咖啡类型和添加的调料。 参考代码： Decorator/main.cpp(github.com) Decorator/main.cpp(gitee.com) 外观模式 外观模式是结构型设计模式。 定义一个高层接口，使得子系统更容易使用，同时也隐藏了子系统。 外观模式的角色有： 外观类：对外的一个统一的高层接口。 子系统类：实现子系统的功能，处理外观类指派的任务。 外观模式的使用情形 外观模式隐藏了系统的复杂性，使得客户端不需要直接与子系统交互，只需与外观接口交互即可。 但是如果要添加子系统或者修改子系统的行为，那么需要修改外观类，违背“开闭原则”。 使用外观模式的例子： Spring 框架的 ApplicationContext 可以看作是外观。 JDBC 提供了一个用于数据库交互的接口，DriverManager 类。 Android 系统的 API。 外观模式的实现 参考代码： class SubSystemA {public:\tvoid operationA() { std::cout \"operationA\" std::endl;\t}};class SubSystemB {public:\tvoid operationB() { std::cout \"operationB\" std::endl;\t}};class SubSystemC {public:\tvoid operationC() { std::cout \"operationC\" std::endl;\t}};class Facade {public:\tvoid operation() { subSystemA.operationA(); subSystemB.operationB(); subSystemC.operationC();\t}private:\tSubSystemA subSystemA;\tSubSystemB subSystemB;\tSubSystemC subSystemC;}; 外观模式的设计题 【设计模式专题之外观模式】9-电源开关 (kamacoder.com)： 小明家的电源总开关控制了家里的三个设备：空调、台灯和电视机。每个设备都有独立的开关密码，分别用数字1、2和3表示。即输入1时，空调关闭，输入2时，台灯关闭，输入3时，电视机关闭，当输入为4时，表示要关闭所有设备。请你使用外观模式编写程序来描述电源总开关的操作。 第一行是一个整数 N（1 = N = 100），表示后面有 N 行输入。 接下来的 N 行，每行包含一个数字，表示对应设备的开关操作（1表示关闭空调，2表示关闭台灯，3表示关闭电视机，4表示关闭所有设备）。 输出关闭所有设备后的状态，当输入的数字不在1-4范围内时，输出Invalid device code. 参考代码： Facade/main.cpp(github.com) Facade/main.cpp(gitee.com) 桥接模式 桥接模式是结构型设计模式。其 UML 图很像一座桥。 将抽象部分与实现部分分离，通过组合建立两个类之间的联系，而不是继承。 桥接模式的角色有： 抽象：抽象类，定义抽象部分的接口，维护一个对实现的引用。 修正抽象：对抽象类进行扩展。 实现：定义实现的接口，抽象化接口的实现。 具体实现：实现接口的具体类，实现具体操作。 举个例子，图形编辑器中，每一种图形都需要蓝色、红色、黄色不同的颜色。 不使用桥接模式，可能需要为每一种图形类型和每一种颜色都创建一个具体的子类； 使用桥接模式可以将图形和颜色两个维度分离，两个维度都可以独立进行变化和扩展，如果要新增其他颜色，只需添加新的 Co1or 子类，不影响图形类；反之亦然。 桥接模式的使用情形 使用情况： 一个类存在两个独立变化的维度，且两个维度都需要扩展时； 不希望使用继承时。 适用于多个独立变化维度，需要灵活扩展的系统。 桥接模式的实现 // 实现class Implementation {public:\tvirtual void operationImpl() {};};// 具体实现Aclass ConcreteImplementationA : public Implementation {public:\tvoid operationImpl() override {};};// 具体实现Bclass ConcreteImplementationB : public Implementation {public:\tvoid operationImpl() override {};};// 抽象class Abstraction {public:\tAbstraction(Implementation *impl) : impl(impl) {}\tvirtual void operation() = 0;protected:\tImplementation *impl;};// 修正抽象class RefinedAbstraction : public Abstraction {public:\tRefinedAbstraction(Implementation *impl) : Abstraction(impl) {}\tvoid operation() override { impl-operationImpl();\t}}; 桥接模式的设计题 【设计模式专题之桥接模式】10-万能遥控器 (kamacoder.com)： 小明家有一个万能遥控器，能够支持多个品牌的电视。每个电视可以执行开机、关机和切换频道的操作，请你使用桥接模式模拟这个操作。 第一行是一个整数 N（1 = N = 100），表示后面有 N 行输入。 接下来的 N 行，每行包含两个数字。第一个数字表示创建某个品牌的遥控和电视，第二个数字表示执行的操作。 其中，0 表示创建 Sony 品牌的电视，1 表示创建 TCL 品牌的遥控和电视； 2 表示开启电视、3表示关闭电视，4表示切换频道。 对于每个操作，输出相应的执行结果。 参考代码： Bridge/main.cpp(github.com) Bridge/main.cpp(gitee.com) 组合模式 组合模式是结构型设计模式。 将对象组合成树状结构来表示部分和整体的层次关系。 组合模式使得客户端可以统一处理单个对象和对象的集合。 组合模式的角色有： 组件：根节点，定义组合中所有对象的通用接口，定义共性内容。 叶子：实现组件的内容，表示组合中的叶子对象。 合成：存储子部件，实现对子部件的相关操作，比如添加、删除、获取子组件等。 比如，省份中包含了多个城市，如果比喻成一个树形结构，城市就是叶子节点，它是省份的组成部分，而省份就是合成节点，可以包含其他城市。省份和城市都是组件，它们都有一些共同的操作，比如获取信息。 通过组合模式，整个省份的获取信息操作可以一次性执行，无需关心省份中的具体城市。 组合模式的使用情形 可以使得客户端统一处理单个对象和组合对象。适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。 组合模式的实现 // 组件class Component {public:\tvirtual ~Component() = default;\tvirtual void operation() = 0;};// 叶子节点class Leaf : public Component {public:\tvoid operation() override { std::cout \"Leaf operation\" std::endl;\t}};// 组合节点：包含叶子节点的操作行为class Composite : public Component {public:\tvoid add(Component *component) { m_component.push_back(std::make_uniqueComponent(component));\t}\tvoid remove(Component *component) { // ...\t}\tvoid operation() override { std::cout \"Composite operation\" std::endl; for (auto component : m_component) { component-operation(); }\t}private:\tstd::vectorstd::unique_ptrComponent m_component;}; 组合模式的设计题 【设计模式专题之组合模式】11-公司组织架构 (kamacoder.com)： 小明所在的公司内部有多个部门，每个部门下可能有不同的子部门或者员工。 请你设计一个组合模式来管理这些部门和员工，实现对公司组织结构的统一操作。部门和员工都具有一个通用的接口，可以获取他们的名称以及展示公司组织结构。 第一行是一个整数 N（1 = N = 100），表示后面有 N 行输入。 接下来的 N 行，每行描述一个部门或员工的信息。部门的信息格式为 D 部门名称，员工的信息格式为 E 员工名称，其中 D 或 E 表示部门或员工。 输出公司的组织结构，展示每个部门下的子部门和员工 参考代码： Combination/main.cpp(github.com) Combination/main.cpp(gitee.com) 享元模式 享元模式是结构型设计模式。 对象被设计为可共享的，可被多个上下文使用。 认识并区分内部状态和外部状态： 内部状态：指那些可以被多个对象共享的状态，存储在享元对象内部，对于所有享元对象都是相同的，这部分状态通常是不变的。 外部状态：享元对象依赖的、可变的部分，这部分状态不存储在享元对象内部，而是使用享元对象时通过参数传递给对象。 享元模式的角色有： 抽象享元类：所以具体享元类的共享接口，包含对外部状态的操作。 具体享元类：继承实现享元接口，包含内部状态。 享元工厂类：创建并管理享元对象，当用户请求时，提供实例。 客户端：维护外部状态，在使用享元对象时，将外部状态传递给享元对象。 享元模式的使用情形 享元模式适用于包含大量相似对象，并且这些对象的内部状态可以共享。 具体的应用场景包括文本编辑器，图形编辑器，游戏中的角色创建，这些对象的内部状态比较固定（外观，技能，形状），但是外部状态变化比较大时，可以使用。 享元模式的实现 class FlyWeight {public: virtual ~FlyWeight() = default; virtual void operation(std::string externalState) = 0;};class ConcreteFlyWeight : public FlyWeight {public: ConcreteFlyWeight(std::string const state) : m_state(state) {} void operation(std::string externalState) override { std::cout \"ConcreteFlyWeight: \" m_state \" \" externalState std::endl; }private: std::string m_state; // 内部状态};class FlyWeightFactory {public: FlyWeight* getFlyWeight(std::string key) { if (m_flyweights.find(key) == m_flyweights.end()) { FlyWeight* flyweight = new ConcreteFlyWeight(key); m_flyweights[key] = flyweight; } return m_flyweights[key]; }private: std::mapstd::string, FlyWeight* m_flyweights;}; 享元模式的设计题 【设计模式专题之享元模式】12-图形编辑器 (kamacoder.com)： 在一个图形编辑器中，用户可以绘制不同类型的图形，包括圆形（CIRCLE）、矩形（RECTANGLE）、三角形（TRIANGLE）等。现在，请你实现一个图形绘制程序，要求能够共享相同类型的图形对象，以减少内存占用。 输入包含多行，每行表示一个绘制命令。每个命令包括两部分： 图形类型（Circle、Rectangle 或 Triangle） 绘制的坐标位置（两个整数，分别表示 x 和 y） 对于每个绘制命令，输出相应图形被绘制的位置信息。如果图形是首次绘制，输出 “drawn at”，否则输出 “shared at”。 参考代码： FlyWeight/main.cpp(github.com) FlyWeight/main.cpp(gitee.com) 行为型设计模式 观察者模式 观察者模式（发布-订阅模式）是行为型设计模式。 定义了一种一对多的依赖关系，多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。 观察者模式有两个角色： 主题：被观察的对象，维护一组观察者，自身变化时通知观察者。 观察者：观察主题的对象，当主题发生变化，会得到通知。 具体可以设计为四个角色： 抽象主题：抽象类，提供注册、删除和通知观察者的方法，通常包含一个状态。 抽象观察者：抽象类，包含一个更新方法。 具体主题：主题的具体实现，维护一个观察者列表，实现抽象类的方法。 具体观察者：观察者的具体实现，每个具体观察者都注册到具体主题中，实现抽象类方法。 观察者模式可以将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。 观察者模式的使用情形 观察者模式特别适用于一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。 图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于 GUl 框架，比如 Java 的 Swing 框架。 前端开发中，比较典型的例子是前端框架 Vue，当数据发生变化时，视图会自动更新。 分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。 观察者模式的实现 class Observer {public: virtual ~Observer() = default; virtual void update(std::string message) = 0;};class Subject {public: virtual ~Subject() = default; virtual void registerObserver(Observer *observer) = 0; virtual void removeObserver(Observer *observer) = 0; virtual void notifyObserver() = 0;};class ConcreteSubject : public Subject {public: ~ConcreteSubject() = default; void registerObserver(Observer *observer) override { observers.emplace_back(observer); } void removeObserver(Observer *observer) override { observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); } void notifyObserver() override { for (auto observer : observers) { observer-update(state); } } void setState(std::string state) { this-state = state; notifyObserver(); }private: std::vectorObserver * observers; std::string state;};class ConcreteObserver : public Observer {public: ~ConcreteObserver() = default; void update(std::string message) override { std::cout \"ConcreteObserver: \" message std::endl; }}; 观察者模式的设计题 【设计模式专题之观察者模式】13. 时间观察者 (kamacoder.com)： 小明所在的学校有一个时钟（主题），每到整点时，它就会通知所有的学生（观察者）当前的时间，请你使用观察者模式实现这个时钟通知系统。 注意点：时间从 0 开始，并每隔一个小时更新一次。 输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示学生的数量。 接下来的 N 行，每行包含一个字符串，表示学生的姓名。 最后一行是一个整数，表示时钟更新的次数。 对于每一次时钟更新，输出每个学生的姓名和当前的时间。 参考代码： Observer/main.cpp(github.com) Observer/main.cpp(gitee.com) 策略模式 策略模式是行为型设计模式。 定义一系列算法（完成相同工作，实现不同），并将每个算法封装起来，可以相互替换，算法的变化不会影响使用算法的客户。 策略模式的角色有： 策略类：抽象类，定义所有支持的算法。 具体策略类：实现策略类的方法。 上下文类：包含一个策略实例，并在需要时调用策略对象方法。 举个例子，电商网站对于商品的折扣策略有不同的算法，比如新用户满减优惠，不同等级会员的打折情况不同。 一般情况下，产生大量的 if-e1se 语句，并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。 可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。 策略模式的使用情形 使用策略模式的情形： 当一个系统根据业务场景需要动态地在几种算法中选择一种时，例如，根据用户的行为选择不同的计费策略。 当代码中存在大量条件判断，条件判断的区别仅仅在于行为。 在已有的工具库中，Java 标准库中的 Comparator 接口就使用了策略模式，通过实现这个接口，可以创建不同的比较器（指定不同的排序策略）来满足不同的排序需求。 策略模式的实现 class Strategy {public: virtual ~Strategy() = default; virtual void AlgorithmInterface() = 0;};class ConcreteStrategyA : public Strategy {public: void AlgorithmInterface() override { std::cout \"Called ConcreteStrategyA's AlgorithmInterface\" std::endl; }};class ConcreteStrategyB : public Strategy {public: void AlgorithmInterface() override { std::cout \"Called ConcreteStrategyB's AlgorithmInterface\" std::endl; }};class Context {public: Context(Strategy* strategy) : m_strategy(strategy) {} void ContextInterface() { m_strategy-AlgorithmInterface(); }private: Strategy* m_strategy;}; 策略模式的设计题 【设计模式专题之策略模式】14. 超市打折 (kamacoder.com)： 小明家的超市推出了不同的购物优惠策略，你可以根据自己的需求选择不同的优惠方式。其中，有两种主要的优惠策略： 九折优惠策略：原价的90%。 满减优惠策略：购物满一定金额时，可以享受相应的减免优惠。 具体的满减规则如下： 满100元减5元 满150元减15元 满200元减25元 满300元减40元 请你设计一个购物优惠系统，用户输入商品的原价和选择的优惠策略编号，系统输出计算后的价格。 输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示需要计算优惠的次数。 接下来的 N 行，每行输入两个整数，第一个整数M( 0 M 400) 表示商品的价格, 第二个整数表示优惠策略，1表示九折优惠策略，2表示满减优惠策略 每行输出一个数字，表示优惠后商品的价格 参考代码： Strategy/main.cpp(github.com) Strategy/main.cpp(gitee.com) 命令模式 命令模式是行为型设计模式。 允许将请求封装成一个对象（命令对象，包含执行操作所需的所有信息），并将命令对象按照一定顺序存储在队列中，再逐一调用执行，命令支持反向操作、撤消重做。 命令模式的角色有： 抽象命令类：抽象类，定义执行操作的接口。 具体命令类：实现命令，执行具体操作。 接收者类：接受并执行命令的对象。 调用者：发起请求的对象。不关心命令的具体实现。 使用时创建具体的命令对象和接收者对象，将其组装起来。 命令模式的使用情形 命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。 撤销操作：需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。 队列请求：命令模式可以将请求排队，形成一个命令队列，依次执行命令。 可扩展性：可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。 但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。 命令模式同样有着很多现实场景的应用： 比如 Git 中的很多操作，如提交（commit）、合并（merge）等，都可以看作是命令模式的应用，用户通过执行相应的命令来操作版本库。 Java 的 GUI 编程中，很多事件处理机制也都使用了命令模式。例如，每个按钮都有一个关联的Action，它代表一个命令，按钮的点击触发 Action 的执行。 命令模式的实现 // 抽象命令类class Command {public: virtual ~Command() {} virtual void execute() = 0;};// 接收者class Receiver {public: void action() { std::cout \"Receiver::action()\" std::endl; }};// 调用者class Invoker {public: Invoker(Command *command) : m_command(command) {} void executeCommand() { m_command-execute(); }private: Command *m_command;};// 具体命令类class ConcreteCommand : public Command {public: ConcreteCommand(Receiver receiver) : m_receiver(receiver) {} void execute() override { m_receiver.action(); }private: Receiver m_receiver;}; 命令模式的设计题 【设计模式专题之命令模式】15-自助点餐机 (kamacoder.com)： 小明去奶茶店买奶茶，他可以通过在自助点餐机上来点不同的饮品，请你使用命令模式设计一个程序，模拟这个自助点餐系统的功能。 输入第一行是一个整数 n（1 ≤ n ≤ 100），表示点单的数量。接下来的 n 行，每行包含一个字符串，表示点餐的饮品名称。 输出执行完所有点单后的制作情况，每行输出一种饮品的制作情况。如果制作完成，输出 “XXX is ready!”，其中 XXX 表示饮品名称。 参考代码： Command/main.cpp(github.com) Command/main.cpp(gitee.com) 中介者模式 中介者模式也称为调停者模式，是行为型设计模式。 通过一个中介对象来封装一组对象之间的交互，从而使得这些对象之间不需要相互引用。 中介者模式的角色有： 抽象中介者：抽象类，定义中介者接口，用于各个具体同事对象之间的通信。 具体中介者：实现抽象类方法，协调各个具体同事对象的交互关系。 抽象同事类：抽象类，定义同事类接口，维护一个对中介者对象的引用，用于通信。 具体同事类：实现抽象类方法，每个具体同事类只知道自己的行为，不了解其他同事类的情况。 与代理模式区别 中介者模式与代理模式在表述上类似，但是解决不同类型的问题： 中介者模式通过一个中介者对象，使得系统中的其他对象通过中介者进行通信交互，降低了系统各个对象间的直接耦合。 代理模式通过一个代理类，使得客户端可以与目标对象进行通信，且可以在调用实际目标对象方法前后进行额外的操作，控制对象的访问。 中介者模式的使用情形 中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。 中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化， 中介者模式的实现 class Colleague;// 抽象中介者class Mediator {public: virtual ~Mediator() {} virtual void Register(Colleague *colleague) = 0; virtual void Send(std::string const message, Colleague *colleague) = 0;};// 具体中介者class ConcreteMediator : public Mediator {public: void Register(Colleague *colleague) override { m_colleagues.push_back(colleague); } void Send(std::string const message, Colleague *colleague) override { for (auto const c : m_colleagues) { if (c != colleague) { c-receive(message); } } }private: std::vectorColleague * m_colleagues;};// 抽象同事class Colleague {public: virtual ~Colleague() {} virtual void send(std::string const message) = 0; virtual void receive(std::string const message) = 0;protected: Mediator *m_mediator;};// 具体同事Aclass ConcreteColleagueA : public Colleague {public: ConcreteColleagueA(Mediator *mediator) { m_mediator = mediator; } void send(std::string const message) override { m_mediator-Send(message, this); } void receive(std::string const message) override { std::cout \"ColleagueA received: \" message std::endl; }};// 具体同事Bclass ConcreteColleagueB : public Colleague {public: ConcreteColleagueB(Mediator *mediator) { m_mediator = mediator; } void send(std::string const message) override { m_mediator-Send(message, this); } void receive(std::string const message) override { std::cout \"ColleagueB received: \" message std::endl; }}; 中介者模式的设计题 【设计模式专题之中介者模式】16-简易聊天室 (kamacoder.com)： 小明正在设计一个简单的多人聊天室系统，有多个用户和一个聊天室中介者，用户通过中介者进行聊天，请你帮他完成这个系统的设计。 第一行包括一个整数N,表示用户的数量（1 = N = 100) 第二行是N个用户，比如User1 User2 User3，用空格分隔。第三行开始，每行包含两个字符串，表示消息的发出者和消息内容，用空格分隔。 对于每个用户，输出一行，包含该用户收到的所有消息内容。 参考代码： Mediator/main.cpp(github.com) Mediator/main.cpp(gitee.com) 备忘录模式 备忘录模式是行为型设计模式。 允许在不暴露对象实现的情况下捕获对象的内部状态并在对象之外保存这个状态，以便可以还原状态。 备忘录的角色有： 发起人：需要还原状态的对象，负责创建备忘录，使用备忘录记录。 备忘录：存储发起人对象的内部状态，包含发起人部分或全部状态信息，但对外不可见，仅发起人可见。 管理者：负责（一个或多个）存储备忘录对象，但不了解其内部结构。 备忘录模式的使用情形 备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过备份对象往往会消耗较多的内存，资源消耗增加。 备忘录模式常常用来实现撤销和重做功能，比如在 Java Swing GUI 编程中，javax.swing.undo 包中的撤销（undo）和重做（redo）机制使用了备忘录模式。UndoManager 和 UndoableEdit 接口是与备忘录模式相关的主要类和接口。 备忘录模式的实现 // 备忘录class Memento {public: Memento(std::string state) : m_state(state) {} std::string getState() const { return m_state; }private: std::string m_state;};// 发起人class Originator {public: void setState(std::string state) { m_state = state; } std::string getState() const { return m_state; } Memento *createMemento() { return new Memento(m_state); } void restoreFromMemento(Memento *memento) { m_state = memento-getState(); }private: std::string m_state;};// 管理者class Caretaker {public: void addMemento(Memento *memento) { m_mementos.emplace_back(memento); } Memento *getMemento(int idx) { if (idx = 0 idx m_mementos.size()) return m_mementos[idx]; }private: std::vectorMemento * m_mementos;}; 备忘录模式的设计题 【设计模式专题之备忘录模式】17-redo计数器应用 (kamacoder.com)： 小明正在设计一个简单的计数器应用，支持增加（Increment）和减少（Decrement）操作，以及撤销（Undo）和重做（Redo）操作，请你使用备忘录模式帮他实现。 输入包含若干行，每行包含一个字符串，表示计数器应用的操作，操作包括 “Increment”、“Decrement”、“Undo” 和 “Redo”。 对于每个 “Increment” 和 “Decrement” 操作，输出当前计数器的值，计数器数值从0开始 对于每个 “Undo” 操作，输出撤销后的计数器值。 对于每个 “Redo” 操作，输出重做后的计数器值。 参考代码： Memento/main.cpp(github.com) Memento/main.cpp(gitee.com) 模板方法模式 模板方法模式是行为型设计模式。 定义一个算法骨架，将一些步骤的实现延迟到子类。 模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 举个简单的例子，做一道菜通常都需要包含至少三步：准备食材；亨饪过程；上菜。 不同菜品的亨饪过程是不一样的，但是可以先定义一个“骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。 模板方法模式的角色有： 模板类：一个模板方法和若干个基本方法构成。 模板方法定义逻辑的骨架，按照顺序调用包含的基本方法。 基本方法通常是抽象方法，由子类实现。 基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，可以在具体子类中继承或重写。 具体类：继承自模板类，实现在模板类中定义的抽象方法。 模板方法模式的使用情形 模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。 总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板方法模式来处理。如： Spring 框架中的 JdbcTemplate 类使用了模板方法模式，其中定义了一些执行数据库操作的模板方法，具体的数据库操作由回调函数提供。 Java 的 JDK 源码中，AbstractList 类也使用了模板方法模式，它提供了一些通用的方法，其中包括一些模板方法。具体的列表操作由子类实现。 模板方法模式的实现 // 模板类class AbstractClass {public: virtual ~AbstractClass() = default; void templateMethod() { step1(); step2(); step3(); }protected: virtual void step1() {} virtual void step2() {} virtual void step3() {}};// 具体类class ConcreteClass : public AbstractClass {protected: void step1() override { std::cout \"Step 1 \"; } void step2() override { std::cout \"Step 2 \"; } void step3() override { std::cout \"Step 3 \"; }}; 模板方法模式的设计题 【设计模式专题之模板方法模式】18-咖啡馆 (kamacoder.com)： 小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。 咖啡制作过程包括以下步骤： 研磨咖啡豆 Grinding coffee beans 冲泡咖啡 Brewing coffee 添加调料 Adding condiments 其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk。 多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。 根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。 参考代码： TemplateMethod/main.cpp(github.com) TemplateMethod/main.cpp(gitee.com) 迭代器模式 迭代器模式是行为型设计模式。 提供一种统一的方式访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。 迭代器模式的角色有： 迭代器抽象类：定义访问和遍历元素的接口。 具体迭代器：实现抽象迭代器。 抽象聚合类：定义创建迭代器接口，创建迭代器对象。 具体聚合类：实现抽象聚合类方法。 迭代器模式的使用情形 迭代器模式使用很广泛。客户端不需要知道集合的内部结构，只需要关心迭代器和迭代器接口就可以完成元素的访问。如： Java 的集合类，ArrayList、LinkedList。 Python 的 iter() 、 next()。 C++ 中 STL 的迭代器，begin()、end()。 迭代器模式的实现 // 抽象迭代器template typename Tclass Iterator {public: virtual ~Iterator() = default; virtual bool hasNext() = 0; virtual T next() = 0;};// 具体迭代器template typename Tclass ConcreteIterator : public Iterator {public: ConcreteIterator(std::vectorT elements) : m_elements(elements) , m_idx = 0 {} void bool hasNext() override { return m_idx m_elements.size(); } T next() override { if (hasNext()) { return m_elements[m_idx++]; } return nullptr; }private: int m_idx; std::vectorT m_elements;};// 抽象聚合template typename Tclass Iterable {public: virtual ~Iterable() = default; virtual IteratorT *createIterator() = 0;};// 具体聚合template typename Tclass ConcreteIterable : public Iterable {public: ConcreteIterable(std::vectorT elements) : m_elements(elements) {} IteratorT *createIterator() override { return new ConcreteIterator(m_elements); }private: std::vectorT m_elements;}; 迭代器模式的设计题 【设计模式专题之迭代器模式】19-学生名单 (kamacoder.com)： 小明是一位老师，在进行班级点名时，希望有一个学生名单系统，请你实现迭代器模式提供一个迭代器使得可以按顺序遍历学生列表。 第一行是一个整数 N （1 = N = 100), 表示学生的数量。 接下来的 N 行，每行包含一个学生的信息，格式为 姓名 学号 输出班级点名的结果，即按顺序遍历学生列表，输出学生的姓名和学号 参考代码： Iterator/main.cpp(github.com) Iterator/main.cpp(gitee.com) 状态模式 状态模式是行为型设计模式。 将对象每个状态的行为封装在一个具体类中，使得每个状态类相互独立，对象从而可以在运行时动态改变。 状态模式的角色有： 抽象状态类：抽象类，封装 Context 的一个特定状态相关的行为。 具体状态类：为每一个具体状态实现一个行为。 Context 类：维护一个具体状态的子类实例，实例定义当前状态。 状态模式的使用情形 适用于一个对象在不同状态下有不同的行为。 适用于有限状态机的场景，其中对象的行为在运行时可以根据内部状态的改变而改变。 在游戏开发中，Unity 3D 的 Animator 控制器就是一个状态机。它允许开发人员定义不同的状态（动画状态），并通过状态转换来实现角色的动画控制和行为切换。 状态模式的实现 // 抽象状态类class State {public: virtual ~State() = default; virtual void handle() = 0;};// 具体状态 Aclass ConcreteStateA : public State {public: void handle() override { std::cout \"状态A下的操作 \"; }};// 具体状态 Bclass ConcreteStateB : public State {public: void handle() override { std::cout \"状态B下的操作 \"; }};class Context {public: void setState(State *state) { currentState = state; } void request() { currentState-handle(); }private: State *currentState;}; 状态模式的设计题 【设计模式专题之状态模式】20-开关台灯 (kamacoder.com)： 小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（“ON”）、关闭（“OFF”）和闪烁（“blink”）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。 第一行是一个整数 n（1 = n = 1000），表示接收的命令数量。 接下来的 n 行，每行包含一个字符串 s，表示一个命令（“ON”、“OFF\"或\"blink”）。 对于每个命令，输出一行，表示执行该命令后灯泡的状态。 参考代码： State/main.cpp(github.com) State/main.cpp(gitee.com) 责任链模式 责任链模式是行为型设计模式。 允许构建一个对象链，请求从链的一端进入，沿着链上的对象依次处理，直至链上某个对象能够处理该请求。 责任链模式的角色有： 处理者：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一处理者的链接。 具体处理者：实现处理请求的方法，判断能否处理，能处理则处理，否则传递下一处理者。 责任链模式的使用情形 责任链模式优点有： 降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与自己相关的请求，客户端不需要知道具体是哪个处理者处理请求。 增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满足不同需求。 但是由于一个请求可能会经过多个处理者，这可能会导致一些性能问题，并且如果整个链上也没有合适的处理者来处理请求，就会导致请求无法被处理。 实际使用有 Java 开发中过滤器的链式处理，以及 Spring 框架中的拦截器，都组装成一个处理链对请求、响应进行处理。 责任链模式的实现 // 处理者class Handler {public: virtual void handleRequest(int requestId) = 0; virtual void setNextHandler(Handler *next) = 0;protected: Handler *m_nextHandler;};// 具体处理者class ConcreteHandler : public Handler {public: void handleRequest(int requestId) { if (canHandle(requestId)) { std::cout \"ConcreteHandler::handleRequest() \" requestId std::endl; return; } else if (m_nextHandler != nullptr) { m_nextHandler-handleRequest(requestId); } else { // 无法处理请求 } } void setNextHandler(Handler *next) { m_nextHandler = next; }private: bool canHandle(int requestId) { // 根据具体情况判断是否能处理请求 return requestId 0; }}; 责任链模式的设计题 【设计模式专题之责任链模式】21-请假审批 (kamacoder.com)： 小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。 审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。 第一行是一个整数N（1 = N = 100), 表示请求申请的数量。 接下来的N行，每行包括一个请求申请的信息，格式为\"姓名 请假天数\" 对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。 参考代码： ResponsibilityChain/main.cpp(github.com) ResponsibilityChain/main.cpp(gitee.com) 解释器模式 解释器模式是行为型设计模式。 定义了语言的文法，并且建立一个解释器解释句子。 解释器模式的角色有： 抽象表达式：定义了解释器抽象类，包含解释器方法。 终结符表达式：语法中不能再分解为更小单元的符号。 非终结符表达式：复杂表达式，由终结符和其他非终结符组成。 上下文：解释器之外的全局信息，存储解释器中间结果，也可以向解释器传递信息。 比如表达式 1+1，数字 1 是终结符，而运算符 + 需要两个操作数，属于非终结符。 解释器模式的使用情形 当需要解释和执行特定领域或业务规则的语言时，可以使用解释器模式。例如： SQL 解释器; 正则表达式解释器。 但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使用要慎重。 解释器模式的实现 // 抽象表达式class Expression {public: virtual ~Expression() = default; virtual int interpret() = 0;};// 终结符表达式class TerminalExpression : public Expression {public: TerminalExpression(int value) : m_value(value) {} int interpret() override { return m_value; }private: int m_value;};// 非终结符表达式，此处举例为加法class AddExpression : public Expression {public: AddExpression(Expression *left, Expression *right) : m_left(left) , m_right(right) {} int interpret() override { return m_left-interpret() + m_right-interpret(); }private: Expression *m_left; Expression *m_right;};class Context {public: // 存储一些全局信息或状态}; 解释器模式的设计题 【设计模式专题之解释器模式】22-数学表达式 (kamacoder.com)： 小明正在设计一个计算器，用于解释用户输入的简单数学表达式，每个表达式都是由整数、加法操作符+、乘法操作符组成的，表达式中的元素之间用空格分隔，请你使用解释器模式帮他实现这个系统。 每行包含一个数学表达式，表达式中包含整数、加法操作符（+）和乘法操作符（*）。 表达式中的元素之间用空格分隔。 对于每个输入的数学表达式，每行输出一个整数，表示对应表达式的计算结果。 参考代码： Interpreter/main.cpp(github.com) Interpreter/main.cpp(gitee.com) 访问者模式 访问者模式是行为型设计模式。 在不改变对象结构的前提下，对对象中的元素进行新的操作。 访问者模式的角色有： 抽象访问者：抽象类，声明访问者可以访问的元素，以及声明访问方法。 具体访问者：实现了抽象类的方法。 抽象元素：定义方法接受访问者的访问。 具体元素：实现抽象元素的方法。 对象结构：元素的集合，负责遍历元素，并调用元素的接受方法。 访问者模式的使用情形 访问者模式结构较为复杂，但是访问者模式将同一类操作封装在一个访问者中，使得相关的操作彼此集中，提高了代码的可读性和维护性。 常用于对象结构比较稳定，但经常需要在此对象结构上定义新的操作，这样就无需修改现有的元素类，只需要定义新的访问者来添加新的操作。 访问者模式的实现 class Visitor;// 抽象元素类class Element {public: virtual ~Element() = default; virtual void accept(Visitor *visitor) = 0;};// 具体元素 Aclass ConcreteElementA : public Element {public: void accept(Visitor *visitor) override { visitor-visit(this); }};// 具体元素 Bclass ConcreteElementB : public Element {public: void accept(Visitor *visitor) override { visitor-visit(this); }};// 抽象访问者class Visitor {public: virtual ~Visitor() = default; virtual void visit(ConcreteElementA *element) = 0; virtual void visit(ConcreteElementB *element) = 0;};// 抽象访问者 Aclass ConcreteVisitorA : public Visitor {public: void visit(ConcreteElementA *element) override { std::cout \"ConcreteVisitorA visit ConcreElementA \"; } void visit(ConcreteElementB *element) override { std::cout \"ConcreteVisitorA visit ConcreElementB \"; }};// 抽象访问者 Bclass ConcreteVisitorB : public Visitor {public: void visit(ConcreteElementA *element) override { std::cout \"ConcreteVisitorB visit ConcreElementA \"; } void visit(ConcreteElementB *element) override { std::cout \"ConcreteVisitorB visit ConcreElementB \"; }};// 对象结构class ObjectStructure {public: void attach(Element *element) { m_elements.emplace_back(element); } void detach(Element *element) { auto it = std::find(m_elements.begin(), m_elements.end(), element); if (it != m_elements.end()) { m_elements.erase(it); } } void accept(Visitor *visitor) { for (Element *element : m_elements) { element-accept(visitor); } }private: std::vectorElement * m_elements;}; 访问者模式的设计题 【设计模式专题之访问者模式】23-图形的面积 (kamacoder.com)： 小明家有一些圆形和长方形面积的土地，请你帮他实现一个访问者模式，使得可以通过访问者计算每块土地的面积。 图形的面积计算规则如下： 圆形的面积计算公式为：3.14 * 半径 * 半径 矩形的面积计算公式为：长 * 宽 第一行是一个整数 n（1 = n = 1000），表示图形的数量。 接下来的 n 行，每行描述一个图形，格式为 “Circle r” 或 “Rectangle width height”，其中 r、width、height 是正整数。 对于每个图形，输出一行，表示该图形的面积。 参考代码： Visitor/main.cpp(github.com) Visitor/main.cpp(gitee.com)","tags":["CPP","设计模式"],"categories":["笔记"]},{"title":"Linux 服务器编程入门尝试 - C++","path":"/2024/LinuxServerCpp/","content":"关键词：C++、Linux References： 30天自制C++服务器 配套网络库 pine Linux下操作。 零、前言 这个项目原作者暂未更新，单凭我自己的话，还没能力续写下去。我的想法是有时间再重新组织一下语言，细化一下每一章的描述。这个项目作为一个 Linux 网络编程的入门项目还是相当不错的，能够了解到 Socket、线程池以及一系列抽象编程思想。如果想继续深入学习网络编程，那路还有很长很长…… ——Fingsinz，2024.06.06留 碰巧看到一位大牛在原仓库的基础上专注于功能的实现，并进行了自我改造，我将根据这位大牛的思想继续完善这个 Linux 高性能服务器。 Reference：https://github.com/Wlgls/30daysCppWebServer ——Fingsinz，2024.07.11留 一、从socket开始 socket，被翻译为套接字，它是计算机之间进行通信的一种约定或一种方式。套接字是双方通过网络进行通信的通道。Socket 连接的一边是客户端，另一边是服务器端。一个正常的服务器端能服务多个客户端。 通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。 1.1 服务端干了什么 在服务器端，需要建立一个 socket 套接字，对外提供一个网络通信接口。 在 Linux 系统中这个套接字仅仅是一个文件描述符，也就是一个int类型的值。 对套接字的所有操作（包括创建）都是最底层的系统调用。 创建套接字： int sockfd = socket(AF_INET, SOCK_STREAM, 0); 创建一个 sockaddr_in 结构体并初始化（bzero 函数）： struct sockaddr_in serverAddr;bzero(serverAddr, sizeof(serverAddr)); 设置地址族、IP 地址和端口号： serverAddr.sin_family = AF_INET;serverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");serverAddr.sin_port = htons(1234); 将 socket 地址与文件描述符绑定： bind(sockfd, (struct sockaddr *)serverAddr, sizeof(serverAddr)); 使用 listen 函数监听套接字： listen(sockfd, SOMAXCONN); 服务端想要接受一个客户端连接，需要使用 accept 函数： struct sockaddr_in clientAddr;socklen_t clientAddrLen = sizeof(clientAddr);bzero(clientAddr, sizeof(clientAddr));int clientSockfd = accept(sockfd, (sockaddr *)clientAddr, clientAddrLen); 输出 socket 连接信息： printf(\"Client connected: %d!\\tIP: %s\\tPort: %d \", clientSockfd, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port)); 至此，客户端已经可以通过 IP 地址和端口号连接到这个 socket 端口了。 1.2 客户端如何配合 在客户端，也需要建立一个 socket 套接字。 对于客户端，服务器存在的唯一标识是 IP 地址和端口号。此时需要将套接字绑定到一个 IP 地址和端口上。 创建套接字： int sockfd = socket(AF_INET, SOCK_STREAM, 0); 创建一个 sockaddr_in 结构体，并绑定 IP 族、IP 地址和端口号： struct sockaddr_in serverAddr;bzero(serverAddr, sizeof(serverAddr));serverAddr.sin_family = AF_INET;serverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");serverAddr.sin_port = htons(1234); 使用 connect 函数进行连接： connect(sockfd, (sockaddr *)serverAddr, sizeof(serverAddr)); 注意，需要先 ./server 运行服务端进行等待，再 ./client 运行客户端进行连接请求。 1.3 该节涉及函数及源代码 相关头文件： #include sys/socket.h // 创建 socket 所需#include arpa/inet.h // socket 地址结构体所需 创建 socket： int socket (int __domain, int __type, int __protocol);/** __domain：IP 地址类型，AF_INET 表示 IPv4，AF_INET6 表示 IPv6。* __type：数据传输方式，SOCK_STREAM 表示流格式、面向链接，多用于 TCP； SOCK_DGRAM 表示数据报格式、无连接，多用于 UDP。* __protocol：协议，0 表示根据前面两个参数自动推导协议类型。设置为 IPPROTO_TCP 和 IPPROTO_UDP，分别表示 TCP 和 UDP。*/ 初始化： void bzero (void *__s, size_t __n);/** __s：指向要清零的内存块的指针。* __n：要清零的内存块的大小。* 该函数在头文件 string.h 或 cstring 中。* Effective C++ - 条款01：视 C++ 为一个语言联邦。写 C 就用 string.h，写 C++ 就用 cstring。* Effective C++ - 条款04：确定对象被使用前已先被初始化。使用 bzero 进行初始化。*/ 绑定函数： int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);/** __fd：文件描述符。* __addr：sockaddr 参数。* __len：sockaddr 参数的大小。*/ listen 函数： int listen (int __fd, int __n);/** __fd：文件描述符。* __n：最大监听队列长度，宏定义 SOMAXCONN 为最大值。*/ accept 函数： int accept (int __fd, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len);/** __fd：服务端的文件描述符。* __addr`：sockaddr 参数。* __addr_len`：指向 sockaddr 参数大小的指针。因为 accept 需要写入客户端 socket 长度，所以需要地址* 另外，该函数会阻塞当前程序，直到有一个客户端 socket 被接受后程序才会往下执行。*/ connect 函数： int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);/** __fd：客户端的文件描述符。* __addr：sockaddr 参数。* __len：sockaddr 参数大小。*/ 关于 Socket 的有些地址结构需要清楚： // 通用的套接字地址类型struct sockaddr { unsigned short sa_family; // AF_INET 或 AF_INET6 char sa_data[14]; // 无关紧要};// 实际使用的套接字地址类型struct sockaddr_in { short sin_family; // AF_INET unsigned short sin_port; // 端口号，大端 struct in_addr sin_addr; // IPv4 地址 char sin_zero[8]; // 无关紧要};struct sockaddr_in6 { uint16_t sin6_family; // AF_INET6 uint16_t sin6_port; // 端口号，大端 uint32_t sin6_flowinfo; struct in6_addr sin6_addr; // IPv6 地址 uint32_t sin6_scope_id;};struct sockaddr_storage { sa_family_t ss_family; // AF_INET 或 AF_INET6 // 为IPv4和IPv6提供足够的空间 char __ss_pad1[_SS_PAD1SIZE]; int64_t __ss_align; char __ss_pad2[_SS_PAD2SIZE];}; struct sockaddr_storage 对于IPv4和IPv6都足够大，可以在实际中使用它。 struct sockaddr_in 和 struct sockaddr_in6 是IPv4和IPv6的具体结构。 struct sockaddr * 是 socket API 使用的类型，结构本身是无用的。程序员不应操作 sockaddr，sockaddr 是给操作系统用的。应使用 sockaddr_in 来表示地址，sockaddr_in 区分了地址和端口，将 struct sockaddr_storage 引用（指针）转换为 struct sockaddr_in 或 struct sockaddr_in6 以初始化/读取结构。 当在 Linux 上调用任何系统调用时，实际上是在调用 libc 中的一个瘦包装器，即一个稳定的 Linux 系统调用接口的包装器。在 Windows 上，套接字 API 遵循相同的 BSD API，但有许多不同的细节。接口来自 OS DLL 而不是系统调用。 该节代码：Github，Gitee 二、完善代码，数据读写 上面的代码是基础版的，但要想真正运行使用，需要完善代码，并抓住错误。 Effective C++ 中有提到：“别让异常逃离析构函数”（条款08）。 2.1 错误检查处理函数 对于 Linux 系统调用，常见的错误提示方式是使用返回值和设置错误码。 当一个系统调用返回 -1，说明有错误发生。 增加一个错误检查处理函数： void errorif(bool condition, const char *errmsg){\tif (condition)\t{ perror(errmsg); exit(EXIT_FAILURE);\t}} 第一个参数为判断是否发生错误条件，调用 iostream 中的 perror 打印错误。 第二个参数为错误信息。 然后使用 exit 函数让程序退出并返回一个预定义常量 EXIT_FAILURE。 使用就很方便： int sockfd = socket(AF_INET, SOCK_STREAM, 0);errorif(sockfd == -1, \"socket create error\"); 对所有函数都进行处理错误： errorif(bind(sockfd, (struct sockaddr *)serverAddr, sizeof(serverAddr)) == -1, \"socket bind error\");errorif(listen(sockfd, SOMAXCONN) == -1, \"socket listen error\");errorif(clientfd == -1, \"socket accept error\");errorif(connect(sockfd, (struct sockaddr *)serverAddr, sizeof(serverAddr)) == -1, \"socket connect error\"); 错误的处理是必须的，但处理函数不一定这样写。 2.2 数据读写 当建立 socket 连接后，就可以使用 unistd.h 中的 read 和 write 函数进行数据读写。（仅限于 TCP 连接。UDP 连接使用 sendto 和 recvfrom 函数。） 接下来做一个通信情况：客户端向服务端发送一定数据，然后服务端接收后转发回客户端，客户端将接收的转发数据再进行标准输出。 客户端： while (true)\t// 持续通信{\tchar buffer[1024];\t// 定义缓冲区\tstd::cin buffer;\t// 从标准输入读取数据\t// 向服务端发送数据\tsize_t writeLen = write(sockfd, buffer, sizeof(buffer));\t// 发送失败处理\tif (writeLen == -1)\t{ std::cout \"Socket already disconnected! \"; break;\t}\tbzero(buffer, sizeof(buffer));\t// 清空缓冲区\t// 读回数据\tsize_t readLen = read(sockfd, buffer, sizeof(buffer));\t// 读数据问题判断\tif (readLen 0)\t{ std::cout buffer \" \";\t}\telse if (readLen == 0)\t{ std::cout \"Server socket disconnected! \"; break;\t}\telse if (readLen == -1)\t{ close(sockfd); errorif(true, \"socket read error\");\t}} 服务端： while (true){\t// 定义并初始化缓冲区\tchar buffer[1024];\tbzero(buffer, sizeof(buffer));\t// 从客户端读取数据\tsize_t readLen = read(clientfd, buffer, sizeof(buffer));\t// 读取数据问题判断\tif (readLen 0)\t{ std::cout \"Message from client:\" clientfd \": \" buffer \" \"; write(clientfd, buffer, sizeof(buffer));\t// 读到后转回客户端\t}\telse if (readLen == 0)\t{ std::cout \"Client \" clientfd \" disconnected \"; close(clientfd); break;\t}\telse if (readLen == -1)\t{ close(clientfd); errorif(true, \"socket read error\");\t}} 需要注意的是： 服务端和客户端都可以从对方中读写数据。 使用完一个 fd（文件描述符） 后，记得使用 close 函数进行关闭。 2.3 该节涉及函数及源代码 相关头文件： #include unistd.h\t// 读写数据等需要#include \"util.h\" // 放置错误处理函数 write 函数： ssize_t write (int __fd, const void *__buf, size_t __n);/** __fd：文件描述符。* __buf：写入缓冲区。* __n：写入缓冲区大小。* 返回写入的大小，或-1。*/ read 函数： ssize_t read (int __fd, void *__buf, size_t __nbytes);/** __fd：文件描述符。* __buf：读取缓冲区。* __nbytes：读取缓冲区大小。* 返回读取的大小，-1表示错误，0表示EOF。*/ close 函数： int close (int __fd);/** __fd：文件描述符。*/ 该节代码：Github，Gitee 三、高并发使用epoll 之前只写了一个简单的服务器，只能同时处理一个客户端连接。事实上，所有的服务都是高并发的，可以同时为成千上万个客户端提供服务——IO复用。 IO 复用和多线程相似，但不是一个概念。 IO 复用针对 IO 接口； 多线程针对 CPU。 IO 复用的基本思想是事件驱动，服务器同时保持多个客户端 IO 连接。 当 IO 上有可读或可写事件发生，表示这个 IO 对应的客户端在请求服务器的服务，服务器应当响应。 Linux 中， IO 复用使用 select、poll 和 epoll 来实现。 epoll 相比 select、poll，表现性能更好，更加高效。 3.1 从select、poll到epoll 从实现原理上来说，select 和 poll 采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是 O(n)O(n)O(n)。epoll_wait 则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插人内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此 epoll_wait 无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是 O(1)O(1)O(1)。详见《Linux高性能服务器编程-游双，第9章》 当活动连接比较多的时候，epoll_wait 的效率未必比 select 和 poll 高，因为此时回调函数被触发得过于频繁。所以 epoll_wait 适用于连接数量多，但活动连接较少的情况。 epoll 是 Linux 特有的 IO 复用函数。 使用一组函数完成任务。 把用户关心的文件描述符上的事件放到内核的一个事件表中。 而不像 select 和 poll 那样每次调用都重复传入文件描述符或事件集。 需要额外的文件描述符来标识内核中的事件表。 创建文件描述符： #include sys/epoll.hint epoll_create(int size);/** size：内核事件表大小。* 返回文件描述符，用作其他所有 epoll 系统调用的第一个参数，指定访问的内核事件表。*/ 操作 epoll 的内核事件表： int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);/** epfd：文件描述符。* op：操作类型。有 EPOLL_CTL_ADD（往事件表中注册 fd 上的事件）、 * EPOLL_CTL_DEL（修改 fd 上的注册事件）、* EPOLL_CTL_MOD（删除 fd 上的注册事件） 三种。* fd：文件描述符。* event：指定事件，是 epoll_event 结构体指针。* 返回值：成功返回 0，失败返回 -1 并设置错误码。*/ 而关于 epoll_event 结构体的定义： struct epoll_event{\t__uint32_t events;\t/*epoll事件*/\tepoll_data_t data;\t/*用户数据*/}typedef union epoll_data{\tvoid *ptr; // 指定与fd相关的用户数据\tint fd; // 指定事件所从属的目标文件描述符\tuint32_t u32;\tuint64_t u64;} epoll_data_t; epoll 系列系统调用的主要接口是 epoll_wait 函数，它在一段超时时间内等待一组文件描述符上的事件： int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);/** 该函数如果检测到事件，就将所有就绪的事件从内核事件表（epfd指定）中复制到events中。* epfd：文件描述符。* events：事件数组。* maxevents：监听事件数组大小。* timeout：超时时间，单位为毫秒。* 返回值：成功返回就绪事件个数，失败返回 -1 并设置错误码。*/ epoll 对文件描述符的操作有两种： LT（Level Trigger，电平触发）模式 默认的工作模式，相当于效率较高的 poll。 对于采用 LT 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 epoll,_wait 时，epoll_wait 还会再次向应用程序通告此事件，直到该事件被处理。 ET（Edge Trigger，边沿触发）模式 对于采用ET工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait 调用将不再向应用程序通知这一事件。可见，ET 模式在很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。 ET 模式必须搭配非阻塞式 socket 使用。 epoll 的事件有： EPOLLIN：表示对应的文件描述符可读（包括对端 socket 正常关闭）； EPOLLOUT：表示对应的文件描述符可写； EPOLLPRI：表示对应的文件描述符有紧急的数据可读（表示有带外数据到来）； EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET：将 epoll 设为边缘触发模式。 EPOLLONESHOT：只监听一次事件，当监听完事件后，如果还需要继续监听这个 socket 的情况下，需要再次把这个 socket 加到 epoll 队列里。 3.2 将服务器改写成epoll版本 在创建了服务器 socket fd 后，将这个 fd 添加到 epoll。 epoll 监听事件的描述符会放在一棵红黑树上，将要监听的 IO 口放入 epoll 红黑树中，就可以监听该 IO 上的事件。 只要这个 fd 上发生可读事件，表示有一个新的客户端连接。 然后 accept 这个客户端并将客户端的 socket fd 添加到 epoll，epoll 会监听客户端 socket fd 是否有事件发生，如果发生则处理事件。 所以服务器大概的步骤如下： 创建 epoll，同时定义事件数组。 // 创建 epollint epfd = epoll_create1(0);errorif(epfd == -1, \"epoll create error\");// 定义事件数组struct epoll_event events[MAX_EVENTS], ev;bzero(events, sizeof(events)); 将要监听的 IO 口放入 epoll 中。 ev.data.fd = sockfd; // 该 IO 口为服务器 socket fdev.events = EPOLLIN; // 可读setnonblocking(sockfd); // 设置 sockfd 为非阻塞// 将服务器 socket fd 注册到 epollepoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, ev); 不断监听 epoll 上的事件并处理。 如果监听发生的事件是服务器 socket fd 上的事件，表示有一个新的客户端连接。 if (events[i].data.fd == sockfd){\t// 接收客户端信息\t// 新增监听\tbzero(ev, sizeof(ev));\tev.data.fd = clientfd; // 该 IO 口为客户端 socket fd\tev.events = EPOLLIN | EPOLLET;\t// 客户端连接使用 ET 模式\tsetnonblocking(clientfd); // ET 需要搭配非阻塞式 socket 使用\t// 将客户端 socket fd 注册到 epoll\tepoll_ctl(epfd, EPOLL_CTL_ADD, clientfd, ev);} 如果监听发生的事件是客户端，并且是可读事件，表示有客户端发送消息： else if (events[i].events EPOLLIN){\twhile (true)\t// 非阻塞 IO，需要不断读取，直至完毕\t{ ssize_t bytesRead = read(events[i].data.fd, buf, sizeof(buf)); // 正常读取数据 if (bytesRead 0) // ... // 客户端正常中断，继续读取 else if (bytesRead == -1 and errno == EINTR) //... // 非阻塞 IO，这个条件表示数据全部读取完毕 else if (bytesRead == -1 and ((errno == EAGAIN) or (errno == EWOULDBLOCK))) // ... // EOF 事件，一般表示客户端断开连接 else if (bytesRead == 0) // ...\t}} 该节代码：Github，Gitee 四、封装成类，程序模块化 4.1 将socket和InetAddress封装成类 当新建服务器 socket 时，需要完成绑定 IP 地址、监听、接受客户端连接等任务，这些任务都封装成 Socket 类来完成。希望简化成以下操作： // 新建服务器 socketSocket *serverSocket = new Socket();// 实例化 IP 地址InetAddress *serverAddr = new InetAddress(\"127.0.0.1\", 1234);// 绑定 IP 地址serverSocket-bind(serverAddr);// 监听serverSocket-listen();// 实例化一个客户端地址InetAddress *clientAddr = new InetAddress();// 接受一个客户端连接Socket *clientSocket = new Socket(serverSocket-accept(clientAddr)); 4.2 将epoll封装成类 对于 epoll，希望简化操作，封装成类后： // 实例化 epollEpoll *ep = new Epoll();// 将要监听的 IO 口放入 epollep-epoll_add(serverSocket-getFd(), EPOLLIN | EPOLLET);while(true){\tstd::vectorepoll_event events = ep-poll();\tfor (auto ev : events) // 处理事件} 4.3 目录结构及源代码 目录结构如下： client.cppserver.cpputil.hutil.cppSocket.hSocket.cppInetAddress.hInetAddress.cppEpoll.hEpoll.cpp 该节代码：Github，Gitee 五、向着Reactor模式转变 5.1 Reactor和Proactor Reactor 翻译过来的意思是「反应堆」，这里的反应指的是「对事件反应」。 当来了一个事件，Reactor 就有相对应的反应/响应。 事实上，Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 I/O 多路复用监听事件。 收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。 Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成。 Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件； 处理资源池负责处理事件，如 read - 业务逻辑 - send； Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于： Reactor 的数量可以只有一个，也可以有多个； 处理资源池可以是单个进程 / 线程，也可以是多个进程 / 线程； 有 3 个方案都是比较经典的，且都有应用在实际的项目中： 单 Reactor 单进程 / 线程； 单 Reactor 多线程 / 进程； 多 Reactor 多进程 / 线程； 方案具体使用进程还是线程，要看使用的编程语言以及平台有关： Java 语言一般使用线程，比如 Netty； C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。 Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。 Proactor 是异步网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。 因此，Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。 作者：小林coding 链接：https://www.zhihu.com/question/26943938/answer/1856426252 来源：知乎著作权归作者所有。 详细请参考游双《Linux高性能服务器编程》第八章第四节、陈硕《Linux多线程服务器编程》第六章第六节。 接下来要将服务器向着 Reactor 模式转变： 首先将整个服务器抽象成一个 Server 类，这个类中有一个 main-Reactor，里面的核心是一个 EventLoop，这是一个事件循环； 添加需要监听的事务到这个事件循环内，每次有事件发生时就会通知，在程序中返回给 Channel（自封装的类），然后根据不同的描述符、事件类型以回调函数的方式进行处理。 5.2 加入Channel类 面对服务器许多服务时，不同的连接类型也将决定不同的处理逻辑，仅仅通过一个文件描述符来区分显然会很麻烦。希望得到文件描述符的更多消息。 epoll 的 epoll_event 结构体中，data 字段可以放一个 void * 类型的指针，用来保存更多信息。 typedef union epoll_data{ void *ptr; int fd; uint32_t u32; uint64_t u64;} epoll_data_t;struct epoll_event{ uint32_t events; /* Epoll events */ epoll_data_t data;\t/* User data variable */} __EPOLL_PACKED; epoll 中的 data 是一个联合类型： 可以存储一个指针，指向任何一个地址块的内容； 可以是一个类的对象，就此将一个文件描述符封装成一个 Channel 类，一个 Channel 类始终负责一个文件描述符。对不同的服务、不同的事件类型，都可以在类中进行处理。 设计 Channel 类，核心成员如下： class Channel{private:\tEventLoop *loop;\tint fd;\tuint32_t events;\tuint32_t revents;\tbool isEpoll;\tstd::functionvoid() callback;} loop：指向与之关联的事件循环的指针。 fd：Channel 负责的文件描述符。 events：表示希望监听这个文件描述符的哪些事件。 revents：表示在 epoll 返回该 Channel 时文件描述符正在发生的事件。 isEpoll：表示当前 Channel 是否已经添加到 epoll 红黑树中，区分使用 EPOLL_CTL_ADD 还是 EPOLL_CTL_MOD。 callback：发生事件时执行的回调函数。 添加 Channel 类可以更加方便简单、多样化地处理 epoll 中发生的事件。同时脱离了底层，将 epoll、文件描述符和事件进行了抽象，形成了事件分发的模型，这也是 Reactor 模式的核心。 5.3 加入EventLoop类 EventLoop 类的定义如下： class EventLoop {private: Epoll *ep; bool quit;public: EventLoop(); ~EventLoop(); void loop(); void updateChannel(Channel*);}; ep：指向Epoll类实例的指针； quit：指示程序是否应该退出； loop()：事件循环函数，调用开始事件驱动，即原来调用 epoll_wait 函数的死循环； updateChannel()：更新 Channel。 将需要监听的事务加入到事件循环中，每次有事件发生就会通知，返回到 Channel，然后根据不同的描述符、事件类型以回调函数方式进行处理： void EventLoop::loop(){\twhile (!quit)\t{ // 使用epoll实例轮询事件 std::vectorChannel * channels = ep-poll(); // 处理每个Channel的事件 for (Channel *channel : channels) channel-handleEvent();\t}} 5.4 加入Server类 服务器类 Server 的核心成员如下： class Server{private: EventLoop *loop;public: Server(EventLoop*); ~Server(); void handleReadEvent(int); void newConnection(Socket *serv_sock);}; loop：事件循环对象。 handleReadEvent()：处理读事件。 newConnection()：处理新连接。 之后启动服务器的操作抽象为： EventLoop *loop = new EventLoop();Server *server = new Server(loop);loop-loop(); 这个版本服务器内只有一个 EventLoop，当其中有可读事件发生时，可以拿到该描述符对应的 Channel。 在新建 Channel 时，根据 Channel 描述符的不同分别绑定了两个回调函数： newConnection() 函数被绑定到服务器socket上； 如果服务器 socket 有可读事件，Channel 里的 handleEvent() 函数实际上会调用 Server 类的 newConnection() 新建连接。 handlrReadEvent() 被绑定到新接受的客户端socket上。 如果客户端 socket 有可读事件，Channel 里的 handleEvent() 函数实际上会调用 Server 类的 handleReadEvent() 响应客户端请求。 至此，根据抽象出的 EventLoop 和 Channel，构成了事件驱动模型。这两个类和服务器核心 Server 已经没有任何关系，经过完善后可以被任何程序复用，达到了事件驱动的设计思想，现在的服务器也可以看成一个最简易的 Reactor 模式服务器。 需要注意的是，目前该服务器的内存管理一塌糊涂。 该节代码：Github，Gitee 六、把服务器的接受抽象化 6.1 抽象化接受 服务器中，对于每一个事件，首先都是调用 accept() 函数去接受一个 TCP 连接，然后把 Socket 文件描述符添加到 epoll。当这个 IO 口有事件发生时，对该连接提供相应的服务。 分离接受连接这个功能，添加 Acceptor 类。 6.2 Acceptor 类 Acceptor 类应该有以下特点： 类中有一个 Socket fd，就是服务器监听的 Socket fd，每一个 Acceptor 对象都对应一个 Socket fd。 类存在于事件驱动 EventLoop 类中。 类也通过一个 Channel 负责分发到 epoll，该 Channel 的事件处理函数 handleEvent() 会调用 Acceptor 类中的连接函数进行新建一个 TCP 连接。 将新建连接的逻辑就在 Acceptor 类中。但逻辑上新 Socket 建立后就和之前的监听的服务器 Socket 没有任何关系了。 新的 TCP 连接应该由 Server 类来创建并管理生命周期，而不是 Acceptor。并且将一部分代码放在 Server 类里也并没有打破服务器的通用性，因为对于所有的服务，都要使用 Acceptor 来建立连接。 Acceptor 类的新建连接功能是在 Server 类中实现的。 可以使用 std::function、std::bind、右值引用、std::move 等实现函数回调。 定义该类： class Acceptor{private:\t// 用于事件处理的EventLoop指针\tEventLoop *loop;\t// 用于处理套接字操作的套接字指针\tSocket *sock;\t// 用于存储地址信息的指针\tInetAddress *addr;\t// 用于接受连接的 Channel 指针\tChannel *acceptChannel;public:\t// 定义一个新建连接的回调函数\tstd::functionvoid(Socket *) newConnectionCallback;public:\tAcceptor(EventLoop *_loop);\t~Acceptor();\t/** * @brief 接受新连接 */\tvoid acceptConnection();\t/** * @brief 设置新连接的回调函数。 * @param _callback 为新连接设置的回调函数。 */\tvoid setNewConnectionCallback(std::functionvoid(Socket *) _callback);}; 抽象后，Server类的变化如下： // 之前class Server{private:\t// 指向EventLoop对象的指针\tEventLoop *loop;\t// 服务器套接字\tSocket *serverSock;\t// 服务器地址\tInetAddress *serverAddr;\t// 服务器通道\tChannel *serverChannel;\t// 保存客户端的套接字\tstd::vectorstd::pairSocket *, InetAddress * clients;\t// ...}// 之后class Server{private:\t// 指向EventLoop对象的指针\tEventLoop *loop;\t// 指向Acceptor对象的指针\tAcceptor *acceptor;\t// ...} 该节代码：Github，Gitee 七、把TCP连接抽象化 7.1 抽象化连接 对于 TCP 协议，在三次握手新建连接后，该连接会一直存在直至四次挥手断开连接。 那么把这个连接也抽象化，抽象成 Connection 类。 7.2 Connection 类 Connection 类应该有以下特点： 类存在于事件驱动类中； 类的 Socket fd 就是客户端的 Socket fd，每一个 Connection 对象都对应一个 Socket fd。 类也通过一个 Channel 负责分发到 epoll，该 Channel 的事件处理函数 handleEvent() 会调用 Connection 类中的事件处理函数进行响应客户端请求。 Connection 类与 Acceptor 类十分相似，它们都由 Server 管理，由一个 Channel 分发到 epoll，通过回调函数处理响应事件。 一个高并发服务器一般只有一个 Acceptor（可以有多个），但会同时有成千上万个 TCP 连接，也就是 Connection 的实例。 对 Connection 类的定义如下： class Connection{private:\tEventLoop *loop;\tSocket *sock;\tChannel *channel;\tstd::functionvoid(Socket *) deleteConnectionCallback;public:\tConnection(EventLoop *_loop, Socket *_sock);\t~Connection();\t// @brief 回显sockfd发来的数据\tvoid echo(int sockfd);\t// @brief 设置删除连接时要调用的回调函数\tvoid setDeleteConnectionCallback(std::functionvoid(Socket *) _callback);}; 7.3 改写 Server 类 Server 类的核心变成： class Server{private:\t// 指向EventLoop对象的指针\tEventLoop *loop;\t// 指向Acceptor对象的指针\tAcceptor *acceptor; // 存储连接及其相应的文件描述符\tstd::mapint, Connection * connections;public:\tServer(EventLoop *_loop);\t~Server();\t// @brief 处理客户端请求，暂时没有\t// void handleReadEvent(int fd);\t// @brief 处理与所提供套接字的新连接\tvoid newConnection(Socket *_socket);\t// @brief 断开与提供的套接字关联的连接\tvoid deleteConnection(Socket *_socket);}; 通过 Map 映射将众多连接保存起来，键为该连接客户端的 socket fd，值为指向该连接的指针。 该连接客户端的 socket fd 通过一个 Channel 类分发到 epoll，该 Channel 的事件处理回调函数 handleEvent() 绑定为 Connection 的处理函数，这样每当该连接的 socket fd 上发生事件，就会通过 Channel 调用具体连接类的处理函数。 此处将新建连接的功能放回到 Acceptor 类中管理： void Acceptor::acceptConnection(){\t// 创建一个新的InetAddress对象来存储客户端地址信息\tInetAddress *clientAddr = new InetAddress();\t//通过使用客户端地址接受来自服务器套接字的连接，创建一个新的Socket对象\tSocket *clientSock = new Socket(sock-accept(clientAddr));\t// 打印有关新客户端连接的信息\tstd::cout \"New client \" clientSock-getFd() \": \" inet_ntoa(clientAddr-addr.sin_addr) \" : \" ntohs(clientAddr-addr.sin_port) \" \";\tclientSock-setNonBlocking();\tnewConnectionCallback(clientSock);\tdelete clientAddr;} Server 类变得只负责管理 Acceptor 和 Connection 类，其成员函数也集中在管理 Acceptor 和 Connection 类中。改写后的 Server 类代码如下： void Server::newConnection(Socket *_socket){\tConnection *conn = new Connection(loop, _socket);\tstd::functionvoid(Socket *) cb = std::bind(Server::deleteConnection, this, std::placeholders::_1);\tconn-setDeleteConnectionCallback(cb);\tconnections[_socket-getFd()] = conn;}void Server::deleteConnection(Socket *_socket){\tConnection *conn = connections[_socket-getFd()];\tconnections.erase(_socket-getFd());\tdelete conn;} 当有新的 TCP 连接时，实例化一个 Connection 对象，设置其删除时的回调函数，并放置在 connections 中管理。 目前该服务器的唯一功能——接受客户端的信息并发回，封装成 Connection 类的 echo 函数，在 Connection 构造时绑定给 Channel 类的事件回调函数，由 Channel 实例遇到事件时触发。 当有 TCP 连接断开时，从 connections 中删除该连接，并释放对象。 由于 Connection 的生命周期由 Server 进行管理，所以也应该由 Server 来删除连接 至此，服务器到了一个比较重要的阶段，服务器最核心的几个模块都已经抽象出来，一个完整的单线程服务器设计基本完成。 该节代码：Github，Gitee 八、闲来无事，整个缓冲区 8.1 引入缓冲区 此节引入一个最简单、最基本的缓冲区，完善改进之前的服务器。 没有使用缓冲区时，服务器回送信息的代码如下： void Connection::echo(int sockfd){\tchar buf[READ_BUFFER];\twhile (true)\t{ bzero(buf, sizeof(buf)); ssize_t readLen = read(sockfd, buf, sizeof(buf)); if (readLen 0) { std::cout buf \" \"; write(sockfd, buf, sizeof(buf)); } // ...\t}} 这是非阻塞式 socket IO 的读取，缓冲区大小为 1024，表示每次 TCP 缓冲区读取 1024 大小的数据到缓冲区，然后发送到客户端。 只能以 1024 地读，当数据没有 1024，用空值补满。 所以，封装一个缓冲区，为每一个 Connection 类分配一个读缓冲区和写缓冲区： 从客户端读来的数据存放在都缓冲区。 8.2 Buffer类 Buffer 类的代码如下： #pragma once#include stringclass Buffer{private:\tstd::string buf;public:\tBuffer() = default;\t~Buffer() = default;\t// @brief 向当前字符串追加一个字符串\tvoid append(char const *str, int _size);\t// @brief 返回当前缓冲区字符串大小\tssize_t size();\t// @brief返回指向底层字符串数据的指针\tchar const *c_str();\t// @brief 清空当前缓冲区字符串\tvoid clear();\t// @brief 从控制台获取输入\tvoid getline();}; 使用如下： /* src/Connection.cpp */void Connection::echo(int sockfd){\tchar buf[1024];\twhile (true)\t{ bzero(buf, sizeof(buf)); ssize_t readLen = read(sockfd, buf, sizeof(buf)); if (readLen 0) { readBuffer-append(buf, readLen);\t// 缓冲区追加 } else if (readLen == -1 and errno == EINTR) continue; else if (readLen == -1 and ((errno == EAGAIN) or (errno == EWOULDBLOCK))) {\t// 从缓冲区中读取数据，同时进行回写 std::cout readBuffer-c_str() \" \"; errorif(write(sockfd, readBuffer-c_str(), readBuffer-size()) == -1, \"***\"); readBuffer-clear(); break; } else if (readLen == 0) { deleteConnectionCallback(sock); break; }\t}} 虽然仍有 char buf[1024] 这样的低级缓冲区，用于系统调用 read() 的读取，但这个缓冲区大小无所谓，设置为1到设备TCP缓冲区的大小都可以。 太大导致资源浪费，单词读取速度低； 太小导致读取次数增多。 以上代码会把 socket IO 上的可读数据全部读取到缓冲区，缓冲区大小就等于客户端发送的数据大小。全部读取完成之后，可以构造一个写缓冲区、填好数据发送给客户端。 由于是echo服务器，所以这里使用了相同的缓冲区。 8.3 其他方面的改进 优化 InetAddress 类，将成员私有化，提供访问方法。（—— src/InetAddress.h 和 src/InetAddress.cpp） Socket 类添加 connect 方法，方便 client.cpp 调用。（—— src/Socket.h 和 src/Socket.cpp） 结合现有的模块，改进 client 文件。（—— client.cpp） 整体改进了了输出信息提示。 该节代码：Github，Gitee 九、线程池啊线程池 9.1 为什么加入线程池 当前的代码是单线程模式，所有 fd 上的事件都由一个线程（主线程，EventLoop线程）处理。 假设响应一个事件需要 1s，那么如果有 1000 个事件，那么主线程就要等待很久。 这不现实。 引入多线程，当发现 socket fd 有事件时，应该分发一个工作线程。 由这个工作线程处理 fd 上的事件。 再者，每一个 Reactor 只应该负责事件分发而不负责事件处理。 9.2 如何设计线程池 最简单的想法就是，每次遇到一个新的任务，就开一个新线程去执行。 这种方式虽然简单，但是太粗暴了。 我们的机器是有上限的，不可能无限开新线程。 那么，可以固定一个线程的数量。启动固定数量的工作线程，然后将任务添加到任务队列，工作线程不断取出任务队列的任务执行。 设计线程池还需要注意： 多线程环境下任务队列的读写应该考虑互斥锁。 当任务队列为空时，CPU 不应该一直轮询耗费 CPU 资源。 此处解决方法如下： std::mutex 对任务队列进行加锁解锁。 std::condition_variable 使用条件变量。 9.3 线程池用到的语法知识 关于互斥锁：mutex头文件 - cppreference mutex 类是能用于保护共享数据免受从多个线程同时访问的同步原语。 lock()：成员函数，锁定互斥体，若互斥体不可用则阻塞。位于头文件 mutex。 通常不直接调用 lock()。 用 std::unique_lock 与 std::lock_guard 管理排他性锁定。 unique_lock 类是一种通用互斥包装器，允许延迟锁定、有时限的锁定尝试、递归锁定、所有权转移和与条件变量一同使用。 构造函数：explicit unique_lock( mutex_type m );，通过调用 m.lock() 锁定关联互斥体。 析构函数：若拥有关联互斥体且获得了其所有权，则解锁互斥体。 try_lock()：成员函数，尝试锁定互斥体，若互斥体不可用则返回 false。位于头文件 mutex。 unlock()：成员函数，解锁互斥体。位于头文件 mutex。 关于线程等待条件：condition_variable头文件 - cppreference std::condition_variable（线程等待条件） 是与 std::mutex 一起使用的同步原语。 它能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 std::condition_variable。 有意修改变量的线程必须： 获得 std::mutex（常通过 std::lock_guard） 在保有锁时进行修改 在 std::condition_variable 上执行 notify_one 或 notify_all（可以释放锁后再通知） 任何有意在 std::condition_variable 上等待的线程必须： 在用于保护共享变量的互斥体上获得 std::unique_lockstd::mutex。 执行下列之一： 检查条件，是否为已更新且已提醒的情况。 调用 std::condition_variable 的 wait、wait_for 或 wait_until（原子地释放互斥体并暂停线程的执行，直到条件变量被通知，时限过期，或发生虚假唤醒，然后在返回前自动获得互斥体）。 检查条件，并在未满足的情况下继续等待。 wait()：成员函数，阻塞当前进程，直至条件变量被唤醒。位于头文件 condition_variable。 类似还有wait_for、wait_until。不多说，自行查阅。 notify_one()：成员函数，通知一个等待的线程。位于头文件 condition_variable。 notify_all()：成员函数，通知所有等待的线程。位于头文件 condition_variable。 9.4 线程池类 线程池类代码如下： class ThreadPool{private:\t// 线程池中的线程\tstd::vectorstd::thread threads;\t// 要执行的函数\tstd::queuestd::functionvoid() tasks;\t// 声明互斥锁以同步对任务队列的访问\tstd::mutex tasksMtx;\t// 声明在线程之间进行协调的条件变量\tstd::condition_variable cv;\t// 指示线程停止的标志\tbool stop;public:\tThreadPool(int size = 10);\t~ThreadPool();\t// @brief 加入任务到任务队列中\tvoid add(std::functionvoid() task);}; 线程池的构造函数设计为： ThreadPool::ThreadPool(int size) : stop(false){\tfor (int i = 0; i size; ++ i)\t{ threads.emplace_back(std::thread([this] () { while (true) { std::functionvoid() task; {// 使用作用域生命期解锁 std::mutex，而不调用unlock() std::unique_lockstd::mutex lock(tasksMtx); // 当任务队列不为空或线程池停止时停止等待（阻塞） cv.wait(lock, [this] (){ return stop or !tasks.empty(); }); if (stop and tasks.empty())\t// 任务队列为空且线程池停止，退出循环 return; task = tasks.front(); tasks.pop(); } task();\t// 执行任务 } }));\t}} 初始线程池大小为 size，创建线程并让每个线程等待将任务添加到任务队列中。 使用 std::unique_lock 锁定任务互斥锁以防止并发访问，并将其置于局部作用域，当离开作用域时，它将自动解锁互斥锁。 当添加任务时，线程从队列中获取任务并执行它。线程将继续执行任务，直到线程池停止。 析构函数设计为： ThreadPool::~ThreadPool(){\t{ std::unique_lockstd::mutex lock(tasksMtx); stop = true;\t} cv.notify_all();\t// 通知所有等待的线程线程池正在停止\tfor (std::thread th : threads)\t{\t// 检查线程是否可接合 if (th.joinable()) th.join();\t// 阻塞当前线程，直到指定线程完成其执行\t}} 在线程池析构时，需要注意将已经添加的所有任务执行完，最好不采用外部的暴力kill、而是让每个线程从内部自动退出，具体实现参考源代码。 在上锁的情况下，把线程池的停止状态设置为true，然后通知所有等待的线程线程池正在停止。 然后，等待所有线程完成其执行。 加入线程池后，当 Channel 类有事件需要处理时，将这个事件处理添加到线程池，主线程 EventLoop 就可以继续进行事件循环，而不在乎某个 socket fd 上的事件处理。 该节代码：Github，Gitee 十、有了线程池之后的考虑 10.1 完善线程池 上一节添加的线程池是最简单的线程池，还存在许多问题，比如： 任务队列的添加、取出都会有不必要的拷贝操作； 线程池只接受 std::functionvoid 类型的参数，所有函数参数都要事先使用 std::bind()，并且无法得到返回值。 解决方法一一对应： 使用右值移动去避免拷贝操作。 改写 add() 函数，希望使用前不需要手动绑定参数，直接传递并且可以得到任务的返回值。 10.2 完善线程池用到的语法知识 关于模板编程：模板 - MSLearn、理解C++模板 - 知乎 简单来说，模板编程就是提供了一套模具，对于不同的数据类型都可以适用于这套模具。 函数模板的结构一般如下： template typename T 返回类型 函数名(参数列表){ /*函数的主体*/ } 类模板结构一般如下： template class T class 类名 {} 变长参数模板：参数个数和类型都可能发生变化的模板。 使用模板形参包实现。 模板形参包是可以接受 0 个或者 n 个模板实参的模板形参，至少有一个模板形参包的模板就可以称作变参数模板。 模板形参包有：非类型模板形参包、类型模板形参包、模板模板形参包三种。 此节使用类型模板形参包：表示该可变形参包可以接受无限个不同的实参类型。 typename... Args 或 class ... Args 关于右值和移动 std::move：C++引用和右值引用 - CSDN、【C++】C++11——左右值|右值引用|移动语义|完美转发、一文读懂C++右值引用和std::move - 知乎 C++11 后增加了移动语义，出现了移动构造、移动赋值等。 简单来说，移动语义的出现，可以把旧对象所拥有的资源交给新对象，而旧对象什么都没有了。 右值引用的出现也是为了移动语义。 关于完美转发 std::forward： 和 std::move 类似，与 std::move相比，它更强大，move 只能转出来右值，forward 都可以。 std::forwardT(u) 有两个参数：T 与 u。 当 T 为左值引用类型时，u 将被转换为 T 类型的左值； 否则 u 将被转换为 T 类型右值。 关于 std::future：future - cppreference 类模板 std::packaged_task 可以包装任何可调用 (Callable) 目标（函数、lambda 表达式、bind 表达式或其他函数对象），使得能异步调用它。其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。 成员函数 get_future()，返回与 *this 共享同一共享状态的 future，每个 packaged_task 对象只能调用一次。 类模板 std::future：future 对象提供访问异步操作结果的机制，从异步任务中返回结果。 类模板 std::future 提供访问异步操作结果的机制： （通过 std::async、std::packaged_task 或 std::promise 创建的）异步操作能提供一个 std::future 对象给该异步操作的创建者。 然后，异步操作的创建者可以使用多个方法查询、等待或从 std::future 提取值。若异步操作尚未提供值，则这些方法可能阻塞。 当异步操作准备好发送结果给创建者时，它可以修改与创建者的 std::future 相链接的共享状态（例如 std::promise::set_value）。 10.3 再修修补补 除了上面线程池的部分有修改，以下部分也有修改： Channel 部分： 新增标记位和是否使用线程池的函数； 对于处理事件区分了读事件和写事件分别的回调函数； 新增可选择性 epoll ET 模式或 epoll LT 模式； Acceptor 部分：因为接受连接处理时间短、报文数据小，也不会有同时到达的新连接，所以 Acceptor 的 socket fd （服务器监听 socket）使用阻塞式： Acceptor 从 epoll ET 模式改为 epoll LT 模式，建立好连接后处理事件 fd 读写用 ET 模式。 Acceptor 的连接建立不适用线程池，建立好连接后处理事件使用线程池。 Connection 部分： 新增 send() 函数，独立发送数据。 修改 deleteConnectionCallback() 函数，参数类型改为 int。 Epoll 部分： 新增 deleteChannel() 函数，用于删除 Channel。 Server 部分： 新增 deleteConnection() 函数。 更多细节上的变化（可能有部分错误处理、变量变化）可比较前一天的文件。 服务器中还可能有潜在的bug。 最后，添加测试连接的程序 test.cpp，使用命令 make t 编译，使用如下： ./test -t 1000 -m 10 -w 100 -t 表示线程数量，此处为 1000 个线程进行服务器连接； -m 表示每个线程的回显次数，此处为每个线程回显 10 次； -w 表示每个线程的等待时间，可以测试最大连接数，可以不设置。 该节代码：Github，Gitee 十一、改写成主从Reactor多线程模式 11.1 什么是主从Reactor多线程模式 现在实现的服务器多线程 Reactor 模式，是给每一个 Channel 的任务分配一个线程执行。但目前的线程池对象置于 EventLoop 中，而不是由服务器类 Server 类管理。 主从 Reactor 多线程模式是大多数高性能服务器采用的模式。 陈硕《Linux多线程服务器编程》书中的 one loop per thread 模式。 该模式的特点有： 服务器一般只有一个 main Reactor，有多个 sub Reactor。 服务器管理一个线程池，每一个 sub Reactor 由一个线程来负责 Connection 上的事件循环，事件执行也在这个线程中完成。 main Reactor 只负责 Acceptor 建立新连接，然后将这个连接分配给一个 sub Reactor。 11.2 代码上的变化 根据主从 Reactor 多线程模式的特点，将服务器类重写如下： class Server{private:\tEventLoop *mainReactor; // 只负责接受连接，然后分发给一个subReactor\tAcceptor *acceptor; // 连接接受器\tstd::vectorEventLoop * subReactors; // 负责处理事件循环\tstd::mapint, Connection * connections;\t// 存储连接及其相应的文件描述符\tThreadPool *threadPool; // 线程池public:\t// ...} 在有一个新连接到来时，采用随机调度策略分配给一个 subReactor： int random = _socket-getFd() % subReactors.size();Connection *conn = new Connection(subReactors[random], _socket); 这种调度算法适用于每个socket上的任务处理时间基本相同，可以让每个线程均匀负载。但事实上，不同的业务传输的数据极有可能不一样，也可能受到网络条件等因素的影响，极有可能会造成一些 subReactor 线程十分繁忙，而另一些 subReactor 线程空空如也。此时需要使用更高级的调度算法，如根据繁忙度分配，或支持动态转移连接到另一个空闲 subReactor 等。 调度问题是个很有趣的问题，会直接影响服务器的效率和性能。 代码上，还将原来在 EventLoop 的线程池去掉，Channel 也不再区分是否使用线程池。 现在，服务器以事件驱动为核心，服务器线程只负责 mainReactor 的新建连接任务，同时维护一个线程池，每一个线程是一个事件循环，新连接建立后分发给一个 subReactor 开始事件监听，有事件发生则在当前线程处理。 该节代码：Github，Gitee 十二、项目工程化 目前服务器的结构是主从 Reactor 多线程模式，是比较主流的模式。所以大体上的方向已经确定，接下来对细节进行优化，把项目工程化。 12.1 认识Cmake 首先，CMake是一个跨平台的编译工具，可以用简单的语句进行编译。 一个项目使用 CMake 维护一个 CMakeLists.txt 配置文件来描述一个项目的编译过程。利用这个文件，就可以搭建起来这个项目。 目前将所有文件都放在一个文件夹，并且没有分类。随着项目越来越复杂、模块越来越多，开发者需要考虑这座屎山的可读性，如将模块拆分到不同文件夹，将头文件统一放在一起等。 对于这样复杂的项目，如果手写复杂的Makefile来编译链接，那么将会相当负责繁琐。我们应当使用 CMake 来管理我们的项目，CMake 的使用非常简单、功能强大，会帮我们自动生成 Makefile 文件，使项目的编译链接更加容易，程序员可以将更多的精力放在写代码上。 这是 CmakeLists.txt 基本结构： # xxx：本 CMakeLists.txt 的 project 名称# 会自动创建两个变量，PROJECT_SOURCE_DIR 和 PROJECT_NAME# ${PROJECT_SOURCE_DIR}：本 CMakeLists.txt 所在的文件夹路径# ${PROJECT_NAME}：本CMakeLists.txt 的 project 名称project(xxx)# 获取路径下所有的.cpp/.c/.cc文件，并赋值给变量中aux_source_directory(路径 变量)# 给文件名/路径名或其他字符串起别名，用${变量}获取变量内容set(变量 文件名/路径/...)# 添加编译选项add_definitions(编译选项)# 打印消息message(消息)# 编译子文件夹的CMakeLists.txtadd_subdirectory(子文件夹名称)# 将.cpp/.c/.cc文件生成.a静态库# 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可add_library(库文件名称 STATIC 文件)# 将.cpp/.c/.cc文件生成可执行文件add_executable(可执行文件名称 文件)# 规定.h头文件路径include_directories(路径)# 规定.so/.a库文件路径link_directories(路径)# 对add_library或add_executable生成的文件进行链接操作# 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可target_link_libraries(库文件名称/可执行文件名称 链接的库文件名称) 12.2 工程化的实际操作 首先规范化目录的意义： src 目录（即source），用于存放核心的代码； include 目录，用于存放源代码中的头文件； test 目录，用于存放测试的代码； projiect/├─src/│ ├─include/│ │ ├─*.h│ ├─*.cpp├─test/│ ├─*.cpp 在这一章，我们使用的是一个 CMake 工程，所以 Visual Studio 创建的是 CMake 项目。接下来就是 CMake 的配置工作。（有关 CMake 的安装使用可参考附 2） 构建上述文件目录，将对应的文件分类进去。 接着，开始编写项目的根 CMakeLists.txt 文件（即根目录下的 CMakeLists.txt ）： cmake_minimum_required(VERSION 3.10) # CMake运行的最小版本set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 启用编译命令的导出，常与代码分析工具配合使用set(BUILD_SHARED_LIBS ON) # 构建共享（动态）库set(CMAKE_CXX_STANDARD 17) # 设置C++标准为17set(CMAKE_CXX_STANDARD_REQUIRED ON) # 要求编译器支持C++17# 设置编译器set(CMAKE_C_COMPILER \"clang\")set(CMAKE_CXX_COMPILER \"clang++\")# 项目信息project(Day12 # 项目名称 LANGUAGES CXX # 项目语言 )# 为源代码和测试添加子目录add_subdirectory(src)add_subdirectory(test)# 设置包含目录set(SRC_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/src/include)# set(TEST_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/test/include)include_directories(${SRC_INCLUDE_DIR})# 设置输出目录set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)# 设置编译和链接选项set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fPIC -Wall -Wextra -std=c++17 -pthread\")set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -O0 -ggdb -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls\")set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fPIC\")set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -fPIC\")set(CMAKE_STATIC_LINKER_FLAGS \"${CMAKE_STATIC_LINKER_FLAGS} -fPIC\")set(GCC_COVERAGE_LINK_FLAGS \"-fPIC\")# 显示编译器和链接器标志message(STATUS \"CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}\")message(STATUS \"CMAKE_CXX_FLAGS_DEBUG: ${CMAKE_CXX_FLAGS_DEBUG}\")message(STATUS \"CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}\")message(STATUS \"CMAKE_SHARED_LINKER_FLAGS: ${CMAKE_SHARED_LINKER_FLAGS}\") 第一次接触 CMake 命令可以参考注释理解。 接着，尝试把我们关于服务器的设计打包成一个库，即编写 src/CMakeLists.txt： # 设置包含目录set(SRC_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/src/include)include_directories(${SRC_INCLUDE_DIR})# 递归搜索/src目录中的所有.cpp文件file(GLOB_RECURSE day12_sources ${PROJECT_SOURCE_DIR}/src/*.cpp)# 设置共享库链接选项set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -fPIC -pthread\")# 使用源文件创建一个名为day12_shared的共享库add_library(day12_shared SHARED ${day12_sources}) 然后，把测试文件的 CMakeLists.txt（即 test/CMakeLists.txt）也编写一下，用于管理测试文件的编译： # 设置包含目录set(SRC_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/src/include)include_directories(${SRC_INCLUDE_DIR})# 设置变量TEST_SOURCES，将所有.cpp文件存储在测试目录中file(GLOB TEST_SOURCES \"${PROJECT_SOURCE_DIR}/test/*.cpp\")# 创建名为“build-tests”的自定义目标以仅显示测试add_custom_target(build-tests COMMAND ${CMAKE_CTEST_COMMAND} --show-only)# 创建名为“check-tests”的自定义目标以在详细模式下运行测试add_custom_target(check-tests COMMAND ${CMAKE_CTEST_COMMAND} --verbose)# 遍历TEST_SOURCES中的每个测试源文件foreach (test_source ${TEST_SOURCES}) # 组合为可读的名称，使得每个Cpp都可以make get_filename_component(test_filename ${test_source} NAME) string(REPLACE \".cpp\" \"\" test_name ${test_filename}) # 为测试添加可执行目标，默认情况下将其从所有生成中排除 add_executable(${test_name} EXCLUDE_FROM_ALL ${test_source}) # 添加对生成测试和检查测试的依赖项 add_dependencies(build-tests ${test_name}) add_dependencies(check-tests ${test_name}) # 将“day12_shared”库链接到可执行测试文件 target_link_libraries(${test_name} day12_shared) # 设置测试目标的属性，指定输出目录和运行测试的命令 set_target_properties(${test_name} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\" COMMAND ${test_name} )endforeach(test_source ${TEST_SOURCES}) 当然，这章在代码上也有些许修改，比如函数参数做了 const ，类也禁止了拷贝和移动操作。 该节代码：Github，Gitee 接着只需要把项目部署到远程 Linux 服务器，使用以下命令编译即可： make server：编译服务端代码 make SingleClient：编译单个客户端连接代码 make MultipleClients：编译多个客户端连接代码 make clean：清理生成 运行只需要： ./bin/server：启动服务端 ./bin/SingleClient：启动单个客户端连接 ./bin/MultipleClients -t 线程数 -m 回显消息数 -w 延时发送信息：启动多个客户端连接 原作者还进行了代码静态分析和代码格式化，详见地址：Github 十三、业务逻辑自定义化 13.1 业务逻辑思想 首先回顾之前的思想，我们目前服务器只有一个功能，就是进行回声（Echo）：把客户端发来的消息再发送回去。而这个功能，或者说业务逻辑，就固定在 Connection 类。 而通过第十二章的设计，我们把网络方面的代码整合为一个链接库。很明显，作为一个库，并不能就这样把业务逻辑固定了，应该支持业务逻辑自定义。 业务逻辑由用户自定义，然后使用网络库进行服务器与客户端间的交互。 怎样事件触发、读取数据、异常处理等流程应该是网络库提供的基本功能，用户只应当关注怎样处理业务即可，所以业务逻辑的进入点应该是服务器读取完客户端的所有数据之后。这时，客户端传来的请求在 Connection 类的读缓冲区里，只需要根据请求来分发、处理业务即可。 总体上，服务器端提出这样的设计： 具有一个 Server 类和一个事件循环类。 通过回调函数的方式编写业务逻辑，传给 Server 类的实例。 只需关心服务器的处理方法，比如一个 Echo 服务器只需要把对方发来的信息发回去。通过设置 onMessage 回调函数来自定义自己的业务逻辑，在服务器完全接收到客户端的数据之后，该函数触发。 可以设置连接时的业务逻辑和整个服务端的业务逻辑。 Server *server = new Server(loop);server-newConnect([] (Connection *conn) { // 服务器对有新连接时的操作函数\t});server-onMessage([] (Connection *conn)\t{ // 服务器对客户端消息的操作函数\t}); 另外，希望客户端的代码也可以通过我们的网络库进行实现：将 Connection 类进行完善，使得其满足服务端（Server → Client）和客户端（Client → Server）的使用： 服务端和客户端的传输数据方向是相反的：对于服务端，它从客户端中读取数据，或者写入数据到客户端；对于客户端，它从服务端中读取数据，或者写入数据到服务端。 在发回数据时，应该考虑对方是否已经关闭了链接。所以还需要设计 Connection 的状态。 总体上，客户端要使用 Connection 类，提出这样的设计： 提供 write() 和 read() 函数。 write() 函数表示将写缓冲区里的内容发送到该 Connection 的 socket，发送后会清空写缓冲区； read() 函数表示清空读缓冲区，然后将 TCP 缓冲区内的数据读取到读缓冲区。 考虑 Connection 的状态 State。 13.2 操刀动代码 根据上面的分析，Server 进行改动如下： 将 Server 类进行改写： // Server.hclass Server{private:\t// ......\tstd::functionvoid(Connection *) onConnectionCallback;\t// 连接的业务逻辑\tstd::functionvoid(Connection *) onMessageCallback;\t// 消息的业务逻辑\tstd::functionvoid(Connection *) newConnectCallback;\t// 新连接的业务逻辑public:\t// ...\t/** * @brief 设置服务器的业务逻辑 * @param fn 业务逻辑函数 */\tvoid onConnect(std::functionvoid(Connection *) fn);\t/** * @brief 设置接收消息时调用的回调函数 * @param fn 回调函数 */\tvoid onMessage(std::functionvoid(Connection *) fn);\t/** * @brief 设置在建立新连接时调用的回调函数。 * @param fn 回调函数 */\tvoid newConnect(std::functionvoid(Connection *) fn);\t// ...} 但是我们不能急，修改 Server 必须还得对 Connection 类的完善。因为服务器的一些操作是通过连接类完成，改动如下： 添加连接状态（此处其实只关注是否连接建立即可）： enum State{\tInvalid = 1, // 初始无效状态\tHandshaking, // 握手过程中的状态\tConnected, // 连接建立\tClosed, // 连接关闭\tFailed, // 连接失败}; 提供读写函数（详细见章末 Gitee 或 Github 链接）： void Connection::read(){\t// 判断连接状态\t// 清空读缓冲区\t// 读操作}void Connection::write(){\t// 判断连接状态\t// 写操作\t// 清空写缓冲区}// 用于服务器程序回发消息void send(std::string msg); 读操作和写操作区分是否阻塞：对于客户端，使用阻塞读写；对于服务端，使用非阻塞读写。在判断 Socket 是否阻塞时，需要添加个函数（之前没有）。 将原来成员属性 int fd 变成 Socket *mSocket。 添加上对应的回调函数及其 Set 函数： std::functionvoid(Socket *) mDeleteConnectionCallback;\t// 删除连接的回调函数std::functionvoid(Connection *) mOnConnectCallback; // 连接建立时的回调函数std::functionvoid(Connection *) mOnMessageCallback; // 业务逻辑回调函数/** * @brief 设置连接时的业务逻辑回调函数 * @param callback 回调函数 */void setOnConnectionCallback(std::functionvoid(Connection *) const callback);/** * @brief 将回调函数设置为在收到消息时调用 * @param callback 接收到消息时调用的函数 */void setOnMessageCallback(std::functionvoid(Connection *) const callback);/** * @brief 设置删除连接时要调用的回调函数 * @param _callback 删除连接时要调用的回调函数 */void setDeleteConnectionCallback(std::functionvoid(Socket *) const callback); 编写业务函数。在构建服务器时指定对客户端消息的响应，然后通过对 Server 类的设置，传递到 Connection 类，最后传递到 Channel 类的 handleEvent() 进行调用。 /** * @brief 该函数表示业务逻辑。 */void business(){\t// 大概操作有：\t// - 接受客户端信息\t// - 做出响应，即 mOnMessageCallback()} 现在也差不多了，但是可以完善（重构）一下 Channel 类，让其意义更明确，更规范一些： 规范私有成员变量： private:\tEventLoop *mLoop; // 指向与之关联的事件循环\tSocket *mSocket; // 与之关联的Socket\tuint32_t mListenEvents{ 0 }; // 监听的事件\tuint32_t mReadyEvents{ 0 }; // 就绪事件\tbool exist{ false }; // 指示该Channel是否存在有效\tstd::functionvoid() readCallback;\t// 读回调\tstd::functionvoid() writeCallback;// 写回调 编写相关成员函数（函数名修改后记得在对应调用处修改）： // 处理事件void handleEvent();// 开启读操作void enableRead();// 开启写操作void enableWrite();// 使用ETvoid useET();// 获取SocketSocket *getSocket() const;// 获取监听事件uint32_t getListenEvents();// 获取就绪事件uint32_t getReadyEvents();// 设置就绪事件void setReadyEvents(uint32_t events);// 检查有效性bool getExist() const;// 设置有效性void setExist(bool _exist);// 设置回调函数。void setReadCallback(std::functionvoid() const callback); 修改 Channel 类的析构函数，其析构为 loop 调用 deleteChannel()（需要添加函数）（实际上还是相关联的 Epoll 封装类去 deleteChannel()）： Channel::~Channel(){\tmLoop-deleteChannel(this);}void EventLoop::deleteChannel(Channel *channel){\tep-deleteChannel(channel);} 在修改了 Channel 类后，其相关联的 Epoll 封装类也需要修改： 修改 Epoll::deleteChannel(Channel *channel)，需要把当前的 Channel 对象从 epoll 中删除，然后设置有效性为 false： void Epoll::deleteChannel(Channel *channel){\tint fd = channel-getSocket()-getFd();\terrorif(epoll_ctl(mEpFd, EPOLL_CTL_DEL, fd, nullptr) == -1, \"epoll delete error\");\tchannel-setExist(false);} 完善 Epoll::updateChannel(Channel *channel)： void Epoll::updateChannel(Channel *channel){\t// 更新事件event，读写事件区分开\tif (!channel-getExist())\t// 如果不存在，则添加 // 添加到epoll\telse\t// 存在，只需要修改 // 修改epoll} 完善 Epoll::poll(int timeout)： vectorChannel * Epoll::poll(int timeout){\t// epoll_wait\tfor (int i = 0; i nfds; ++i)\t{ // 遍历事件 events if(events EPOLLIN) // 读 if (events EPOLLOUT) // 写 if(events EPOLLET) // ET 模式\t}\t// 返回事件（Channel数组）} 最后检查各个文件无报错后，根据需要修改 CMakeLists.txt 文件。 之后，如果想创建不一样功能的服务器，可以通用我们这样的一个网络库。 该节代码：Github，Gitee 十四、再次重构，告一段落 14.1 重构思想 使用智能指针进行内存管理。在之前的开发中，使用的都是原始的指针，但是原始的指针对内存管理而言是困难的，极易产生内存泄漏、悬垂引用、野指针等问题。从 C++11 标准后，可以使用智能指针来管理内存，让程序员无需过多考虑内存资源的使用。 std::unique_ptr std::shared_ptr std::weak_ptr 避免资源的复制操作，尽量使用移动语义来进行所有权的转移，这对提升程序的性能有十分显著的帮助。 对错误、异常的处理。在项目上线后，我们不能因为某些错误就直接让程序崩溃或者终止。而且，绝大部分错误都是可恢复的： 如创建 socket 失败可能是文件描述符超过操作系统限制，稍后再次尝试即可。 监听 socket 失败可能是端口被占用，切换端口或提示并等待用户处理即可。 打开文件失败可能是文件不存在或没有权限，此时只需创建文件或赋予权限即可。 所以在底层的编码上，对于部分错误需要进行可恢复处理，避免一个模块或资源发生的小错误影响整个服务器的运行。 14.2 加入.clang-fromat Clang 本身是一个 C++ 的编译器。而 Clang-Format 是其中的一个格式化工具，可用于格式化（排版）多种不同语言的代码。在 Linux 中安装一下 clang-format： sudo apt install -y clang-format 如果使用 VSCode 进行编程的话，需要安装插件 Clang-Format，格式化快捷键：shift + alt + f。 详见：使用clang-format给你代码格式化 纯靠手动控制格式太麻烦了，还是使用工具吧 14.3 设计宏定义（Common.h） 显式将拷贝和移动函数删除，避免拷贝和移动操作： #define DISALLOW_COPY(className) \\\tclassName(const className ) = delete; \\\tclassName operator = (const className ) = delete;#define DISALLOW_MOVE(className) \\\tclassName(className ) = delete; \\\tclassName operator = (className ) = delete;#define DISALLOW_COPY_AND_MOVE(className) \\\tDISALLOW_COPY(className); \\\tDISALLOW_MOVE(className); 新增 FLAG 标记，统一标记函数的返回： enum FLAG {\tFL_UNDIFINED,\tFL_SUCCESS,\tFL_SOCKET_ERROR,\tFL_EPOLL_ERROR,\tFL_CONNECTION_ERROR,\tFL_ACCEPTOR_ERROR,\tFL_UNIMPLEMENTED}; 记得修改包含的头文件。 14.4 重构Socket类 Socket 类主要是对 socket 操作进行了封装，并主要应用在 Acceptor 类中和 Connection 类中。对 Socket 类的函数进行重构，同时删去 InetAddress 类： class Socket {public: DISALLOW_COPY_AND_MOVE(Socket); Socket(); ~Socket(); void setFd(int fd); int getFd() const; std::string getAddr() const; FLAG socketCreate(); FLAG socketBind(const char *ip, uint16_t port) const; FLAG socketListen() const; FLAG socketAccept(int clientFd) const; FLAG socketConnect(const char *ip, uint16_t port) const; FLAG setNonBlocking() const; bool isNonBlocking() const; size_t recvBufSize() const;private: int mFd{-1}; // socket 文件描述符}; 对于 Socket的创建、绑定、监听、接受等操作进行错误、异常的处理，在函数中大概如下： FLAG xxx() const {\t// 断言 fd 是否合法\t// 进行创建、绑定、监听、接受等操作\t// 判断上述操作是否出现异常\t// 出现异常则输出并返回错误标记，无异常则返回成功标记} 对于 Socket 的连接操作，是将 Socket 连接到某个 IP 地址，在函数中如下： FLAG Socket::socketConnect(const char *ip, uint16_t port) const {\t// 构建地址结构体\t// 连接\t// 判断上述操作是否出现异常\t// 出现异常则输出并返回错误标记，无异常则返回成功标记} 还有其他的 Get、Set 函数可详见代码。 14.4 小改Channel类和Epoll类 修改完 Socket 类后，比较底层的还有 Channel 类。Channel 类是网络库的核心组建之一，其对 socket 进行了更深度的封装，保存了需要对 socket 监听的事件和当前 socket 已经准备好的事件，并进行处理。此外，为了更新和获取在 epoll 中的状态，需要使用EventLoop进行管理。 对于 Channel 类的改动并不多，类声明如下： class Channel {public: DISALLOW_COPY_AND_MOVE(Channel); explicit Channel(EventLoop *loop, int fd); ~Channel(); void handleEvent() const; void enableRead(); void enableWrite(); void useET(); int getFd() const; uint32_t getListenEvents() const; uint32_t getReadyEvents() const; void setReadyEvents(uint32_t events); bool getExist() const; void setExist(bool _exist = true); void setReadCallback(std::functionvoid() const callback); void setWriteCallback(std::functionvoid() const callback);private: EventLoop *mLoop; // 指向与之关联的事件循环 int mFd; // 与之关联的Socket fd uint32_t mListenEvents{0}; // 监听的事件 uint32_t mReadyEvents{0}; // 就绪事件 bool exist{false}; // 指示该Channel是否存在有效 std::functionvoid() readCallback; // 读回调 std::functionvoid() writeCallback; // 写回调}; 大部分代码没什么特别的，可以见代码。但是需要注意的是，设置回调函数时，使用 std::move() ： void Channel::setxxxCallback(std::functionvoid() const callback){\txxxCallback = std::move(callback);} Epoll 类主要是进行 IO 多路复用，保证高并发。在 Epoll 类主要是对 epoll 中 channel 的监听与处理。声明改为如下： class Epoll {public: // 禁用拷贝和移动 DISALLOW_COPY_AND_MOVE(Epoll); Epoll(); ~Epoll(); FLAG updateChannel(Channel *channel) const; FLAG deleteChannel(Channel *channel) const; std::vectorChannel * poll(int timeout = -1) const; private: int mEpFd{-1}; // epoll文件描述符 struct epoll_event *mEvents{nullptr}; // epoll事件}; 函数方面也是小改。 14.5 小改EventLoop类 EventLoop 类用于对事件的轮询和处理。每一个 EventLoop 不断地调用 epoll_wait 来获取激活的事件，并处理。原本的 EventLoop 类中有一个普通的指针 Epoll*，现改为 std::unique_ptr。顺便再把函数声明为 const，使其更安全。 EventLoop 类声明如下： class EventLoop {public: EventLoop(); ~EventLoop(); DISALLOW_COPY_AND_MOVE(EventLoop); void loop() const; void updateChannel(Channel *channel) const; void deleteChannel(Channel *channel) const;private: std::unique_ptrEpoll ep; // 指向Epoll类实例的指针}; 由于使用了智能指针，所以其构造函数和析构函数也简化了不少。 14.6 小改Acceptor类 Acceptor 主要用于服务器接受连接，并在接受连接之后进行相应的处理。这个类需要独属于自己的 Channel，因此采用了智能指针管理。 Acceptor 类的重构类似。 将一些指针变成智能指针； 使用之前定义的 FLAG 标记。 Acceptor 类声明如下： class Acceptor {public: DISALLOW_COPY_AND_MOVE(Acceptor); explicit Acceptor(EventLoop *loop); ~Acceptor(); FLAG acceptConnection() const; void setNewConnectionCallback(std::functionvoid(int) const callback);private: std::unique_ptrSocket mSocket; // 用于处理套接字操作的套接字指针 std::unique_ptrChannel mChannel; // 用于接受连接的 Channel 指针 // 定义一个新建连接的回调函数 std::functionvoid(int) mNewConnectionCallback;}; 14.7 小改Connection类 对于每个 TCP 连接，都可以使用一个类进行管理，在这个类中，将注意力转移到对客户端 socket 的读写上，除此之外，他还需要绑定几个回调函数，例如当接收到信息时，或者需要关闭时进行的操作。 对于 Connection 类中的指针改用智能指针，同时按需求简化了部分函数，声明如下： class Connection {public: enum State { Invalid = 0, // 初始无效状态 Handshaking, // 握手过程中的状态 Connected, // 连接建立 Closed, // 连接关闭 Failed, // 连接失败 };public: explicit Connection(EventLoop *loop, int fd); ~Connection(); DISALLOW_COPY_AND_MOVE(Connection); FLAG read(); FLAG write(); FLAG send(std::string msg); void setOnMessageCallback(std::functionvoid(Connection *) const callback); void setDeleteConnectionCallback(std::functionvoid(int) const callback); void business(); State getState(); void close(); void setSentBuffer(char const *str); Buffer *getReadBuffer(); Buffer *getSendBuffer(); Socket *getSocket();private: // EventLoop *mLoop; // EventLoop指针 std::unique_ptrSocket mSocket; // Socket指针 std::unique_ptrChannel mChannel{nullptr}; // Channel指针 std::unique_ptrBuffer mReadBuffer{nullptr}; // 读缓冲区 std::unique_ptrBuffer mSendBuffer{nullptr}; // 写缓冲区 State mState{Invalid}; // 连接状态 std::functionvoid(int) mDeleteConnectionCallback; // 删除连接的回调函数 std::functionvoid(Connection *) mOnMessageCallback; // 业务逻辑回调函数 FLAG readNonBlocking(); // 非阻塞读 FLAG writeNonBlocking(); // 非阻塞写 FLAG readBlocking(); // 阻塞读 FLAG writeBlocking(); // 阻塞写}; 14.8 重头戏Server类 Server 类是对整个服务器的管理，他通过创建 acceptor 来接收连接。并管理 Connection 的添加。 对 Server 类的众多指针都改为智能指针，声明如下： class Server {public: Server(); ~Server(); DISALLOW_COPY_AND_MOVE(Server); void start(); void onConnect(std::functionvoid(Connection *) fn); void onMessage(std::functionvoid(Connection *) fn); FLAG newConnection(int fd); FLAG deleteConnection(int fd);private: std::unique_ptrEventLoop mainReactor; // 只负责接受连接，然后分发给一个subReactor std::vectorstd::unique_ptrEventLoop subReactors; // 处理事件循环 std::unique_ptrAcceptor acceptor; // 连接接受器 std::unordered_mapint, std::unique_ptrConnection connections; // 存储连接及其相应的文件描述符 std::unique_ptrThreadPool threadPool; // 线程池 std::functionvoid(Connection *) onConnectionCallback; // 连接的业务逻辑 std::functionvoid(Connection *) onMessageCallback; // 接收消息后的业务逻辑}; 修改完这么多类后，记得查看代码修改一下测试的 server.cpp、SingleClient.cpp、MultipleClients.cpp 等文件，然后编译即可。 该节代码：Github，Gitee 附录 附 1 - 代码运行环境 前十四章： 代码编写：Windows 下 Visual Studio 2022 代码编译及执行：阿里云 ECS，Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-169-generic x86_64) 在 Visual Studio 2022 中编写代码，接着连接远程服务器，将代码部署到服务器上。 前期在服务器使用 make 编译代码。Ubuntu之make：make命令行工具的简介、安装、使用方法之详细攻略 编译命令见每个 Day 中的 Makefile 文件。 make 命令为：make build 或 make。 清理编译结果命令为：make clean。 若没有 make，可以手动输入（Makefile中的） g++ 命令编译。 后期考虑使用 CMake 将项目工程化，详情看附录 2。 剩下章节： 代码编写：Windows 下 Visual Studio Code 代码编译及执行：WSL2 - Ubuntu 18.04 用 Visual Studio Code 远程连接 WSL 进行编写代码，使用 cmake 进行项目管理。 附 2 - CMake的安装和使用 此处的环境是：Visual Studio 2022 远程连接 Ubuntu 20.04.6 LTS 当然 Windows 也有 CMake，此处主要是在 Linux 下的使用。 附 2.1 检查远程的CMake环境和编译环境 可能需要先 apt-get update 更新一下 apt。 安装 CMake 工具 apt-get install cmake 可选择安装使用 clang 编译器 apt-get install clang 附 2.2 Visual Studio 2022中使用CMake进行远程Linux服务器开发 创建选择 CMake 项目，我此处构建演示项目 CMakeTestProject。 选择远程的 Linux 计算机，管理配置，新建一个配置。 编辑配置，具体看下图，主要修改部分已经框选。 正常编写代码，此处我用 Day12（第十二章）的代码作为演示。编写代码后，可以点进去根目录的 CMakeLists.txt 文件，保存一下（ctrl + s），就会自动复制到远程。 进行项目生成和编译，项目生成有两种方式： 可以选择右键项目名，选择以 CMake 视图查看。再进行生成或清理，最后使用编译命令进行编译。 可以在 Linux 的终端上执行以下命令： mkdir build cd build cmake ../src/ make 可以在 CMakeLists.txt 中的项目信息之前设置编译器为Clang。 生成成功后就可以在 CMakeLists.txt 中指定的输出文件夹中找到可执行文件或其他。 附 2.2 Visual Studio 2022中使用CMake进行WSL开发 有的人可能没有Linux服务器，但是WSL可以有的。如何安装WSL可以查看这里 基本步骤同上，但在新建配置和编辑时，需要做一些修改： 附 2.3 CMake相关资料 https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/ 附 3 - 可能出现的问题 在 Ubuntu 中安装 make 时，出现 “dpkg: error processing package ***” 的问题，可以参考 CSDN。 在线程池部分中，直接使用 g++ 命令会出现 “对‘pthread_create’未定义的引用” 的问题，需要加上 -lpthread 参数，详见 CSDN 或 Makefile 中的做法。","tags":["CPP","Linux"],"categories":["笔记"]},{"title":"Windows 下 vcpkg 的配置与使用","path":"/2024/19/","content":"关键词：C++ 什么是 vcpkg vcpkg 是 Microsoft 和 C++ 社区维护的免费开放源代码 C/C++ 包管理器。 使用上就类似于 Python 的 pip。 下载 vcpkg 前提条件： Git CMake IDE（我使用的是 Visual Studio 2022） 步骤如下： 使用 Git 命令下载 vcpkg，Git 会自动新建一个文件夹。 git clone https://github.com/Microsoft/vcpkg 运行文件夹下的 bootstrap-vcpkg.bat 文件，下载 vcpkg.exe。（如果下载卡顿可以自己去 Github 的 Release 处下载） 使用 vcpkg 运行： vcpkg integrate install 让系统里所有 C++ 编辑器都能与 vcpkg 建立链接。 对于库的安装和卸载 查找库： vcpkg search [packages] 安装库： vcpkg install [packages to install] 安装库还是从 Github 里下载安装，网络问题自行解决。 卸载库： vcpkg remove [packages to remove] 更多命令 集成到全局： vcpkg integrate install 移除全局： vcpkg integrate remove 集成到工程： vcpkg integrate project（在“\\scripts\\buildsystems”目录下，生成nuget配置文件） 查看支持的架构： vcpkg help triplet 指定编译某种架构的程序库： vcpkg install xxxx:x64-windows（x86-windows） 卸载已安装库： vcpkg remove xxxx 指定卸载平台： vcpkg remove xxxx:x64-windows 移除所有旧版本库： vcpkg remove --outdated 查看已经安装的库： vcpkg list 更新已经安装的库： vcpkg update xxx 导出已经安装的库： vcpkg export xxxx --7zip（–7zip –raw –nuget –ifw –zip） Visual Studio 中使用 安装完之后（以及集成到全局的情况下），可以在 VS 项目中直接 #include。 可能里面的库不是那么全。","tags":["CPP"],"categories":["日常"]},{"title":"JetBrains系软件的数据位置修改","path":"/2024/18/","content":"日常记录 以 CLion 为例。 需要关闭软件后操作。 查找原来的数据位置 config 项默认在：C:/Users/用户名/AppData/Roaming/JetBrains/产品 system 项默认在：C:/Users/用户名/AppData/Local/JetBrains/产品 把原来的数据拷贝到新位置 比如我需要把原来的数据拷贝到 E:/CLion 下新建的 .CLion 文件夹。 将 C:/Users/用户名/AppData/Roaming/JetBrains/CLion 下所有内容复制到 E:/CLion/.CLion 下新建的文件夹 config 。 将 C:/Users/用户名/AppData/Local/JetBrains/产品 下所有内容复制到 E:/CLion/.CLion 下新建的文件夹 system 。 修改配置文件指定路径 找到 CLion 安装目录下的 bin 目录，打开 idea.properties 配置文件，修改路径如下： #---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the settings directory.#---------------------------------------------------------------------idea.config.path=E:/CLion/.CLion/config#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the caches directory.#---------------------------------------------------------------------idea.system.path=E:/CLion/.CLion/system#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the user-installed plugins directory.#---------------------------------------------------------------------idea.plugins.path=E:/CLion/.CLion/config/plugins#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the logs directory.#---------------------------------------------------------------------idea.log.path=E:/CLion/.CLion/system/log 此处为我自己个人的配置，自行选择合适的路径修改。","categories":["日常"]},{"title":"使用免安装版VSCode","path":"/2024/17/","content":"日常记录 记录免安装VSCode的配置和插件安装位置设置 VSCode 下载地址：https://code.visualstudio.com/Download# 选择 .zip 格式。 下面是关于修改插件默认安装位置： 创建自定义文件夹，如 VSCode 目录下的 extensions。 使用命令定位到自定义文件夹。 code --extensions-dir \"path/to/extensions\" 给快捷方式也定位到自定义文件夹，在 .exe 后添加上 --extensions-dir \"path/to/extensions。 Reference： https://blog.csdn.net/weixin_43751329/article/details/122506815","categories":["日常"]},{"title":"Rust 语言学习记录","path":"/2024/rustbasic/","content":"关键词：Rust References： Rust语言圣经(Rust Course) Rust 程序设计语言 中文版 未完，待施工… 前言 什么是 Rust Rust 是一门新的静态编译编程语言，其功能定位与 C++ 相似，它的 1.0 版本于 2015 年发布。 rustc 使用 LLVM 作为它的后端。 Rust 支持多种平台和架构：x86、ARM、WebAssembly、Linux、Mac、Windows…… Rust 被广泛用于各种设备中： 固件和引导程序 智能显示器 手机 桌面 服务器 Rust 和 C++ 适用于类似的场景： 极高的灵活性。 高度的控制能力。 能够在资源匮乏的设备（如手机）上运行。 没有运行时和垃圾收集。 关注程序可靠性和安全性，而不会牺牲任何性能。 Rust 系统由许多工具组成： rustc：Rust 编译器，将 .rs 文件转换为二进制文件和其他中间格式。 cargo：Rust 依赖项管理器和构建工具（包管理工具）。负责下载依赖项并在构建项目时传递给编译器。其还附带内置的测试运行程序，用于执行单元测试。 rustup：Rust 工具链安装和更新工具。当更新版本时，其用于安装并更新 rustc 和 cargo。还可用于下载标准库的文档，同时安装多个 Rust 版本。 Rust 区分版本。这些版本支持对语言进行向后不兼容的更改。 为防止破坏代码，版本是可选的： 通过 Cargo.toml 文件为 crate 选择合适的版本。 为免分割生态系统，Rust 编译器可以混合使用为不同版本编写的代码。 Rust 的优势 编译时内存安全：在编译时可防止所有类内存 bug。 不存在未初始化的变量。 不存在“双重释放”。 不存在“释放后使用”。 不存在 NULL 指针。 不存在被遗忘的互斥锁。 不存在线程之间的数据竞争。 不存在迭代器失效。 没有未定义的运行时行为：每个 Rust 语句的行为都有明确定义。 数组访问有边界检查。 整数溢出有明确定义（panic 或回绕）。 现代语言功能：具有与高级语言一样丰富且人性化的表达能力。 枚举和模式匹配。 泛型。 无额外开销的外部函数接口（FFI）。 零成本抽象。 强大的编译器错误提示。 内置依赖管理器。 对测试的内置支持。 优秀的语言服务协议（Language Server Protocol）支持。 Windows 下安装 Rust 可执行二进制文件下载地址： https://www.rust-lang.org/zh-CN/tools/install https://rustup.rs/ 两个地址下载一个即可。 点击运行 rustup-init.exe。 显示默认安装在 C 盘。 此处已做修改，自定义安装路径。 自定义安装路径步骤如下： 创建自定义文件夹，我此处为 D:/rust。在内创建两个文件夹，分别为 .cargo 和 .rustup。 配置环境变量：把新建的文件夹添加到环境变量中。 在 PATH 环境变量中加入上两个变量。 至此再打开 rustup-init.exe，观察路径是否修改。 接着输入 1 执行默认安装即可。 在 VSCode 上使用 Rust 步骤如下： 在扩展中查找并安装 rust-analyzer 和 Native Debug 两个插件。 另外两个推荐插件： Even Better TOML，支持 .toml 文件完整特性 Error Lens，更好的获得错误展示 新建代码文件夹，在终端使用命令生成工程： cargo new hello 编写代码后，在终端使用命令运行： cargo buildcargo run 第一个 Rust 程序 每一个语言一开始会有它的 Hello World。 fn main(){ println!(\"Hello, world!\");} 函数以 fn 开头。 代码块以 { 开头，以 } 结尾。 Rust 有卫生宏，println! 就是一个例子。 这意味着它们不会意外地捕获它们所在作用域中的标识符。 Rust 字符串是 UTF-8 编码，可以包含 Unicode 字符。 下载依赖卡顿问题 解决方法是：覆盖默认的镜像地址 在 $HOME/.cargo/config.toml 添加以下内容： [source.crates-io]replace-with = 'ustc'[source.ustc]registry = \"git://mirrors.ustc.edu.cn/crates.io-index\" 创建一个新的镜像源 [source.ustc]，然后将默认的 crates-io 替换成新的镜像源: replace-with = 'ustc'。 Rust 基础入门 速览语法： // Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值fn main() { // 使用let来声明变量，进行绑定，默认a是不可变的 // 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数 let a = 10; // 语句的末尾必须以分号结尾 // 主动指定b的类型为i32 let b: i32 = 20; // 可以在数值中带上类型:30i32表示数值是30，类型是i32 // 声明变量时添加 mut 表示变量是可变的，mut是mutable的缩写 let mut c = 30i32; // 还能在数值和类型中间添加一个下划线，让可读性更好 let d = 30_i32; // 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数 let e = add(add(a, b), add(c, d)); // println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块 // 该函数将指定的格式化字符串输出到标准输出中(控制台) // {}是占位符，在具体执行过程中，会把e的值代入进来 println!(\"( a + b ) + ( c + d ) = {}\", e); // println! 会自动推导出具体的类型，因此无需手动指定输出类型}// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和fn add(i: i32, j: i32) - i32 { // 返回相加值，这里可以省略return // 不添加 ;，表示返回 i + j，添加则表示返回空。 i + j} 变量绑定与解构 Rust 默认变量是不可修改的，这使得程序运行时性能上的提升。 在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 Rust 命名规范。 变量绑定 在其他语言中，如 int a = 1 称为赋值。但 Rust 中， let a = 1 称为 变量绑定。 绑定一词源自 Rust 的所有权问题。 任何内存对象都是有主人的（Owner），对象完全属于它的主人。 绑定就是把这个对象绑定给一个变量，使变量成为它的主人。 变量的不可变与可变 fn main() { let x = 5; println!(\"Hello, world! {}\", x); x = 6; // 错误：x 是不可变的 println!(\"Hello, world! {}\", x); let mut y = 10; println!(\"Hello, world! {}\", y); y = 11; // 正确 println!(\"Hello, world! {}\", y);} 这种不可变的优势是：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。 忽略未使用的变量 Rust 的高安全性会认为不使用的变量可能会是个 BUG，所以进行警告。 使用下划线 _ 开头的变量名会被忽略。 fn main { let _x = 1;} 变量解构 let 不仅可以进行变量的绑定，还可以进行复杂变量的解构。 从一个相对复杂的变量中，匹配出该变量的一部分内容。 fn main() { // 匹配 a 和 b let (a, mut b): (bool, bool) = (true, false); println!(\"Hello, world! {} {}\", a, b); b = true; println!(\"Hello, world! {} {}\", a, b);} 不可变量与常量 Rust 默认的是不可变量。常量是经过 const 修饰的量，且在 Rust 中值类型必须标注。 fn main() { let a = 123; // 可以编译，但可能有警告，因为该变量没有被使用 let a = 456; const b: i32 = 1; let b = 2; // 错误：常量不能被重新赋值} 变量遮蔽 像上面写过的，Rust 允许声明相同的变量名，且后声明的变量名会遮蔽前面声明的。 fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\"x = : {x}\"); // 12 } println!(\"x = : {x}\"); // 6} 这个程序首先将数值 5 绑定到 x，然后通过重复使用 let x = 来遮蔽之前的 x，并取原来的值加上 1，所以 x 的值变成了 6。第三个 let 语句同样遮蔽前面的 x，取之前的值并乘上 2，得到的 x 最终值为 12。 这和 mut 变量的使用是不同的，第二个 let 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配，而 mut 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。 变量遮蔽的用处，在于在某个作用域内无需再使用之前的变量时，就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。 基本类型 内置数据类型有： 类型 字面量 有符号整数 i8、i16、i32、i64、i128、isize -10、0、1_000、123_i64 无符号整数 u8、u16、u32、u64、u128、usize 0、123、10_u16 浮点数 f32、f64 3.14、-10.0e20、2_f32 Unicode 标量类型 char 'a'、'α'、'∞' 布尔值 bool true、false 单元类型 () 其唯一的值也是 () 数字中的下划线均可忽略，仅方便辨识，即 1_000 可以写成 1000，123_i64 等价 123i64 每种类型占用空间为： iN、uN 和 fN 占用 NNN 位。 isize 和 usize 占用一个指针大小的空间。 char 占用 4 个字节，32 位空间。 bool 占用 1 个字节，8 位空间。 类型推导与标注：编译器必须在编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型。 Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型。 在某些情况下，Rust 编译器无法推导出变量类型，需要手动去给予一个类型标注。 数值类型 整数运算溢出 关于运算时整数溢出： fn mul(a: i16, b: i16, c: i16) - i16{ return a * b * c;}let _product = mul(100, 200, 300);// 尝试与溢出相乘，有符号整数16位的最大值为65535 在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic（崩溃,Rust 使用这个术语来表明程序因错误而退出）。 可以显式处理溢出，通过标准库针对原始数字类型提供的方法： wrapping_* 在所有模式下都按照补码循环溢出规则，如 wrapping_add。 checked_* 在发生溢出时返回 None 值。 overflowing_* 返回该值和一个指示是否存在溢出的布尔值。 saturating_* 可以限定计算后的结果不超过目标类型的最大值或低于最小值。 fn main() { let a: u8 = 255; let b = a.wrapping_add(20); let c = a.checked_add(20); let d = a.overflowing_add(20); let e = a.saturating_add(20); println!(\"{a}\"); // 255 println!(\"{b}\"); // 19 println!(\"{c:?}\"); // None println!(\"{d:?}\"); // (19, true) println!(\"{e}\"); // 255} 浮点数陷阱 浮点数的使用需要谨慎，原因： 浮点数往往是数字的近似表达（并不是精确的）。 浮点数在某些特性上时反直觉的（比如比较时）。 所以： 避免在浮点数上判断相等； 当结果在数学上存在未定义时需要小心。 一段代码： fn main() { let abc: (f32, f32, f32) = (0.1, 0.2, 0.3); let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3); println!(\"abc (f32)\"); println!(\" 0.1 + 0.2: {:x}\", (abc.0 + abc.1).to_bits()); // 3e99999a println!(\" 0.3: {:x}\", (abc.2).to_bits()); // 3e99999a println!(); println!(\"xyz (f64)\"); println!(\" 0.1 + 0.2: {:x}\", (xyz.0 + xyz.1).to_bits()); // 3fd3333333333334 println!(\" 0.3: {:x}\", (xyz.2).to_bits()); // 3fd3333333333333 println!(); assert!(abc.0 + abc.1 == abc.2); assert!(xyz.0 + xyz.1 == xyz.2);} NaN 对于数学上未定义的结果，比如负数取平方根，会返回一个 NaN表示。 所有与 NaN 交互的操作都会返回一个 NaN。 NaN 并不能用于比较。 可以使用 is_nan() 方法判断是否为 NaN。 数字运算 Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。 更多，运算符如下： 运算符 示例 解释 是否可重载 ! ident!(...), ident!{...}, ident![...] 宏展开 ! !expr 按位非或逻辑非 Not != var != expr 不等比较 PartialEq % expr % expr 算术取模 Rem %= var %= expr 算术取模与赋值 RemAssign expr, mut expr 借用 type, mut type, 'a type, 'a mut type 借用指针类型 expr expr 按位与 BitAnd = var = expr 按位与及赋值 BitAndAssign expr expr 逻辑与 * expr * expr 算术乘法 Mul *= var *= expr 算术乘法与赋值 MulAssign * *expr 解引用 * *const type, *mut type 裸指针 + trait + trait, 'a + trait 复合类型限制 + expr + expr 算术加法 Add += var += expr 算术加法与赋值 AddAssign , expr, expr 参数以及元素分隔符 - - expr 算术取负 Neg - expr - expr 算术减法 Sub -= var -= expr 算术减法与赋值 SubAssign - fn(...) - type, \\|...\\| - type 函数与闭包，返回类型 . expr.ident 成员访问 .. .., expr.., ..expr, expr..expr 右排除范围 .. ..expr 结构体更新语法 .. variant(x, ..), struct_type { x, .. } “与剩余部分”的模式绑定 ... expr...expr 模式: 范围包含模式 / expr / expr 算术除法 Div /= var /= expr 算术除法与赋值 DivAssign : pat: type, ident: type 约束 : ident: expr 结构体字段初始化 : 'a: loop {...} 循环标志 ; expr; 语句和语句结束符 ; [...; len] 固定大小数组语法的部分 expr expr 左移 Shl = var = expr 左移与赋值 ShlAssign expr expr 小于比较 PartialOrd = expr = expr 小于等于比较 PartialOrd = var = expr, ident = type 赋值/等值 == expr == expr 等于比较 PartialEq = pat = expr 匹配准备语法的部分 expr expr 大于比较 PartialOrd = expr = expr 大于等于比较 PartialOrd expr expr 右移 Shr = var = expr 右移与赋值 ShrAssign @ ident @ pat 模式绑定 ^ expr ^ expr 按位异或 BitXor ^= var ^= expr 按位异或与赋值 BitXorAssign \\| pat \\| pat 模式选择 \\| expr \\| expr 按位或 BitOr \\|= var \\|= expr 按位或与赋值 BitOrAssign \\|\\| expr \\|\\| expr 逻辑或 ? expr? 错误传播 序列 即基于范围，如 1..5 生成从1到4的连续数字，左闭右开，常用于循环中。 1..=5 即可表示全闭区间。 fn main() { for i in 1..5 { print!(\"{} \", i); } // 1 2 3 4} 使用 As 完成类型转换 使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型。 有理数与复数 社区开发的高质量 Rust 数值库：num。 导入也十分简单： 创建工程：cargo new complex-num； 在 Cargo.toml 中的 [dependencies] 添加 num = \"0.4.0\"。 导入 num：use num::Complex;。 cargo build cargo run。 实例代码： use num::complex::Complex;fn main() { let a = Complex { re: 2.1, im: -1.2 }; let b = Complex::new(11.1, 22.2); let result = a + b; println!(\"{} + {}i\", result.re, result.im); // 13.2 + 21i} 字符、布尔、单元类型 字符： 所有的 Unicode 值都可以作为 Rust 字符。 Unicode 为 4 字节编码，故字符类型也占用 4 个字节。 布尔类型： 占用 1 字节。 单元类型： 就是 ()，唯一的值也为 ()，可以理解为 void。 main 函数返回的就是单元类型。 可以用 () 作为 map 的值，表示不关注具体的值，只关注 key。 Rust中没有返回值的函数称为发散函数，即无法收敛的函数。 语句与表达式 Rust 的语句和表达式： 语句会执行一些操作但是不会返回一个值 表达式会在求值后返回一个值。 let mut x = 0; // 语句x = x + 1; // 语句x + 1 // 表达式 表达式总要返回值，且不能包含分号 带上分号则变成一条语句。 let 也是语句，故不能将 let 语句赋值给其他值。 表达式可以成为语句的一部分，例如 let y = 6 中，6 就是一个表达式，处理后后返回一个值 6。 能返回值，它就是表达式。 函数 大概的格式如： fn 函数名 ( 参数 ) 函数体 规范上，函数名和变量名需要使用蛇形命名法。 函数的位置随便，不在乎定义在何处。 Rust 中定义函数如果需要具备参数 必须声明参数名称和类型 。 fn main(){ fun(5, 6);} fn fun(x: i32, y: i32) { println!(\"x 的值为 : {}\", x); println!(\"y 的值为 : {}\", y);} Rust 函数声明返回值类型的方式： 在参数声明之后用 - 来声明函数返回值的类型。 fn five() - i32{ 5} 在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值。 fn ten() - i32{ return 10;} 当函数无返回值时： 返回一个 ()。 通过 ; 结尾的语句返回一个 ()。 上面的发散函数，可以用 ! 作返回类型，表示永不返回。 这种语法往往用作会导致程序崩溃的函数。 fn eend() - ! { panic!();} 所有权和借用 所有权 Rust 使用 所有权系统。 对于内存管理方面，计算机语言出现了三种流派： 垃圾回收机制（GC）：程序运行时不断寻找不再使用的内存，代表有 Java、Go； 手动管理内存：通过调用函数方式进行申请和释放内存，代表有 C++； 通过所有权管理内存：编译器在编译时会根据一系列规则进行检查。 检查只发生在编译器，所有在运行期并不会有性能上的损失。 C 语言上的不安全： int * fun(){ int a; a = 100; char *c = \"xyz\"; return a;} 上述代码可以编译通过。 a 为局部变量，当离开作用域时，其内存会被系统回收，从而返回成了悬挂指针。 c 的值时常量，存储在常量区，其生命周期为整个程序运行期间，当程序结束系统才会回收这片内存。 栈与堆 栈：先进后出。栈中的所有数据都必须占用已知且固定大小的内存空间。 堆：可存放对于大小未知或可能变化的数据。 当往堆上放入数据时，请求一定大小的内存空间，OS在堆的某处寻找并标记区域为已使用，返回该地址的指针。这个过程称为在堆上分配内存（分配）。 指针会被推入栈中，通过栈中的指针获取在堆上的数据。 两者在性能上：在栈上分配内存比在堆上分配内存要快，处理器在栈上分配数据会比在堆上分配数据更高效。 当代码调用函数时，传递给函数的参数（可能指向堆上数据的指针和函数的局部变量）依次入栈；当调用结束时，这些值按相反顺序出栈。 堆上的数据是缺乏组织的，所以管理堆上数据的分配和释放尤为重要。 当没有及时释放时，便造成了内存泄漏（数据无法被回收）。 所有权的原则 原则如下： Rust 中每一个值都被一个变量所拥有，该变量称为值的所有者（Owner）。 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。 当变量（所有者）离开作用域时，这个值将被丢弃。 变量绑定背后的数据交互 了解深拷贝和浅拷贝。 简单来说，深拷贝在内存上独立，复制内容在新的内存空间上。浅拷贝在内存上共享。比如把A复制到B，如果是深复制，则A和B独立互不影响；如果是浅复制，在修改A，B也会改变。 拷贝（浅拷贝） 浅拷贝只发生在栈上，如： let x = 5;let y = x; 基本类型在编译时是已知大小，会存储在栈上，所以拷贝其值是快速的。 Rust 具有 Copy 的特征，可以用在类似整型这样在栈中存储的类型。 如果拥有 Copy 特征，则一个旧变量在被赋值给其他变量后仍可用，即赋值的过程是拷贝的过程。 规则： 任何基本类型的组合可以 Copy； 不需要分配内存或某种形式的资源的类型是可以 Copy 一些 Copy 的类型： 所有整数类型； 所有浮点数类型； 布尔类型； 字符类型； 包含的类型都可 Copy 的元组； 不可变引用 T mut T 是可变引用，不可以 Copy。 克隆（深拷贝） Rust 永远不会自动创建数据的深拷贝。 任何自动的复制都不是深拷贝。 当需要深度复制数据时，使用方法 clone()。 使用 clone() 会降低程序性能 转移所有权 有代码如下： let x = 5;let y = x; 这是浅拷贝，且没有发生所有权的转移。 整个过程的赋值都是通过浅拷贝方式完成，发生在栈中，所以不需要所有权转移。 另有代码如下： let s1 = String::from(\"hello\");let s2 = s1; String 为字符串类型，是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存（跟 C++ 的 std::vector 类似）。 即不会自动拷贝。 此时处理方式为：当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop（丢弃） 任何东西。 把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。 这种类似于移动语义的机制，C++ 的 std::move()。 如果真的有两个所有者，那么当 s1 和 s2 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放（double free） 的错误。 函数传值与返回 将值传递给函数，一样会发生移动或者赋值。 fn main() { let s = String::from(\"hello\"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 // println!(\"s value: {}\", s); // 报错，s 已经移出作用域 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， println!(\"x value: {}\", x); // 但 i32 是 Copy 的，所以在后面可继续使用 x}// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，// 所以不会有特殊操作fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\"{}\", some_string);} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\"{}\", some_integer);} // 这里，some_integer 移出作用域。不会有特殊操作 对于返回的值： fn main() { let s1 = gives_ownership(); // gives_ownership 将返回值移给 s1 let s2 = String::from(\"hello\"); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 takes_and_gives_back 中,它也将返回值移给 s3 println!(\"s1: {:?}\", s1); // println!(\"s2: {:?}\", s2); // s2 被移走 println!(\"s3: {:?}\", s3);}// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，// 所以什么也不会发生。s1 移出作用域并被丢弃/// gives_ownership 将返回值移动给调用它的函数/// #### 返回值/// 返回一个 String 的所有权fn gives_ownership() - String { let some_string = String::from(\"hello\"); some_string}/// takes_and_gives_back 将传入字符串并返回该值/// #### 参数/// * `a_string` - 要被移动给调用者的 String/// #### 返回值/// 将接收到的 String 的所有权返回出去fn takes_and_gives_back(a_string: String) - String { // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数} 由于所有权，所以总是把一个值传来传去来使用它。 引用和借用 Rust 具有 借用 这一概念。 借用：获取变量的引用。 如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。 引用和解引用 常规引用是一个指针类型，指向了对象存储的内存地址。 fn main() { let x = 5; let y = x; assert_eq!(5, x); assert_eq!(5, *y);} 使用 * 进行解引用。 不可变引用 有如下代码： fn calculate_length(s: String) - usize { s.len()}fn main() { let s1 = String::from(\"hello\"); // 构造一个字符串 let len = calculate_length(s1); println!(\"{} {}\", s1, len); // hello 5} 此处函数传入字符串，但无需再用返回的方式传出所有权。 函数参数为 String。 在此处表示引用，允许使用值，但不获取所有权。 s1 为指向 s1 的引用，但不拥有它。 这样借用可以进行对变量一定的访问。 可变引用 当然也可以试着修改借用的变量。（得寸进尺） fn change(string: mut String) { string.push_str(\", 🌏\");}fn main() { let mut s = String::from(\"hello\"); change(mut s); println!(\"{}\", s); // hello, 🌏 // 由于 Unicode 编码，当然 🌏 也可以显示} s 是可变类型，mut s 是可变的引用，string: mut String 是接收可变引用的参数。 但是，可变引用同时只能存在一个。 fn main() { let mut s = String::from(\"hello\"); let r1 = mut s; // let r2 = mut s; // 报错 // print!(\"{} {}\", r1, r2);} 可变借用 r1 持续到最后一次使用的位置（即输出）； 在 r1 存活间，又尝试创建第二个可变借用 r2 是会引起出错的。 这种限制的好处就是使 Rust 在编译期就避免数据竞争。数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。 数据竞争可由以下行为造成： 两个或更多的指针同时访问同一数据 至少有一个指针被用来写入数据 没有同步数据访问的机制 可以通过加大括号限制作用域的方式解决部分问题。引用的作用域从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 还有一件事，可变引用与不可变引用不能同时存在。（太安全了吧QAQ） fn main() { let mut s = String::from(\"hello\"); let r1 = s; // 没问题 let r2 = s; // 没问题 let r3 = mut s; // 大问题，不能将`s`借用为可变的，因为它也被借用为不可变的 println!(\"{}, {}, and {}\", r1, r2, r3);} 可以理解为，正在借用不可变引用的用户，肯定不希望借用的东西莫名其妙被改了。 NLL NLL：Not-Lexical-Lifetimes，一种 Rust 编译器优化行为。 用于找到某个引用在作用域 } 结束前就不再被使用的代码位置。 悬垂引用 悬垂引用也叫做悬垂指针。 指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。 如在 C++ 中，易见的悬挂： int* fun(){\tint a = 10;\treturn a;}int main(){\tint aa = *fun();\tcout aa;\treturn 0;} 这其实是可以编译通过，但函数 fun 返回的指针式悬挂的。 当 fun 中的 a 离开作用域时，a 会被释放，但 fun 返回的指针仍然指向 a。 在 Rust 中编译器可以确保 引用永远也不会变成悬垂状态。 当获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。（🐂牛） fn main() { let r1 = dangle(); let r2 = no_dangle();}fn dangle() - i32 { // 报错：该函数返回了一个借用的值，但是已经找不到它所借用值的来源 let a = 10; a}fn no_dangle() - i32 { // 正常的，返回一个解引用，即值 let a = 10; *a} 借用规则总结 同一时刻，要么只有一个可变引用，要么有任意数量的不可变引用。 引用必须总是有效的（非悬挂）。 复合类型 复合类型是由其它类型组合而成的，最典型的就是结构体 struct 和枚举 enum。 字符串与切片 Rust 的字符串并没有想象中的简单。 切片 切片：允许引用集合中部分连续的元素序列，而不是引用整个集合。 创建切片的语法：[开始索引..终止索引]，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，左闭右开。 let s = String::from(\"hello world\");let hello = s[0..5]; // 等价于 s[..5]let world = s[6..11];let len = s.len();let all1 = s[0..len]; // 完整切片let all2 = s[..]; // 完整切片 注意，中文在 UTF-8 中占用三个字节。 字符串切片的类型标识是 str。 一个对初学者难受的代码： fn main() { let s = String::from(\"hello world\"); let word = first_word(s); println!(\"the first word is: {}\", word);}fn first_word(s: String) - str { s[..1]} 字符串 Rust 中的字符是 Unicode 类型。 每个字符占据 4 个字节内存空间。 但是在字符串中是 UTF-8 编码。 也就是字符串中的字符所占的字节数是变化的（1 - 4）。 Rust 语言级别上的字符串类型：str。 通常以引用类型出现 str，即字符串切片。 str 是硬编码进可执行文件，无法修改。 String 是一个可增长、可改变且具有所有权的 UTF-8 编码字符串。 当提及字符串，往往指的是 String 类型和 str 字符串切片类型。 除了 String，还有 OsString、OsStr、CsString、CsStr 等。 都以 String 或 Str 结尾，分别对应具有所有权和被借用的变量。 String 与 str 的转换 从 str 类型生成 String： let s1 = String::from(\"hello\")let s2 = \"hello\".to_string(); 从 String 类型转为 str：取引用 fn say_hello(s: str) { println!(\"Hello, {}!\", s);}fn main() { let s = String::from(\"Fingsinz\"); say_hello(s); say_hello(s[..2]); say_hello(s.as_str());} 字符串索引 字符串底层数据存储是 [u8]。 但不能使用索引进行访问字符串的子串。 因为字符串中的字符所占的字节数是变化的。 比如汉字占 3 个字节，而英文占 1 个字节。 以此类推，使用索引进行字符串切片（如 str[0..2]）时也需要格外小心。 字符串的操作 追加：在原有的字符串上追加，并不会返回新的字符串。 push(@pos, @char) 追加字符 char； push_str(@pos, @str) 追加字符串字面量。 字符串需要是可变的。 fn main() { let mut s = String::from(\"Hello\"); s.insert(5, '!'); println!(\"{}\", s); // Hello! s.insert_str(6, \"World\"); println!(\"{}\", s); // Hello!World} 替换：将字符串中的某个字符串替换成其他字符串。 replace(@target, @replacement)：将所有的目标字符串替换成新字符串。适用于 String 和 str。 该方法是返回一个新的字符串，而不是操作原来的字符串。 replacen(@target, @replacement, @count)：将 count 个的目标字符串替换成新字符串。适用于 String 和 str。 该方法是返回一个新的字符串，而不是操作原来的字符串。 replace_range(@range, @replacement)：将范围内的字符串替换成新字符串。仅适用于 String 类型。 该方法是直接操作原来的字符串，不会返回新的字符串。 fn main() { let s = \"rust rust rust\"; let news1 = s.replace(\"rust\", \"Rust\"); let news2 = s.replacen(\"rust\", \"Rust\", 2); println!(\"{}\", news1); // Rust Rust Rust println!(\"{}\", news2); // Rust Rust rust let mut ms = \"rust rust rust\".to_string(); ms.replace_range(5..6, \"R\"); println!(\"{}\", ms); // rust Rust rust} 删除：都仅适用于 String 类型。 pop()：删除并返回字符串的最后一个字符。 该方法直接操作原来的字符串。 返回值是一个 Option 类型，如果字符串为空，则返回 None。 remove(@pos)：删除并返回字符串指定位置（按字节处理）的字符。 该方法直接操作原来的字符串。 truncate(@pos)：删除字符串从指定位置（按字节处理）开始到结尾的全部字符。 该方法直接操作原来的字符串。 clear()：清空字符串。 该方法直接操作原来的字符串。 fn main() { let mut s1 = \"Rrust!\".to_string(); let popstr = s1.pop(); println!(\"{}\", popstr.unwrap()); // ! s1.remove(1); println!(\"{}\", s1); // Rust s1.truncate(2); println!(\"{}\", s1); // Ru s1.clear(); println!(\"{}\", s1); // s1 为空} 连接：连接字符串。 使用 + 或者 += 连接字符串：要求右边参数必须为字符串的切片引用类型，不能直接传递 String 类型。 + 返回一个新的字符串，调用了 add() 方法：fn add(self, s: str) - String。 format! ：与 print! 类似。适用于 String 和 str 类型。 fn main() { let s1 = \"Hello \".to_string(); let s2 = \"World\"; let s3 = s1 + s2; // println!(\"{}\", s1); // s1 所有权由函数已经转移给 s3 println!(\"{}\", s2); // World println!(\"{}\", s3); // Hello World let mut s4 = s3.clone(); s4 += \"!\"; println!(\"{}\", s4); // Hello World!} 字符串转义 通过转移的方式 \\ 输出 ASCII 和 Unicode 字符。 fn main() { // 通过 \\ + 字符的十六进制表示，转移输出一个字符 let s1 = \"\\x52\\x75\\x73\\x74\"; println!(\"{}\", s1); // Rust // \\u 可以输出一个 unicode 字符 let s2 = \"\\u{211D}\"; println!(\"{}\", s2); // ℝ // 加 \\ 转义不换行 let s3 = \"a\\ b\\ c\\ d e\"; println!(\"{}\", s3); // abcd // e} 操作 UTF-8 字符串 逐字符遍历： 避免索引尴尬情况。 逐字节遍历： 遍历字符串的底层字节数组表现形式。 fn main() { let s = \"我在用 Rust 编程\"; for c in s.chars() { print!(\"{}\", c); } // 我在用 Rust 编程 println!(\"\"); for b in s.bytes() { print!(\"{} \", b); } // 230 136 145 229 156 168 231 148 168 32 82 117 115 116 32 231 188 150 231 168 139 println!(\"\"); // 如果字符串包含双引号，可以在开头和结尾加 # let quotes = r#\"a\"bbb\"a\"#; println!(\"{}\", quotes); // 如果还是有歧义，可以继续增加，没有限制 let longer_delimiter = r###\"aaaa\"##!\"###; println!(\"{}\", longer_delimiter);} 如果需要准确从 UTF-8 字符串中获取子串是较为复杂的事情。 比如，想要从 holla中国人नमस्ते 这种变长的字符串中取出某一个子串，使用标准库是做不到的。 需要在 crates.io 上搜索第三方库来寻找想要的功能。 剖析字符串 关于 String 可变，而字符串字面值 str 却不可以： 字面值文本在编译时就知道内容，直接硬编码进可执行文件中。 字面值是不可变的，而字符串是有在程序运行中动态变化的需求。 String 类型支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来管理内容： 在使用 String::from 是就会构造 String类型； 在 } 处会自动调用释放内存函数 drop，用于释放离开作用域的变量。 元组 元组是由多种类型组合到一起形成的。 创建元组的语法如下： let tup: (i32, f64, u8) = (500, 6.4, 1); 解构元组 用同样的形式把一个复杂对象中的值匹配出来或者使用 . 都可以访问元组的元素。 fn main() { let tup = (500, 6.4, 1, \"aaa\".to_string()); let (x, y, z, w) = tup; println!(\"{}, {}, {}, {}\", x, y, z, w); // 500, 6.4, 1 //println!(\"{}, {}, {}, {}\", tup.0, tup.1, tup.2, tup.3); // 上语句会报错，因为字符串的所有权已经转移到 w，所以 tup.3 不再有效} 使用 let (x, y, z, w) = tup 进行模式匹配，用相似的模式进行匹配，元组对应的值就会绑定到变量 x、y、z 和 w 上。 元组常用于函数的返回值上，返回多个值。 fn main() { let s1 = \"Hello \".to_string(); let s2 = \"World\"; let (s1, len) = string_splicing(s1, s2); println!(\"{}:{}\", s1, len);}fn string_splicing(s1: String, s2: str) - (String, usize) { let ret = s1 + s2; let len = ret.len(); (ret, len)} 结构体 结构体与元组：都是由多种类型组合而成。 但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。 结构体的语法 一个结构体由几部分组成： 关键字 struct 定义； 清晰的结构体名称； 几个结构体字段。 如： struct Student { id: i32, name: String, age: i8,}fn main() { let student = Student { id: 1, age: 20, name: String::from(\"John\"), }; println!(\"{}, {}, {}\", student.id, student.name, student.age);} 初始化实例时，每个字段都需要初始化； 初始化时的顺序不必与定义时的顺序一致。 访问结构体字段时使用 .。 另外注意，Rust 不支持将结构体的某个字段标记为可变，需要整个结构体声明为可变。 支持简化结构体构建： fn make_student(id: i32, name: String, age: i8) - Student { Student { id, name, age }} 进行结构体更新时，也是挺方便的： fn main() { let student1 = Student { id: 1, age: 20, name: String::from(\"John\"), }; let student2 = Student { age: 21, ..student1 }; println!(\"{} {} {}\", student2.id, student2.name, student2.age);} .. 语法表明凡是没有显式声明的字段，全部从 student1 中自动获取。 需要注意的是 ..student1 必须在结构体的尾部使用。 此处 student1.name 的所有权已经移到 student2，所以 student1.name 不再有效，不能输出，但是其他字段（基本类型）依旧有效。 结构体的内存排序 struct File { name: String, data: Vecu8,} File 的内存排序如下： File struct name data String Vec ptr size capacity ptr size capacity name 的 ptr 指向一块 [u8; name.size] 内存的开头。 data 的 ptr 指向另一块 [u8; data.size] 内存的开头。 元组结构体 结构体必须要有名称，但是结构体的字段可以没有名称。 元组结构体：这种结构体长得很像元组，字段没有名称。 struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() { let p1 = Point(0, 0, 0);} 单元结构体 单元结构体跟单元类型很像，没有任何字段和属性。 当定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用单元结构体。 结构体数据的所有权 结构体当中它所拥有的数据应当是拥有所有权的，而不是其他地方借用的。 借用数据需要考虑生命周期：生命周期确保结构体的作用范围比它所借用的数据的作用范围要小。 [derive(Debug)] Rust 默认没有给结构体实现 Display 特征，而把输出格式的选择权利交给程序员。 顾名思义，Display 特征能够使得结构体实现自动格式输出。 使用 #[derive(Debug)] 对结构体进行了标记，这样才能使用 println!(\"{:?}\", s); 的方式对其进行打印输出： #[derive(Debug)]struct Rectangle { width: u32, height: u32,}fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!(\"{:?}\", rect1); // Rectangle { width: 30, height: 50 }} 使用 println!(\"{:?}\", s); 输出时，需要结构体实现 Debug 特征。 #[derive(Debug)] 用 derive 派生实现了 Debug 特征。 当结构体较大时，此时可以使用 {:#?} 来替代 {:?} 会有更美观的格式。 还有一个简单的输出 debug 信息的方法：使用 dbg! 宏。 该宏会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，还有表达式的求值结果。 它最终还会把表达式值的所有权返回。 #[derive(Debug)]struct Rectangle { width: u32, height: u32,}fn main() { let scale = 2; let rect1 = Rectangle { width: dbg!(30 * scale), // 30 * scale = 60 height: 50, }; dbg!(rect1); // [src\\main.rs:14:5] rect1 = Rectangle { // width: 60, // height: 50, // }} 枚举 通过列举可能的成员来定义一个枚举类型，如熟悉的枚举一周： enum Weekday { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday,} 枚举类型是一个类型，其会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。 #[derive(Debug)]enum Weekday { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday,}fn main() { let (oh_no, no_no, ok, come_on, happy) = ( Weekday::Monday, Weekday::Tuesday, Weekday::Wednesday, Weekday::Thursday, Weekday::Friday, ); let (happier, sad) = (Weekday::Saturday, Weekday::Sunday); println!(\"{:?} {:?} {:?} {:?} {:?}\", oh_no, no_no, ok, come_on, happy); println!(\"{:?} {:?}\", happier, sad);} 在 Rust 中，任何数据类型都可以放入到枚举中，这给枚举增加了更多功能。 enum Operation { Quit, // 不包含变量 ChangeColor(u8, u8, u8), // 包含三个 u8 变量 Write(String), // 包含一个 String 变量 Move { x: i32, y: i32 }, // 包含一个匿名结构体变量}fn main() { let o1 = Operation::Quit; let o2 = Operation::ChangeColor(0, 0, 0); let o3 = Operation::Write(\"hello\".to_string());} 数组 数组：array，长度固定，是基本类型。 动态数组：Vector，长度可动态增长。 数组的长度是编译时确定的，而动态数组的长度是运行时确定的。 数组 array 是存储在栈上，而动态数组 Vector 是存储在堆上。 Vector 和 String 一样都是高级类型，即集合类型。 创建数组 fn main() { let a = [1, 2, 3, 4, 5]; let b: [i32; 5] = [1, 2, 3, 4, 5]; let c = [3; 5]; // [3, 3, 3, 3, 3]} 数组类型通过方括号声明； 可以显式指定数组元素类型和长度。 数组的长度也是类型的一部分。 访问数组元素 数组是连续的，可以通过索引访问。 下标从 0 开始。 另外，如果使用索引访问元素时，编译器会在编译期预防越界情况。但如果索引是外部输入的，那么编译器并不能预防。 如果数组元素非基础类型，且出现： fn main() { let array = [String::from(\"rust is good!\"); 8]; println!(\"{:#?}\", array);} 那必然是报错的。String 是具有所有权的高级类型，其并不能在数组中使用这种形式进行复制（没有深拷贝）。 而解决方法应该是调用 std::array::from_fn： fn main() { let array: [String; 8] = std::array::from_fn(|_i| String::from(\"rust\")); println!(\"{:#?}\", array);} 数组切片 数组也允许引用集合中的部分连续片段： let a = [1, 2, 3, 4, 5];let slice = a[1..3];println!(\"{:#?}\", slice); 省略主函数部分。 切片的特点： 切片的长度可以与数组不同，并不是固定的，取决于指定的起始和结束位置。 创建切片的代价非常小，因为切片只是针对底层数组的一个引用。 切片类型 [T] 拥有不固定的大小，而切片引用类型 [T] 则具有固定的大小，[T] 更有用，str 字符串切片也同理。 流程控制 if-else if if else 表达式根据条件执行不同的代码分支： if condition == true { // A...} else { // B...} 若 condition 的值为 true，则执行 A 代码，否则执行 B 代码。 if 语句（块）是表达式，可以返回值，但是需要保证每个分支的返回类型一样： let a = 1;let b = if a == 1 { 5 } else { 6 // 正确 //'6' // 错误，类型不一致 }; 与其它语言一样，通过 if-else if 可以处理多重条件判断。 循环控制 Rust 有三种循环控制方式： for 循环； while 循环； loop 循环。 for 循环 简单举个例子： fn main() { for i in 1..=5 { print!(\"{} \", i); }} 1..=5 是一个范围，表示 从 1 到 5 的 序列。 除了数字的循环外，for-in 用法更靓眼： for 元素 in 集合 { // do something...} for-in的用法 使用方法 等价使用方式 所有权 for item in collection for item in IntoIterator::into_iter(collection) 转移所有权 for item in collection for item in collection.iter() 不可变借用 for item in mut collection for item in collection.iter_mut() 可变借用 for-in 中也可以获取元素的索引： fn main() { let a = [4, 3, 2, 1]; // 一般的循环，数组实现了深拷贝所以所有权还在 for i in a { print!(\"{} \", i); // 4 3 2 1 } // 可获取索引的循环 // `.iter()` 方法把 `a` 数组变成一个迭代器 for (i, v) in a.iter().enumerate() { print!(\"({}:{}) \", i + 1, v); // (1:4) (2:3) (3:2) (4:1) }} 如果想单纯的循环十次，（用于）循环变量不使用，可以这样写： fn main() { for _ in 1..=10 { println!(\"Hello, world!\"); // 打印10次 }} _ 的含义是忽略该值或类型的意思。 比较两种循环： // 第一种let collection = [1, 2, 3, 4, 5];for i in 0..collection.len() { let item = collection[i]; // ...}// 第二种for item in collection {} 性能比较： 第一种方式使用索引，会触发边界检查，导致性能损耗。 第二种方式在编译时就完成分析并证明访问时合法的，性能不会有损失。 安全性比较： 第一张对 collection 的索引访问是非连续的，存在一定可能性在两次访问之间 collection 发生了变化，导致脏数据产生。 第二种直接迭代是连续访问。（由于所有权限制，访问过程中，数据不会发生变化） continue 和 break 使用 continue 可以跳过当次循环，开始下次循环。（在其它语言也这样吧） 使用 break 可以直接跳出当前整个循环。 while 循环 跟 C++ 类似。 fn main() { let mut n = 0; while n = 5 { print!(\"{} \", n); // 0 1 2 3 4 5 n = n + 1; } println!(\"{}\", n); // 6} loop 循环 loop 就是一个简单的 无限循环，不会自动结束。 需要额外的 break 关键字控制循环结束。 loop 是一个表达式，可以返回值。 在 loop 循环中，break 结束时可以带出一个返回值。 fn main() { let mut n = 0; let ret = loop { n += 1; if n == 5 { break n; } }; println!(\"{}\", ret); // 5} 模式匹配 match 的魅力。 match 匹配 match 的通用形式： match target { 模式1 = 表达式1, 模式2 = { 语句1; 语句2; 表达式2 }, _ = 表达式3} match 允许将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码。 match 的分支有两个部分：一个模式和针对该模式的处理代码。 跟 switch 很像，_ 类似于 default。 除了 _，还可以随便用一个变量名承接即可。 match 语句会从上往下匹配，遇到第一个匹配的就执行对应的表达式，然后结束。 可能会出现 |，类似于逻辑或，比如 X|Y 可以匹配 X 也可以匹配 Y。 举一个例子： enum Direction { Up, Down, Left, Right,}fn main() { let direction = Direction::Up; match direction { Direction::Up = println!(\"Up\"), Direction::Down = println!(\"Down\"), Direction::Left = println!(\"Left\"), Direction::Right = println!(\"Right\"), }} match 表达式赋值 match 本身也是一个表达式，因此可以用来赋值： enum Direction { Up, Down,}fn main() { let direction = Direction::Up; let direction_num = match direction { Direction::Up = 0, Direction::Down = 1, }; println!(\"{}\", direction_num);} 模式绑定 模式匹配还可以从模式中取出绑定的值，例如： enum Action { Say(String), MoveTo(i32, i32),}fn main() { let actions = [Action::Say(\"Hello Rust\".to_string()), Action::MoveTo(1, 2)]; for action in actions { match action { Action::Say(s) = { println!(\"{}\", s); } Action::MoveTo(x, y) = { println!(\"Point ({}, {})\", x, y); } } }} enum 中可以放入数据类型，再加上模式匹配可以从模式中取出绑定的值，所以可以实现上述代码。 穷尽匹配 match 的匹配必须穷尽所有情况，比如下述代码因为没有穷尽所有情况而报错。 enum Direction { Up, Down, Left, Right,}fn main() { let direction = Direction::Up; match direction { Direction::Up = println!(\"UpUp\"), // 缺少 Down 的匹配 Direction::Left | Direction::Right = { println!(\"ohh\"); } };} if let 匹配 当只要匹配一个条件，且忽略其他条件时就用 if let。 如下面两个代码是等价的： 实现1： fn main() { let v = Some(3u8); match v { Some(3) = println!(\"three\"), _ = (), }} 实现2： fn main() { let v = Some(3u8); if let Some(3) = v { println!(\"three\"); }} 变量遮蔽 无论是 match 还是 if let，这里都是一个新的代码块，而且这里的绑定相当于新变量，如果你使用同名变量，会发生变量遮蔽： enum Action { Say(String),}fn main() { let action = Action::Say(\"Hello Rust\".to_string()); let s = \"abc\".to_string(); match action { Action::Say(s) = { println!(\"{}\", s); // Hello Rust } } println!(\"{}\", s); // abc} matches! 宏 matches! 宏可以将一个表达式跟模式进行匹配，然后返回匹配的结果 true 或者 false。 如使用： fn main() { let ch = 'a'; let number = 5; println!(\"{}\", matches!(ch, 'a'..='z')); // true println!(\"{}\", matches!(number, 10..=20)); // false} 解构 Option Option 是一种枚举，用于解决 Rust 中变量是否有值的问题： enum OptionT { None, Some(T),} 一个变量要么有值：Some(T)，要么为空：None。 由于封装，可以直接使用 Some(T) 和 None，而不需要使用 Option::Some(T) 和 Option::None。 使用 OptionT，是为了从 Some 中取出其内部的 T 值以及处理没有值的情况。 编写一个函数，它获取一个 Optioni32，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 None 值： fn add_one(x: Optioni32) - Optioni32 { match x { None = None, Some(x) = Some(x + 1), }}fn main() { let five = Some(5); let none: Optioni32 = None; let (ans1, ans2) = (add_one(five), add_one(none)); println!(\"{:?}, {:?}\", ans1, ans2); // Some(6), None} 模式使用场景 用到模式的地方： match 分支。 if let 语句。 while let 循环。 fn main() { let mut v = ['a', 'b', 'c'].to_vec(); while let Some(top) = v.pop() { print!(\"{} \", top); } // c b a} for 循环：使用特定模式匹配可迭代容器。 let 语句：使用变量绑定数据也是一种模式匹配。 函数参数也是模式。 还有关于 let 和 if let： let Some(x) = some_option_value; 因为右边的值可能不为 Some，而是 None，这种时候就不能进行匹配。 对于 let、for、match 都要求完全覆盖匹配。 而 if let： if let Some(x) = some_option_value { println!(\"{}\", x);} if let 允许匹配一种模式，忽略其余模式。 全模式列表 模式的相关语法 匹配字面值 fn main() { let x = 1; match x { 1 = println!(\"one\"), _ = println!(\"anything\"), }} 代码获得特定的具体值。 匹配命名变量 fn main() { let x = Some(5); let y = 10; match x { Some(y) = println!(\"match y = {:?}\", y), _ = println!(\"match： x = {:?}\", x), } println!(\"main: x = {:?}, y = {:?}\", x, y);} 变量遮蔽。 单分支多模式 fn main() { let x = 1; match x { 1 | 2 = println!(\"one or two\"), 3 = println!(\"three\"), _ = println!(\"anything\"), }} 使用 | 表示或。 通过序列 …= 匹配值范围 fn main() { let x = 5; match x { 1..=5 = println!(\"1~5\"), _ = println!(\"something else\"), }} 序列只允许用于数字或字符类型，原因是它们可以连续。 解构并分解值 使用模式来解构结构体、枚举、元组、数组和引用。 解构结构体 struct Point { x: i32, y: i32,}fn main() { let p = Point { x: 0, y: 7 }; let Point { x, y } = p; let Point { x: a, y: b } = p; println!(\"({}, {})\", x, y); // (0, 7) println!(\"({}, {})\", a, b); // (0, 7)} 模式中的变量名不必与结构体中的字段名一致。 还可以匹配结构体中的某个字段： fn main() { let p = Point { x: 0, y: 7 }; match p { Point { x, y: 0 } = println!(\"在x轴上{}\", x), Point { x: 0, y } = println!(\"在y轴上{}\", y), Point { x, y } = println!(\"不在轴上({}, {})\", x, y), } // 在y轴上7} 解构枚举 enum Op { Quit, Move1 { x: i32, y: i32 }, // 绑定结构体 Move2(i32, i32), // 绑定元组}fn main() { let op = Op::Move2(1, 2); match op { Op::Quit = println!(\"Quit\"), Op::Move1 { x, y } = println!(\"Move1: ({}, {})\", x, y), Op::Move2(x, y) = println!(\"Move2: ({}, {})\", x, y), };} 模式匹配需要类型相同。 解构嵌套的结构体和枚举 enum Color { Rgb(i32, i32, i32), Hsv(i32, i32, i32),}enum Op { Quit, ChangeColor(Color),}fn main() { let msg = Op::ChangeColor(Color::Hsv(0, 160, 255)); match msg { Op::ChangeColor(Color::Rgb(r, g, b)) = { println!(\"R:{}, G:{}, B:{}\", r, g, b) } Op::ChangeColor(Color::Hsv(h, s, v)) = { println!(\"H:{}, S:{}, V:{}\", h, s, v) } _ = (), }} match 可以匹配嵌套的项。 解构结构体和元组 fn main() { struct Point { x: i32, y: i32, } let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 }); println!(\"feet: {}, inches: {}, x: {}, y: {}\", feet, inches, x, y);} 用复杂的方式来混合、匹配和嵌套解构模式。 上述代码为结构体和元组嵌套在元组中，把原始类型解构出来。 解构数组 定长数组解构： fn main() { let arr = [1, 2, 3]; let [x, y, z] = arr; println!(\"{} {} {}\", x, y, z);} 不定长数组解构： fn main() { let _arr = [1, 2, 3]; let arr = _arr[..]; if let [x, ..] = arr { println!(\"{}\", x); // 1 } if let [.., y] = arr { println!(\"{}\", y); // 3 } let arr: [i32] = []; assert!(matches!(arr, [..])); // 断言成功 assert!(!matches!(arr, [x, ..])); // 断言成功} 忽略模式中的值 使用 _ 忽略整个值：当不再需要特定函数参数时，最好修改签名不再包含无用的参数。 fn fun(_: i32, y: i32) - () { println!(\"只使用y：{}\", y);}fn main() { fun(1, 2);} 使用嵌套的 _ 忽略部分值。 fn main() { let mut setting_value = Some(5); let new_setting_value = Some(10); match (setting_value, new_setting_value) { (Some(_), Some(_)) = {} // 不关心值，只关心类型 _ = { setting_value = new_setting_value; } } println!(\"setting is {:?}\", setting_value); let numbers = (2, 3, 6, 7, 8); match numbers { (first, _, third, _, fifth) = { println!(\"{}, {}, {}\", first, third, fifth); // 2, 6, 8 } }} 使用下划线开头忽略未使用的变量。 带 _ 的变量仍会将值绑定到变量，而 _ 则完全不会绑定。 用 .. 忽略剩余值。 fn main() { let numbers = (2, 3, 6, 7, 8); match numbers { (first, .., end) = { println!(\"{}, {}\", first, end); // 2, 8 } } match numbers { (first, ..) = { println!(\"{}\", first); // 2 } }} 匹配守卫提供的额外条件 匹配守卫（match guard）是一个位于 match 分支模式之后的额外 if 条件，它能为分支模式提供更进一步的匹配条件。 fn main() { let x = Some(6); let y = false; match x { Some(n) if n 5 = println!(\" 5\"), Some(n) if y = println!(\"{}\", n), Some(_) | None if y = println!(\"aa\"), _ = println!(\"bb\"), }} 匹配守卫直接取得解构后的值作比较（如匹配分支1）； 匹配守卫可以直接用外部的 y（如匹配分支2）； 使用 | 加上匹配守卫，需要先满足前面 或 的条件再判断匹配守卫的条件（如匹配分支3），即 (Some(_) | None) if y。 @ 绑定 @ 运算符允许为一个字段绑定另一个变量。 enum Op { Operation { id: i32 },}fn main() { let op = Op::Operation { id: 5 }; match op { Op::Operation { id: mid @ 3..=7 } = { println!(\"{} = 3 and {} = 7\", mid, mid); } Op::Operation { id: 0..=2 } = { println!(\"= 0 and = 2\"); } Op::Operation { id } = { println!(\"{}\", id); } };} 第一个匹配分支中，测试 Op::Operation 的 id 字段是否位于 3..=7 范围内，同时也希望能将其值绑定到 mid 变量中以便此分支中相关的代码可以使用它。 其实也可以把 mid 命名为 id，不影响、 第二个匹配分支中，没有使用 @ 绑定，所以不能再使用结构体中的 id。 在 Rust 1.56 时新增，使用 @ 还可以在绑定新变量的同时对目标进行解构。 struct Point { x: i32, y: i32,}fn main() { // 绑定新变量 `p`，同时对 `Point` 进行解构 let p @ Point { x: px, y: py } = Point { x: 10, y: 23 }; println!(\"x: {}, y: {}\", px, py); // x: 10, y: 23 println!(\"{:?}\", p); // Point { x: 10, y: 23 } let point = Point { x: 10, y: 5 }; if let p @ Point { x: 10, y } = point { println!(\"({},{})\", p.x, p.y); // (10,5) } else { println!(\":(\"); }} 在 Rust 1.53 新增特性： 在 Rust 1.53 之前，需要这么写： fn main() { let number = 5; match number { num @ 1 | num @ 2 | num @ 3 = println!(\"{}\", num), _ = println!(\"{}\", number), }} 但是在 Rust 1.53 之后，可以这么写： fn main() { let number = 5; match number { num @ (1 | 2 | 3) = println!(\"{}\", num), _ = println!(\"{}\", number), }} 方法 在面向对象编程中，方法指的是对象可执行的函数。 object.method(); 定义方法 使用 impl 来定义方法。 struct Rect { width: i32, height: i32,}impl Rect { fn new(w: i32, h: i32) - Rect { Rect { width: w, height: h, } } fn area(self) - i32 { self.width * self.height }}fn main() { let shape = Rect::new(4, 5); println!(\"{}\", shape.area());} impl Rect 表示为 Rect 实现方法，即 impl 语句块中一切都是跟 Rect 相关联的。 new 是 Rect 的关联函数，因为第一个参数不是 self，且 new 不是关键字。 area 中的参数 self 表示借用当前的 Rect 结构体， Rust 的对象定义和方法定义是分离的。 方法代替函数的好处有： 不用再在函数签名中书写 self 对应的类型； 代码的组织性、内聚性更强，对于代码维护和阅读有好处。 self self 指代类型的实例（跟Python中挺像）。 为哪个结构体实现方法，那么 self 就是指代哪个结构体的实例。 self 依然具有所有权的概念： self 表示 Rect 的所有权转移到该方法中，这种形式用的较少。 self 表示该方法对 Rect 的不可变借用。 mut self 表示可变引用。 方法名 在 Rust 中，允许方法名跟结构体的字段名相同。 struct Rect { width: i32, height: i32,}impl Rect { fn width(self) - i32 { self.width } fn height(self) - i32 { self.height } fn area(self) - i32 { self.width * self.height }} 此时，rect.width() 表示调用方法，rect.width 表示访问字段。 方法跟字段同名，适用于 getter 访问器的实现。 -运算符？ C/C++ 中，如果对象指针调用方法时，会使用到 -：object-fun()。 但在 Rust 中，会有自动引用和解引用的功能。 当使用 object.fun() 调用方法时，会自动为 object 添加 、mut 或 * 以便使得与方法签名匹配。 因为方法中明确接收 self 的类型。 带有多个参数的方法 和普通函数一样： impl Rect { fn can_hold(self, other: Rect) - bool { self.width = other.width self.height = other.height }} 关联函数 关联函数：定义在 impl 中且参数没有 self 的函数。 构造函数的写法：不包含 self 即可。 Rust 中有一个约定俗成的规则，使用 new 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 new 作为关键字。 struct Rect { width: i32, height: i32,}impl Rect { fn new(width: i32, height: i32) - Rect { Rect { width, height } }}fn main() { let rect = Rect::new(30, 50);} 多个 impl 定义 Rust 允许为一个结构体定义多个 impl 块，目的是提供更多的灵活性和代码组织性。 例如当方法多了后，可以把相关的方法组织在同一个 impl 块中。 为枚举实现方法 枚举可以像结构体一样，实现方法。 #![allow(dead_code)]enum WeekDays { Monday, Tuesday, Wednesday, Thursday, Friday,}impl WeekDays { fn get_day_name(self) - String { match self { WeekDays::Monday = \"Monday\".to_string(), WeekDays::Tuesday = \"Tuesday\".to_string(), WeekDays::Wednesday = \"Wednesday\".to_string(), WeekDays::Thursday = \"Thursday\".to_string(), WeekDays::Friday = \"Friday\".to_string(), } }}fn main() { let day = WeekDays::Friday; println!(\"今天是 {}\", day.get_day_name());} 泛型和特征 泛型 Generics 当出现需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。 C++ 中的模板函数就是一种解决方法。 泛型怎么不是一种多态呢。 Rust 给出的解决方案是： fn addT: std::ops::AddOutput = T(a: T, b: T) - T { a + b}fn main() { println!( \"{}, {}, {}\", add(1i8, 2i8), // 3 add(1.2f32, 2.3f32), // 3.5 add(20, 30) // 50 );} T 就是泛型参数。 std::ops::AddOutput = T 为对 T 进行限制，因为不是所有的 T 类型都能进行相加。 结构体中使用泛型 struct PointT { x: T, y: T,}fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3.0, y: 4.0 };} 需要提前声明泛型参数 PointT。 x 和 y 字段时相同的类型。 当然可以不止一个泛型参数： struct PointT, U { x: T, y: U,} 枚举中使用泛型 很明显，Option 中过就有一个泛型参数 T。 enum OptionT { Some(T), None,} 还有一个： enum ResultT, E { Ok(T), Err(E),} 这个枚举主要用于函数返回值，Result 关注的主要是值的正确性。 方法中使用泛型 struct RectT { width: T, height: T,}implT RectT { fn width(self) - T { self.width }} 使用泛型参数前，需要提前声明，如 implT。 impl 处的 RectT 不再是泛型声明，而是一个完整的结构体类型。 为具体的泛型类型实现方法 把 T 换成特定的具体类型： struct RectT, U { width: T, height: U,}impl Recti32, i32 { fn width(self) - i32 { self.width }}fn main() { let rect1 = Rect { width: 10, height: 20, }; let rect2 = Rect { width: 10, height: 22.0, }; println!(\"{}\", rect1.width()); println!(\"{}\", rect2.width()); // 报错，无该方法} const 泛型 Rust 1.51 版本引入。 const 泛型是针对值的泛型。 正好可以用于处理数组长度的问题。 数组而言，长度也是类型的一部分。 fn display_arrayT: std::fmt::Debug, const N: usize(arr: [T; N]) { println!(\"{:?}\", arr);}fn main() { let arr: [i32; 3] = [1, 2, 3]; display_array(arr); let arr: [i32; 2] = [1, 2]; display_array(arr);} 定义一个类型为 [T; N] 的数组，T 是一个基于类型的泛型参数；而 N 是一个基于值的泛型参数，用来代替数组的长度。 泛型的性能 在 Rust 中泛型是零成本的抽象，意味着在使用泛型时，完全不用担心性能上的问题。 实际上是损失了编译速度和增大了最终生成文件的大小。 Rust 通过在编译时进行泛型代码的单态化来保证效率。 单态化：将通用代码转换为特定代码的过程。 编译器的工作与创建泛型函数的步骤相反。 对于程序员而言，使用泛型可以编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。 特征 Trait 特征定义了一组可以被共享的行为：只要实现了特征，就能使用这组行为。 定义特征 定义特征：把一些方法组合在一起。 目的是定义一个实现某些目标所必需的行为的集合。 举个例子，在数据中有小说和日记等内容载体，希望对相应的内容进行总结。那么总结这个行为就是共享的，可以都用一个特征： pub trait Summary { fn summarize(self) - String;} 使用 trait 关键字声明一个特征，Summary 是特征名。 大括号中定义了该特征的所有方法。 特征不定义行为具体是怎么样的，因此使用函数签名。 每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现 Summary 特征的类型都拥有与这个签名的定义完全一致的 summarize 方法。 为类型实现特征 pub trait Summary { fn summarize(self) - String;}#[derive(Debug)]pub struct Novel { pub title: String, pub author: String, pub content: String,}#[derive(Debug)]pub struct Diary { pub date: String, pub content: String,}impl Summary for Novel { fn summarize(self) - String { format!(\"{} by {}\", self.title, self.author) }}impl Summary for Diary { fn summarize(self) - String { format!(\"Diary for {}\", self.date) }}fn main() { let novel = Novel { title: String::from(\"Dracula\"), author: String::from(\"Bram Stoker\"), content: String::from( \"Bram Stoker's classic novel about a bloodthirsty master of the night.\", ), }; let diary = Diary { date: String::from(\"2014-01-02\"), content: String::from(\"A record of my daily life.\"), }; println!(\"Novel: {:#?}\", novel); println!(\"Diary: {:#?}\", diary);} 特征定义与实现的位置 孤儿规则 上述代码中，Summary 被定义为公开的 pub，所以只需要引入到包中，就可使用该特征。 关于特征实现与定义的位置：如果想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的。 这样确保其他人编写的代码不会破坏自己的代码。 默认实现 在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法： pub trait Summary { fn summarize(self) - String { \"Reading...\".to_string() }} 还有，默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现： pub trait Summary { fn simple_summary(self) - String; fn summarize(self) - String { println!(\"{}\", self.simple_summary()); \"Reading...\".to_string() }}// ...impl Summary for Novel { fn simple_summary(self) - String { format!(\"{}\", self.content) }} 那么通过上述代码，Novel 的实例可以通过调用 summarize 方法间接调用了 simple_summary 方法。 使用特征作为函数参数 先定义一个函数，使用特征作为函数参数： pub fn notify(item: impl Summary) { println!(\"{}\", item.summarize());} impl Summary 表示实现了 Summary 特征的 item 参数。 可以使用任何实现了 Summary 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法。 特征约束 通过特征约束一些变量类型。 pub fn notifyT: Summary(item: T) { println!(\"{}\", item.summarize());} T: Summary 被称为特征约束。 特征约束的表达很奇妙，比如； pub fn notify(item1: impl Summary, item2: impl Summary) {} 函数的两个参数可以是实现了 Summary 特征的不同的类型。 pub fn notifyT: SUmmary(item1: T, item2: T) {} 函数的两个参数都必须是实现了 Summary 特征的相同的类型。 多重约束 可以指定多个约束条件： pub fn notify(item: (impl Summary + Send)) {} 或 pub fn notifyT: Summary + Send(item: T) {} T: Summary + Send 表示 T 必须同时实现 Summary 和 Send 特征。 Where 约束 当特征约束变得很多时，使用 where 进行一些形式上的改进： fn funT, U(t: T, u: U) - i32where T: Send + Clone, U: Clone + Summary,{...} 例-找最大值 方式一：使用特征约束，且使用引用方式。 fn largest_1T: PartialOrd(list: [T]) - T { let mut largest = list[0]; for item in list.iter() { if item largest { largest = item; } } largest} PartialOrd 特征可以用于比较两个值。 方法二：使用特征约束，使得值具有 Copy 特征。 fn largest_2T: PartialOrd + Copy(list: [T]) - T { let mut largest = list[0]; for item in list.iter() { if item largest { largest = item; } } largest} 特征约束有条件地实现方法或特征 特征约束，可以在指定类型 + 指定特征的条件下去实现方法： fn main() { use std::fmt::Display; struct PairT { x: T, y: T, } implT PairT { fn new(x: T, y: T) - Self { Self { x, y } } } implT: Display + PartialOrd PairT { fn cmp_display(self) { if self.x = self.y { println!(\"The largest member is x = {}\", self.x); } else { println!(\"The largest member is y = {}\", self.y); } } }} 只有同时实现了 Display 和 PartialOrd 特征的类型 T，才可以调用 cmp_display 方法。 函数返回中的 impl Trait 可以通过 impl Trait 来说明一个函数返回了一个类型，该类型实现了某个特征： fn ret_summary() - impl Summary { Novel { title: String::from(\"a\"), author: String::from(\"b\"), content: String::from(\"c\"), }} Novel 实现了 Summary 特征，所以可以用它作为返回值。 ret_summary 返回一个实现了 Summary 特征的类型，但不知道具体什么类型。 可能在数据类型十分复杂，不知道怎么声明，就可以使用这种返回类型。如闭包和迭代器的类型就是很复杂。 但是这种返回值只能有一种具体的类型，不能模棱两可。 即一个分支下返回实现了某特征的 A 类型，而另一个分支又返回实现了某特征的 B 类型。这种情况是拒绝的。 通过 derive 派生特征 形如 #[derive(Debug)] 的代码，是一种特征派生语法。 derive 派生出来的是 Rust 默认提供的特征。 更多见派生特征。 调用方法需要引入特征 如果要使用一个特征的方法，那么需要将该特征引入当前的作用域中。 Rust 把最常用的标准库中的特征通过 std::prelude 模块提前引入到当前作用域中。 综合例子 自定义类型实现加法操作。 自定义类型实现打印输出。 use std::{fmt::Display, ops::Add};//限制类型 T 必须实现了 Add 特征，否则无法进行 + 操作struct ComplexT: AddT, Output = T { real: T, imag: T,}// 为 ComplexT: AddT, Output = T 实现 Add 特征implT: AddT, Output = T Add for ComplexT { type Output = ComplexT; // 定义了一个类型别名 Output fn add(self, p: ComplexT) - ComplexT { Complex { real: self.real + p.real, imag: self.imag + p.imag, } }}// 为 ComplexT: AddT, Output = T 实现 Display 特征implT: AddT, Output = T + Display ComplexT { fn print(self) { println!(\"{} + {}i\", self.real, self.imag); }}fn addT: AddT, Output = T(a: T, b: T) - T { a + b}fn main() { let a = Complex { real: 1, imag: 2 }; let b = Complex { real: 3, imag: 4 }; let c = add(a, b); c.print();} 特征对象 Todo 深入特征 Todo 集合类型 Todo 动态数组 Vector KV 存储 HashMap 认识生命周期 Todo 返回值和错误处理 Todo 包和模块 Todo 包 Crate 模块 Module 使用 use 引入模块及受限可见性 注释和稳定 Todo 格式化输出 Todo","tags":["Rust"],"categories":["笔记"]},{"title":"MySQL 数据库学习记录","path":"/2024/MySQL/","content":"关键词：MySQL、C++ 一、认识 MySQL 1.1 什么是 MySQL MySQL 是 关系型 数据库。 关系型可以理解为表格的概念。 表格具有表头、行、列、键、值等。 表头：每一列的名称； 列：具有相同数据类型的集合； 行：每一行用来描述某个具体信息； 键：表中用来识别某个特定对象的方法，键的值在当前列中具有唯一性； 值：行的具体信息，每个值必须与该列的数据类型相同。 一个关系型数据库由一个或多个表格组成。 如： id name sex age 1 小明 男 18 2 小红 女 17 3 小张 男 19 4 小李 女 16 表头为 id、name、sex、age； id：作为一个键。 1.2 Windows 下配置 MySQL 此处为免安装版 MySQL-8.0.36，下载地址 - ZIP文件 解压到目录：E:\\MySQL-8.0.36。 接着在文件夹中创建配置文件 my.ini，内容如下： [client]# 设置mysql客户端默认字符集default-character-set=utf8port=3306 [mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=E:\\\\MySQL-8.0.36# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 然后配置环境变量： 打开环境变量设置，新建变量名 MYSQL_HOME，变量值为 E:\\MySQL-8.0.36。 系统变量 PATH 中添加 E:\\MySQL-8.0.36\\bin。 最后启动命令提示符（cmd），执行命令： mysqld.exe --install MySQL --defaults-file=\"E:\\MySQL-8.0.36\\my.ini\" 如果安装被拒绝，请使用管理员权限启动cmd。 提示 Service successfully installed. 表示成功。 1.2.1 MySQL 的启动、停止和卸载 MySQL 服务的启动：net start MySQL MySQL 服务的停止：net stop MySQL MySQL 服务的卸载：sc delete MySQL 1.3 MySQL 脚本的基本组成 MySQL 通过执行 SQL 脚本来完成对数据库的操作。 脚本由一条或多条 MySQL 语句（SQL 语句 + 扩展语句）组成，保存为脚本文件一般为 .sql 文件。 控制台可以进行单句脚本执行。 标识符： 命名对象，如数据库、表、列、变量等。由字母、数字、下划线组成，第一个字符不能为数字。 大小写是否敏感取决于操作系统，Windows 下是不敏感的，但大多数 Linux 下是敏感的。 关键字： 关键字有特定的含义，避免作为标识符。（此处不列出，使用中学习） 语句： 是组成 MySQL 脚本的最小单位。每条语句可以完成特定操作，由 SQL 语句 + 扩展语句组成。 函数： 实现数据库操作的高级功能，大致分为：字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。 1.4 MySQL 中的数据类型 三大数据类型：数字、日期/时间、字符串。 数字： 整型： tinyint：1个字节，带符号范围 −128∼127-128\\sim127−128∼127； smallint：2个字节，带符号范围 −32768∼32767-32768\\sim32767−32768∼32767； mediumint：3个字节，带符号范围 −8388608∼8388607-8388608\\sim8388607−8388608∼8388607； int：4个字节，带符号范围 −231∼231−1,−2147483648∼2147483647-2^{31}\\sim2^{31}-1,-2147483648\\sim2147483647−231∼231−1,−2147483648∼2147483647； bigint：8个字节，带符号范围 −263∼263−1,±9.22×1018-2^{63}\\sim2^{63}-1,\\pm9.22\\times10^{18}−263∼263−1,±9.22×1018； 浮点型： float(m,d)：单精度浮点型，8位精度（4字节），总精度 mmm，小数位 ddd，以实际为准。 double：双精度浮点型，16位精度（8字节），总精度 mmm，小数位 ddd，以实际为准。 real decimal(m,d)：定点数，存放精确的值。如果 mdmdmd 则大小为 m+2m+2m+2 字节，否则为 d+2d+2d+2 字节。 日期和时间： date：格式为 YYYY-MM-DD，大小3字节，范围1000-01-01/9999-12-31。 time：格式为 HH:MM:SS，大小3字节，范围-838:59:59/838:59:59。 year：格式为 YYYY，大小1字节，范围1901/2155。 datetime：格式为 YYYY-MM-DD HH:MM:SS，大小8字节，范围1000-01-01 00:00:00/9999-12-31 23:59:59。 timestamp：格式为 YYYY-MM-DD HH:MM:SS，大小4字节，范围1970-01-01 00:00:00/2038-01-19 03:14:07（结束时间为距离1970-01-01 00:00:00 的第 231−12^{31}-1231−1 秒，看时区）。 时间戳的数据会随其他字段修改时自动更新。 字符串类型： 字符串： char(n)：定长字符串，0~255字节。 varchar(n)：变长字符串，0~65535字符。 char(n) 与 varchar(n)：两者的 nnn 都表示字符个数，而不是字节个数。前者若存入字符数小于 nnn，则用空格补在后面，查询时去掉空格；而后者没这个规定。 文本： tinytext：短文本字符串，0~255字节。 text：长文本数据，0~65535字节。 mediumtext：中等长度文本数据，0~16777215字节。 longtext：极大文本数据，0~4294967295字节。 varchar 与 text： 前者可以指定 n，后者不能指定； 后者不能有默认值； 前者可直接创建索引，后者创建索引需要指定前多少个字符。前者查询速度快于后者。 二进制（存储图片、音乐等）： tinyblob：二进制字符串，0~255字节。 blob：二进制长文本，0~65535字节。 mediumblob：二进制中等长度文本，0~16777215字节。 longblob：二进制极大文本，0~4294967295字节。 _blob 与 _text： 前者以二进制方式存储，英文不区分大小写，后者以文本方式存储，英文区分大小写； 前者存储的数据只能整体读出； 前者不用指定字符集，后者可以指定字符集。 数据类型的属性： NULL：数据列可包含 NULL 值。 NOT NULL：数据列不允许包含 NULL 值。 DEFAULT：数据列的默认值。 PRIMARY KEY：主键。 AUTO_INCREMENT：自动递增。 UNSIGNED：无符号。 CHARACTER SET name：指定字符集。 二、使用 MySQL 2.1 登录到 MySQL 先启动 MySQL 服务（管理员权限cmd）： net start mysql 然后使用自带的客户端工具登录，cmd输入： mysql -h 主机名 -u 用户名 -p -h：表示登录到的主机名，当前机器可省略。 -u：表示登录的用户名。 -p：表示登录时需要输入密码，密码为空可忽略。 这里安装的 MySQL 默认 root 账号是无密码的。 我的第一次安装出现了坑：“如何解决本地计算机上的mysql服务启动停止后,某些服务在未由其他服务或程序使用时将自动停止” 可能是因为之前不懂事弄着玩过，然后出了一堆错误。 解决办法：CSDN - 如何解决本地计算机上的mysql服务启动停止后,某些服务在未由其他服务或程序使用时将自动停止 2.2 创建一个数据库 创建命令如下： create database 数据库名 [options]; MySQL 语句以分号作为结束。 show databases; 可查看创建了的数据库。 选择操作的数据库（必须先选择数据库，才能进行数据库的操作）。 登录时指定数据库： mysql -D 数据库名 -h 主机名 -u 用户名 -p 登陆后使用 use 数据库名; 语句选择数据库。 2.2.1 创建数据库表 比如创建一张表，存放学号、姓名、性别、年龄、电话号码。 使用命令： create table 表名称; 有时候表信息比较多，使用 .sql 脚本事先记录，然后执行 .sql 文件。 create tables students( id int unsigned not null auto_increment primary key, name char(8) not null, sex char(1) not null, age tinyint unsigned not null, tel char(13) null default \"-\"); 通过命令提示符下的文件重定向执行执行该脚本。打开命令提示符, 输入： mysql -D samp_db -u root -p createtable.sql 使用 show tables; 可以查看已创建的表。 使用 describe 表名; 可以查看已创建表的详细信息。 2.3 操作 MySQL 数据库 2.3.1 向表中插入数据 使用 insert 语句： insert [into] 表名 [(列名1,列名2,列名3,...)] values (值1,值2,值3,...); 如： insert into students values (NULL,'ZhangSan','M',18,'13800000000'); 也可以不按列的顺序： insert into students (name,sex,age) values ('LiSi','F',19); 2.3.2 查询表中的数据 使用 select 语句： select 列名称 from 表名称 [查询条件]; 如查询表中所有学生的名字和年龄： select name, age from students; 通配符 *：表示所有内容。 select * from students; 如果具有查询条件，使用 where 关键字： select 列名称 from 表名称 where 条件; 如查找女性： select * from students where sex = 'F'; 查询前已添加了 LiSi 的数据。 where 支持 =、!=、、=、、=、in、not in、is [not] null、like 等运算符，支持与 or、and 的组合。 如： 查询名字中带有 “Wang” 字的所有人信息： select * from students where name like \"%Wang%\"; 查询 id 小于5且年龄大于20的所有人信息： select * from students where id5 and age20; 2.3.3 更新表中的数据 使用 update 语句： update 表名称 set 列名称=新值 where 更新条件; 如： 将 id 为5的手机号改为默认的\"-\"： update students set tel=default where id=5; 将所有人的年龄增加1： update students set age=age+1; 2.3.4 删除表中的数据 使用 delete 语句： delete from 表名称 where 删除条件; 如： 删除所有年龄小于21岁的数据： delete from students where age20; 删除表中的所有数据： delete from students; 2.3.5 创建后表的修改 使用 alter table 语句： 添加列 alter table 表名 add 列名 列数据类型 [after 插入位置]; 如： 在表后添加列 address：alter table students add address char(20); 在 age 列后插入 birthday：alter table students add birthday date after age; 修改列 alter table 表名 change 列名 新列名 新列数据类型; 如： 修改列 age 的数据类型：alter table students change age age tinyint unsigned null; 删除列 alter table 表名 drop 列名; 如： 删除列 birthday：alter table students drop birthday; 修改表名 alter table 表名 rename 新表名; 删除整张表 drop table 表名; 删除整个数据库 drop database 数据库名; 2.4 修改 root 用户密码 其中一种方法： mysqladmin -u root -p password 新密码 三、在C++工程上使用MySQL 3.1 使用mysql.h IDE：Visual Studio 2022 3.1.1 VS中配置MySQL 添加包含目录：VC++目录 中的 包含目录 添加上 MySQL 文件夹中的 include 目录。 添加库目录：VC++目录 中的 库目录 添加上 MySQL 文件夹中的 lib 目录。 添加附加依赖项：链接器 中的 输入 → 附加依赖项 添加上 libmysql.lib。 复制动态库：将 lib 文件夹下的 libmysql.dll 复制到工程文件夹下。 3.1.2 相关函数代码 头文件：mysql.h // 连接数据库：MYSQL *mysql_real_connect( MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag);// 执行MySQL语句:int mysql_query(MYSQL *mysql, const char *q);// 获取上一条MySQL语句执行结果：MYSQL_RES *mysql_store_result(MYSQL *mysql);// 获取上一条MySQL语句执行结果行数：uint64_t mysql_affected_rows(MYSQL *mysql); 用类实现一个基础连接数据库，可以执行数据库语句、输出查询结果等功能。 // DataBase.h#pragma once#include mysql.h#include vector#include string#include windows.h#include winsock.hclass DataBase{private:\tbool _state; // 连接状态\tMYSQL *_conn; // 数据库连接\tstd::vectorMYSQL_FIELD * fd;\t// 字段列数组\tstd::vectorstd::string _field;// 字段名\tMYSQL_RES *_res; // 返回行的查询结果集\tMYSQL_ROW _column; // 一个行数据的类型安全的表示public:\t/*\t* @brief 构造函数，初始化参数\t*/\tDataBase();\t/*\t* @brief 连接数据库\t* @param ip IP地址\t* @param name 用户名\t* @param pass 密码\t* @param dataBaseName 数据库名\t* @param port 端口\t*/\tbool connect(std::string const ip, std::string const name, std::string const pass, std::string const dataBaseName, int const port);\t/*\t* @brief 获取表字段数\t* @param tableName 表名\t*/\tint getTableField(std::string const tableName);\t/*\t* @brief 查询表\t* @param tableName 表名\t* @return 查询结果\t*/\tstd::string query(std::string const tableName);\t/*\t* @brief 执行 sql 指令\t* @param sentence sql 命令\t*/\tbool implement(std::string const sentence);}; //DataBase.cpp#include \"DataBase.h\"DataBase::DataBase() : _state(false), _res(nullptr), _column(nullptr){\t_conn = new MYSQL;}bool DataBase::connect(std::string const ip, std::string const name, std::string const pass, std::string const dataBaseName, int const port){\tif (_state) return false;\t// 初始化数据库\tmysql_init(_conn);\t// 连接数据库\tif (mysql_real_connect(_conn, ip.c_str(), name.c_str(), pass.c_str(), dataBaseName.c_str(), port, NULL, 0))\t{ _state = true; return true;\t}}int DataBase::getTableField(std::string const tableName){\tif (!_state) return -1;\t// 将字符串格式化为查询数组\tchar query[150];\tsprintf_s(query, \"show columns from %s\", tableName.c_str());\t// 执行查询\tif (mysql_query(_conn, query)) return -1;\t// 获取查询结果\t_res = mysql_store_result(_conn);\tif (_res == nullptr) return -1;\treturn mysql_affected_rows(_conn);}std::string DataBase::query(std::string const tableName){\tif (!_state) return \"\";\t// 获取列数\tint field = getTableField(tableName);\t// 将字符串格式化为查询数组\tchar query[150];\tsprintf_s(query, \"select * from %s\", tableName.c_str());\t// 执行查询\tif (mysql_query(_conn, query)) return \"\";\t// 获取查询结果\t_res = mysql_store_result(_conn);\tif (_res == nullptr) return \"\";\t// 将查询结果转化为字符串输出\tfd.reserve(field);\tfd.resize(field);\tfor (int i = 0; i field; i ++) fd[i] = mysql_fetch_field(_res);\tstd::string res = \"\";\twhile (_column = mysql_fetch_row(_res))\t{ for (int i = 0; i field; i ++) res += _column[i], res += \"\\t\"; res += \" \";\t}\treturn res;}bool DataBase::implement(std::string const sentence){\tif (!_state) return false;\t// 字符串格式化\tchar query[150];\tsprintf_s(query, \"%s\", sentence.c_str());\t// 执行命令\tif (mysql_query(_conn, query)) return false;\treturn true;} 完整代码见仓库：Gitee - MySQL - C++ 更多可参考：https://blog.csdn.net/cpp_learner/article/details/116171955 3.2 使用QtSQL Qt6.6.1_msvc2019_64 3.2.1 Qt的SQL模块 VS 中勾选上 SQL 模块： 3.2.2 数据库驱动 QtSQL 是 Qt 提供的一个访问数据库的接口。但需要数据库驱动才能使用不同类型的数据库。 驱动名称 对应数据库 QDB2 IBM DB2 QIBASE Borland Interbase QMYSQL MySQL QOCI Oracle Call Interface Driver QODBC ODBC（包括MS SQL Server） QPSQL PostgreSQL QSQLITE SQLite v3 QSQLITE2 SQLite v2 很不幸，MySQL 需要额外下载驱动，可前往 Github - thecodemonkey86/qt_mysql_driver 下载对应版本的编译后的文件。 将下载到的压缩包解压后，把 sqldrives 文件夹中的文件复制到 Qt 目录下的 sqldrives 文件夹中。如此处我是： ..\\Qt\\6.6.1\\msvc2019_64\\plugins\\sqldrivers 3.2.3 连接数据库 通过 QSqlDatabase 类，可以操作数据库。 连接数据库的代码： // QtSql 连接数据库QSqlDatabase db;db = QSqlDatabase::addDatabase(\"QMYSQL\", \"connection\");// 配置主机名db.setHostName(\"localhost\");// 配置数据库名db.setDatabaseName(\"students\");// 配置用户名和密码db.setUserName(\"root\");db.setPassword(\"\");// 配置端口db.setPort(3306);// 打开数据库db.open(); 其中函数： QSqlDatabase addDatabase( const QString type, const QString connectionName = QLatin1StringView(defaultConnection)); 创建一个数据库连接，第一个参数指定数据库驱动，第二个参数指定连接名称，多线程访问数据库中每个线程都需要使用不同的连接名称。 3.2.4 访问数据库 通过 QSqlQuery 类，可以访问数据库。 // 创建查询对象QSqlQuery query(db);// 执行查询语句query.exec(\"...\"); 可以通过 QSqlQuery::prepare() 和 QSqlQuery::bindValue() 函数进行数据库语句的构造。 如： void updateUser(QSqlDatabase db,const int id,const QString username) { QSqlQuery query(db); // 构造查询语句 query.prepare(\"update newUser set username=:username WHERE id=:id\"); // 绑定参数 query.bindValue(\":id\", id); query.bindValue(\":username\", username); // 执行语句 query.exec();} 3.3 学生管理系统demo 完整代码见仓库：Gitee - MySQL - C++ 分支： master：mysql.h方式 QSQL：QtSql方式 Reference： 21分钟 MySQL 入门教程 - https://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html C/C++ vs2017连接MySQL数据库 - 增删改查(详细步骤) - https://blog.csdn.net/qq_45698148/article/details/117136407 MySQL 教程 - RUNOOB：https://www.runoob.com/mysql/mysql-tutorial.html Qt零基础系列10：使用Qt如何操作数据库：https://zhuanlan.zhihu.com/p/348174965","tags":["MySQL"],"categories":["笔记"]},{"title":"Qt for Android配置记录","path":"/2024/16/","content":"关键词：Qt、C++、Android 前言 一开始想着弄个安卓软件玩玩，但是不想学 Java，于是乎发现了 Qt for Android。 配置过程 前期准备 使用的是 Qt6.5.3 的 Android 组件。 我尝试过使用 Qt6.6.1 和 Qt5.15.2 的 Android 组件，但不成功，原因未知。 Java 方面，JDK 使用 Java 17，下载地址 这里简单说一下 JDK、SDK 和 NDK： JDK：Java Development Kit，是整个Java的核心，其中包括Java编译器、Java运行工具、Java文档生成工具、Java打包工具等 SDK：Software Development Kit，软件开发工具包 NDK：Native Development Kit，是 Android 的一个工具开发包 创建 Qt Android 项目 1.新建项目 像之前一样正常新建项目 2.选择安卓构建开发 点击管理，可以进入设置页面。设置好 JDK 路径 和 SDK 路径。 可能还需下载配置安卓 OpenSSL。 设置完成如下图： 3.正常项目开发 完成设置后进入项目，可以进行代码编写和界面设计 release下需要生成 apk 签名： 4.效果展示 编译并连接手机运行，手机打开开发者选项，进入 USB 调试，打开 USB 安装功能（建议打开文件传输功能）。编译过程比较漫长。 问题汇总 编译时下载 gradle 卡住超时退出。 解决办法：找到 ..\\build-demo-Qt_6_5_3_Clang_arm64_v8a-Debug\\android-build\\gradle\\wrapper 目录下的 gradle-wrapper.properties，使用记事本打开，修改为 distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-8.0-bin.zip，然后继续编译生成。 出现红色报错 Failure [INSTALL_FAILED_USER_RESTRICTED: Install canceled by user]。 解决办法：确认手机是否进入 USB 调试模式，且打开 USB 安装。","tags":["CPP","Qt","Android"],"categories":["日常"]},{"title":"C++基础语法杂记","path":"/2024/cppbasic/","content":"关键词：C++ 假定读者有一定的 C 语言基础 Reference：https://hackingcpp.com/cpp/beginners_guide.html 从C语言到C++ C++开发设置 编辑器 集成开发环境IDE Visual Studio Code Visual Studio VIM Qt Creator CLion …… 编译器 gcc/g++ clang/clang++ Microsoft Visual Studio（msvc） …… 第一个程序Hello World // hello.cpp#include iostream// 注释int main(){ std::cout \"Hello World! \"; return 0;} #include iostream 包含头文件，这行将会被头文件 iostream 所替换； iostream 是编译器目录中的一个头文件，其提供了基本的输入和输出方法。 #include \"filename\" 可以引入头文件； #include filename 同上，但在包含目录中查找。 发生在编译之前，编译器只能看到已经预处理的文件。 注释 // 表示单行注释； /* */ 表示多行注释。 int main() 定义了主函数； 主函数是每个程序的入口； int 表明主函数的返回类型是整型； () 表示主函数的参数列表，此处为空。 {} 表示语句块 std::cout \"Hello World! \"; 在控制台输出 Hello World。 std 是标准库的命名空间； cout 表示控制台标准输出，是“character out”的缩写。 Hello World 是一个字符串，即字符组成的串。 表示换行。 return 0; 函数出口，返回值0。 注：少用甚至不用 using namespace std; 可能大多数的代码都会附带上 using namespace std; 但使用名称空间将该名称空间中的所有符号拖放到全局名称空间中。这可能会导致名称冲突和歧义，在某些情况下甚至会导致只在运行时才会出现并且很难检测到的bug。 使用来自其他名称空间的所有符号污染全局名称空间在任何生产代码库中都是一个严重的问题，应该从一开始就避免使用这种模式。 编译hello.cpp 预处理，在源代码中处理头文件等； 编译：将源代码转化成机器码； 链接：结合多个二进制机器码文件，生成可执行文件。 编译术语： 编译错误（Compiler Error，CE）： 编译器无法正确处理源代码，一般为语法错误； 编译警告（Compiler Warning）：程序可编译，编译器将继续，但有一段有问题的代码可能导致运行时错误； 静态（static）：在编译时固定（固定到可执行文件中，在运行时不可更改）； 动态（dynamic）：在运行时可更改（可能由用户输入）。 编译器参数标记 使用 g++ 进行编译时，有一些可选的选项。下面是一条编译指令： g++ -std=c++20 -Wall -Wextra -Wpedantic -Wshadow input.cpp -o output -std=c++20 表示使用 C++20 标准。 -Wall -Wextra -Wpedantic -Wshadow 表示额外的警告信息。 -o output 表示输出可执行文件名。 都这个年代了，尽量使用高版本 C++ C++的I/O I/O流 对于数据而言，其可以从程序中产生并输出到显示终端，也可以从输入设备中输入到程序中。 // IO流.cpp#include iostreamint main(){ int i; std::cin i; // 输入 i std::cout i; // 输出 i} std::cin：表示从输入流中读取字符，从外界（缓冲区）读入字符； std::cout：表示把字符放入输出流，首先写入缓冲区，缓冲区满时输出到控制台； std::clog：表示把字符放入错误流，首先写入缓冲区，缓冲区满时输出到控制台； std::cerr：表示把字符放入错误流，但立刻输出到控制台。 和 ：流符号，尖端表示数据的流向，如 源 目标。 支持基本类型和字符串(可以添加对其他类型的支持)； 读取直到下一个空白字符(空格，制表符，换行符，…) 可以连续使用，如 std::cin i j; 注：在必要的时候才用 std::endl 也许会见到代码中出现 std::endl，其也是流处理中的操作，但是每次调用 std::endl 都会刷新输出缓冲区并立即写入输出。C++的I/O流使用缓冲区来减轻系统输入或输出操作对性能的影响。将收集输出，直到可以写入最小数量的字符为止。 如果经常这样做，可能会导致严重的性能下降。过度使用 std::endl 会干扰这一机制。 使用 代替或只有一次对操作符 的调用（每次额外的调用会产生很小的开销） 基本类型 变量声明 type variable = value;type variable {value}; // C++11后的初始化 但基本类型的变量默认情况下不会初始化。 int i;cout i ' '; // i未被初始化，值不可知 变量类型 布尔类型：值只有真（true）和假（false）。 字符类型：一个字节大小，通常范围在-128~127。 整型类型：一般的整数，short、int、long、long long。 带符号整型 无符号整型 C++14中可支持数字分隔符，如 long num = 512'232'697'499; 浮点类型：一般的小数 float：32位，4字节 double：64位，8字节 long double：80位，10字节 C++11支持强制转换为 long double，如 long double num = 3.5e38L C++14中也支持数字分隔符 std::numeric_limitstype 查看变量可表示范围。 #include iostream#include limitsint main () { std::cout \"lowest: \" std::numeric_limitsdouble::lowest() ' '; // lowest: -1.79769e+308\tstd::cout \"min: \" std::numeric_limitsdouble::min() ' ';\t// min: 2.22507e-308\tstd::cout \"max: \" std::numeric_limitsdouble::max() ' ';\t// max: 1.79769e+308\tstd::cout \"epsilon: \" std::numeric_limitsdouble::epsilon() ' ';\t// epsilon: 2.22045e-16\treturn 0; } 类型窄化 从可以表示更多值的类型转换为可以表示更少值的类型，可能导致信息丢失。 类型提升 涉及浮点类型的提升： 小类型转换成大类型 两种整数类型的操作： 整数提升: 基本上任何小于int的值都会被提升为int或unsigned int（取决于哪一种类型可以表示未提升类型的所有值） 如果两个操作数类型不同，则应用整数转换 两种符号：小类型转换成大类型 都是无符号的：将较小的类型转换为较大的类型 有符号⊕无符号: 如果两者宽度相同，则有符号转换为无符号 否则，如果可以表示所有值，则将无符号转换为有符号 否则都转换为无符号 const修饰符 使用 const 限定变量为常量。 值一旦赋值就不能更改。 如果不需要在初始赋值后改变变量的值，总是将变量声明为 const 。 避免错误:如果稍后不小心更改值，则不会编译 帮助更好地理解你的代码：清楚地传达值将在代码中保持不变 可以提高性能(可能进行更多编译器优化) constexpr常量表达式 C++11支持，常量表达式必须在编译时可计算 如果未在constexpr上下文中调用，则可以在运行时进行计算 constexpr上下文中的所有表达式必须是constexpr本身 Constexpr函数可能包含： C++ 11：只有一条返回语句 C++ 14：多个语句 auto关键字 使用如下： auto variable = expression; 从赋值的右侧推导出变量类型 往往更方便、更安全、更经得起未来考验 对于泛型（与类型无关）编程也很重要 类型别名 // C++11支持using NewType = OldType;// C++98支持typedef OldType NewType; 算术运算符 +、+=：算术加 -、-=：算术减 *、*=：算术乘 /、/=：算术除 %、%=：算术取余 自增自减符 作用：将值更改+/- 1 前缀表达式 ++x / --x 返回新的（递增/递减）值； 后缀表达式 x++ / x-- 增加/减少值，但返回旧值。 比较运算符 返回值只有真（true）和假（false）。 ==：判断相等 !=：判断不相等 ：小于 ：大于 =：小于或等于 =：大于或等于 C++20引入 = 当 a b 时， (a = b) 0 当 a b 时， (a = b) 0 当 a = b 时， (a = b) == 0 逻辑运算符 返回值只有真（true）和假（false）。 0 永远是假，其他值都是真。 或 and：逻辑与 || 或 or：逻辑或 ! 或 not：逻辑非 短路评估：如果布尔比较的第二个操作数在计算第一个操作数后已经知道结果，则不计算第二个操作数。 位运算符 ：按位与 |：按位或 ^：按位异或 ~：按位取非 、=：左移 、=：右移 将类型为N位的对象的位移位 N 位或 N 位以上是未定义的行为！ 控制流 条件结构 if (condition1) { // 条件1为真则执行}else if (condition2) { // 条件2为真则执行}else { // 否则执行} C++17支持以下语法： // 即在条件判断前可执行一句语句if(statement; condition){ // ……} 另外还有 switch： switch(variable){ case value1: break; case value2: break; default:} C++17同样支持多执行一句语句： switch(statement; variable){ case value1: break; case value2: break; default:} 三元运算符 condition ? statement1 : statement2 同样可用于分支结构。 循环结构 for 循环： for (initialization; condition; step){ // 循环体} 在C++11支持针对可迭代对象的迭代循环，即 for(variable : range){ // 循环体} while 循环： while(condition){ // 循环体} do-while 循环： do{ // 循环体} while(condition); 枚举 普通枚举： enum　枚举名 {枚举元素1,枚举元素2,……}; 如： enum day {mon, tue, wed, thu, fri, sat, sun};day d;d = mon; // 正确d = tue; // 正确 但 C++11 中允许带有作用域的枚举： enum class 枚举名 {枚举元素1,枚举元素2,……}; 如： enum class day {mon, tue, wed, thu, fri, sat, sun};day d;d = day::mon; // 正确d = tue; // 错误 枚举的内在类型：必须是整型类型，默认情况下枚举是 int 类型。 如： // 枚举只有7个值，使用char类型足够enum class day : char {mon, tue, wed, thu, fri, sat, sun}; 枚举可以自定义映射值，如： enum class day : char {mon = 1, tue = 2, wed = 3, thu = 4, fri = 5, sat = 6, sun = 7}; 枚举可以与基本数据类型进行转换，如： enum class day : char {mon = 1, tue = 2, wed = 3, thu = 4, fri = 5, sat = 6, sun = 7};int i = static_castint(month::tue); // i = 2int j = 1;day d = static_castday(j); // d = tue 数据类型聚合 基础数据类型： void、bool、char、int、float、double 等。 聚合的例子： struct point{ int x; int y;};point p = {1, 2};std::cout p.x \",\" p.y \" \"; 为什么要自定义类型/数据聚合？ 接口变得更容易正确使用 语义数据分组:点、日期、… 避免了许多函数参数，因此，混淆 可以从一个专用类型的函数返回多个值，而不是多个非const引用输出参数 聚合后的初始化： Type {arg1 arg2 ... argn} 如： struct point{ int x; int y;};point p{1, 2}; 可以多重聚合： struct point{ int x; int y;};struct line{ point _begin; point _end;} 引用 使用引用：定义一个变量的引用，引用相对于一个变量的别名。 int i = 2;int r = i; // 定义 i 的引用 rstd::cout i \" \" r \" \"; // i 与 r 是一样的值// 2 2i = 10；std::cout i \" \" r \" \"; // i 与 r 是一样的值// 10 10r = 20;std::cout i \" \" r \" \"; // i 与 r 是一样的值// 20 20 引用必须总是指向一个对象 变量的一个引用总是指向与变量相同的内存位置 引用类型必须与被引用对象的类型一致 const 引用： int i = 2;const int r = i; // 定义 i 的常量引用 ri = 10; // 不报错std::cout i \" \" r \" \"; // i 与 r 是一样的值// 10 10r = 20; // 报错 引用可应用于： 基于范围的循环，改变值 函数参数传入，不会进行复制减少开销，且改变值，还能达到返回值的效果 当只想减少开销，但不想改变值，可以考虑 const 的引用 等等 引用的绑定： ：只能绑在左值上； const ：能绑定在左值和右值上。 bool is_palindrome (std::string const s) { … }std::string s = \"uhu\"; cout is_palindrome(s) \", \" is_palindrome(\"otto\") ' ';// 左值变量 s 和 右值 \"otto\" 都可以执行 void swap (int i, int j) { … }int i = 0; swap(i, 5); // 5 是右值，不能绑定引用，编译错误 使用引用的陷阱： 不要返回对函数局部对象的引用：函数局部对象函数结束时会被销毁，返回的引用也会变得无效。 引用 std::vector 要小心：在任何改变vector中元素数量的操作之后，对std::vector中元素的引用都可能失效。 在一些vector操作期间，std::vector 存储元素的内部内存缓冲区可以被交换为一个新的，因此对旧缓冲区的任何引用都可能是悬空的。 引用能延长临时变量（或右值）的生存期：如 const auto r = vectorint{1, 2, 3}，引用r存在，右边vector则一直存在。 不要通过引用去延长变量生存期，请使用合适的变量。 但当对临时的vector成员进行引用时，则生存期不会延长。如： std::vectorstd::string foo () { … }const std::string s = foo()[0];// 对函数返回的临时 vector 的成员进行引用，并不会延长生存期std::cout s; // 未定义的行为 悬空引用：引用不再有效的内存位置的引用。 C++的默认动态数组 std::vector 数组：可以存放多个相同类型的值； 动态：长度可以动态变化。 std::vector 的使用需要包含头文件：#include vector std::vector的使用 std::vector 的定义和初始化： std::vectorint v; // 定义一个空，元素类型为int的vectorstd::vectorint v1 = {1, 2, 3}; // 定义一个vector并初始化std::vectorint v2{1, 2, 3}; // 定义一个vector并C++11的初始化std::vectorint v3(10); // 定义一个长度为10，未初始化的vectorstd::vectorint v4(10, 0); // 定义一个长度为10，且都初始化为0的vectorstd::vectorint v5{v1}; // 定义vector，并用v1的值和长度初始化 遍历 std::vector： std::vectorint v1{1, 2, 3};for (int i = 0; i v1.size(); i++){ // 下标访问 std::cout v1[i] ' ';}for (int x : v1) // 此时 x 只能从 v1 中读，并不能修改值{ // 基于范围for循环 std::cout x ' ';}for (int x : v1) // 此时 x 附加了引用，可以修改值{ // 基于范围for循环 x = 1; std::cout x ' ';}// 对于x的变量类型很复杂时的只读，减少开销for (auto const x : v1) { std::cout x \" \"; }// .front()首元素，.back()尾元素std::cout v1.front() ' ' v1.back() ' '; 添加元素： std::vectorint v;v.push_back(1); // 向v的后面添加一个元素 删除元素： std::vectorint v{1, 2, 3};v.pop_back(); // 删除v的最后一个元素v.clear(); // 清空v中的所有元素 std::vector 的长度调整： std::vectorint v{1, 2, 3};v.resize(5); // 将v的长度调整为5 示例代码： #include iostream#include vectorint main () { std::vectorint v{1, 2, 3};\tv.resize(6);\tfor(int x : v)\tstd::cout x \" \"; // 1 2 3 0 0 0\tv.push_back(7);\tstd::cout std::endl;\tfor(int x : v)\tstd::cout x \" \"; // 1 2 3 0 0 0 7\treturn 0; } std::vector 中的复制都是深复制。 深度复制：创建一个新的对象并复制源的所有包含对象； 深度赋值：将所有包含的对象从源复制到赋值目标； 深度比较：比较两个向量，比较所包含对象的值； 深层所有权：销毁vector将销毁所有包含的对象。 深复制和浅复制（深拷贝和浅拷贝）：简单来说，深拷贝在内存上独立，复制内容在新的内存空间上。浅拷贝在内存上共享。比如把A复制到B，如果是深复制，则A和B独立互不影响；如果是浅复制，在修改A，B也会改变。 std::vectorint a{1, 2, 3};std::vectorint b = a; // 深度赋值，a和b独立，互不影响a[0] = 9; // a：9 2 3；b：1 2 3 另外，C++对 std::vector 进行了一系列的运算符重载，即可以对 std::vector 使用 == （判断相等）、!=（判断不相等）、（判断大小）等运算符。 std::vector 的判断大小：比较两个vector上每个位置上的元素，当发现不同的且字典序小的，拥有该元素的vector判定为小。 std::vector 的大小和容量： 大小：指元素个数，函数 .size() 可以获取，同时函数 .resize(newSize) 可以改变大小。 容量：指能容纳的元素个数，函数 .capacity() 可以获取，同时函数 .resize(newCapacity) 可以改变最大容纳元素个数。 std::vectorint a{1, 2, 3};std::cout a.size() \" \" a.capacity() \" \";// 3 3a.push_back(4);std::cout a.size() \" \" a.capacity() \" \";// 4 6 std::vector迭代器 优先使用迭代器而不是索引器。 begin(vector)：指向vector的第一个元素 end(vector)：指向vector的最后一个元素的后面，只能用作位置指示符，不能用于访问元素。 迭代器：类似一个指针，指向容器的某个位置，便于迭代循环 std::vectorint a{1, 2, 3};std::vectorint::iterator p = begin(a);for(p; p != end(a); p ++)\tstd::cout *p \" \"; 所以迭代器也可以进行自增自减，加法减法运算。 除了正向迭代器，还有反向迭代器，其作用与正向迭代器类似： rbegin(vector)：指向vector的最后一个元素 rend(vector)：指向vector的第一个元素的前面，只能用作位置指示符，不能用于访问元素。 用迭代器表示范围的 std::vector 初始化和赋值： std::vectorint u{1, 2, 3};std::vectorint v{begin(u), begin(u) + 1};std::vectorint w;w.assign(begin(u) + 1, end(u)); 通过迭代器在 std::vector 中插入元素： std::vectorint v{1, 2, 3};// 函数结构1//.insert(插入位置, 插入元素)//.insert(插入位置, {插入元素1, 插入元素2, ……})v.insert(begin(v), 0); // 在v的第一个位置前插入0// 0 1 2 3v.insert(end(v), {4, 5}); // 在v的最后一个位置后插入{4, 5}// 0 1 2 3 4 5// 函数结构2//.insert(插入位置, 起始位置, 结束位置)，范围左闭右开std::vectorint v1{7, 8, 9};// 在v的第一个位置前插入v1的所有元素v.insert(begin(v), begin(v1), end(v1));// 7 8 9 0 1 2 3 4 5 通过迭代器在 std::vector 中删除元素：（从vector中擦除元素不会改变容量，因此不会释放任何内存。） // 函数结构//.erase(位置)//.erase(起始位置, 结束位置)，范围左闭右开std::vectorint v{1, 2, 9, 3, 4, 5};v.erase(begin(v) + 2);// 1 2 3 4 5v.erase(begin(v), begin(v) + 2);// 3 4 5 在使用迭代器进行元素操作后，如添加删除，原迭代器并未更新，如： std::vectorint v{1, 2, 3, 4, 5, 6};\tauto i = begin(v) + 3; // auto 表示编译器自动推导类型v.insert(i, 8);// 输出 *i 为 4，是原来vector的第3个元素，不计刚刚插入的8，因为当前 i 已经失效了// 使用 i = v.insert(i, 8); 更新迭代器，输出 *i 才为 8 同时，经过增删元素后，std::vector 的长度可能变短或者变长。当长度变短时，其容量并不会变小，仍保持之前操作中的最大值，此时可能需要“刷新”一下容量，减少空间消耗： std::vectorint v;// 一系列增删改操作后v = std::vectorint(v); // C++11~20支持v.swap(std::vectorint(v)); // C++98~20支持 做一个临时的副本，通过交换内存缓冲区更新容量，临时变量自动销毁。 std::vector 的工作原理 vector 的数据总是在堆上的，但对象的地址根据定义的方式不同可能在堆上，也可能在栈上。 vector元素保证驻留在一个连续的内存块中。 大小：指元素个数。 容量：指能容纳的元素个数。 内存块一旦分配后不能调整大小。 动态数组增长方式: 动态分配新的（≈1.1-2倍）更大的内存块 复制/移动旧值到新块 摧毁旧的内存块 当在某位置擦除（删除）元素时，方式如下： 析构（销毁）元素 剩下的元素前移 长度减少，但容量不变 当在某位置添加（插入）元素时，方式如下： 判断容量大小是否允许，允许则不需再开辟空间增长，不允许则进行增长。 将插入位置及后面的元素后移 在插入位置复制上新元素 字符串std::string 基本特性： 是动态的 char 数组（类似于 vectorchar ） 支持 + 或 += 进行字符串之间的连接 支持使用 [下标] 进行单字符访问 深复制 支持 == 和 != 进行比较 #include iostream#include string // 字符串操作的头文件int main () { using std::cout; std::string hw = \"Hello\"; std::string s = hw; // 复制 hw 到 s hw += \" World!\"; cout hw ' '; // Hello World! cout hw[4] ' '; // o cout s ' '; // Hello} 字符串的操作，对于 std::string s = \"Hello World\"; s.insert(5, \",\")：在下标为 5 的位置插入字符串 “,”，变成 “Hello, World” s.erase(6, 7)：删除下标为 5 的位置后的 7 个字符，变成“Hello,” s.replace(5, 3, \" C++\")：将下标为 5 的位置的后 3 个字符替换为 “C++”，变成“Hello C++” s.resize(5)：调整字符串长度为5，即变成“Hello” s.resize(8, '!')：调整字符串长度为8，多出来的部分用 ! 代替，变成“Hello!!!” s.find(\"l\")：字符串中从头到尾寻找“l”，返回 l 所在的下标 2 ，找不到返回 string::npos s.rfind(\"l\")：字符串中从尾到头寻找“l，返回 l 所在的下标 3 ，找不到返回 string::npos s.find('e', 5)：字符串从第5个位置往后寻找“e”。 s.substr(0, 2)：在字符串 s 中从下标为0到2（左闭右开）截取子字符串，返回“He” s.ends_with(\"\"):判断字符串是否以 “” 结尾，返回 true 或者 false s.starts_with(\"\"):判断字符串是否以 “” 开头，返回 true 或者 false 在定义并初始化时： std::string a = \"hello\"; // std::string 类型// 使用 auto：auto b = \"hello\";// 此时 b 会被推导为 const char[] 类型，而不是std::string// 在 C++14及以后using namespace std::string_literals;auto c = \"hello\"s;// 此时 c 是 std::string 类型 另外，仅用空格分隔的字符串字面值将被连接起来： std::string s = \"hello\" \" world\";// s 现在是 \"hello world\" 如果想让字符串的转义字符失效： using namespace std::string_literals;auto s = R\"( )\"s; // C++14及之后支持，类型为 std::stringauto t = R\"(\\ )\"; // C++11支持，类型为 const char[] 函数 std::getline() ：该函数需要包含头文件 std::string s;// 从标准输入中读取一行std::getline(std::cin, s);// 从标准输入中读取一行，直到下一个制表符std::getline(std::cin, s, '\\t'); // 从标准输入中读取一行，直到下一个 'a'std::getline(std::cin, s, 'a'); 当需要把 std::string 作为函数参数传入时，有以下选择： 要求 使用形式 优势 总是需要复制值时 std::string 值传参 在C++17/20下只读 std::string_view(#include string_view) 省去大部分复制 在C++98/11/14下只读 const std::string 引用传递，省去大部分复制 原地修改输入字符串 std::string 非const的引用传递 const表示把变量常量化，不允许改变值 C++还提供了关于 std::string 与基本类型转换的函数： #include stringstd::to_string(5); // 数字（整型和浮点型）转字符串std::string s = \"123\";int num = std::stoi(s); // 字符串转整型// 类似的还有 std::stol, std::stoll, std::stof, std::stod// 分别是字符串转long，转long long，转float，转double 函数 与C语言类似，函数实现细节的封装；通过将问题分解为单独的函数，更容易对正确性和测试进行推理；避免为常见任务重复代码。 函数结构： 返回类型 函数名 (参数列表){ // 函数体} 函数参数的默认值： // a 默认值为0，b 默认值为0int add(int a, int b = 0){ return a + b;}int num1 = add(1, 2); // num1 = 3;int num2 = add(1); // num2 = 1; 注意：第一个默认值之后的每个参数也必须有默认值。 函数相关的知识点还有：函数定义、函数声明、函数签名、函数递归。这些与C语言中的知识互通。 函数重载 具有相同名称但不同参数列表的函数，不能单独重载返回类型。 如： int add(int a, int b){ return a + b;}double add(double a, double b){ return a + b;} 函数设计 约定： 前提条件：您对输入值的期望/要求是什么? 后置条件：对于输出值应该给出什么保证? 不变量：函数的调用者/用户希望不改变什么? 目的：你的职能有明确的目的吗? 名称：函数的名称是否反映了它的目的? 参数：调用者/用户是否容易混淆它们的含义? C++17中，支持使用 [[nodiscard]] 鼓励编译器在发现返回值被丢弃时发生警告： [[nodiscard]] bool odd(int num){ return num % 2 == 1;}bool yes = odd(3); // 正常odd(4); // 警告，因为返回值被丢弃 C++11及以后支持使用关键字 noexcept，指定函数承诺永远不会抛出异常/让异常逃逸。如果一个异常从noexcept函数中逃逸，程序将被中止。 内存模型（部分） 堆 用于动态存储持续时间的对象，例如std：：vector的内容 空间大，可用于大容量存储（大部分主存） 可以按需分配和解除分配任何对象 不按特定顺序分配（取消）资源 缓慢分配：需要为新对象找到连续的未占用空间 栈（先进后出） 用于对象的自动存储期限：局部变量、函数参数等。 空间小（通常只有几MB） 快速分配：新对象总是放在最上面 对象按其创建的相反顺序解除分配 无法取消分配最顶层（=最新）以下的对象 对象存储生存期： 类型 生存期 举例 自动回收型 对象生存期绑定到语句块范围的开始和结束 如局部变量，函数参数 动态变化型 用特殊语句控制的对象生存期 按需创建/销毁的对象 线程生存型 对象生存期绑定到线程的开始和结束 静态生存型 对象生存期与程序的开始和结束有关 静态变量(static) 输入和输出 命令行的输入输出 Windows 系统中，打开控制台（命令提示符，CMD），可以在里面输入一些命令。 C++ 也支持通过命令输入一些参数。有时候会遇到下面的代码： #include iostreamint main(int argc, char* argv[]){ return 0;} 其中，argc 表示命令行传入参数的个数， argv 表示命令行传入的参数字符串数组。 argv[0] 为当前程序名 比如有一程序代码： // test.cpp#include iostreamint main(int argc, char* argv[]){ for(int i = 0; i argc; i++) std::cout argv[i] \" \"; return 0;} 在经过编译后，可以在 cmd 中进行调用可执行文件： g++ -o test.exe test.cpptest.exe 1 2 3 上述 test.cpp 代码中，功能是将程序的命令行输入都输出到控制台。 实际上 C++ 程序的输出（返回值）也是可以获取的。 比如有代码： // test.cpp#include iostreamint main(int argc, char* argv[]){ if(argc = 1) return 0; else return argc;} 经过编译后运行有： g++ -o test.exe test.cpptest.exeecho %errorlevel%test.exe 1 2 3 4 5echo %errorlevel% 输入输出流 一些标准输入输出流有： 输入流 istream 输出流 ostream 文件输入流 ifstream：从文件中读取提取的数据 文件输出流 ofstream：插入的数据存储在文件中 字符串输入流 istringstream：从字符串缓冲区读取提取的数据 字符串输出流 ostringstream：插入的数据存储在字符串缓冲区中 一些关于流的控制格式函数： 冒号表示进入命名空间，表示该函数或内容属于某命名空间，防止命名冲突 std::getline(istream, string, stopat=' ')：读取到下一个停止字符（默认直到行尾） std::istream::ignore(n, c)：忽略字符，直至忽略 n 个字符或字符 c 被发现 std::setprecision(n)：定义保留精度，对于小数表示共保留 n 位。需要包含头文件 iomanip std::fixed：修改浮点输入/输出为默认格式 std::scientific：修改浮点输入/输出为科学计数法格式 std::boolalpha：修改 bool 类型的输入/输出为字母格式 文件的输入输出 需要包含头文件 fstream。 打开和关闭文件 在输入输出流中，使用文件输入输出流 ifstream 和 ofstream 操作文件。 函数 open() 和 clost() 分别控制文件的打开和关闭。 打开文件操作如下： // 1. 初始化流时打开文件std::ifstream in1(\"test.txt\"); // 使用文件名打开文件std::string path = \"test.txt\";std::ifstream in2(path); // 文件名使用字符串和字符数组都可以// 文件将自动关闭// 2. 使用open函数打开文件std::ifstream in3;in3.open(\"test.txt\"); 关闭文件操作如下： std::ifstream in4;in4.open(\"test.txt\");// ……in4.close(); 文件在打开时，可以选择打开的模式： 默认情况下，文件输入流的模式为 std::ios::in，即只读模式；文件输出流的模式为 std::ios::out，即只写模式； 追加到现有文件： std::ios::app； 以二进制方式打开文件： std::ios::binary； 只需要在初始化时声明打开模式即可： // 以二进制方式打开文件std::ifstream in(\"test.txt\", std::ios::in | std::ios::binary); 读文件 使用文件输入流 ifstream： std::ifstream in(\"test.txt\");int x;while(in x) std::cout x ' '; 当打开模式为二进制打开时，读文件使用 std::istream::read()。 函数参数为指针和长度，将文件读入到指针的空间中，返回读取的字节数； std::ifstream in(\"test.txt\", std::ios::in | std::ios::binary);unsigned int i;in.read(reinterpret_castchar*(i), sizeof(i)); 写文件 使用文件输出流 ofstream： std::ofstream out(\"test.txt\");if(out.good()) // 判断流是否正常可写文件{ out \"Hello World! \";} 当打开模式为二进制打开时，写文件使用 std::ostream::write()。 函数参数为指针和长度，将指针指向的内容写入文件，返回写入的字节数； std::ofstream out(\"test.txt\", std::ios::out | std::ios::binary);unsigned int i = 10;out.write(reinterpret_castchar*(i), sizeof(i)); 输入流的错误 当有代码： #include iostreamint main(){ int i = 0, j = 0; std::cout \"input i:\"; std::cin i; std::cout \"input j:\"; std::cin j; std::cout i \" \" j std::endl; return 0;} 如果输入的是： 1 2 这没有问题； 但如果输入的是： asd 2，此时将中断 j 的输入并输出 0 0。 当进行输入时，读取不能转换为 int 的字符（非0~9）： cin 将会置错误位； cin 的缓冲区内容不会被丢弃，并且仍然包含有问题的输入； 任何随后从 cin 读取 int 的尝试也将失败。 要想解决这个问题，需要清除 cin 的错误位以及输入缓冲区。 #include iostreamvoid resetCin(){ // 清空错误状态 std::cin.clear(); // 清空输入缓冲区 std::cin.ignore(std::numeric_limitsstd::streamsize::max(), ' ');}int main(){ int i = 0, j = 0; std::cout \"input i:\"; std::cin i; if(std::cin.fail()) resetCin(); std::cout \"input j:\"; std::cin j; std::cout i \" \" j \" \"; return 0;} 此时再次输入 asd 2，将输出 0 2。 更多参考官方文档： C++ iostream C++ fstream 类的初接触 引例 实现一个单调计数器，支持自增和读取计数值。 分析要求，如果是 C 语言，可以包装成结构体： struct Counter{ int count;}Counter cnt;std::cout cnt.count; // 访问cnt.count++; // 自增cnt.count = 10; // 访问 可是应当考虑到： 成员变量未显式初始化； 可以自由地修改任何整数成员 甚至跟基础的 int 无差别 在 C++ 中，考虑实现为一个类。 C++ 的类可以有构造函数，析构函数，成员函数，成员变量，以及成员函数的重载，成员变量的默认初始化等。 注：虽然结构体 struct 在 C++ 中也支持成员函数，但此处介绍类 class 类成员的受限制访问 成员函数 成员函数可用于 操作或查询数据成员，通过成员函数访问成员变量 控制/限制对数据成员的访问，通过成员函数访问私有成员变量 隐藏低级实现详细信息 确保正确性：保持/保证不变量 确保清晰：为类型的用户提供结构良好的界面 确保稳定性：大部分内部数据表示独立于接口 避免重复/样板：对于潜在的复杂操作封装成成员函数，只需要一个调用 class Counter{ int count; // 成员变量public: void inc() { count++; } // 成员函数 int get() { return count; }};Counter cnt;std::cout cnt.get();cnt.inc();std::cout cnt.get(); 公有与私有 私有成员只能通过成员函数访问！！！ 结构体与类的主要区别是默认的成员访问权限： 结构体默认为公有 类默认为私有。 const限定的成员函数 非 const 对象不管是否 const 限定都可以调用，const 对象只能调用 const 限定的函数。 #include iostreamclass Counter{ int count; // 成员变量public: Counter() : count(0) {} explicit Counter(int _count) { count = _count;} // 构造函数 void inc() { count++; } // 成员函数 int get() const { return count; }};int main(){ Counter cnt1; auto const pcnt1 = cnt1; pcnt1.inc(); // 编译错误，inc() 是非const函数 std::cout pcnt1.get(); return 0;} 成员变量在 const 限定的成员函数内 也具有 const 属性。 如果一个函数是常量限定的，另一个不是，则两个成员函数可以有相同的名称（和参数列表）。这使得可以清楚地区分只读访问和读/写操作。 即成员函数可以被 const 重载 int getAndSet() const { return count; } // 只读访问void getAndSet(int newcount) { count = newcount; } // 写 成员函数的定义 当类的成员函数较为复杂时，一般不会在类内定义，而是定义在类的外部，此时加上作用域： class A{ int value;public: void setValue(int v); int getValue() const;}void A::setValue(int v){ // ……}int A::getValue() const{ // ……} 初始化 成员初始化 成员变量初始化，C++11 下： class Counter{ int count = 0;public: //……} 构造函数的初始化列表 构造函数是创建对象时执行的特殊成员函数 class Counter{ int count = 0;public: Counter() : count(0) {} // ……} 确保初始化列表中的成员顺序始终与成员声明顺序相同 构造函数 构造函数：创建对象时执行的特殊成员函数。 构造函数名就是其类型名 没有返回类型 可以通过初始化列表初始化数据成员 确保初始化列表中的成员顺序始终与成员声明顺序相同 可以在首次使用对象之前执行代码 可以用来建立不变量 调用顺序自上而下 默认构造函数 类默认提供 默认构造函数，其不带参数。但是当显式定义构造函数时，需要手动提供一个默认构造函数，默认构造函数只能有一个（避免二义性），但构造函数可以有多个。 如： class Counter{ int count; // 成员变量public: Counter() : count(0) {} // 默认构造函数，采用初始化列表，确保初始化列表中的成员顺序始终与成员声明顺序相同！ Counter(int _count) { count = _count;} // 构造函数，且默认用1初始化 void inc() { count++; } // 成员函数 int get() { return count; }};Counter cnt1; // 默认构造函数，并初始化count = 0Counter cnt2(10); // 构造函数，初始化count = 10 或者使用 TypeName() = default;，编译器提供默认构造函数的实现。 class Counter{ int count; // 成员变量public: Counter() = default; // 默认构造函数，未初始化 Counter(int _count) { count = _count;} // 构造函数 void inc() { count++; } // 成员函数 int get() { return count; }}; 默认构造函数还可以通过给函数参数设置默认值提供： class Counter{public: Counter(int _count = 0) { count = _count; } // 默认构造 // Counter() = default; // 默认构造函数} 定义构造函数时，加上关键字 explicit 表示构造函数只能用于显式转换，即不会被隐式调用，隐式调用的构造是很难找到的 bug 的主要来源。如： #include iostreamclass Counter{ int count; // 成员变量public: Counter() : count(0) {} explicit Counter(int _count) { count = _count;} // 构造函数 void inc() { count++; } // 成员函数 int get() { return count; }};int fun (Counter c) { return c.get(); }int main(){\tstd::cout fun(2) \" \"; // 编译错误，避免了由2隐式转换为Counter的bug std::cout fun(Counter(2)) \" \"; // 正确 return 0;} 可以尝试把 explicit 去掉，体验如何隐式调用构造函数。 拷贝构造函数 默认情况下，类也提供默认拷贝构造函数 默认拷贝构造函数：简单来说就是从源复制到新的地方，进行变量之间的复制 默认拷贝构造函数是浅复制 浅复制（拷贝）：拷贝者和被拷贝者是同一个地址，改变其中一个，另一个也改变 深复制（拷贝）：拷贝者和被拷贝者不是同一个地址，改变其中一个，另一个不变 拷贝构造函数的函数名就是其类型名，参数为拷贝源 拷贝函数的形式： T::T(const T t) {} 可以重载拷贝构造函数，进行一些自定义的复制操作。 class Counter{ int count; // 成员变量public: Counter() : count(0) {} // 默认构造函数 explicit Counter(int _count) { count = _count;} // 构造函数 Counter(const Counter c) { count = c.get(); }\t// 拷贝构造函数 void inc() { count++; } // 成员函数 int get() const { return count; }};Counter cnt1; // 默认构造函数，并初始化count = 0Counter cnt2 = cnt1;\t// 调用拷贝构造函数 赋值运算符函数 默认赋值运算符函数：就是重载了赋值运算符 具有其返回值类型，函数名字以及参数列表 赋值运算符函数形式如下： T T::operator=(const Counter rhs) 具体如： class Counter{ int count; // 成员变量public: Counter() : count(0) {} // 默认构造函数 explicit Counter(int _count) { count = _count;} // 构造函数 Counter(const Counter c) { count = c.get(); }\t// 拷贝构造函数 Counter operator =(const Counter c) // 赋值运算符函数 { if(this != c) // 判断赋值是否为本身，若为本身则无需操作 { this-set(c.get()); } return *this;\t} void inc() { count++; } // 成员函数 void set(int _count) { count = _count; } int get() const { return count; }}; 除了赋值运算符，其他大部分运算符也可以重载。但不可重载的运算符有： .：成员访问运算符 .*，-*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 移动构造函数和移动赋值运算符函数 C++引入了移动语义，也产生了移动构造函数和移动赋值运算符函数。 移动构造函数：能够从一个右值引用创建新的对象，而无需进行深拷贝 假设你搬家，有一堆家具需要装进卡车。传统的深拷贝（复制构造函数）就像是你把每一件家具都精心地复制一份，然后放进卡车上。这个过程费时费力，而且你原本的家具还要保留。但是，如果你找来一位勇敢的快递员（移动构造函数），他们可以直接将你的家具移动到新的屋子里，而不用复制。这样，节省了时间和精力，而且你原本的家具可以顺利放进新的屋子。 移动构造函数形式： T::T(T) noexcept; 移动赋值运算符函数：允许将一个对象的资源转移到另一个对象上 想象一下，你在一家公司工作，有一天你被调往另外一个部门。传统的方式是，你将自己的工作内容复制一份，再将新工作的内容复制回来，形成了两份一样的工作内容。这样的操作显然很冗余。然而，通过移动赋值操作符，你可以直接将自己的工作内容交给新的员工，并且接管他们原本的工作，省去了不必要的复制步骤。 移动赋值运算符函数形式： T T::operator=(const T rhs); 析构函数 析构函数：当对象的生命周期结束时，会调用析构函数，用于释放对象的资源。 如果不定义默认构造函数和析构函数，编译器会生成它们。 函数形式： Type::~Type() { ... } 析构函数的执行顺序：所有数据成员的析构函数将以其构造函数相反的声明顺序执行 调用顺序自下而上 资源获取即初始化RAII 对象构建：获取资源 对象销毁：释放资源 如 std::vector 每个 vector 对象都是堆中存储实际内容的单独缓冲区的所有者。 该缓冲区按需分配，如果vector对象被销毁则取消分配。 如果一个对象对其生命周期(初始化/创建、结束/销毁)负责，则该对象被称为资源(内存、文件句柄、连接、线程、锁等)的所有者。 注意资源的使用，避免资源泄漏。 零规则 The Rule of Zero：尽量不要自己写特殊成员函数。 避免编写特殊的成员函数，除非需要进行 RAII 风格的资源管理或跟踪生命周期。 编译器生成的默认构造函数和析构函数在大多数情况下就足够了。 初始化并不总是依赖编写构造函数。 大多数数据成员都可以用成员初始化器初始化（声明定义时初始化）。 不要给类型添加空析构函数。 用户定义析构函数的存在阻止了许多优化，并可能严重影响性能。 如果不需要在析构函数体中做任何事情，那么就不要定义它。 几乎不需要编写析构函数。 在现代 C++ 中，内存管理策略大多封装在专用类(容器、智能指针、分配器等)中。 指针 为什么需要指针？ 观察对象 引用/跟踪对象 在运行时更改间接的目标 访问动态内存 访问动态存储持续时间的对象，即生命周期不与变量/作用域绑定的对象 构建动态、基于结点的数据结构 动态数组 链表 树/图 有时候可以用于前向声明：定义一个类型，它的所有成员的内存大小必须是已知的。 例子中，Hub 类和 Device 类相互类型引用。 因为，所有指针类型都具有相同的大小。 所以先声明 Hub 的存在。 然后 Device 只需要一个指向 Hub 的指针，即已知成员内存大小。 class Hub;class Device { Hub* hub_; …};class Hub { std::vectorDevice const* devs_; …}; 指向类型为T的对象的指针 T* ptr; 存储类型为 T 的对象 ptr 的内存地址； 可以用来检查/观察/修改目标对象； 可以重定向到不同的目标（不同于引用，引用不可以重定向）； 也可能根本不指向任何对象，为空指针。 原始指针：T * 本质：一个存储内存地址的（无符号）整数变量 大小：64位，8个字节（64位机） 许多原始指针可以指向相同的地址/对象 指针和目标（被指向）对象的生存期是独立的，可能会出现野指针。 野指针：指向一个已经销毁的对象的指针或指向一个未定义内容的内存地址。 智能指针：（C++11及以后） std::unique_pointerT 用于访问动态存储，即堆上的对象； 每个对象只能有一个 unique_pointer； 指针与指向对象具有相同的生存期。 std::shared_pointerT 用于访问动态存储，即堆上的对象； 每个对象可以有多个 shared_pointer 只要至少有一个 shared_pointer 指向目标对象，目标对象就存在 std::weak_pointerT 用于访问动态存储，即堆上的对象； 每个对象可以有多个 weak_pointer C++11及以后： nullptr 特殊指针值； 可隐式转换为 false 在内存中不一定用0表示（取决于平台） nullptr 表示值不可用 在初始化时设置指向空指针或有效地址的指针 取消引用前检查是否为nullptr 指针相关的运算符 取地址符 ：返回内存地址。 char c = 65;char *pc = c; 解引用（取值）符 * ： 访问地址中的值 char c = 65;char *pc = c;*pc = 66; 成员访问符 - ： 访问指针指向的对象的成员 struct coord{ char x = 0; char y = 0;}coord a{1, 2};coord *pa = a;char v = pa-x; // 访问指针pa指向地址中的x成员的值char w = (*pa).y; // 解引用后使用.访问成员 * 和 的语法： 用处 * 作类型修饰符 声明指针：Type *ptr = nullptr 声明引用：Type ref = variable 作一元运算符 解引用：value = *pointer 取地址：pointer = variable 作二元运算符 乘法：ans = expr1 * expr2 按位与：bitand = expr1 expr2 指针声明时注意： int* p1, p2; // p1 是 int*，p2 是 intint *p1, *p2; // p1 是 int*，p2 是 int* const 指针 目的： 对于目标只读访问 防止指针重定向 语法： T类型的指针 指向的值能否修改 指针能否重定向 T * 能 能 T const * 不能 能 T * const 能 不能 T const * const 不能 不能 从右向左读：(是否const修饰的) 指针指向一个（是否const修饰的）类型 int i = 5;int j = 8;const int *cp = i;*cp = 8; // 编译器错误：指向的值是常量cp = j; // OKint * const pc = i;*pc = 8; // OKpc = j; // 编译器错误：指针本身是常量const int * const cpc = i;*cpc = 8; // 编译器错误：指向的值是常量cpc = j; // 编译器错误：指针本身是常量 还有代码风格的一致性问题：使用像是 int const 而不是 const int。 // const 修饰它的左边int const c = ...; // const 修饰它的左边（int）int const cr = ...; // const 修饰它的左边（int）int const *pc = ...; // const 修饰它的左边（int）int * const cp = ...; // const 修饰它的左边（*）int const * const cpc = ...;// const 修饰它的左边（int和*） this 指针 this： 成员函数内部可用 this 返回对象本身的地址 this- 可用于访问成员 *this 访问对象本身 如： class IntRange{ int l_ = 0; int r_ = 0;public: explicit IntRange (int l, int r): l_{l}, r_{r} { if (l_ r_) std::swap(l_, r_); } int left () const { return l_; } // 也可以使用“this”访问成员： int right () const { return this-r_; } // 返回对象本身的引用 IntRange shift (int by) { l_ += by; r_ += by; return *this; }}; 少使用指针 推荐合适使用 引用 代替指针。 指针容易悬空 悬空：指针指向无效或不可访问的内存地址 指针中的值可以是任意地址，程序员必须确保指针目标是有效的/仍然存在 容易出现错误参数传递 指针让代码更难理解 *p = *p * *p + (2 * *p + 1); 异常 什么是异常 对象可以在调用层次结构中向上抛出： 通过“抛出”将控制转回到当前函数的调用方。 如果不处理，异常会一直传播，直到它们到达 main 函数。但如果在主函数中中没有处理异常，将会调用 std::terminate，即终止程序。 void fun1(){\tthrow \"Exception\";}void fun2(){\tfun1();}int main(){\tfun2(); // 没有处理异常，终止程序 return 0;} 通过 throw 关键字抛出异常。 通过 try-catch 语句捕获异常。 例子： // 定义除法函数， a / b double division(double a, double b){\tif(b == 0) throw std::invalid_argument{\"divided by 0\"};\treturn a / b;}int main(){\tdouble number1 = 0, number2 = 0, ans = 0;\tstd::cin number1 number2;\ttry\t{ ans = division(number1, number2);\t}\tcatch (std::invalid_argument const err)\t{ std::cout err.what() ' '; return -1;\t}\tstd::cout number1 \" / \" number2 \" = \" ans; return 0;} 输入：1 2输出：1 / 2 = 0.5输入：1 0输出：divided by 0 异常用处 报告违规行为。 输入与期望或规定不符（违法输入，或违法的函数参数）。 如：负数的平方根、下标越界等。 定义或保留不变量失败。 如：公共成员函数无法设置有效的成员值、vector 扩充空间期间爆内存。 输出、返回值与期望或规定不符，函数无法生成有效的返回值或损坏全局。 如：构造函数失败、无法返回除以零的结果。 异常的优劣： 错误处理代码与业务逻辑的分离 错误处理的集中化 当不引发异常时，性能影响可以忽略不计 抛出异常时通常会影响性能，由于额外的有效性检查而导致的性能影响 容易产生资源/内存泄漏 异常替代方案 输入值无效：输入前进行检查，用参数类型排除无效值。 定义或保留不变量失败：设置错误状态/标志，将对象设置为特殊，无效值/状态。 不能返回有效值：通过单独的输出参数（引用或指针）返回错误代码、返回特殊的有效值、返回特殊类型 std::optional(C++17) 标准库异常 std::exception：其子类型有： logic_error invalid_argument domain_error length_error out_of_range …… runtime_error range_error overflow_error underflow_error …… vector 支持一种“宽规约”函数，通过抛出异常来报告无效的输入值： std::vectorint v{ 0, 1, 2 };int a = v[3]; // 越界且窄规约，即错误int b = v.at(3); // 越界且宽规约，即抛出异常 std::out_of_range 处理异常 重复抛出： try{ // ...}catch(std::exception const ){ throw;} 捕获所有异常： try{ // ...}catch(...){ // ...} 集中异常处理： 如果在许多不同的地方抛出相同的异常类型，可以避免代码重复。 void handle_init_errors(){ try { throw; // 重抛出 } catch(err::device_unreachable const e) { //... } catch(err::bad_connection const e) { //... } catch(err::bad_protocol const e) { //... }}void init_server(){ try { ///... } catch(...) { handle_init_errors(); }}void init_client(){ try { //... } catch(...) { handle_init_errors(); }} 异常的问题 几乎任何一段代码都可能引发异常，对C++类型和库的设计产生重大影响。 资源/内存泄漏的潜在来源： 进行自己的内存管理的外部C库； 不使用 RAII 进行自动资源管理的C++库（设计存在缺陷）； 在销毁时不清理资源的类型（设计存在缺陷）； 如： void add_to_database (database const db, std::string_view filename){ DBHandle h = open_dabase_conncection(db); // 建立远程连接 auto f = open_file(filename); // 如果 open_file 抛出异常，则不会调用 close_database_connection // do work… close_database_connection(h); // 断开远程连接} 这个例子可以使用 RAII，在类析构时断开连接释放资源。 但也不要让异常逃离析构函数，如果在析构函数运行时发生异常，可能导致析构函数终止，但对象还没完全释放。 需要在析构函数作成套的 try-catch。 异常保障 为了避免抛出异常： 当没有保障时： 操作可能会失败 资源可能会泄露 可能违反不变量（=成员可能包含无效值） 部分执行失败的操作可能会产生副作用（例如输出） 异常可能向外传播 存在基本保障时： 不变量被保留，没有资源泄露 所有成员都将包含有效值 部分执行失败的操作可能会产生副作用（例如，值可能已写入文件） 强保障时： 操作可能会失败，但不会产生明显的副作用 所有成员都保留其原始值 内存分配容器应提供这种保证，即如果增长期间内存分配失败，容器应保持有效且不变 使用无抛出保障时： 行动一定会成功 无法从外部观察到的异常，即没有抛出或内部捕获 使用 noexcept 关键字进行记录和强制执行 无抛出保障关键字： noexcept （C++11） int f() noexcept{ ...} f 函数承诺永远不抛出异常，不允许任何转义 如果从 noexcept 函数中逃脱出异常，则程序将终止 带条件的 noexcept 语句： A noexcept(exp) // 如果表达式产生真值，声明'A'为noexceptA noexcept(noexcept(B)) // 如果`B`没有抛出异常，声明`A`为noexcept noexcept() 默认是 true。 终止处理程序 当在主函数有未捕获的异常时： 调用终止函数 std::terminate。 它调用终止处理程序，默认调用 std::abort ，从而正常终止程序。 可以自定义处理程序：std::set_terminate(handler); 如： #include stdexcept#include iostreamvoid my_handler (){ std::cerr \"Unhandled Exception! \"; std::abort(); // 终止程序}int main (){ std::set_terminate(my_handler); throw std::exception{}; } 异常指针 std::current_exception： 捕获当前异常对象 返回一个 std::exception_ptr 引用该异常 如果没有异常，则返回空的 std::exception_ptr std::exception_ptr 保存一个异常副本或对异常的引用 std::rethrow_exception(exception_ptr) 抛出异常指针所引用的异常对象 #include exception#include stdexceptvoid handle_init_errors (std::exception_ptr eptr){ try { if (eptr) std::rethrow_exception(eptr); } catch (err::bad_connection const e) { // ... } catch (err::bad_protocol const e) { // ... }}void initialize_client (){ if (exp) throw err::bad_connection; // ...}int main (){ std::exception_ptr eptr; try { initialize_client(); // ... } catch (...) { eptr = std::current_exception(); } handle(eptr);} // eptr已销毁，则捕获的异常已销毁 计数未捕获的异常 C++17中，std::uncaught_exceptions 返回当前线程中当前未处理的异常数。 #include exceptionvoid foo (){ bar(); // 可能抛出异常 int count = std::uncaught_exceptions(); // ...} C++诊断 关于诊断的术语 Warnings：编译器指出潜在的有问题的行为，可能在运行时形成错误。 Assertions：断言，用于比较和报告表达式的预期值和实际值的语句。 Testing：比较部分或整个程序的实际情况和预期行为。 Code Coverage：代码覆盖情况，即实际执行或测试了多少代码。 Static Analysis：静态分析，通过分析源代码（就看着代码）发现潜在的运行时问题，如未定义行为。 Dynamic Analysis：动态分析，通过运行实际的程序（跑下代码）发现潜在的问题，如内存泄漏。 Debugging：在运行时逐步执行代码并检查内存中的值。 Profiling：找出每个函数、循环、代码块占总运行时间、内存消耗等的比例。 Micro Benchmarking：对单个函数或语句块调用的小测试。 记得使用针对性的数据类型，避免出错。 编译警告 Compiler Error：CE，编译器错误，程序不能编译。 Compiler Warning：程序能够编译，但是有一段有问题的代码可能会导致运行时错误。 一些 gcc/clang 编译器的编译设置： Wall：没有真正启用所有警告，而是启用了最重要的警告，这些警告不会产生太多的干扰。 Wextra：启用比 -Wall 更多的警告。 Wpedantic：发出严格 ISO C++ 要求的所有警告；拒绝特定于编译器的扩展。 Wshadow：当变量或类型声明相互隐藏时发出警告。 Werror：把所有警告当作错误行为。 gcc [options] file .. 如： g++ -Wall -o test.exe test.cpp MS Visual Studio 的编译设置： /W1：严重的警告。 /W2：重要的警告。 /W3：生产级别警告。 /W4：并不能真正启用所有警告，而是最重要的警告，新项目推荐。 /Wall：启用比级别4更多的警告。 /WX：把所有的警告当成错误行为。 断言 头文件：#include cassert assert(bool 表达式); 如果表达式产生 false，则中止程序。 使用案例： 在运行时检查预期值/条件 验证前提条件（输入值） 验证不变量（例如，中间状态/结果） 验证后置条件（输出/返回值） 注意，逗号需要加上括号：assert 是一个预处理器宏，逗号将被解释为宏参数分隔符。 assert( min(1, 2) == 1 ); // errorassert((min(1, 2) == 1)); // ok 可以使用自定义宏添加： #define assertmsg(expr，msg) assert (((void)msg，expr))assertmsg(1+2=2，\"1加1必须是2\"); 对于 g++/clang，通过定义预处理器宏 NDEBUG 来停用断言，例如，使用编译器开关：g++-DNDEBUG… 对于 MS Visual Studio： 断言会被显式激活的情况： 如果定义了预处理器宏 _DEBUG，例如使用编译器开关/D_DEBUG。 如果提供了编译器开关 /MDd。 断言会被显式停用的情况： 如果定义了预处理器宏 NDEBUG。 在项目设置中或使用编译器开关 /DNDEBUG。 静态断言 C++11支持。 static_assert(bool 表达式);static_assert(1+1==2，\"1加1必须是2\"); C++17下： static_assert(bool 表达式); 功能：如果编译时常数表达式产生 false，则中止编译。 测试 测试准则： 使用断言：检查类型无法表达、保证的期望或假设，如 仅在运行时可用的预期值 先决条件（输入值） 不变量（例如，中间状态/结果） 后置条件（输出/返回值） Release版本中应该去掉断言。 编写测试用例：一旦确定了函数或类型的基本目的和接口即可开始准备。 使用测试框架： 小项目可以使用：doctest 大工程可以使用：Catch2 测试中最好不要 直接 用 cin、cout、cerr。 直接使用全局I/O流使得函数或类型难以测试。 函数中用引用传递流： struct State {std::string msg; ...};void log(std::ostream os, State const s){ os s.meg;}TEST_CASE(\"State Log\"){ State s{\"expected\"}; std::ostringstream oss; log(oss, s); CHECK(oss.str() == \"expected\");} 类作用域中使用流指针存储： class Logger{ std::ostream *_os; int _count;public: explicit Logger(std::ostream *os) : _os(os), _count(0) {} // ... bool add(std::string_view msg) { if(!_os) return false; *_os _count \": \" msg \" \"; ++_count; return true; }}TEST_CASE(\"Logging\"){ std::ostringstream oss; Logger log{oss}; log.add(\"message\"); CHECK(oss.str() == \"0: message \");} 使用 gdb 进行调试 gdb，GNU Debugger，是一种开源的调试器，与在 Visual Studio 上进行调试类似。不同的是，gdb 通过命令进行调试。 现有代码： #includeiostream#includestringint fun(int n){\tif(n = 1) return 1;\telse return fun(n - 1) * n; }int main(int argc, char *argv[]){\tint num = std::stoi(argv[1]);\tstd::cout fun(num) std::endl;\treturn 0;} 使用命令： g++ -o test test.cpp 编译后，使用 gdb 调试： gdb test 输出如下： GNU gdb (GDB) 11.2Copyright (C) 2022 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.htmlThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type \"show copying\" and \"show warranty\" for details.This GDB was configured as \"x86_64-w64-mingw32\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:https://www.gnu.org/software/gdb/bugs/.Find the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...Reading symbols from test...(gdb) 接着输入： run 5 输出如下： Starting program: F:\\Program\\C++\\\\test.exe 5[New Thread 11572.0x4338][New Thread 11572.0x28e8][New Thread 11572.0x307c][Thread 11572.0x4dcc exited with code 0][Thread 11572.0x4338 exited with code 0][Thread 11572.0x307c exited with code 0][Inferior 1 (process 11572) exited normally] 这就完成了输入为 5 的测试。 可以设置断点： 在当前源代码的第12行添加断点break 12在所有源代码文件中第一个执行 fun 函数的那行添加断点break fun在 test.cpp 的第12行添加断点break test.cpp:12// 在 test.cpp 的 main 函数第一行添加断点break test.cpp:main 也可以使用条件型断点： break 20 if i == 2000 控制断点： 下一行next单步步进step 还有一些控制断点的操作： 输出所有断点info breakpoints删除所有断点delete删除1号断点delete 1禁用2号断点disable 2启用2号断点enable 2保存断点到 filesave breakpoints file从 file 中加载断点source file 可以监视和设置变量值： 监视局部变量info locals输出变量（表达式）值print xprint x + 2设置变量值set x = 20 常用命令还有： 跳转jump loc继续直到下一个断点或结束continue继续直到下一个位置（函数、行）until loc结束（跳出）当前函数finish查看调用栈backtrace 清理器 C++ 功能强大，但会遇到一些 bug，所以需要清理器（善后）。 地址清理器ASAN 对于 g++ 和 clang++而言： 检测内存损坏 bug： 内存泄漏 访问已释放的内存 访问不正确的堆栈区域 … 用附加指令对代码进行检测： 运行时间大约增加70% 内存使用量大约增加了3倍 如有代码： #include iostreamusing std::cin;using std::cout;int main(){ int *p = nullptr; cout *p \" \"; return 0;} 在 Ubuntu 中使用 gcc 9.4.0，输入下列命令： g++ test.cpp -o test -fsanitize=address./test 后提示： AddressSanitizer:DEADLYSIGNAL===================================================================1698==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x56468da812d8 bp 0x7fff3402eec0 sp 0x7fff3402eeb0 T0)==1698==The signal is caused by a READ memory access.==1698==Hint: address points to the zero page. #0 0x56468da812d7 in main (/home/ecs-assist-user/test/tes+0x12d7) #1 0x7f22b0c18082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) #2 0x56468da811cd in _start (/home/ecs-assist-user/test/tes+0x11cd)AddressSanitizer can not provide additional info.SUMMARY: AddressSanitizer: SEGV (/home/ecs-assist-user/test/tes+0x12d7) in main==1698==ABORTING 对于 MSVC： https://learn.microsoft.com/zh-cn/cpp/sanitizers/asan?view=msvc-170 从 Visual Studio 2019 版本 16.9 开始，Microsoft C/C++ 编译器 (MSVC) 和 IDE 支持AddressSanitizer清理器。 检测 bug： alloc/dealloc 不匹配和 new/delete 类型不匹配 分配对堆来说太大 calloc 溢出和 alloca 溢出 重复释放和释放后使用 全局变量溢出 堆缓冲区溢出 对齐值对齐无效 memcpy 和 strncat 参数重叠 堆栈缓冲区溢出和下溢 return 后使用堆栈和限定作用域后使用 在内存中毒后使用内存 未定义行为清理器UBSAN 对于 g++ 和 clang++而言： 在运行时检测许多类型的未定义行为： 解引用空指针 从未对齐的指针中读取 整数溢出 除零 … 用附加指令检测代码： 调试版运行时间增加25% 如有代码： #include iostream#include limitsusing std::cin;using std::cout;int main(){ int i = std::numeric_limitsint::max(); i += 1; cout i \" \"; return 0;} 在 Ubuntu 中使用 gcc 9.4.0，输入下列命令： g++ test.cpp -o test -fsanitize=undefined./test 后提示： test.cpp:9:7: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'-2147483648 内存泄漏检测工具valgrind Valgrind是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合。 检测常见的运行时错误： 读/写释放内存或不正确的堆栈区域 使用未初始化的值 不正确的内存释放，如双重释放 错误地使用函数来分配内存 内存泄漏——通常与程序有关的无意内存消耗 导致内存指针在释放之前丢失的逻辑缺陷 更多查看：https://blog.csdn.net/weixin_45518728/article/details/119865117 Lambda函数 Lambda 函数的形式如下： [捕获列表] (参数列表) - 返回值类型 { 代码块 } 举几个例子： [] { return 1; }[] (int x, int y) { return x * x + y * y; }[] (int x, int y) - double { return 1.0 * x * x + y * y; } Lambda 函数可以看作匿名函数，它没有名字。 关于变量捕获： [=]：捕获所有变量，值传递。 []：捕获所有变量，引用传递。 [x, y]：x为值传递，y为引用传递。 [=, y]：除了y是引用传递，其他都是值传递。 在某些情况下，可以使用 Lambda 函数。 函数 std::partition(@first, @last, p)，定义于头文件 algorithm。 其一个功能用法是：重排序范围 [first, last) 中的元素，使得谓词 p 对其返回 true 的元素前于谓词 p 对其返回 false 的元素。不保持相对顺序。 std::vectorint v{5, 3, -3, 2, 7, 1, 0, 99, 3};\tstd::partition(v.begin(), v.end(), [](int x) { return x 0; });\tfor(int x : v) std::cout x ' ';// 5 3 3 2 7 1 99 0 -3 函数 std::transform(@first, @last, @result, @op)，定义于头文件 algorithm。 其一个功能用法是：将范围 [first, last) 中的元素应用 op 变化 ，结果存储在 result 中。 // 字符串转全大写void upper(std::string s) { std::transform(s.begin(), s.end(), s.begin(), [] (unsigned char c) { return toupper(c); }); // 等价于 std::transform(s.begin(), s.end(), s.begin(), ::toupper);} // 对序列每个数字求平方std::vectorint v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};auto squared = [](int x) { return x * x; };// 匿名函数类型还是用 auto 自动推导吧std::transform(v.begin(), v.end(), v.begin(), squared);// 等价于std::transform(v.begin(), v.end(), v.begin(), [](int x) { return x * x; }); 函数 std::generate(@first, @last, @op)，定义于头文件 algorithm。 其中一个用法是：为 [first, last)范围内的每个元素分配一个由给定函数对象 g 生成的值。 #include iostream#include vector#include algorithmsigned main(){ std::vectorint v(10); int step = 1; std::generate(v.begin(), v.end(), [step] { step *= 2; return step; }); for (int x : v) std::cout x ' ';} 在C++14及以后，如果变量的类型复制代价昂贵，可以使用std::move class Expensive {...};Expensive f{1};auto g = [cf = std::move(f)]() { return cf; };","tags":["CPP"],"categories":["笔记"]},{"title":"OpenGL图形学编程基础学习记录","path":"/2024/basicOpenGL/","content":"关键词：C++、OpenGL 未完待施工… 一、OpenGL安装与使用 Reference：计算机图形学编程（使用OpenGL和C++）（第2版） 1.1 认识OpenGL 在 C++中使用 OpenGL 需要配置多个库。此处，使用到： C++开发环境； OpenGL / GLSL：2004 年，2.0 版本中引入了 OpenGL 着色语言 GLSL，使得“着色器程序”可以被直接安装到图形管线的各个阶段并执行； 窗口管理库：OpenGL会将图像渲染到一个帧缓冲区，然后由计算机将帧缓冲区的内容绘制到屏幕的窗口中，GLFW 库是最流行的选择之一。 扩展库：常用如 GLEW 库； 数学库：3D 图形编程会大量使用向量和矩阵代数，可使用 OpenGL Mathematics（GLM）库、 Eigen 库或 vmath 库； 纹理图像加载库：比如 FreeImage、DevIL、GLI、Glraw 和 SOIL。 1.2 安装和配置OpenGL 基于Visual Studio 2022进行 1.2.1 准备OpenGL/GLSL 了解计算机支持什么版本的OpenGL，可使用 GLView 查看。 1.2.2 准备GLFW 下载 GLFW 源代码，下载地址 使用 CMake 进行编译源码 接着找到 GLFW.sln，使用VS打开并编译为64位应用程序。 构建完成后得到下面两个内容：lib静态库文件和include文件夹 1.2.3 准备GLEW 下载 GLEW 的二进制文件，下载地址。解压后内有库文件和头文件等。 1.2.4 准备GLM 下载 GLM 压缩包，下载地址，解压后即可。 1.2.5 准备SOIL2 下载并解压 premake，包含 premake5.exe。 下载 SOIL2 的源码，下载地址，解压。 将 premake5.exe 复制到 soil2 目录下。 在 soil2 目录下使用cmd，运行命令： premake5 vs2022 打开 make/windows 文件夹的 SOIL2.sln 文件，右键 soil2-static-lib 在 x64 下选择进行生成。 1.2.6 准备共享的lib和include 选择合适的位置创建文件夹，并设置 lib 和 include 子文件夹。 在 lib 文件夹中放入 glew32.lib、glfw3.lib 和 soil2-debug.lib。 在 include 文件夹中放入 GLEW 的 GL 文件夹、GLFW 文件夹、glm 文件夹 和 SOIL2-1.3.0/src 的 SOIL2 文件夹。 在当前文件夹放入 glew32.dll 文件结构如下图： 1.3 在VS中配置OpenGL项目 创建 VS 自定义项目模板 启动 VS， 创建空白项目，选择 x64。 在 Debug 模式下，进入“项目属性”，在“VC++”目录下的包含目录添加上共享文件夹的 include 文件夹；在“链接器”下，“常规-附加库目录”（或“VC+±库目录”）添加上共享文件夹的 lib 文件夹，“输入-附加依赖项”添加以下文件名： glfw3.lib、glew32.lib、soil2-debug.lib 和 opengl32.lib。 在 Release 模式下，重复上述步骤。 “项目-导出模板”，选择项目模板，命名自定义，此处为“OpenGL project”。 创建 OpenGL C++ 项目时，启动 VS 时，点击“新建项目”，在左上方选择 OpenGL 模板即可使用。 需要注意的是，在新建OpenGL C++项目时，需要把 glew32.dll 放到项目目录下。 1.4 创建一个窗口 这部分可以用来测试上面的配置是否成功。下面给出一个 OpenGL C++ 创建窗口的代码： 展开代码 #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hppGLFWwindow *window;using namespace glm;int main(){ // 初始化 GLFW if (!glfwInit()) { return -1; } glfwWindowHint(GLFW_SAMPLES, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // MacOS 不需要 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 打开一个窗口并创建它的OpenGL上下文 window = glfwCreateWindow(1024, 768, \"New Window\", NULL, NULL); if (window == NULL) { glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 初始化 GLEW if (glewInit() != GLEW_OK) { glfwTerminate(); return -1; } // 确保我们可以捕捉到下面按下的转义键 glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // 蓝色背景 glClearColor(0.0f, 1.0f, 0.0f, 0.0f); do { // 清除屏幕 glClear(GL_COLOR_BUFFER_BIT); // 交换缓冲区 glfwSwapBuffers(window); glfwPollEvents(); } while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS glfwWindowShouldClose(window) == 0); // 检查是否按下了ESC键或窗口已关闭 // 关闭OpenGL窗口并终止GLFW glfwTerminate(); return 0;} 运行结果： 二、OpenGL图像管线 C++/OpenGL 应用程序的一个重要任务是让程序员的 GLSL 代码运行于 GPU 上。 OpenGL 提供了一个多级图形管线，可以使用 GLSL 语言进行部分编程。GLSL 是一种着色器语言。着色器语言主要运行于 GPU 上，在图形管线上下文中。 2.1 管线 OpenGL 图像管线是 OpenGL 的核心，它是一个图像处理的管线。图像管线的工作原理是将图像数据从原始的纹理中渲染到屏幕上。 3D 图形编程会使用管线的概念，在管线中，将 3D 场景转换成 2D 图形的过程被分割成许多步骤。 C++/OpenGL 应用程序发送图形数据到顶点着色器，随着管线处理，最终生成在显示器上显示的像素点。 2.1.1 第一个C++/OpenGL应用程序 即详细解释之前的创建窗口代码 该程序将会使用一些扩展库：GLEW、GLM、SOIL2 和 GLFW。 GLFW 库提供了 GLFWwindow 类，可在其上进行3D场景绘制。 该程序的大概操作有： 初始化 GLFW // 初始化 GLFWif (!glfwInit()){ return -1;} 创建窗口的设置 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);// WindowHint 指定了计算机必须与 OpenGL 版本 4.6 兼容（主版本号为 4，次版本号为 6）。 创建一个 GLFWwindow 实例并创建窗口 GLFWwindow *window = glfwCreateWindow(1024, 768, \"New Window\", NULL, NULL);if (window == NULL){ glfwTerminate(); return -1;}// glfwCreateWindow 命令的参数指定了窗口的宽、高（以像素为单位）以及窗口顶部的标题，后两个NULL分别用来控制全屏显示和资源共享）// 创建一个新窗口，大小为1024×768，窗口名为“New Window”glfwMakeContextCurrent(window);// 创建 GLFW 窗口并不会自动将它与当前 OpenGL 上下文关联起来，因此需要调用 glfwMakeContextCurrent()。 设置窗口属性 // 确保我们可以捕捉到下面按下的转义键glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);// 设置绿色背景，四个参数分别为RGBA。// glClearColor()能够指定颜色缓冲区清除后填充的值glClearColor(0.0f, 1.0f, 0.0f, 0.0f); 初始化 GLEW 库 // 初始化 GLEWif (glewInit() != GLEW_OK){ glfwTerminate(); return -1;} 循环显示窗口 do{ // 清除屏幕，重置缓冲区时填充的颜色 glClear(GL_COLOR_BUFFER_BIT); // 交换缓冲区，绘制屏幕 glfwSwapBuffers(window); // 处理窗口相关事件（如按键事件） glfwPollEvents();} while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS glfwWindowShouldClose(window) == 0); // 检查是否按下了ESC键或窗口已关闭 退出程序 // 关闭OpenGL窗口并终止GLFWglfwDestroyWindow(window);glfwTerminate(); 完整程序 #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hppusing namespace glm;int main(){ // 初始化 GLFW if (!glfwInit()) { return -1; } glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); // 打开一个窗口并创建它的OpenGL上下文 GLFWwindow *window = glfwCreateWindow(1024, 768, \"New Window\", NULL, NULL); if (window == NULL) { glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 确保我们可以捕捉到下面按下的转义键 glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // 绿色背景 glClearColor(0.0f, 1.0f, 0.0f, 0.0f); // 初始化 GLEW if (glewInit() != GLEW_OK) { glfwTerminate(); return -1; } do { // 清除屏幕 glClear(GL_COLOR_BUFFER_BIT); // 交换缓冲区 glfwSwapBuffers(window); glfwPollEvents(); } while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS glfwWindowShouldClose(window) == 0); // 检查是否按下了ESC键或窗口已关闭 // 关闭OpenGL窗口并终止GLFW glfwDestroyWindow(window); glfwTerminate(); return 0;} 2.2 顶点着色器和片段着色器 多数 3D 模型通常由多个三角形图元构成。如点、线、三角形这些简单的图形称作图元。 图元由顶点组成。 在加载顶点之前，C++/OpenGL 应用程序必须编译并链接合适的 GLSL 顶点着色器和片段着色器程序，之后将它们载入管线。 比如绘画三角形时，可以通过该函数实现： glDrawArrays(GLenum mode, Glint first, Glsizei count); mode：表示图元的类型； first：表示从哪个顶点开始绘制； count：表示绘制的顶点数。 以绘画三角形为例子，步骤如下： 注： GLuint 是 OpenGL 提供的 unsigned int 初始化阶段，对 GLFW 和 GLEW 库进行初始化，同时创建窗口； 创建顶点数组对象VAO和缓存区； // 创建一个顶点数组对象，并将它设为当前对象GLuint VertexArrayID;glGenVertexArrays(1, VertexArrayID);glBindVertexArray(VertexArrayID);// 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)static const GLfloat g_vertex_buffer_data[] = { -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f };// 创建缓存区GLuint vertexbuffer; // 顶点缓冲区标识glGenBuffers(1, vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL 循环中绘画三角形 do{ glClear(GL_COLOR_BUFFER_BIT); glEnableVertexAttribArray(0); // 启用顶点数组 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0); glDrawArrays(GL_TRIANGLES, 0, 3); // 绘制三角形 glDisableVertexAttribArray(0); // 禁用顶点数组 glfwSwapBuffers(window); // 交换缓冲区，更新屏幕 glfwPollEvents(); // 监听事件} while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0); 后处理，删除申请的资源 // 后处理，删除资源glDeleteBuffers(1, vertexbuffer);glDeleteVertexArrays(1, VertexArrayID);glfwTerminate(); 完整代码 #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hppint main(){ // 初始化 GLFW if (!glfwInit()) { return -1; } glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); // 打开一个窗口并创建它的OpenGL上下文 GLFWwindow *window = glfwCreateWindow(1024, 768, \"triangle\", NULL, NULL); if (window == NULL) { glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 确保我们可以捕捉到下面按下的转义键 glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // 绿色背景 glClearColor(0.0f, 1.0f, 0.0f, 0.0f); // 初始化 GLEW if (glewInit() != GLEW_OK) { glfwTerminate(); return -1; } // 创建一个顶点数组对象，并将它设为当前对象 GLuint VertexArrayID; // 顶点数组标识 glGenVertexArrays(1, VertexArrayID); glBindVertexArray(VertexArrayID); // 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0) static const GLfloat g_vertex_buffer_data[] = { -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f }; // 创建缓存区 GLuint vertexbuffer; // 顶点缓冲区标识 glGenBuffers(1, vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL do { glClear(GL_COLOR_BUFFER_BIT); glEnableVertexAttribArray(0); // 启用顶点数组属性 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0); glDrawArrays(GL_TRIANGLES, 0, 3); // 绘制三角形 glDisableVertexAttribArray(0); // 禁用顶点数组属性 glfwSwapBuffers(window); // 交换缓冲区，更新屏幕 glfwPollEvents(); // 监听事件 } while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0); // 后处理，删除资源 glDeleteBuffers(1, vertexbuffer); glDeleteVertexArrays(1, VertexArrayID); glfwTerminate(); return 0;} 效果展示： 这个三角形是白色的，因为其并没有进行任何着色。 使用顶点着色器和片段着色器可以进行着色。 完整代码 #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hppGLuint createShadeProgram(){ // 顶点着色器 const char *vshaderSource = \"#version 460 core \" \"layout(location = 0) in vec3 vertexPosition_modelspace; \" \"void main() \" \"{ gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0; }\"; // 片段着色器 const char *fshaderSource = \"#version 460 core \" \"out vec3 color; \" \"void main() \" \"{ color = vec3(0, 0, 0.3); }\"; // OpenGL 创建每个着色器对象（初始值为空）的时候，会返回一个整数 ID 作为后面引用它的序号 // 分别存入 vShader 和 fShader 变量 GLuint vShader = glCreateShader(GL_VERTEX_SHADER); // 创建了类型为GL_VERTEX_SHADER 的着色器，即顶点着色器 GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 创建了类型为GL_FRAGMENT_SHADER 的着色器，即片段着色器 // 将 GLSL 代码从字符串载入空着色器对象中 glShaderSource(vShader, 1, vshaderSource, NULL); glShaderSource(fShader, 1, fshaderSource, NULL); // 编译着色器 glCompileShader(vShader); glCompileShader(fShader); // 创建了一个叫作 vfProgram 的程序对象并记录其ID GLuint vProgram = glCreateProgram(); // 将着色器加入程序对象 glAttachShader(vProgram, vShader); glAttachShader(vProgram, fShader); // 请求 GLSL 编译器，以确保它们的兼容性 glLinkProgram(vProgram); return vProgram; // 返回着色器程序ID}int main(){ // 初始化 GLFW if (!glfwInit()) { return -1; } glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); // 打开一个窗口并创建它的OpenGL上下文 GLFWwindow *window = glfwCreateWindow(1024, 768, \"triangle\", NULL, NULL); if (window == NULL) { glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 确保我们可以捕捉到下面按下的转义键 glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // 绿色背景 glClearColor(0.0f, 1.0f, 0.0f, 0.0f); // 初始化 GLEW if (glewInit() != GLEW_OK) { glfwTerminate(); return -1; } // 创建一个顶点数组对象，并将它设为当前对象 GLuint VertexArrayID; // 顶点数组标识 glGenVertexArrays(1, VertexArrayID); glBindVertexArray(VertexArrayID); // 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0) static const GLfloat g_vertex_buffer_data[] = { -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f }; // 创建缓存区 GLuint vertexbuffer; // 顶点缓冲区标识 glGenBuffers(1, vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL GLuint programID = createShadeProgram(); // 创建着色器 do { glClear(GL_COLOR_BUFFER_BIT); glUseProgram(programID); // 使用着色器 glEnableVertexAttribArray(0); // 启用顶点数组属性 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0); glDrawArrays(GL_TRIANGLES, 0, 3); // 绘制三角形 glDisableVertexAttribArray(0); // 禁用顶点数组属性 glfwSwapBuffers(window); // 交换缓冲区，更新屏幕 glfwPollEvents(); // 监听事件 } while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0); // 后处理，删除资源 glDeleteBuffers(1, vertexbuffer); glDeleteVertexArrays(1, VertexArrayID); glDeleteProgram(programID); glfwTerminate(); return 0;} 效果展示： 观察着色器部分的代码： 顶点着色器：所有顶点着色器的主要目标都是将顶点发送给管线。 \"#version 460 core \"\"layout(location = 0) in vec3 vertexPosition_modelspace; \"\"void main() \"\"{ gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0; }\" 第一行表示OpenGL版本，同时也使用该版本的语法，我这里是4.6.0； 第二行 layout(location = 0) 指用来赋给 vertexPosition_modelspace 这个属性的缓冲区。每个顶点能有多种属性：位置，一种或多种颜色，一个或多个纹理坐标，等等；通过将 glvertexAttribPointer 函数的第一个参数值赋给layout，就完成了这一点。参数值“0”并不重要，它可以是12（但是不大于 glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, v) ）；重要的是两边参数值保持一致 in 表示表明变量是输入变量； vec3 在GLSL中是一个三维向量； vertexPosition_modelspace 是变量名，将包含每个顶点着色器运行所需的顶点位置值。 第三行表示主函数，与C++语法相似； 第四行内置变量 gl_Position 用来设置顶点在 3D 空间中的坐标位置，并将其发送至下一个管线阶段。 片段着色器：所有片段着色器的目的都是给为要展示的像素赋予颜色。 \"#version 460 core \" \"out vec3 color; \"\"void main() \"\"{ color = vec3(0, 0, 0.3); }\" 第一行表示OpenGL版本，同时也使用该版本的语法，我这里是4.6.0； 第二行 out 标签表明 color 变量是输出变量； 第三行表示主函数，与C++语法相似； 第四行表示设置颜色RGB值。 解释 glvertexAttribPointer 函数，函数使用如下： glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0); 第一参数：指定要配置的顶点属性。在顶点着色器中使用 layout(location = 0) 定义了顶点属性的位置值，它可以把顶点属性的位置值设置为0，所以这里传入0； 第二参数：指定顶点属性的大小； 第三参数：指定数据的类型； 第四参数：是否希望数据被标准化（Normalize）； 第五参数：步长，告诉在连续的顶点属性组之间的间隔； 第六参数：数组缓冲区偏移量。 此示例中着色器代码较短，可以直接编写到程序中。但当着色器代码较为复杂时，希望能文件分开，从文件中读入着色器代码。 // 读代码函数std::string readShaderSource(const char *filePath){ std::string content = \"\"; std::ifstream fileStream(filePath, std::ios::in); std::string line = \"\"; while (!fileStream.eof()) { getline(fileStream, line); content.append(line + \" \"); } fileStream.close(); return content;} 相应地 createShadeProgram() 改成： std::string vs = readShaderSource(\"vertex.glsl\");std::string fs = readShaderSource(\"fragment.glsl\");const char *vshaderSource = vs.c_str();const char *fshaderSource = fs.c_str(); 2.3 GLSL代码检查 编译和运行 GLSL 代码的过程与普通代码的不同，GLSL 的编译发生在 C++运行时。另外一个复杂的点是 GLSL 代码并没有运行在 CPU 中（它运行在 GPU 中），因此操作系统并不总能捕获 OpenGL 运行时的错误。着色器运行时错误的常见结果是输出屏幕上完全空白，根本没有输出。 但是 GLSL 函数 glGetShaderiv() 和 glGetProgramiv() 可提供有关编译过的 GLSL 着色器和程序的信息。 设计三个函数： checkOpenGLError()：既用于检测 GLSL 代码编译错误，又用于检测 OpenGL 运行时的错误。 printShaderLog()：当 GLSL 代码编译失败时，显示 OpenGL 日志内容。 printProgramLog()：当 GLSL 链接失败时，显示 OpenGL 日志内容。 详细代码 /** 当 GLSL 代码编译失败时，显示 OpenGL 日志内容* @param shader 着色器标识*/void printShaderLog(GLuint shader){ int len = 0; int chWrittn = 0; char *log; glGetShaderiv(shader, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetShaderInfoLog(shader, len, chWrittn, log); std::cout \"Shader Info: \" log \" \"; delete[] log; }}/** 当 GLSL 链接失败时，显示 OpenGL 日志内容* @param program 着色器程序标识*/void printProgramLog(GLuint program){ int len = 0; int chWrittn = 0; char *log; glGetProgramiv(program, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetProgramInfoLog(program, len, chWrittn, log); std::cout \"Program Info: \" log \" \"; delete[] log; }}/** 检查 OpenGL 错误标志，即是否发生 OpenGL 错误*/bool checkOpenGLerror(){ bool err = false; int glErr = glGetError(); while (glErr != GL_NO_ERROR) { std::cout \"glError: \" glErr \" \"; err = true; glErr = glGetError(); } return err;} 加入错误检查，创建着色器程序代码更改为： 展开代码 GLuint createShadeProgram(){ // 记录错误信息 GLint vertCompiled, fragCompiled, linked; // 顶点着色器 std::string vs = readShaderSource(\"vertex.glsl\"); // 片段着色器 std::string fs = readShaderSource(\"fragment.glsl\"); const char *vshaderSource = vs.c_str(); const char *fshaderSource = fs.c_str(); // OpenGL 创建每个着色器对象（初始值为空）的时候，会返回一个整数 ID 作为后面引用它的序号 // 分别存入 vShader 和 fShader 变量 GLuint vShader = glCreateShader(GL_VERTEX_SHADER); // 创建了类型为GL_VERTEX_SHADER 的着色器，即顶点着色器 GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 创建了类型为GL_FRAGMENT_SHADER 的着色器，即片段着色器 // 将 GLSL 代码从字符串载入空着色器对象中 glShaderSource(vShader, 1, vshaderSource, NULL); glShaderSource(fShader, 1, fshaderSource, NULL); // 编译顶点着色器 glCompileShader(vShader); checkOpenGLerror(); glGetShaderiv(vShader, GL_COMPILE_STATUS, vertCompiled); if (vertCompiled == GL_FALSE) { std::cout \"vertex compilation failed \"; printShaderLog(vShader); } // 编译片段着色器 glCompileShader(fShader); checkOpenGLerror(); glGetShaderiv(fShader, GL_COMPILE_STATUS, fragCompiled); if (fragCompiled == GL_FALSE) { std::cout \"fragment compilation failed \"; printShaderLog(fShader); } // 创建了一个叫作 vfProgram 的程序对象并记录其ID GLuint vProgram = glCreateProgram(); // 将着色器加入程序对象 glAttachShader(vProgram, vShader); glAttachShader(vProgram, fShader); // 请求 GLSL 编译器，以确保它们的兼容性 glLinkProgram(vProgram); checkOpenGLerror(); glGetProgramiv(vProgram, GL_LINK_STATUS, linked); if (linked == GL_FALSE) { std::cout \"linking failed \"; printProgramLog(vProgram); } return vProgram; // 返回着色器程序ID} 2.4 让图像动起来 实际上，在主函数的循环中，每一次循环都会刷新一次显示。但由于显示内容相同，故看起来是静态的。 对于上面的三角形，添加上些许偏移量，则会自由移动。 效果如下： 主函数代码 int main(){ // 初始化 GLFW if (!glfwInit()) { return -1; } glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); // 打开一个窗口并创建它的OpenGL上下文 GLFWwindow *window = glfwCreateWindow(1024, 768, \"triangle\", NULL, NULL); if (window == NULL) { glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 确保我们可以捕捉到下面按下的转义键 glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // 绿色背景 glClearColor(0.0f, 1.0f, 0.0f, 0.0f); // 初始化 GLEW if (glewInit() != GLEW_OK) { glfwTerminate(); return -1; } // 创建一个顶点数组对象，并将它设为当前对象 GLuint VertexArrayID; // 顶点数组标识 glGenVertexArrays(1, VertexArrayID); glBindVertexArray(VertexArrayID); // 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0) static const GLfloat g_vertex_buffer_data[] = { -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f }; // 创建缓存区 GLuint vertexbuffer; // 顶点缓冲区标识 glGenBuffers(1, vertexbuffer); // 生成1个缓冲区，将生成的标识符放入顶点缓冲 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 把这个三角形传给OpenGL GLuint programID = createShadeProgram(); // 创建着色器 float x = 0.0f, inc = 0.001f; do { glClear(GL_COLOR_BUFFER_BIT); glUseProgram(programID); // 使用着色器 x += inc; // 移动 if (x 1.0f) inc = -0.001f; if (x -1.0f) inc = 0.001f; // 获取指向 offset 变量的指针 GLuint offsetLoc = glGetUniformLocation(programID, \"offset\"); // 将 x 的值复制给 offset glProgramUniform1f(programID, offsetLoc, x); glEnableVertexAttribArray(0); // 启用顶点数组 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 绑定缓冲区 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0); glDrawArrays(GL_TRIANGLES, 0, 3); // 绘制三角形 glDisableVertexAttribArray(0); // 禁用顶点数组 glfwSwapBuffers(window); // 交换缓冲区，更新屏幕 glfwPollEvents(); // 监听事件 } while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS and glfwWindowShouldClose(window) == 0); // 后处理，删除资源 glDeleteBuffers(1, vertexbuffer); glDeleteVertexArrays(1, VertexArrayID); glDeleteProgram(programID); glfwTerminate(); return 0;} 而顶点着色器也需要根据偏移量作修改： #version 460 coreuniform float offset;layout(location = 0) in vec3 vertexPosition_modelspace;void main(){ gl_Position = vec4(vertexPosition_modelspace.x + offset, vertexPosition_modelspace.y, vertexPosition_modelspace.z, 1.0);} 其中 uniform 表示统一变量。 三、OpenGL数学基础 3.1 坐标系 3D 空间中常常使用三个坐标轴组成的坐标系，如左手坐标系和右手坐标系。 左手坐标系：伸出左手，使得拇指、食指和中指两两垂直，则拇指指向为 x 方向，中指指向为 z 方向，食指指向为 y 方向。 右手坐标系：伸出右手，使得拇指、食指和中指两两垂直，则拇指指向为 x 方向，中指指向为 z 方向，食指指向为 y 方向。 此学习记录使用右手坐标系 3.2 点 齐次坐标：具有四个值，分别是 x 坐标、y 坐标、z 坐标、w 坐标。其中 w 总是非零值。 OpenGL 中可用 vec3 或 vec4 类表示点数据。 3.3 向量 向量表示大小和方向。它们没有特定位置。在 3D 图形学中，向量一般用空间中的单个点表示，向量的大小是原点到该点的距离，方向则是原点到该点的方向。 GLSL 和 GLM 所提供的 vec3 和 vec4 类型既能用来存储点，又能用来存储向量。 设有向量 A=(x,y,z)A=(x,y,z)A=(x,y,z) 和 向量 B=(u,v,w)B=(u,v,w)B=(u,v,w)： 向量的加法：对应位置相加 向量归一化：将长度变为1。GLM 库提供了函数 glm::normalize(vec3) A^=A∣A∣=Ax2+y2+z2\\hat{A}=\\frac A{\\vert A\\vert}=\\frac A{\\sqrt{x^2+y^2+z^2}} A^=∣A∣A​=x2+y2+z2​A​ 向量点积： A⋅B=xu+yv+zwA\\cdot B = xu+yv+zwA⋅B=xu+yv+zw。GLM 库提供了函数 glm::dot(vec3,vec3) 向量叉积： A×B=(yw−vz,uz−xw,xv−uy)A\\times B=(yw-vz, uz-xw, xv-uy)A×B=(yw−vz,uz−xw,xv−uy)。GLM 库提供了函数 glm::cross(vec3,vec3) 3.3.1 点积的应用 点积的基本应用是求两向量夹角。 cos⁡θ=V⋅W∣V∣∣W∣\\cos\\theta=\\frac{V\\cdot W}{\\vert V\\vert\\vert W\\vert} cosθ=∣V∣∣W∣V⋅W​ 求向量的大小： V⋅V\\sqrt{V\\cdot V}V⋅V​ 判断向量是否正交，若正交，则 V⋅W=0V\\cdot W=0V⋅W=0 判断向量是否平行，若平行，则 V⋅W=∣V∣∣W∣V\\cdot W=\\vert V\\vert\\vert W\\vertV⋅W=∣V∣∣W∣ 3.3.2 叉积的应用 两向量叉积的一个重要特性是，它会生成一个新的向量（法向量），新的向量正交（垂直）于之前两个向量所定义的平面。所得法向量的方向遵循右手定则，即将右手手指从 V 向 W 卷曲会使得大拇指指向法向量 R 的方向。 叉积的计算与向量顺序有关。 3.4 矩阵 矩阵式矩形的值的阵列，跟很多领域上的矩阵概念相似。 GLSL中的 mat4 数据类型便是用来存储 4 x 4 矩阵。同样 GLM 中的 mat4 类也是用来实例化并表示 4 x 4 矩阵。 比如单位矩阵是对角线值全为1，其余值都为0的矩阵。在 GLM 中，调用构造函数 glm::mat4 m(1.0f) 可以在变量 m 中生成单位矩阵。 [1000010000100001](单位矩阵)\\left[ \\begin{matrix} 1 0 0 0\\\\ 0 1 0 0\\\\ 0 0 1 0\\\\ 0 0 0 1 \\end{matrix} \\right] \\tag{单位矩阵} ⎣⎢⎢⎢⎡​1000​0100​0010​0001​⎦⎥⎥⎥⎤​(单位矩阵) 矩阵转置：矩阵的列与行交换。GLM 库和 GLSL 库都有转置函数，分别是 glm::transpose(mat4) 和 transpose(mat4)。 矩阵加法：两个矩阵对应值相加。在GLSL中，+ 作了重载，支持矩阵加法。 矩阵乘法：与线性代数中的矩阵乘法一致。 在 3D 图形学中，点与矩阵相乘通常将点视作列向量，并从右向左计算，得到点。 矩阵相乘也叫作合并。 矩阵乘法结合律 NewPoint=M1×[M2×(M3×Point)]=(M1×M2×M3)×PointNewPoint = M_1\\times[M_2\\times(M_3\\times Point)]=(M_1\\times M_2\\times M_3)\\times Point NewPoint=M1​×[M2​×(M3​×Point)]=(M1​×M2​×M3​)×Point GLSL 和 GLM 都支持 vec4 与矩阵相乘，并使用 * 操作符表示。 逆矩阵： MM−1=M−1M=单位矩阵MM^{-1}=M^{-1}M=单位矩阵MM−1=M−1M=单位矩阵，GLSL 和 GLM 都提供了 mat4.inverse() 函数。 3.5 变换矩阵 变换矩阵基于 4x4 矩阵，使用齐次坐标系，包括平移矩阵、缩放矩阵、旋转矩阵、投影矩阵和 LookAt 矩阵。 3.5.1 平移矩阵 平移矩阵 A 用于将物体从一个位置移至另一位置。 在单位矩阵的基础上，将 x、y、z 的移动量记录在 A03A_{03}A03​、A13A_{13}A13​、A23A_{23}A23​ 位置。 (X+TxY+TyZ+Tz1)=[100Tx010Ty001Tz0001](XYZ1)\\left( \\begin{matrix} X+T_x\\\\ Y+T_y\\\\ Z+T_z\\\\ 1 \\end{matrix} \\right) = \\left[ \\begin{matrix} 1 0 0 T_x\\\\ 0 1 0 T_y\\\\ 0 0 1 T_z\\\\ 0 0 0 1 \\end{matrix} \\right] \\left( \\begin{matrix} X\\\\ Y\\\\ Z\\\\ 1 \\end{matrix} \\right) ⎝⎜⎜⎜⎛​X+Tx​Y+Ty​Z+Tz​1​⎠⎟⎟⎟⎞​=⎣⎢⎢⎢⎡​1000​0100​0010​Tx​Ty​Tz​1​⎦⎥⎥⎥⎤​⎝⎜⎜⎜⎛​XYZ1​⎠⎟⎟⎟⎞​ 结果就是点 (X,Y,Z)(X,Y,Z)(X,Y,Z) 平移到位置 (X+Tx,Y+Ty,Z+Tz)(X+T_x,Y+T_y,Z+T_z)(X+Tx​,Y+Ty​,Z+Tz​) 平移矩阵的构建可以使用 GLM 中 glm::translate(x,y,z) 函数。接着矩阵与点相乘。 3.5.2 缩放矩阵 缩放矩阵用于改变物体的大小或者将点沿朝向或远离原点的方向移动。 缩放矩阵 A 在单位矩阵的基础上，将位于 A00A_{00}A00​，A11A_{11}A11​， A22A_{22}A22​ 的值替换为 x、y、z 缩放因子。 (XSxYSyZSz1)=[Sx0000Sy0000Sz00001](XYZ1)\\left( \\begin{matrix} X\\ S_x\\\\ Y\\ S_y\\\\ Z\\ S_z\\\\ 1 \\end{matrix} \\right) = \\left[ \\begin{matrix} S_x 0 0 0\\\\ 0 S_y 0 0\\\\ 0 0 S_z 0\\\\ 0 0 0 1 \\end{matrix} \\right] \\left( \\begin{matrix} X\\\\ Y\\\\ Z\\\\ 1 \\end{matrix} \\right) ⎝⎜⎜⎜⎛​XSx​YSy​ZSz​1​⎠⎟⎟⎟⎞​=⎣⎢⎢⎢⎡​Sx​000​0Sy​00​00Sz​0​0001​⎦⎥⎥⎥⎤​⎝⎜⎜⎜⎛​XYZ1​⎠⎟⎟⎟⎞​ GLM 的 glm::scale(x,y,z) 函数用于构建依照 (x,y,z)(x,y,z)(x,y,z) 缩放的矩阵，接着矩阵与点相乘。 缩放还可以用来切换坐标系，比如在右手坐标系下确定左手坐标系的坐标，只需把 z 坐标反转即可。切换坐标系的缩放矩阵： [1000010000−100001]\\left[ \\begin{matrix} 1 0 0 0\\\\ 0 1 0 0\\\\ 0 0 -1 0\\\\ 0 0 0 1 \\end{matrix} \\right] ⎣⎢⎢⎢⎡​1000​0100​00−10​0001​⎦⎥⎥⎥⎤​ 3.5.3 旋转矩阵 3D 空间中旋转物体需要指定旋转轴和旋转角（以度或弧度为单位）。 数学上可证明：围绕任何轴的旋转都可以表示为绕 x 轴、y 轴、z 轴旋转的组合。围绕这 3 个轴的旋转角度被称为欧拉角。 (XY′Z′1)=[10000cos⁡θ−sin⁡θ00sin⁡θcos⁡θ00001](XYZ1)(绕x轴旋转)\\left(\\begin{matrix}X \\\\ Y'\\\\ Z'\\\\ 1\\end{matrix}\\right)=\\left[\\begin{matrix}1 0 0 0\\\\ 0 \\cos\\theta -\\sin\\theta 0\\\\ 0 \\sin\\theta \\cos\\theta 0\\\\ 0 0 0 1\\end{matrix}\\right]\\left(\\begin{matrix}X\\\\ Y\\\\ Z\\\\ 1\\end{matrix}\\right)\\tag{绕x轴旋转} ⎝⎜⎜⎜⎛​XY′Z′1​⎠⎟⎟⎟⎞​=⎣⎢⎢⎢⎡​1000​0cosθsinθ0​0−sinθcosθ0​0001​⎦⎥⎥⎥⎤​⎝⎜⎜⎜⎛​XYZ1​⎠⎟⎟⎟⎞​(绕x轴旋转) (X′YZ′1)=[cos⁡θ0sin⁡θ00100−sin⁡θ0cos⁡θ00001](XYZ1)(绕y轴旋转)\\left(\\begin{matrix}X' \\\\ Y\\\\ Z'\\\\ 1\\end{matrix}\\right)=\\left[\\begin{matrix}\\cos\\theta 0 \\sin\\theta 0\\\\ 0 1 0 0\\\\ -\\sin\\theta 0 \\cos\\theta 0\\\\ 0 0 0 1\\end{matrix}\\right]\\left(\\begin{matrix}X\\\\ Y\\\\ Z\\\\ 1\\end{matrix}\\right)\\tag{绕y轴旋转} ⎝⎜⎜⎜⎛​X′YZ′1​⎠⎟⎟⎟⎞​=⎣⎢⎢⎢⎡​cosθ0−sinθ0​0100​sinθ0cosθ0​0001​⎦⎥⎥⎥⎤​⎝⎜⎜⎜⎛​XYZ1​⎠⎟⎟⎟⎞​(绕y轴旋转) (X′Y′Z1)=[cos⁡θ−sin⁡θ00sin⁡θcos⁡θ0000100001](XYZ1)(绕z轴旋转)\\left(\\begin{matrix}X' \\\\ Y'\\\\ Z\\\\ 1\\end{matrix}\\right)=\\left[\\begin{matrix}\\cos\\theta -\\sin\\theta 0 0\\\\ \\sin\\theta \\cos\\theta 0 0\\\\ 0 0 1 0\\\\ 0 0 0 1\\end{matrix}\\right]\\left(\\begin{matrix}X\\\\ Y\\\\ Z\\\\ 1\\end{matrix}\\right)\\tag{绕z轴旋转} ⎝⎜⎜⎜⎛​X′Y′Z1​⎠⎟⎟⎟⎞​=⎣⎢⎢⎢⎡​cosθsinθ00​−sinθcosθ00​0010​0001​⎦⎥⎥⎥⎤​⎝⎜⎜⎜⎛​XYZ1​⎠⎟⎟⎟⎞​(绕z轴旋转) 旋转变换有 3 种，分别是绕 x 轴、y 轴、z 轴旋转。GLM 提供了函数 glm::rotate(mat4,θ,x,y,z) 构建绕 (x,y,z)(x,y,z)(x,y,z) 旋转 θ\\thetaθ 度的矩阵，接着矩阵与点相乘。 通过 cos⁡(−θ)=cos⁡(θ)\\cos(−θ) = \\cos(θ)cos(−θ)=cos(θ) 和 sin⁡(−θ)=−sin⁡(θ)\\sin(−θ) = −\\sin(θ)sin(−θ)=−sin(θ) 即可验证反向旋转的矩阵恰等于其转置矩阵。 当在 3D 空间中旋转轴不穿过原点时，物体使用欧拉角进行旋转需要几个额外的步骤。一般有： 平移旋转轴以使它经过原点； 绕 x 轴、y 轴、z 轴旋转适当的欧拉角； 复原步骤 1 中的平移。 3.6 视觉空间和合成相机 3D 空间中，需要找到一点并确立观察方向，这个点叫作视图或视觉空间或合成相机。 观察 3D 世界需要以下步骤 确定相机的位置； 调整相机的角度，通常需要一套它自己的直角坐标轴u、v、n； 定义一个视体。视体是从相机的位置出发，沿着相机的视线朝向的可视范围。 将视体内的对象投影到投影平面上。 OpenGL 具有一个固定在原点 (0,0,0)(0,0,0)(0,0,0) 且朝向 z 轴负方向的相机。所以当使用这个相机时，由于相机自身不能移动，所以需要将对象移动到适合的位置并调整合适的方向。 假设有世界空间（类似于全局的空间）中某点 PWP_WPW​，需要对该点进行变换转换成相机空间中适合的点 PCP_CPC​。构建一个单一变换矩阵以完成旋转和平移，这个矩阵叫作视图变换矩阵，记作 V（V合并了平移矩阵和旋转矩阵）。 PC=V×PWP_C=V\\times P_W PC​=V×PW​ 将 V 矩阵与模型矩阵 M 的积定义为 模型-视图(Model-View, MV) 矩阵，记作MV，MV=VMMV=VMMV=VM。 模型矩阵 M 是世界空间中对象定位及定向的矩阵 之后，对于某点 PMP_MPM​ 就可以从自己的模型空间直接转换到相机空间： PC=MVPMP_C=MVP_M PC​=MVPM​ 3.7 投影矩阵 透视投影矩阵和正射投影矩阵 3.7.1 透视投影矩阵 透视投影通过使用透视概念模仿我们看真实世界的方 式，尝试让 2D 图像看起来像是 3D 的。 使用叫作 透视矩阵 或者 透视变换 的变换矩阵将平行线变为恰当的不平行线来实现这个效果。定义 4 个参数来构建视体： 纵横比：远近剪裁平面的宽度与高度之比； 视场：可视空间的纵向角度； 近剪裁平面（也称投影平面） 远剪裁平面。 透视矩阵： [A0000q0000BC00−10](透视矩阵)\\left[ \\begin{matrix} A 0 0 0\\\\ 0 q 0 0\\\\ 0 0 B C\\\\ 0 0 -1 0 \\end{matrix} \\right] \\tag{透视矩阵} ⎣⎢⎢⎢⎡​A000​0q00​00B−1​00C0​⎦⎥⎥⎥⎤​(透视矩阵) 其中： q=1tan⁡(视场2)q = \\frac{1}{\\tan{(\\frac{视场}{2})}} q=tan(2视场​)1​ A=q纵横比A = \\frac{q}{纵横比} A=纵横比q​ B=Znear+ZfarZnead−ZfarB = \\frac{Z_{near}+Z_{far}}{Z_{nead}-Z_{far}} B=Znead​−Zfar​Znear​+Zfar​​ C=2ZnearZfarZnear−ZfarC = \\frac{2Z_{near}Z_{far}}{Z_{near}-Z_{far}}{} C=Znear​−Zfar​2Znear​Zfar​​ GLM 库提供了构建透视矩阵函数 glm::perspective()。 3.7.2 正射投影矩阵 在正射投影中，平行线仍然是平行的。 构建正射矩阵需要以下参数： 从相机到投影平面的距离 znearz_{near}znear​ 从相机到远剪裁平面的距离 zfarz_{far}zfar​ 投影平面左边界 x 坐标 L， 投影平面右边界 x 坐标 R，投影平面上边界 y 坐标 T， 投影平面下边界 y 坐标 B 正射矩阵： [2R−L00−R+LR−L02T−B0−T+BT−B00−2zfar−znear−zfar+znearzfar−znear0001](正射矩阵)\\left[ \\begin{matrix} \\frac{2}{R-L} 0 0 -\\frac{R+L}{R-L}\\\\ 0 \\frac{2}{T-B} 0 -\\frac{T+B}{T-B}\\\\ 0 0 \\frac{-2}{z_{far}-z_{near}} -\\frac{z_{far}+z_{near}}{z_{far}-z_{near}}\\\\ 0 0 0 1 \\end{matrix} \\right] \\tag{正射矩阵} ⎣⎢⎢⎢⎡​R−L2​000​0T−B2​00​00zfar​−znear​−2​0​−R−LR+L​−T−BT+B​−zfar​−znear​zfar​+znear​​1​⎦⎥⎥⎥⎤​(正射矩阵) 3.8 LookAt矩阵 当把相机放在某处并看向一个特定的位置时，就需要用到 LookAt 矩阵。LookAt 变换依然由相机旋转决定。 通过指定大致旋转朝向的向量（如世界空间 y 轴）。可以通过一系列叉积获得一组向量，代表相机的正面（向量 fwd）、侧面（向量 side），以及上面（向量 up）。 由相机位置（点eye）、目标位置（点target）、初始向上向量 Y 构建 LookAt 矩阵： [sidexsideysizez−(side⋅eye)upxupyupz−(up⋅eye)−fwdx−fwdy−fwdz−(−fwd⋅eye)0001](LookAt矩阵)\\left[ \\begin{matrix} side_x side_y size_z -(side\\cdot eye)\\\\ up_x up_y up_z -(up\\cdot eye)\\\\ -fwd_x -fwd_y -fwd_z -(-fwd\\cdot eye)\\\\ 0 0 0 1 \\end{matrix} \\right] \\tag{LookAt矩阵} ⎣⎢⎢⎢⎡​sidex​upx​−fwdx​0​sidey​upy​−fwdy​0​sizez​upz​−fwdz​0​−(side⋅eye)−(up⋅eye)−(−fwd⋅eye)1​⎦⎥⎥⎥⎤​(LookAt矩阵) 其中： fwd=normalize(eye−target)fwd = normalize(eye-target) fwd=normalize(eye−target) side=normalize(−fwd×Y)side = normalize(-fwd \\times Y) side=normalize(−fwd×Y) up=normalize(side×(−fwd))up = normalize(side \\times (-fwd)) up=normalize(side×(−fwd)) 四、OpenGL管理3D图形数据 使用 OpenGL 渲染一个 3D 图形 需要将若干数据发送给 OpenGL 着色器管线。 比如一个立方体，需要发送： 立方体模型的顶点； 控制立方体在3D空间中朝向的变换矩阵。 然而，发送数据到 OpenGL 管线的方式有： 通过顶点属性的 缓冲区； 直接发送给 统一变量。 4.1 缓冲区和顶点属性 绘制对象时，它的顶点数据需要发送给顶点着色器。通常： 顶点数据被发送到一个缓冲区中； 把缓冲区和着色器中声明的顶点属性相关联。 完成这件事，有一系列的步骤，有的步骤只需要做一次，有的步骤每帧都需做一次： 只做一次的步骤： 创建缓冲区 将顶点数据复制到缓冲区 每帧刷新需要的步骤： 启用包含顶点数据的缓冲区 将缓冲区和一个顶点属性相关联 启用这个顶点属性 使用 glDrawArrays() 绘制对象 在 OpenGL 中，缓冲区被包含在顶点缓冲对象（Vertex Buffer Object，VBO）中，VBO 在 C++/OpenGL 应用程序中被声明和实例化。一个场景可能需要很多 VBO，所以常常会在一个地方中生成并填充若干个 VBO，以备程序需要时直接使用。 缓冲区使用特定的方式和顶点属性交互。当 glDrawArrays() 执行时，缓冲区中的数据开始流动，从缓冲区的开头开始，按顺序流过顶点着色器，顶点着色器对每个顶点执行一次。 OpenGL 中还有一种相关的结构，叫作顶点数组对象（Vertex Array Object，VAO）。OpenGL的 3.0 版本引入了 VAO，作为一种组织缓冲区的方法，让缓冲区在复杂场景中更容易操控。OpenGL 要求至少创建一个 VAO。 举个例子，假设想显示两个对象，那么声明一个 VAO 和两个相关的 VBO： GLuint vao[1];GLuint vbo[2];// ……glGenVertexArrays(1, vao);glBindVertexArray(vao[0]);glGenBuffers(2, vbo); glGenVertexArrays()：生成一个 VAO，返回 VAO 的整型 ID 并将存到vao 第一参数表示创建 ID 个数 第二参数表示保存返回 ID 的数组 glBindVertexArray()：将 vao[0] 设为当前对象，这样生成的缓冲区就会和这个 VAO 相关联 glGenBuffers()：生成两个 VBO，返回 VBO 的整型 ID 并将它们存到vbo 第一参数表示创建 ID 个数 第二参数表示保存返回 ID 的数组 缓冲区大概完成之后，顶点着色器需要有相应地顶点属性变量。如： layout (location = 0) in vec3 position; layout (location = 0)：layout修饰符，顶点属性和特定缓冲区关联的方法，这里表示顶点属性的识别号是0 in：表示顶点属性将会从缓冲区中接收数值 vec3：表示顶点属性的类型是三维向量 position：顶点属性的名字 继续假设绘制一个立方体，假定立方体的顶点数据在代码中用数组直接指定，还需要进行以下步骤： 将顶点数据值复制到之前生成的两个缓冲区之一。使用 OpenGL 的函数 glBindBuffer() 将缓冲区标为活跃（使用） 使用 glBufferData() 函数将包含顶点数据的数组复制进活跃缓冲区 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 上述是初始化时执行一次的步骤，接下来对于每一帧刷新，需要进行： 使用 glBindBuffer() 函数标记缓冲区为活跃 将活跃缓冲区与着色器中的顶点属性相关联 启用顶点属性 // 标记第0个缓冲区为活跃glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);// 将第0个属性关联到缓冲区glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);// 启用第0个顶点属性glEnableVertexAttribArray(0); 4.2 统一变量 使用关键字 uniform 在着色器中声明统一变量。 将数据从 C++/OpenGL 应用程序发送到统一变量需要以下步骤： 获取统一变量的引用 将指向所需数值的指针与获取的统一变量引用相关联 比如在上面绘制立方体的例子，假设链接的渲染程序保存在名为 rendering 的变量中，则以下代码会把 MV 和投影矩阵发送到两个统一变量中： // 获取着色器程序中的统一变量位置mvLoc = glGetUniformLocation(rendering, \"mv_m\");projLoc = glGetUniformLocation(rendering, \"proj_m\");// 将矩阵数据发送到统一变量中glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mv));glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(proj));// mv 是模型视图矩阵，proj 是投影矩阵 value_ptr() 返回对矩阵数据的引用， glUniformMatrix4fv() 将矩阵数据传递给统一变量 4.3 顶点属性插值 在片段着色器栅格化之前，由顶点定义的图元被转换为片段。 栅格化：将 3D 空间信息表达在 2D 屏幕的栅格（像素阵列）中。 栅格化过程会线性插值顶点属性值，以便显示的像素能无缝连接建模后的曲面。 比如栅格化一个三角形时，将三角形顶点传入，首先沿着连接顶点的线开始插值，其精度级别和像素显示密度相关。 而统一变量在每次顶点着色器调用时保持不变，本身不是插值的，无论顶点数量有多少，变量都包含相同的值。 顶点着色器中，顶点属性被声明为 in，表示从缓冲区接收，也可以被声明为 out，表示值发送到管线的下一阶段。 OpenGL 内置一个 vec4 变量 gl_Position，在顶点着色器中，将矩阵变换后的顶点赋值给它： gl_Position = proj_matrix * mv_matrix * position; 4.4 MV 矩阵和透视矩阵 渲染 3D 对象的一个基础步骤是创建适当的变换矩阵并将它们发送到统一变量。 模型矩阵：在世界空间中表示对象的位置和朝向。 视图矩阵：移动并旋转世界中的模型，以模拟相机看到的效果。 透视矩阵：根据所需的视锥提供 3D 效果。 假设模型是变动的，相机是可移动的，那么： 需要每帧为每个模型创建模型矩阵； 需要每帧创建视图矩阵，对于这一帧所渲染的所有对象都是一致的； 需要创建一次透视矩阵，确定视锥。 4.5 构建一个 3D 立方体 由于 OpenGL 代码繁多，需要处理多文件，给出文件结构： OpenGL项目├─ main.cpp // 主程序├─ fragment.glsl // 片段着色器├─ vertex.glsl // 顶点着色器├─ Util.h // 常用函数的声明└─ Util.cpp // 常用函数的实现 效果展示： 源代码main.cpp // main.cpp#include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 1;GLuint vao[numVAO], vbo[numVBO];double cameraX, cameraY, cameraZ;double cubeLocX, cubeLocY, cubeLocZ;float aspect;GLuint mvLoc, projLoc;int width, height;glm::mat4 pMat, vMat, mMat, mvMat;void makeVertexArray(){ float vertexs[108] = { -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f }; glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联 glGenBuffers(numVBO, vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // 将缓冲区标为活跃（使用） // 将包含顶点数据的数组复制进活跃缓冲区 glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 8.0f; cubeLocX = 0.0f, cubeLocY = -2.0f, cubeLocZ = 0.0f; // 沿 y 轴下移展示透视 makeVertexArray();}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glUseProgram(renderProgram); // 获取 MV 矩阵 和投影矩阵的统一变量 mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); // 构建透视矩阵 glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 100.0f); // 参数为：视角，宽高比，近裁剪面，远裁剪面 // 构建视图矩阵、模型矩阵和 MV 矩阵 vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ)); mvMat = vMat * mMat; // 将矩阵复制给相应的统一变量 glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); // 将 VBO 关联给顶点着色器中相应的顶点属性 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); // 调整 OpenGL 设置，绘制模型 glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 36);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Cube\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 解释 main.cpp： 函数 makeVertexArray() 创建顶点数组，使用三角形绘制立方体，每个面需要两个三角形，共需要12个三角形，有36个顶点，合36×3=108个坐标（值）。 立方体定义在自己的坐标系上，中心为(0,0,0)。 建立一个 VAO 和 VBO，并把立方体顶点加载到VBO中。 函数 init() 读取着色器代码并构建渲染程序。 将立方体通过函数 makeVertexArray() 加载到 VBO 中。 定义立方体和相机在世界中的位置：(0,0,8)和(0,-2,0)。 函数 display() 不断重绘帧。 调用 glClear(GL_DEPTH_BUFFER_BIT) 清除深度缓冲区。 调用 glUseProgram() 启用着色器，在 GPU 上加载 GLSL 代码，但不会运行着色器程序。 获取统一变量位置，构建透视、视图矩阵和模型矩阵，并合成 MV 矩阵。 使用 glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); 构建视图矩阵。为了模拟以某种方式移动的相机的表现，需要向相反的方向移动物体本身。 使用 glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ)); 构建模型矩阵。 将透视矩阵和 MV 矩阵赋给相应的统一变量。 启用立方体顶点数据的缓冲区，并将其附加到第0个顶点属性。 调用 glDrawArrays() 绘制模型。 Util.h // Util.h#pragma once#include GL/glew.h#include GLFW/glfw3.h#include SOIL2/soil2.h#include glm/glm.hpp#include glm/gtc/type_ptr.hpp#include string#include iostream#include fstream#include cmath#include vectorclass Util{public: static std::string readShaderSource(const std::string path); static void printShaderLog(GLuint shader); static void printProgramLog(GLuint program); static bool checkOpenGLerror(); static GLuint createShadeProgram(const std::string vpath, const std::string fpath);}; Util.cpp // Util.cpp#include \"Util.h\"/** 从文件中读取 GLSL 代码* @param path 文件路径*/std::string Util::readShaderSource(const std::string path){ std::string content = \"\"; std::ifstream fileStream(path, std::ios::in); std::string line = \"\"; while (!fileStream.eof()) { getline(fileStream, line); content.append(line + \" \"); } fileStream.close(); return content;}/** 当 GLSL 代码编译失败时，显示 OpenGL 日志内容* @param shader 着色器标识*/void Util::printShaderLog(GLuint shader){ int len = 0; int chWrittn = 0; char *log; glGetShaderiv(shader, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetShaderInfoLog(shader, len, chWrittn, log); std::cout \"Shader Info: \" log \" \"; delete[] log; }}/** 当 GLSL 链接失败时，显示 OpenGL 日志内容* @param program 着色器程序标识*/void Util::printProgramLog(GLuint program){ int len = 0; int chWrittn = 0; char *log; glGetProgramiv(program, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetProgramInfoLog(program, len, chWrittn, log); std::cout \"Program Info: \" log \" \"; delete[] log; }}/** 检查 OpenGL 错误标志，即是否发生 OpenGL 错误*/bool Util::checkOpenGLerror(){ bool err = false; int glErr = glGetError(); while (glErr != GL_NO_ERROR) { std::cout \"glError: \" glErr \" \"; err = true; glErr = glGetError(); } return err;}/** 创建着色器程序* @param vpath 顶点着色器路径* @param fpath 片段着色器路径*/GLuint Util::createShadeProgram(const std::string vpath, const std::string fpath){ // 记录错误信息 GLint vertCompiled, fragCompiled, linked; // 顶点着色器 std::string vs = readShaderSource(vpath); // 片段着色器 std::string fs = readShaderSource(fpath); const char *vshaderSource = vs.c_str(); const char *fshaderSource = fs.c_str(); // 分别存入 vShader 和 fShader 变量 GLuint vShader = glCreateShader(GL_VERTEX_SHADER); GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 将 GLSL 代码从字符串载入空着色器对象中 glShaderSource(vShader, 1, vshaderSource, NULL); glShaderSource(fShader, 1, fshaderSource, NULL); // 编译顶点着色器 glCompileShader(vShader); checkOpenGLerror(); glGetShaderiv(vShader, GL_COMPILE_STATUS, vertCompiled); if (vertCompiled == GL_FALSE) { std::cout \"vertex compilation failed \"; printShaderLog(vShader); } // 编译片段着色器 glCompileShader(fShader); checkOpenGLerror(); glGetShaderiv(fShader, GL_COMPILE_STATUS, fragCompiled); if (fragCompiled == GL_FALSE) { std::cout \"fragment compilation failed \"; printShaderLog(fShader); } GLuint vProgram = glCreateProgram(); glAttachShader(vProgram, vShader); glAttachShader(vProgram, fShader); glLinkProgram(vProgram); checkOpenGLerror(); glGetProgramiv(vProgram, GL_LINK_STATUS, linked); if (linked == GL_FALSE) { std::cout \"linking failed \"; printProgramLog(vProgram); } return vProgram; // 返回着色器程序ID} vertex.glsl 和 fragment.glsl // vertex.glsl#version 460 corelayout(location = 0) in vec3 position;uniform mat4 mv_matrix;uniform mat4 proj_matrix;void main(){ gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);} // fragment.glsl#version 460 coreout vec4 color;uniform mat4 mv_matrix;uniform mat4 proj_matrix;void main(){ color = vec4(0, 0.6, 0, 1.0);} 关于着色器方面 着色器中传入的顶点属性的 position 变量上存在。layout 修饰符，位置指定为“0”，因此 display() 函数可以简单地通过在 glVertexAttribPointer() 函数调用中（第一个参数）和在 glEnableVertexAttribArray() 函数调用中使用 0 来引用此变量。 position 顶点属性被声明为 vec3 类型，需要将其转换为 vec4 类型，由 vec4(position,1.0) 完成。 顶点着色器中的乘法将矩阵变换应用于顶点，将其转换为相机空间，接着被放入内置的 OpenGL 输出变量 gl_Position 中，然后继续通过管线，并由光栅着色器进行插值。 插值后的像素位置（称为片段）被发送到片段着色器。 片段着色器中也有两个统一变量，但在该着色器中尚未使用。 通过修改着色器，实现彩色立方体 // vertex.glsl#version 460 corelayout(location = 0) in vec3 position;uniform mat4 mv_matrix;uniform mat4 proj_matrix;out vec4 changingColor;void main(){ gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0); changingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);} // fragment.glsl#version 460 corein vec4 changingColor;out vec4 color;uniform mat4 mv_matrix;uniform mat4 proj_matrix;void main(){ color = changingColor;} 效果展示： 同样地，也可以让立方体动起来，只需要在刷新的每一帧加上平移变换和旋转变换： 展开代码 // ……void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); // 获取 MV 矩阵 和投影矩阵的统一变量 mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); // 构建透视矩阵 glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 100.0f); // 参数为：视角，宽高比，近裁剪面，远裁剪面 // 一系列旋转变换矩阵 glm::mat tMat = glm::translate(glm::mat4(1.0f), glm::vec3(sin(0.35f * currentTime) * 2.0f, cos(0.52f * currentTime) * 2.0f, sin(0.7f * currentTime) * 2.0f)); glm::mat rMat = glm::rotate(glm::mat4(1.0f), 1.75f * static_castfloat(currentTime), glm::vec3(0.0f, 1.0f, 0.0f)); rMat = glm::rotate(rMat, 1.75f * static_castfloat(currentTime), glm::vec3(1.0f, 0.0f, 0.0f)); rMat = glm::rotate(rMat, 1.75f * static_castfloat(currentTime), glm::vec3(0.0f, 0.0f, 1.0f)); // 构建视图矩阵、模型矩阵和 MV 矩阵 vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); //mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ)); mMat = rMat * tMat; mvMat = vMat * mMat; // 将矩阵复制给相应的统一变量 glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); // 将 VBO 关联给顶点着色器中相应的顶点属性 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); // 调整 OpenGL 设置，绘制模型 glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 36);}// …… 效果展示： 4.6 渲染一个对象的多个副本 上面实现了一个翻滚的立方体，接着可以考虑实现多个翻滚的立方体。 可以将 display() 函数中用于构建 MV 矩阵并绘制立方体的代码移动到一个执行 24 次的循环中来完成此操作。 展开代码 void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 32.0f; makeVertexArray();}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); // 获取 MV 矩阵 和投影矩阵的统一变量 mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); // 视图矩阵 vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); // 构建透视矩阵 glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 100.0f); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); // 参数为：视角，宽高比，近裁剪面，远裁剪面 float tf; glm::mat4 tMat, rMat; for (int i = 0; i 24; i ++) { tf = currentTime + i; tMat = glm::translate(glm::mat4(1.0f), glm::vec3(sin(0.35f * tf) * 8.0f, cos(0.52f * tf) * 8.0f, sin(0.7f * tf) * 8.0f)); rMat = glm::rotate(glm::mat4(1.0f), 1.75f * tf, glm::vec3(0.0f, 1.0f, 0.0f)); rMat = glm::rotate(rMat, 1.75f * tf, glm::vec3(1.0f, 0.0f, 0.0f)); rMat = glm::rotate(rMat, 1.75f * tf, glm::vec3(0.0f, 0.0f, 1.0f)); // 构建模型矩阵和 MV 矩阵 mMat = rMat * tMat; mvMat = vMat * mMat; // 将矩阵复制给相应的统一变量 glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); // 将 VBO 关联给顶点着色器中相应的顶点属性 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); // 调整 OpenGL 设置，绘制模型 glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 36); }} OpenGL 的实例化提供了一种机制，可以只用一个调用就渲染一个对象的多个副本。 带来显著的性能优势 把原来调用的 glDrawArrays() 改为 glDrawArraysInstanced()。 同时实例化时，顶点着色器可以访问内置变量 gl_InstanceID 来获取当前正在处理对象的实例序号。 实例化的程序： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 1;GLuint vao[numVAO], vbo[numVBO];double cameraX, cameraY, cameraZ;float aspect, timeFactor;GLuint mLoc, vLoc, projLoc, tfLoc;int width, height;glm::mat4 pMat, vMat, mMat;void makeVertexArray(){ float vertexs[108] = { -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f }; glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联 glGenBuffers(numVBO, vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // 将缓冲区标为活跃（使用） // 将包含顶点数据的数组复制进活跃缓冲区 glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);}void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 32.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray();}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); // 获取视图矩阵和投影矩阵的统一变量 vLoc = glGetUniformLocation(renderProgram, \"v_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); glUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(vMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); // 获取时间因子的统一变量 timeFactor = static_castfloat(currentTime); tfLoc = glGetUniformLocation(renderProgram, \"tf\"); glUniform1f(tfLoc, timeFactor); // 将 VBO 关联给顶点着色器中相应的顶点属性 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); // 实例化 glDrawArraysInstanced(GL_TRIANGLES, 0, 36, 24);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Cube\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 从之前的循环多个模型矩阵展示 改为了 在顶点着色器中构建模型矩阵。 将时间因子通过统一变量传递给顶点着色器，还需要将视图矩阵传递到单独的统一变量中 旋转计算被移动到了顶点着色器中 顶点着色器和片段着色器 // vertex.glsl#version 460 corelayout(location = 0) in vec3 position;uniform mat4 v_matrix;uniform mat4 proj_matrix;uniform float tf;out vec4 changingColor;mat4 buildRotateX(float rad){ mat4 xrot = mat4( 1.0, 0.0, 0.0, 0.0, 0.0, cos(rad), -sin(rad), 0.0, 0.0, sin(rad), cos(rad), 0.0, 0.0, 0.0, 0.0, 1.0); return xrot;}mat4 buildRotateY(float rad){ mat4 yrot = mat4( cos(rad), 0.0, sin(rad), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(rad), 0.0, cos(rad), 0.0, 0.0, 0.0, 0.0, 1.0); return yrot;}mat4 buildRotateZ(float rad){ mat4 zrot = mat4( cos(rad), -sin(rad), 0.0, 0.0, sin(rad), cos(rad), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); return zrot;}mat4 buildTranslate(float x, float y, float z){ mat4 trans = mat4( 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0); return trans;}void main(){ float i = gl_InstanceID + tf; float a = sin(0.35 * i) * 8.0; float b = cos(0.52 * i) * 8.0; float c = sin(0.70 * i) * 8.0; mat4 localRotx = buildRotateX(1.75 * i); mat4 localRoty = buildRotateY(1.75 * i); mat4 localRotz = buildRotateZ(1.75 * i); mat4 localTrans = buildTranslate(a, b, c); mat4 newM_matrix = localTrans * localRotx * localRoty * localRotz; mat4 mv_matrix = v_matrix * newM_matrix; gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0); changingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);} 由于着色器内部无法调用 GLM 的函数，故需要编写矩阵变换的相关函数。 // fragment.glsl#version 460 corein vec4 changingColor;out vec4 color;uniform mat4 proj_matrix;void main(){ color = changingColor;} 片段着色器无需做改变。 如果渲染的立方体很多时，实例化极大的方便了程序的编写，只需要修改视野相关的常量： 比如想渲染 100000 个彩色立方体，只需修改： // main.cpp// 实例化个数glDrawArraysInstanced(GL_TRIANGLES, 0, 36, 100000); // main.cpp// 镜头位置，镜头拉远cameraX = 0.0f, cameraY = 0.0f, cameraZ = 402.0f; // vertex.glsl// 位移变大float a = sin(203.0 * i / 8000.0) * 403.0;float b = cos(301.0 * i / 4001.0) * 401.0;float c = sin(400.0 * i / 6003.0) * 405.0; 4.7 同一场景渲染多个对象 要在单个场景中渲染多个模型，简单的做法： 为每个模型使用单独的缓冲区； 每个模型都需要自己的模型矩阵，为渲染的每个模型生成一个新的 MV 矩阵； 为每个模型单独调用 glDrawArrays()。 假如在场景中渲染立方体和四棱锥，且不考虑复杂的情况，复用着色器，效果如下图： 代码如下（自主研究，不过多解释）： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 2;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;float cubeLocx, cubeLocy, cubeLocz;float pyramidLocx, pyramidLocy, pyramidLocz;GLuint mvLoc, projLoc;glm::mat4 pMat, vMat, mMat, mvMat;void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){ float vertexs[108] = { -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f }; float pyramids[54] = { -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f }; glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联 glGenBuffers(numVBO, vbo); // 立方体与缓冲区0绑定 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW); // 四棱锥与缓冲区1绑定 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, sizeof(pyramids), pyramids, GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 8.0f; cubeLocx = 0.0f, cubeLocy = -2.0f, cubeLocz = 0.0f; pyramidLocx = 0.0f, pyramidLocy = 1.0f, pyramidLocz = 0.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray();}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); // 获取视图矩阵和投影矩阵的统一变量 mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); // 绘画立方体 mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocx, cubeLocy, cubeLocz)); mMat *= glm::rotate(glm::mat4(1.0f), static_castfloat(currentTime), glm::vec3(0.25f, 1.0f, 0.0f)); mvMat = vMat * mMat; glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glEnable(GL_DEPTH_TEST); glDrawArrays(GL_TRIANGLES, 0, 36); // 绘画四棱锥 mMat = glm::translate(glm::mat4(1.0f), glm::vec3(pyramidLocx, pyramidLocy, pyramidLocz)); mMat *= glm::rotate(glm::mat4(1.0f), static_castfloat(currentTime), glm::vec3(0.25f, 1.0f, 0.0f)); mvMat = vMat * mMat; glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glEnable(GL_DEPTH_TEST); glDrawArrays(GL_TRIANGLES, 0, 18);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Cube\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 顶点着色器和片段着色器 // 顶点着色器#version 460 corelayout(location = 0) in vec3 position;uniform mat4 mv_matrix;uniform mat4 proj_matrix;out vec4 changingColor;void main(){ gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0); changingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);} // 片段着色器#version 460 corein vec4 changingColor;out vec4 color;uniform mat4 proj_matrix;void main(){ color = changingColor;} 4.8 矩阵栈 前面渲染的模型都是由一组顶点构成，而实际上希望通过组装许多简单地模型来构建复杂的模型。以这种方式构建的对象称为分层模型。 构建分层模型的棘手部分是跟踪所有 MV 矩阵并保证矩阵完美协调。 矩阵栈：变换矩阵的栈。 使得创建和管理复杂分层对象和场景变得容易 使得变换可以构建在其他变换之上 通过 STL 的 stack 类构建 mat4 的栈。 对于 std::stackglm::mat4 的实例 s： s.push(mat4)：将栈顶的矩阵复制一份，并作变换后把新的矩阵压入栈。 s.pop()：弹出栈顶的矩阵。 s.top()：返回栈顶的矩阵的引用。 s.top() *= rotate(args)：直接对栈顶矩阵作旋转变换。 s.top() *= translate(args)：直接对栈顶矩阵作平移变换。 s.top() *= scale(args)：直接对栈顶矩阵作缩放变换。 在此之后，不再通过创建 mat4 的实例来构建变换，而是使用 push() 命令在栈顶部创建新的矩阵，然后根据需要将期望的变换应用于栈顶部的新创建的矩阵。 压入栈的第一个矩阵通常是视图矩阵。它上面的矩阵是复杂程度越来越高的 MV 矩阵，也就是说，它们应用了越来越多的模型变换。这些变换既可以直接应用，也可以先结合其他矩阵再应用。 假设一个例子，实现一个地球围绕太阳旋转和月球围绕地球旋转的场景： 首先压入视图矩阵 V； 压入太阳的 MV 矩阵； 压入地球的 MV 矩阵，由太阳的 MV 矩阵的副本和应用于其之上的地球模型矩阵变换组成； 压入月球的 MV 矩阵，由地球的 MV 矩阵的副本和应用于其之上的月球模型矩阵变换组成。 接着，渲染月球并把月球矩阵弹出，后面的地球和太阳只需要重复即可。步骤如下： 声明矩阵栈； 当相对于父对象创建新对象时，调用 s.push(s.top())； 应用新对象所需的变换； 完成对象或子对象的绘制后，弹出栈顶，移除对应的 MV 矩阵。 在这个例子中，需要注意： 太阳的自转在它自己的局部坐标空间中进行，不应影响地球和月球。因此，太阳的旋转变换矩阵被推到栈上，但是在绘制太阳之后，它必须被从栈中弹出。 地球的公转将影响月球的运动，因此地球的平移变换矩阵被压入栈并保持到绘制月球。 地球的自转是局部的，不会影响月球，因此在绘制月球之前地球的旋转变换矩阵需要从栈中弹出。 效果如图： 顶点着色器与片段着色器无需改变，同上面渲染两个目标的程序。 main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stackGLuint renderProgram;const int numVAO = 1, numVBO = 2;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint mvLoc, projLoc;glm::mat4 pMat, vMat, mMat, mvMat;std::stackglm::mat4 matrixStack;void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){ float vertexs[108] = { -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f }; glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); // 生成的缓冲区和 VAO 相关联 glGenBuffers(numVBO, vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(vertexs), vertexs, GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 4.0f, cameraZ = 20.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray();}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); matrixStack.push(vMat); // 绘制太阳 matrixStack.push(matrixStack.top()); matrixStack.top() *= glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f)); // 太阳位置 matrixStack.push(matrixStack.top()); matrixStack.top() *= glm::rotate(glm::mat4(1.0f), static_castfloat(currentTime), glm::vec3(1.0f, 0.0f, 0.0f)); // 太阳自转 matrixStack.top() *= glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(matrixStack.top())); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 36); matrixStack.pop(); // 绘制地球 matrixStack.push(matrixStack.top()); matrixStack.top() *= glm::translate(glm::mat4(1.0f), glm::vec3(sin(static_castfloat(currentTime)) * 8.0, 0.0, cos(static_castfloat(currentTime)) * 8.0)); // 平移矩阵变换 matrixStack.push(matrixStack.top()); matrixStack.top() *= glm::rotate(glm::mat4(1.0f), static_castfloat(currentTime) * 2.0f, glm::vec3(0.0f, 2.0f, 0.0f)); // 旋转矩阵变换 glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(matrixStack.top())); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 36); matrixStack.pop(); // 绘制月球 matrixStack.push(matrixStack.top()); matrixStack.top() *= glm::translate(glm::mat4(1.0f), glm::vec3(0.0, sin(static_castfloat(currentTime)) * 2.0, cos(static_castfloat(currentTime)) * 2.0)); // 平移矩阵变换 matrixStack.top() *= glm::rotate(glm::mat4(1.0f), static_castfloat(currentTime), glm::vec3(0.0f, 0.0f, 1.0f)); // 旋转矩阵变换 matrixStack.top() *= glm::scale(glm::mat4(1.0f), glm::vec3(0.25f, 0.25f, 0.25f)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(matrixStack.top())); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 36); matrixStack.pop(); matrixStack.pop(); matrixStack.pop(); matrixStack.pop();}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"sun-earth-moon\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 注意的点： 加入缩放矩阵调节各个模型的大小 使用三角函数实现自转和公转 在 glUniformMatrix4fv() 命令中调用的 glm::value_ptr(mvStack.top()) 函数，获取栈顶部矩阵中的值 4.9 应对“Z冲突”伪影 在渲染多个对象时，OpenGL 使用 Z-buffer 算法来进行隐藏面消除。通常情况下，通过选择最接近相机的相应片段的颜色作为像素的颜色，这种方法可决定哪些物体的曲面可见并呈现到屏幕，而位于其他物体后面的曲面不应该被渲染。 Z-buffer 算法思想：先将 Z 缓冲器中各单元的初始置设置为最小值。当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值（保存在该像素所对应的Z 缓冲器的单元中）。如果大于原来的 Z 值，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色。 然而，有时候场景中的两个物体表面重叠并位于重合的平面中，这使得深度缓冲区算法难以确定应该渲染两个表面中的哪一个。 发生这种情况时，浮点舍入误差可能会导致渲染表面的某些部分使用其中一个对象的颜色，而其他部分则使用另一个对象的颜色。这种不自然的伪影称为 Z 冲突（Z-fighting）或深度冲突（depth-fighting）。 是渲染的片段在深度缓冲区中相互对应的像素条目上“斗争”的结果。 部分应对方法： 可以选择适当的近、远剪裁平面值来最小化两个平面之间的距离，同时仍然确保场景必需的所有对象都位于视锥内 建议避免选择太靠近相机的近剪裁平面 4.10 其他图元 目前一直使用三角形进行绘制，其实 OpenGL 还有其他选择。 4.10.1 三角形图元 名称 作用 示例 GL_TRIANGLES 管线中传递的每3个顶点数据组成一个三角形 GL_TRIANGLE_STRIP 管线中传递的每个顶点和之前的两个顶点组成一个三角形 GL_TRIANGLE_FAN 管线中传递的每对顶点和最开始的顶点组成一个三角形 GL_TRIANGLES_ADJACENCY 仅用于几何着色器，允许着色器访问当前三角形的顶点，以及额外的相邻顶点 GL_TRIANGLE_STRIP_ADJACENCY 仅用于几何着色器，类似于 GL_TRIANGLES_ADJACENCY，但三角形顶点像在 GL_TRIANGLE_STRIP 中一样重叠 4.10.2 线图元 名称 作用 示例 GL_LINES 管线中传递的每两个顶点组成一条线 GL_LINE_STRIP 管线中每个顶点和前一个顶点组成一条线 GL_LINE_LOOP 类似于 GL_LINE_STRIP，但最后的顶点和第一个顶点之间会形成一条线 GL_LINE_ADJACENCY 仅用于几何着色器，允许着色器访问当前线的顶点，以及额外的相邻顶点 GL_LINE_STRIP_ADJACENCY 仅用于几何着色器，类似于 GL_LINE_ADJACENCY，但线顶点像在 GL_LINE_STRIP 中一样重叠 4.10.3 点图元 名称 作用 GL_POINTS 管线中传递的每个顶点组成一个点 补丁图元 名称 作用 GL_PATCHES 仅用于细分着色器，指示一组顶点从顶点着色器传递到细分控制着色器，在这里它们通常用于将曲面细分网格塑造成曲面 4.11 性能优先编程 随着 3D 场景逐渐复杂，性能方面不得不关心。 尽量减少动态内存空间分配 关键部分 display() 函数会被重复调用 避免重复实例化对象 避免重复声明变量 C++ 栈类，每次入栈可能会导致动态内存分配 将数据从一种类型转换为另一种类型的函数调用在某些情况下可能会实例化并返回新转换的数据 GLM 库函数优化有限，可能引起动态内存分配 预先计算透视矩阵 将透视矩阵的计算移动到 init() 函数中 一般情况下不需要重新计算透视矩阵，但窗口大小变化时需要重新计算，可以将计算透视矩阵添加到回调函数中。 背面剔除 利用 OpenGL 的背面剔除能力：当 3D 模型完全闭合时，其内部永远不可见时，那么这些部分不需要被栅格化或渲染。 默认背面剔除时关闭的 使用函数 glEnable(GL_CULL_FACE) 开启 启用背面剔除时，默认情况下，三角形只有朝前时才会被渲染。此外，默认情况下，从 OpenGL相机的角度看，如果三角形的 3 个顶点是以逆时针顺序排列的（基于它们在缓冲区中定义的顺序），则三角形被视为朝前；顶点沿顺时针方向排列的三角形是朝后的，不会被渲染 定义“前向”的顶点顺序有时被称为缠绕顺序 使用 glFrontFace(GL_CW) 设置顺时针为正向，使用 glFrontFace(GL_CCW) 设置逆时针为正向 默认下，glCullFace(GL_BACK) 设置背向的三角形被剔除，但参数还有 GL_FRONT 和 GL_FRONT_AND_BACK，分别设置前向或全部三角形被剔除 五、纹理贴图 纹理贴图是在栅格化的模型表面上覆盖图像的技术。 纹理图像可以是任何图像。 5.1 加载纹理图像文件 OpenGL/GLSL 中完成纹理贴图需要协调不同的数据集和机制： 保存纹理图像的纹理对象 特殊的统一采样器变量，用于顶点着色器访问纹理 保存纹理坐标的缓冲区 将纹理坐标传递给管线的顶点属性 显卡上的纹理单元 此处将用 SOIL2 库进行加载图像文件用于贴图： 使用 SOIL2 实例化 OpenGL 纹理对象并从图像文件中读入数据； 调用 glBindTexture() 使得新创建的纹理对象处于激活状态； 使用 glTexParameteri() 调整纹理设置； 最终得到的结果是可用的 OpenGL 纹理对象的整型 ID。 加载纹理的代码（加入在 Util 类中）如下： GLuint Util::loadTexture(const std::string imgPath){ GLuint textureID; textureID = SOIL_load_OGL_texture(imgPath.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y); if (textureID == 0) std::cout \"Failed to load texture: \" imgPath \" \"; return textureID;} 代码先声明了一个 GLuint 类型的变量用于记录 OpenGL 纹理对象的 ID，接着调用 SOIL_load_OGL_texture() 函数生成纹理对象。 函数参数及返回值 第一个参数为文件名； 第二个说明符，SOIL_LOAD_AUTO 表示使用磁盘载入的； 第三个表示让SOIL为我们创建一个ID； 第四个参数 SOIL_FLAG_INVERT_Y 允许做是翻转Y轴 返回值，0表示失败，其他表示 OpenGL 上下文句柄 5.2 纹理坐标 通过为模型中的每个顶点指定纹理坐标来完成纹理贴图。 纹理坐标是对纹理图像（2D 图像文件）中像素的引用，用于将 3D 模型上的点映射到纹理中的位置。 模型除了 3D 空间中的定位坐标 (x, y, z) 外，表面上每个点还具有纹理坐标 (s, t)，用来指定纹理图像中哪个像素为它提供颜色。 必须为要添加纹理的对象中每个顶点提供纹理坐标。 设置两个缓冲区，一个用于顶点坐标，另一个用于纹理坐标。每次调用顶点着色器会接收到两组坐标。 2D 纹理图像被设定为矩形，左下角坐标为 (0,0)(0,0)(0,0)，右上角坐标为 (1,1)(1,1)(1,1)，故纹理坐标取值区间为 [0,1][0,1][0,1]。 由于之前渲染的立方体模型都是由三角形构成，每个面需要两个三角形。 对于立方体或四棱锥这样的简单模型，选择纹理坐标相对容易。但对于具有大量三角形的更复杂的弯曲模型，手动确定它们是不切实际的。在弯曲的几何形状（例如球形或环面）的情况下，可以通过算法或数学方式计算纹理坐标。使用 Maya 或 Blender 等建模工具构建模型时，可以使用“UV 映射”功能，使得确定纹理坐标的任务更容易完成 5.3 构建一个带纹理的四棱锥 首先创建纹理对象： GLuint textureID = Util::loadTexture(\"texture.jpg\"); 接着构建纹理坐标： 四棱锥具有五个面，由6个三角形组成，每个三角形有3个顶点，共18个顶点 使图像的顶部中心对应四棱锥的顶（简单地贴上去）。 float textures[36] = { 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f}; 然后将纹理载入缓冲区：载入缓冲区1。 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);glBufferData(GL_ARRAY_BUFFER, sizeof(textures), textures, GL_STATIC_DRAW); 在着色器中使用纹理：采样器变量和纹理单元。为了提高性能，在硬件中执行纹理处理。则需要通过统一采样器变量实现。 统一采样器变量：指示显卡上的纹理单元，从加载的纹理对象中提取或采样纹理图像中的像素。 layout(binding = 0) uniform sampler2D samp; layout(binding = 0) 表示采样器变量 samp 的绑定第0个纹理单元。 可用纹理单元的数量取决于显卡提供的数量。 在 display() 函数中，调用 glActiveTexture() 函数激活纹理单元并调用 glBindTexture() 函数将纹理单元绑定到特定的纹理对象。 代码中使用 GL_TEXTURE0 让第0个纹理单元处于激活状态。 片段着色器中使用顶点着色器接收的插值纹理坐标来对纹理对象进行采样： in vec2 tc;……color = texture(samp, tc); 效果展示： 完整代码： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stackGLuint renderProgram;const int numVAO = 1, numVBO = 2;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint textureID[2];GLuint mvLoc, projLoc;glm::mat4 pMat, vMat, mMat, mvMat;std::stackglm::mat4 matrixStack;void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){ float pyramidVertexs[54] = { -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f }; float textures[36] = { 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f }; glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); glGenBuffers(numVBO, vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(pyramidVertexs), pyramidVertexs, GL_STATIC_DRAW); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, sizeof(textures), textures, GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 1.5f, cameraY = 0.0f, cameraZ = 5.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray(); textureID[0] = Util::loadTexture(\"brick1.jpg\"); textureID[1] = Util::loadTexture(\"ice.jpg\");}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); for (int i = 0; i 2; i ++) { vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(i * 3.0f, 0.0f, 0.0f)); // 旋转展示各个面 mMat = glm::rotate(mMat, -0.45f, glm::vec3(1.0f, 0.0f, 0.0f)); mMat = glm::rotate(mMat, 0.61f, glm::vec3(0.0f, 1.0f, 0.0f)); mMat = glm::rotate(mMat, 0.00f, glm::vec3(0.0f, 0.0f, 1.0f)); mvMat = vMat * mMat; glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(1); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, textureID[i]); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, 18); }}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Pyramid with texture\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} Util.h #pragma once#include GL/glew.h#include GLFW/glfw3.h#include SOIL2/soil2.h#include glm/glm.hpp#include glm/gtc/type_ptr.hpp#include string#include iostream#include fstream#include cmath#include vectorclass Util{public: static std::string readShaderSource(const std::string path); static void printShaderLog(GLuint shader); static void printProgramLog(GLuint program); static bool checkOpenGLerror(); static GLuint createShadeProgram(const std::string vpath, const std::string fpath); static GLuint loadTexture(const std::string imgPath);}; Util.cpp #include \"Util.h\"/** 从文件中读取 GLSL 代码* @param path 文件路径*/std::string Util::readShaderSource(const std::string path){ std::string content = \"\"; std::ifstream fileStream(path, std::ios::in); std::string line = \"\"; while (!fileStream.eof()) { getline(fileStream, line); content.append(line + \" \"); } fileStream.close(); return content;}/** 当 GLSL 代码编译失败时，显示 OpenGL 日志内容* @param shader 着色器标识*/void Util::printShaderLog(GLuint shader){ int len = 0; int chWrittn = 0; char *log; glGetShaderiv(shader, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetShaderInfoLog(shader, len, chWrittn, log); std::cout \"Shader Info: \" log \" \"; delete[] log; }}/** 当 GLSL 链接失败时，显示 OpenGL 日志内容* @param program 着色器程序标识*/void Util::printProgramLog(GLuint program){ int len = 0; int chWrittn = 0; char *log; glGetProgramiv(program, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetProgramInfoLog(program, len, chWrittn, log); std::cout \"Program Info: \" log \" \"; delete[] log; }}/** 检查 OpenGL 错误标志，即是否发生 OpenGL 错误*/bool Util::checkOpenGLerror(){ bool err = false; int glErr = glGetError(); while (glErr != GL_NO_ERROR) { std::cout \"glError: \" glErr \" \"; err = true; glErr = glGetError(); } return err;}/** 创建着色器程序* @param vpath 顶点着色器路径* @param fpath 片段着色器路径*/GLuint Util::createShadeProgram(const std::string vpath, const std::string fpath){ // 记录错误信息 GLint vertCompiled, fragCompiled, linked; // 顶点着色器 std::string vs = readShaderSource(vpath); // 片段着色器 std::string fs = readShaderSource(fpath); const char *vshaderSource = vs.c_str(); const char *fshaderSource = fs.c_str(); // 分别存入 vShader 和 fShader 变量 GLuint vShader = glCreateShader(GL_VERTEX_SHADER); GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 将 GLSL 代码从字符串载入空着色器对象中 glShaderSource(vShader, 1, vshaderSource, NULL); glShaderSource(fShader, 1, fshaderSource, NULL); // 编译顶点着色器 glCompileShader(vShader); checkOpenGLerror(); glGetShaderiv(vShader, GL_COMPILE_STATUS, vertCompiled); if (vertCompiled == GL_FALSE) { std::cout \"vertex compilation failed \"; printShaderLog(vShader); } // 编译片段着色器 glCompileShader(fShader); checkOpenGLerror(); glGetShaderiv(fShader, GL_COMPILE_STATUS, fragCompiled); if (fragCompiled == GL_FALSE) { std::cout \"fragment compilation failed \"; printShaderLog(fShader); } GLuint vProgram = glCreateProgram(); glAttachShader(vProgram, vShader); glAttachShader(vProgram, fShader); glLinkProgram(vProgram); checkOpenGLerror(); glGetProgramiv(vProgram, GL_LINK_STATUS, linked); if (linked == GL_FALSE) { std::cout \"linking failed \"; printProgramLog(vProgram); } return vProgram; // 返回着色器程序ID}/** 从文件中读取纹理图像并返回纹理 ID* @param imgPath 图像文件路径*/GLuint Util::loadTexture(const std::string imgPath){ GLuint textureID; textureID = SOIL_load_OGL_texture(imgPath.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y); if (textureID == 0) std::cout \"Failed to load texture: \" imgPath \" \"; return textureID;} vertex.glsl #version 460 corelayout(location = 0) in vec3 position;layout(location = 1) in vec2 texCoord;uniform mat4 mv_matrix;uniform mat4 proj_matrix;layout(binding = 0) uniform sampler2D samp;out vec2 tc;void main(){ gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0); tc = texCoord;} fragment.glsl #version 460 corein vec2 tc;out vec4 color;layout(binding = 0) uniform sampler2D samp;void main(){ color = texture(samp, tc);} 5.4 多级渐远纹理贴图 纹理贴图经常会在渲染图像中导致各种不利的伪影。 这是因为纹理图像的分辨率或长宽比很少与被纹理贴图的场景中区域的分辨率或长宽比匹配。 当图像分辨率小于所绘制区域的分辨率时，会出现一种很常见的伪影。在这种情况下，需要拉伸图像以覆盖整个区域，这样图像就会变得模糊（并且可能变形）。 根据纹理的性质，有时可以通过改变纹理坐标分配方式来应对这种情况，使得纹理需要较少的拉伸。 另一种解决方案是使用更高分辨率的纹理图像。 相反的情况是图像纹理的分辨率大于被绘制区域的分辨率。 在这种情况下，可能会出现明显的叠影，从而产生奇怪的错误图案，或移动物体中的“闪烁”效果。 叠影是由采样错误引起的。 使用多级渐远纹理贴图可以很大程度上矫正采样误差伪影。 使用各种分辨率创建纹理图像的不同版本。 被贴图的区域使用最适合的分辨率的纹理图像。 多级渐远纹理贴图的机制： 它在纹理图像中存储相同图像的连续的一系列较低分辨率的副本。 所用的纹理图像比原始图像大 1/3，其中图像的 RGB 值分别存储在纹理图像空间的 3 个 1/4 区域中来实现的。 剩余的 1/4 区域中迭代地将图像分辨率设置为原来的 1/4，直到剩余区域太小而不包含任何有用的图像数据。 使用代码进行构建多级渐远纹理： // ……glBindTexture(GL_TEXTURE_2D, textureID);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glGenerateMipmap(GL_TEXTURE_2D);// …… 对于函数 glTexparameteri() 其第三个参数设置为所需的缩小方法来选择多级渐远纹理的采样方法，方法如下： GL_NEAREST_MIPMAP_NEAREST：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的多级渐远纹理，获取所需纹理坐标的最近的纹理图像像素。 GL_LINEAR_MIPMAP_NEAREST：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的多级渐远纹理，获取最接近纹理坐标的4个纹理图像像素的插值。 GL_NEAREST_MIPMAP_LINEAR：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的2个多级渐远纹理，从每个多级渐远纹理获取纹理坐标的最近的纹理图像像素进行插值。 GL_LINEAR_MIPMAP_LINEAR：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的2多个渐远纹理，从每多个渐远纹理获取最接近纹理坐标的4个纹理图像像素进行插值，又称为“三线性过滤”。 通常选择三线性过滤。 对于特殊的应用场景，可以使用任何图像编辑软件自行构建多级渐远纹理，然后通过为每个多级渐远纹理级别重复调用 OpenGL 的 glTexImage2D() 函数来创建纹理对象，并将它们添加为多级渐远纹理级别 5.5 各向异性过滤 多级渐远纹理贴图有时看起来比非多级渐远纹理贴图更模糊。 这种细节的丢失是因为当物体倾斜时，其图元看起来在一个轴（即沿宽或高）上的尺寸比在另一个轴上更小。 当 OpenGL 为图元贴图时，它选择适合两个轴中尺寸较小的轴的多级渐远纹理）。 可以通过各向异性过滤恢复一些丢失的细节。 各向异性过滤比标准多级渐远纹理贴图的计算代价更高，并且不是 OpenGL 的必需部分。 只需添加以下代码： if (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")){ GLfloat anisoSetting = 0.0f; glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);} if 判断测试显卡是否支持各向异性过滤。如果支持，则设置为支持的最大采样程度，由 glGetFloatv() 函数获取。 使用 glTexParameterf() 函数激活并设置纹理的各向异性采样值。 5.6 环绕和平铺 当纹理坐标超出 [0,1][0,1][0,1] 时，可以使用 glTexParameteri() 函数设置： GL_REPEAT：重复纹理图像，忽略纹理坐标的整数部分，生成重复或平铺的图案，这是默认选项。 GL_MIRRORED_REPEAT：重复纹理图像，忽略纹理坐标的整数部分，但是当整数部分为奇数时反转坐标，重复的图案在原图案和其镜像图案之间交替。 GL_CLAMP_TO_EDGE：将纹理坐标限制在 [0,1][0,1][0,1] 之间，小于0的坐标设置为0，大于1的坐标设置为1。 GL_CLAMP_TO_BORDER：将纹理坐标限制在 [0,1][0,1][0,1] 之间，区间以外设置为指定的边框颜色。 代码上： // 设置为重复glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 修改为 GL_CLAMP_TO_BORDER： glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);float redColor[4] = { 1.0f, 0.0f, 0.0f, 1.0f };glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, redColor); 5.7 透视变形 在纹理坐标的情况下，线性插值可能导致在具有透视投影的 3D 场景中出现明显的失真。 默认情况下，OpenGL 在栅格化期间会应用透视校正算法。 可以在顶点属性中添加关键字 noperspective 来禁用透视校正。 顶点着色器：noperspective out vec2 texCoord; 片段着色器：noperspective in vec2 texCoord; 5.8 材质的更多细节 可以使用 C++ 和 OpenGL 函数直接将纹理图像文件数据加载到 OpenGL 中（不适用 SOIL2 库）： 使用 C++ 工具读取图像文件数据。 C++ 函数 fopen()、fread()。 生成 OpenGL 纹理对象。 使用 glGenTextures() 函数生成纹理对象。 glGenTextures(1, textureID); 将图像文件数据复制到纹理对象中。 使用 glTexImage2D() 函数将图像文件数据复制到纹理对象中。 data 为图像文件数据，数据类型为 unsigned char。 GLuint textureID;glGenTextures(1, textureID);glBindTexture(GL_TEXTURE_2D, textureID);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); 六、3D模型 对于四棱锥和立方体，可以通过在OpenGL中使用顶点数组来创建。但是大部分 3D 场景对象都比较复杂，无法手动构建顶点数组。 对于更为复杂的模型，此处关注： 通过程序来构建模型 加载外部创建的模型 6.1 程序构建模型 6.1.1 构建一个球体 像圆、球体等具有数学定义，其顶点数组可以通过数学计算而生成。 建立一个球体模型： 选择模型精度：一个表示将球体分成相应份数的圆形部分的数字，体现为切片数。 将每个圆形切片的圆周细分若干个点，此处每个切片具有相同数量的点。 将顶点分组为三角形：逐步遍历顶点，在每一步构建两个三角形。 根据纹理图像的性质选择纹理坐标。对于球体，想象让纹理图像围绕球体包裹，可以根据图像中像素的最终对应位置为每个顶点指定纹理坐标。 对于每个顶点，还应该生成法向量，用于光照。 在第3点中，存在顶点出现在多个三角形中，导致每个顶点被多次指定，这对程序不利。仅存储每个顶点一次，然后为三角形的每个角指定索引，引用所需的顶点。 需要存储每个顶点的位置、纹理坐标和法向量。 顶点存储在一维数组中，从最下面的水平切片开始。 索引数组包含相应三角形的每个角，将值设为顶点数组中的下标。 然后，从球体底部开始，围绕每个水平切片以圆形方式遍历顶点。访问每个顶点时，构建两个三角形，在其右上方形成一个方形区域。 // slices 为切片数，也是精度// vertexs 为每个水平切片的顶点数for (int i = 0; i slices; i++) { for(int j = 0; j vertexs; j++) { // 计算顶点j的指向右边相邻顶点、上方顶点 // 以及右上方顶点的两个三角形的索引 }} 索引数组也加载到 VBO 中，指定 VBO 的类型为 GL_ELEMENT_ARRAY_BUFFER（这会告诉 OpenGL 这个 VBO 包含索引）。 在 display() 中： 将 glDrawArrays() 调用替换为 glDrawElements() 调用，它会告诉 OpenGL利用索引 VBO 来查找要绘制的顶点。 还需要使用 glBindBuffer() 启用包含索引的 VBO，指定哪个 VBO 包含索引并且为 GL_ELEMENT_ARRAY_BUFFER 类型。 编写类 Sphere，用于创建球体模型，球体中心位于原点。 顶点存储在 GLM 中的 vec2 和 vec3 示例的 std::vector 中。 因为纹理贴图完全包裹在球体周围，所以在纹理贴图的左右边缘相交的每个点处需要一个额外的顶点来使贴图两侧重合。 顶点的总数是 (prec+1)*(prec+1)。由于每个顶点生成 6 个三角形索引，因此索引的总数是 prec*prec*6。 prec 为精度，体现在切片数。 效果截图： 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint textureID;GLuint mvLoc, projLoc;glm::mat4 pMat, vMat, mMat, mvMat;Sphere sphere(48);static void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){ std::vectorint ind = sphere.getIndices(); std::vectorglm::vec3 vert = sphere.getVertices(); std::vectorglm::vec2 tex = sphere.getTexCoords(); std::vectorglm::vec3 norm = sphere.getNormals(); std::vectorfloat pvalues; // 顶点位置 std::vectorfloat tvalues; // 纹理坐标 std::vectorfloat nvalues; // 法向量 int numIndices = sphere.getNumIndices(); for (int i = 0; i numIndices; ++ i) { pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z); } glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); glGenBuffers(numVBO, vbo); // 顶点坐标放入缓冲区0 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW); // 纹理坐标放入缓冲区1 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW); // 法向量放入缓冲区2 glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW); // 索引放入缓冲区3 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), ind[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 5.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray(); textureID = Util::loadTexture(\"ice.jpg\");}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -1.0f)); mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f)); mvMat = vMat * mMat; glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(1); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, textureID); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glGenerateMipmap(GL_TEXTURE_2D); if (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")) { GLfloat anisoSetting = 0.0f; glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); } glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); // 利用索引 vbo3 来查找要绘制的顶点 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); glDrawElements(GL_TRIANGLES, sphere.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Sphere\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 球体类 // Sphere.h#pragma once#include cmath#include vector#include glm/glm.hppclass Sphere{private: int numVertices; // 顶点数组大小 int numIndices; // 索引数组大小 std::vectorglm::vec3 vertices; // 顶点数组 std::vectorint indices; // 索引数组 std::vectorglm::vec3 normals; // 法向量数组 std::vectorglm::vec2 texCoords; // 纹理坐标数组 void init(int); float toRadians(float degrees);public: Sphere(int prec = 48); int getNumVertices(); int getNumIndices(); std::vectorglm::vec3 getVertices(); std::vectorint getIndices(); std::vectorglm::vec3 getNormals(); std::vectorglm::vec2 getTexCoords();}; // Sphere.cpp#include \"Sphere.h\"Sphere::Sphere(int prec){ init(prec);}void Sphere::init(int _prec){ numVertices = (_prec + 1) * (_prec + 1); numIndices = _prec * _prec * 6; for (int i = 0; i numVertices; ++ i) vertices.push_back(glm::vec3()); for (int i = 0; i numVertices; ++ i) texCoords.push_back(glm::vec2()); for (int i = 0; i numVertices; ++ i) normals.push_back(glm::vec3()); for (int i = 0; i numIndices; ++ i) indices.push_back(0); // 计算三角形顶点 for (int i = 0; i = _prec; ++ i) for (int j = 0; j = _prec; ++ j) { float y = static_castfloat(cos(toRadians(180.0f - i * 180.0f / _prec))); float x = - static_castfloat(cos(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y)))); float z = static_castfloat(sin(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y)))); vertices[i * (_prec + 1) + j] = glm::vec3(x, y, z); texCoords[i * (_prec + 1) + j] = glm::vec2(j * 1.0f / _prec, i * 1.0f / _prec); normals[i * (_prec + 1) + j] = glm::vec3(x, y, z); } // 计算三角形索引 for (int i = 0; i _prec; ++ i) for (int j = 0; j _prec; ++ j) { indices[6 * (i * _prec + j) + 0] = i * (_prec + 1) + j; indices[6 * (i * _prec + j) + 1] = i * (_prec + 1) + j + 1; indices[6 * (i * _prec + j) + 2] = (i + 1) * (_prec + 1) + j; indices[6 * (i * _prec + j) + 3] = i * (_prec + 1) + j + 1; indices[6 * (i * _prec + j) + 4] = (i + 1) * (_prec + 1) + j + 1; indices[6 * (i * _prec + j) + 5] = (i + 1) * (_prec + 1) + j; }}float Sphere::toRadians(float degrees){ return degrees * 2.0f * 3.14159f / 360.0f;}int Sphere::getNumVertices(){ return numVertices;}int Sphere::getNumIndices(){ return numIndices;}std::vectorglm::vec3 Sphere::getVertices(){ return vertices;}std::vectorint Sphere::getIndices(){ return indices;}std::vectorglm::vec3 Sphere::getNormals(){ return normals;}std::vectorglm::vec2 Sphere::getTexCoords(){ return texCoords;} 着色器 // vertex.glsl#version 460 corelayout(location = 0) in vec3 position;layout(location = 1) in vec2 texCoord;uniform mat4 mv_matrix;uniform mat4 proj_matrix;layout(binding = 0) uniform sampler2D samp;out vec2 tc;void main(){ gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0); tc = texCoord;} // fragment.glsl#version 460 corein vec2 tc;out vec4 color;layout(binding = 0) uniform sampler2D samp;void main(){ color = texture(samp, tc);} 6.1.2 构建一个环面 产生环面需要一定的算法。 构建一个环面如图： 将一个顶点定位到原点的右侧，然后在 xOy 平面上的圆中让这个顶点围绕 z 轴旋转，以形成“环”，最后将这个环“向外”移动“内径”的距离。 在构建这些顶点时，会为每个顶点计算纹理坐标和法向量，还会额外为每个顶点生成与环面表面相切的向量（称为切向量）。在顶点创建之后，逐环遍历所有顶点，并在每个顶点上生成两个三角形。两个三角形的 6 个索引表的生成方式和之前的球体类似。 效果截图： 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack//#include \"Sphere.h\"#include \"Torus.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint textureID;GLuint mvLoc, projLoc;glm::mat4 pMat, vMat, mMat, mvMat;//Sphere sphere(48);Torus torus(48, 0.5f, 0.2f);static void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){ std::vectorint ind = torus.getIndices(); std::vectorglm::vec3 vert = torus.getVertices(); std::vectorglm::vec2 tex = torus.getTexCoords(); std::vectorglm::vec3 norm = torus.getNormals(); std::vectorfloat pvalues; // 顶点位置 std::vectorfloat tvalues; // 纹理坐标 std::vectorfloat nvalues; // 法向量 int numIndices = torus.getNumIndices(); for (int i = 0; i numIndices; ++ i) { pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z); } glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); glGenBuffers(numVBO, vbo); // 顶点坐标放入缓冲区0 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW); // 纹理坐标放入缓冲区1 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW); // 法向量放入缓冲区2 glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW); // 索引放入缓冲区3 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), ind[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 5.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray(); textureID = Util::loadTexture(\"ice.jpg\"); glBindTexture(GL_TEXTURE_2D, textureID); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -0.5f)); mMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f)); mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(2.0f, 2.0f, 2.0f)); mvMat = vMat * mMat; glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(1); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, textureID); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glGenerateMipmap(GL_TEXTURE_2D); if (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")) { GLfloat anisoSetting = 0.0f; glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); } glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); // 利用索引 vbo3 来查找要绘制的顶点 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); glDrawElements(GL_TRIANGLES, torus.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Torus\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 环面类 // Torus.h#pragma once#include cmath#include vector#include glm/gtc/matrix_transform.hppclass Torus{private: int numVertices; int numIndices; int prec; float inner, outer; std::vectorint indices; std::vectorglm::vec3 vertices; std::vectorglm::vec2 texCoords; std::vectorglm::vec3 normals; std::vectorglm::vec3 sTangents; std::vectorglm::vec3 tTangents; void init(); float toRadians(float degrees);public: Torus(int _prec = 48, float _inner = 0.5, float _outer = 0.2); int getNumVertices(); int getNumIndices(); std::vectorint getIndices(); std::vectorglm::vec3 getVertices(); std::vectorglm::vec2 getTexCoords(); std::vectorglm::vec3 getNormals(); std::vectorglm::vec3 getStangents(); std::vectorglm::vec3 getTtangents();}; // Torus.cpp#include \"Torus.h\"Torus::Torus(int _prec, float _inner, float _outer){ prec = _prec; inner = _inner; outer = _outer; init();}void Torus::init(){ numVertices = (prec + 1) * (prec + 1); numIndices = prec * prec * 6; for (int i = 0; i numVertices; ++ i) vertices.push_back(glm::vec3()); for (int i = 0; i numVertices; ++ i) texCoords.push_back(glm::vec2()); for (int i = 0; i numVertices; ++ i) normals.push_back(glm::vec3()); for (int i = 0; i numIndices; ++ i) indices.push_back(0); for (int i = 0; i numVertices; ++ i) sTangents.push_back(glm::vec3()); for (int i = 0; i numVertices; ++ i) tTangents.push_back(glm::vec3()); // 计算第一个环 for (int i = 0; i prec + 1; ++ i) { float amt = toRadians(i * 360.0f / prec); glm::mat4 rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 0.0f, 1.0f)); glm::vec3 initPos(rMat * glm::vec4(0.0f, outer, 0.0f, 1.0f)); vertices[i] = glm::vec3(initPos + glm::vec3(inner, 0.0f, 0.0f)); texCoords[i] = glm::vec2(0.0f, static_castfloat(i) / prec); rMat = glm::rotate(glm::mat4(1.0f), amt + (3.14159f / 2.0f), glm::vec3(0.0f, 0.0f, 1.0f)); tTangents[i] = glm::vec3(rMat * glm::vec4(0.0f, -1.0f, 0.0f, 1.0f)); sTangents[i] = glm::vec3(glm::vec3(0.0f, 0.0f, -1.0f)); normals[i] = glm::cross(tTangents[i], sTangents[i]); } // 将第一个环绕Y轴旋转，得到其他环 for (int ring = 1; ring prec + 1; ++ ring) for (int i = 0; i prec + 1; ++ i) { float amt = toRadians(ring * 360.0f / prec); glm::mat4 rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f)); vertices[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(vertices[i], 1.0f)); texCoords[ring * (prec + 1) + i] = glm::vec2(ring * 2.0f / prec, texCoords[i].t); rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f)); sTangents[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(sTangents[i], 1.0f)); rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f)); tTangents[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(tTangents[i], 1.0f)); rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f)); normals[ring * (prec + 1) + i] = glm::vec3(rMat * glm::vec4(normals[i], 1.0f)); } // 计算三角形索引 for (int ring = 0; ring prec; ++ ring) for (int i = 0; i prec; ++ i) { indices[((ring * prec + i) * 2) * 3 + 0] = ring * (prec + 1) + i; indices[((ring * prec + i) * 2) * 3 + 1] = (ring + 1) * (prec + 1) + i; indices[((ring * prec + i) * 2) * 3 + 2] = ring * (prec + 1) + i + 1; indices[((ring * prec + i) * 2 + 1) * 3 + 0] = ring * (prec + 1) + i + 1; indices[((ring * prec + i) * 2 + 1) * 3 + 1] = (ring + 1) * (prec + 1) + i; indices[((ring * prec + i) * 2 + 1) * 3 + 2] = (ring + 1) * (prec + 1) + i + 1; }}float Torus::toRadians(float degrees){ return degrees * 2.0f * 3.14159f / 360.0f;}int Torus::getNumVertices(){ return numVertices;}int Torus::getNumIndices(){ return numIndices;}std::vectorint Torus::getIndices(){ return indices;}std::vectorglm::vec3 Torus::getVertices(){ return vertices;}std::vectorglm::vec2 Torus::getTexCoords(){ return texCoords;}std::vectorglm::vec3 Torus::getNormals(){ return normals;}std::vectorglm::vec3 Torus::getStangents(){ return sTangents;}std::vectorglm::vec3 Torus::getTtangents(){ return tTangents;} 当绕 y 轴旋转生成环时，指定一个从 1 开始并增加到指定精度的变量 ring。然后将纹理坐标值设置为 ring*2.0/prec，使其取值范围为 0.0～2.0，再前面描述的，将纹理的平铺模式设为 GL_REPEAT。运用这种方法的目的是避免纹理图像在水平方向上过度“拉伸”。反之，如果确实希望纹理完全围绕环面拉伸，只需从纹理坐标计算代码中删除 *2.0。 6.2 加载外部构建的模型 通过一些建模工具也可以构建模型，如：Maya、Blender、Cinema4D等，而一般模型导出也有许多格式。此处使用 OBJ 格式进行处理。 OBJ 文件中的行以字符标签开头，表明该行的数据类型，常见的标签如下： v：几何数据（顶点位置） vt：纹理坐标 vn：顶点法向量 f：面（通常是三角形中的顶点） 可能还有标签存储对象名称、使用的材质、曲线、阴影和许多其他细节。 使用 Blender 绘制一个四棱锥，并导出为 OBJ文件： 使用记事本打开一个 OBJ 文件，其内容如下： 以 # 开头的是 Blender 添加的注释，可以忽略。 以 o 开头的是对象的名称，导入时也可以忽略。 以 s 开头表明不应该平滑处理，此处同样忽略。 以 v 开头的是顶点位置，顶点位置的顺序是 x y z。此处有8个顶点，原点在中心。 以 vt 开头的是各种纹理坐标，纹理坐标列表比顶点列表长的原因是一些顶点参与了多个三角形的构建，并且在这些情况下可能使用不同的纹理坐标。 以 vn 开头的是各种法向量，通常也是比顶点列表长，原因同上。 以 f 开头的行指定面（三角形）。每个面（三角形）具有三个元素，由 / 分隔。每个元素的值分别是顶点列表、纹理坐标和法向量的索引，如第三个面是：3/4/3 5/2/3 4/5/3，表明顶点列表第3个、第5个、第4个组成一个面，相应的纹理坐标是第4项、第2项、第5项，法向量相同都是第3项。 OBJ 格式的模型并不要求具有法向量，甚至纹理坐标。 如果模型没有纹理坐标和法向量，则面的数值将仅指定顶点索引： 3 5 4 如果模型有纹理坐标，没有法向量，则格式为： 3/4 5/2 4/5 如果模型没有纹理坐标，有法向量，则格式为： 3//3 5//3 4//3 在互联网上可以获得各种能导入 OBJ 模型的程序，但此处手动编写程序进行简单地导入 OBJ 文件，局限如下： 仅支持包含 3 个面属性字段，即以 f #/#/# #/#/# #/#/# 的形式存在。 材质标签将被忽略。 仅支持由单个三角形网格组成的 OBJ 模型。 假设每行上的元素都只用一个空格分隔。 没有使用上索引机制。 定义两个类（置于同一个文件）： ModelImporter 类用于从 OBJ 文件中导入模型数据。 ImportedModel 类用于保存并构建一个模型，类似于上面的球体类、环面类。 对于四棱锥，加载 OBJ 与先前手动构建的模型差不多。通过 Windows 自带的 3D 查看器，可以获取一些模型（格式为 .glb ，将其放入 Blender 中，再导出为 OBJ 文件）。获取模型后在 OpenGL 程序中加载，如图： 导入模型后，对模型的大小和位置进行修改，移动适合的相机位置并加入材质，最后如图： 更多可以自己摸索。 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint textureID;GLuint mvLoc, projLoc;glm::mat4 pMat, vMat, mMat, mvMat;//Sphere sphere(48);//Torus torus(48, 0.5f, 0.2f);ImportedModel model(\" Pyramid.obj\");static void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){ //std::vectorint ind = model.getIndices(); 不使用索引数组 std::vectorglm::vec3 vert = model.getVertices(); std::vectorglm::vec2 tex = model.getTexCoords(); std::vectorglm::vec3 norm = model.getNormals(); std::vectorfloat pvalues; // 顶点位置 std::vectorfloat tvalues; // 纹理坐标 std::vectorfloat nvalues; // 法向量 int numObjVertices = model.getNumVertices(); for (int i = 0; i numObjVertices; ++ i) { pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z); } glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); glGenBuffers(numVBO, vbo); // 顶点坐标放入缓冲区0 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW); // 纹理坐标放入缓冲区1 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW); // 法向量放入缓冲区2 glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray(); textureID = Util::loadTexture(\"ice.jpg\"); glBindTexture(GL_TEXTURE_2D, textureID);}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f)); mMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f)); mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(1.0f, 1.0f, 1.0f)); mvMat = vMat * mMat; glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(1); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, textureID); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glGenerateMipmap(GL_TEXTURE_2D); if (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")) { GLfloat anisoSetting = 0.0f; glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); } glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices()); // 利用索引 vbo3 来查找要绘制的顶点 // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); // glDrawElements(GL_TRIANGLES, torus.getVertices(), GL_UNSIGNED_INT, 0);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Pyramid\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 导入模型类 // ImportedModel.h#pragma once#include glm/glm.hpp#include string#include vector#include fstream#include sstreamclass ImportedModel{private: int numVertices; std::vectorglm::vec3 vertices; std::vectorglm::vec2 texCoords; std::vectorglm::vec3 normals;public: ImportedModel(); ImportedModel(const std::string filePath); int getNumVertices(); std::vectorglm::vec3 getVertices(); std::vectorglm::vec2 getTexCoords(); std::vectorglm::vec3 getNormals();};class ModelImporter{private: // OBJ 读取 std::vectorfloat vertVals; std::vectorfloat stVals; std::vectorfloat normalVals; // 保存为顶点属性以供后续使用的数值 std::vectorfloat triangleVerts; std::vectorfloat texCoords; std::vectorfloat normals;public: ModelImporter(); void parseOBJ(const std::string filePath); int getNumVertices(); std::vectorfloat getVertices(); std::vectorfloat getTexCoords(); std::vectorfloat getNormals();}; // ImportedModel.cpp#include \"ImportedModel.h\"ImportedModel::ImportedModel(){}ImportedModel::ImportedModel(const std::string filePath){ ModelImporter modelImporter = ModelImporter(); modelImporter.parseOBJ(filePath); numVertices = modelImporter.getNumVertices(); std::vectorfloat verts = modelImporter.getVertices(); std::vectorfloat tcs = modelImporter.getTexCoords(); std::vectorfloat nms = modelImporter.getNormals(); for (int i = 0; i numVertices; ++ i) { vertices.push_back(glm::vec3(verts[i * 3], verts[i * 3 + 1], verts[i * 3 + 2])); texCoords.push_back(glm::vec2(tcs[i * 2], tcs[i * 2 + 1])); normals.push_back(glm::vec3(nms[i * 3], nms[i * 3 + 1], nms[i * 3 + 2])); }}int ImportedModel::getNumVertices(){ return numVertices;}std::vectorglm::vec3 ImportedModel::getVertices(){ return vertices;}std::vectorglm::vec2 ImportedModel::getTexCoords(){ return texCoords;}std::vectorglm::vec3 ImportedModel::getNormals(){ return normals;}ModelImporter::ModelImporter(){}void ModelImporter::parseOBJ(const std::string filePath){ float x, y, z; std::string content; std::ifstream fin(filePath, std::ios::in); std::string line = \"\"; while (!fin.eof()) { getline(fin, line); if (line.compare(0, 2, \"v \") == 0) { std::stringstream s(line.erase(0, 1)); s x y z; vertVals.push_back(x); vertVals.push_back(y); vertVals.push_back(z); } if (line.compare(0, 2, \"vt\") == 0) { std::stringstream s(line.erase(0, 2)); s x y; stVals.push_back(x); stVals.push_back(y); } if (line.compare(0, 2, \"vn\") == 0) { std::stringstream s(line.erase(0, 2)); s x y z; normalVals.push_back(x); normalVals.push_back(y); normalVals.push_back(z); } if (line.compare(0, 2, \"f \") == 0) { std::string oneCorner, v, t, n; std::stringstream s(line.erase(0, 2)); for (int i = 0; i 3; ++ i) { std::getline(s, oneCorner, ' '); std::stringstream oneCornerSS(oneCorner); std::getline(oneCornerSS, v, '/'); std::getline(oneCornerSS, t, '/'); std::getline(oneCornerSS, n, '/'); int vertRef = (std::stoi(v) - 1) * 3; int tcRef = (std::stoi(t) - 1) * 2; int nmRef = (std::stoi(n) - 1) * 3; triangleVerts.push_back(vertVals[vertRef]); triangleVerts.push_back(vertVals[vertRef + 1]); triangleVerts.push_back(vertVals[vertRef + 2]); texCoords.push_back(stVals[tcRef]); texCoords.push_back(stVals[tcRef + 1]); normals.push_back(normalVals[nmRef]); normals.push_back(normalVals[nmRef + 1]); normals.push_back(normalVals[nmRef + 2]); } } }}int ModelImporter::getNumVertices(){ return triangleVerts.size() / 3;}std::vectorfloat ModelImporter::getVertices(){ return triangleVerts;}std::vectorfloat ModelImporter::getTexCoords(){ return texCoords;}std::vectorfloat ModelImporter::getNormals(){ return normals;} 七、光照 7.1 光照模型 光照模型有时也称为着色模型。 常见的光照模型称为 ADS 模型，基于标记为 A、D 和 S 三种类型的反射： A：环境光反射（ambient reflection）：模拟低级光照，影响场景中的所有物体。 D：漫反射（diffuse reflection）：根据光线的入射角度调整物体亮度。 S：镜面反射（specular reflection）：展示物体的光泽，通过在物体表面上，光线直接地反射到我们的眼睛的位置，策略性地放置适当大小的高光来体现。 使用 ADS 光照模型需要指定用于像素输出的 RGBA 值上因光照 而产生的分量。因素包括： 光源类型及其环境光反射、漫反射和镜面反射特性； 对象材质的环境光反射、漫反射和镜面反射特征； 对象材质的“光泽度”； 光线照射物体的角度； 从中查看场景的角度。 7.2 光源 常见的光源类型有： 全局光：通常称为全局环境光，仅包含环境光组件 定向光：远距离光 位置光：点光源 聚光灯 全局环境光用于显示对象的每个像素都有相同的光照。 全局环境光模拟了现实世界光线经过多次反射，无法确定光源和方向。 仅有环境光反射分量，没有漫反射或镜面反射分量。 通常被建模为偏暗的白光。 用 RGBA 值设定：float globalAmbient[4] = {0.6f, 0.6f, 0.6f, 1.0f}; RGBA 值的范围是 0.0 到 1.0。A 设置为1。 定向光或远距离光 没有源位置但具有方向。用于模拟光源距离非常远，光线接近平行的情况。 定向光对物体的影响取决于光照角度，物体朝向定向光的一侧比对侧更亮。 建模定向光需要指定其方向（向量）及其环境、漫反射和镜面特征。 用 RGBA 设定，如指向 z 轴负方向的红色定向光代码： float dirLightAmbient[4] = {0.1f, 0.0f, 0.0f, 1.0f};float dirLightDiffuse[4] = {1.0f, 0.0f, 0.0f, 1.0f};float dirLightSpecular[4] = {1.0f, 0.0f, 0.0f, 1.0f};float dirLightDirection[3] = {0.0f, 0.0f, -1.0f}; 位置光在 3D 场景中具有特定位置，用以体现靠近场景的光源。 位置光没有方向，因为它对场景中每个顶点的光照方向都不同。 位置光还可以包含衰减因子，用于模拟它们的强度随着距离减小的程度。 用 RGBA 设定，如位置(5,2,-3)处的红色位置光可以指定为： float posLightAmbient[4] = {0.1f, 0.0f, 0.0f, 1.0f};float posLightDiffuse[4] = {1.0f, 0.0f, 0.0f, 1.0f};float posLightSpecular[4] = {1.0f, 0.0f, 0.0f, 1.0f};float posLightPosition[3] = {5.0f, 2.0f, -3.0f}; 衰减因子有许多建模方式，其中一种是使用恒定衰减、线性衰减和二次方衰减，引入3个非负可调参数，与离光源的距离 ddd 结合进行计算： attenuationFactor=1kc+kld+kqd2attenuationFactor = \\frac{1}{k_c + k_l d + k_q d^2} attenuationFactor=kc​+kl​d+kq​d21​ kck_ckc​：应永远大于等于1； 另外两个参数至少有一个大于零； 使得因子取值为 [0,1][0,1][0,1]，并当 ddd 增大时接近0。 将因子与光的强度相乘即可。 聚光灯 同时具有位置和方向。 聚光灯参数如下图 具有衰减指数模拟随光束角度的强度变化，具有衰减因子模拟光束距离衰减。 当 φ\\varphiφ 小于 θ\\thetaθ 时，计算 φ\\varphiφ 的余弦的衰减指数次幂来计算强度因子。 当 φ\\varphiφ 大于 θ\\thetaθ 时，强度因子为0。 强度因子取值范围为 [0,1][0,1][0,1]，将强度因子乘光的强度即可模拟锥形效果。 用 RGBA 设定，如位置(5,2,-3)处向下照射 z 轴负方向的红色聚光灯可以表示为： float spotLightAmbient[4] = {0.1f, 0.0f, 0.0f, 1.0f};float spotLightDiffuse[4] = {1.0f, 0.0f, 0.0f, 1.0f};float spotLightSpecular[4] = {1.0f, 0.0f, 0.0f, 1.0f};float spotLightPosition[3] = {5.0f, 2.0f, -3.0f};float spotLightDirection[3] = {0.0f, 0.0f, -1.0f};float spotLightCutoff = 20.0f;float spotLightExponent = 10.0f; 当设计拥有许多光源的系统时，程序员应该考虑创建相应的类结构，如定义 Light 类及其子类 GlobalAmbient、Directional、Positional、Spotlight 7.3 材质 场景中给物体的外观添加光照，产生反射特性。即对象与 ADS 光照模型相互作用。 通过指定4个值，在 ADS 光照模型中模拟材质： 环境光反射 漫反射 镜面反射 光泽 如锡铝合金的效果，指定： float pewterMatAmbient[4] = {0.11f, 0.06f, 0.11f, 1.0f};float pewterMatDiffuse[4] = {0.43f, 0.47f, 0.54f, 1.0f};float pewterMatSpecular[4] = {0.33f, 0.33f, 0.52f, 1.0f}; 没有纹理的物体在渲染时，可以指定材质特性。此处预定义一些可选择的材质（置于Util类中）： 黄金、白银、青铜材质代码 // 黄金材质的环境光float *Util::goldAmbient(){ static float ambient[4] = { 0.2473f, 0.1995f, 0.0745f, 1.0f }; return ambient;}// 黄金材质的漫反射float *Util::goldDiffuse(){ static float diffuse[4] = { 0.7516f, 0.6065f, 0.2265f, 1.0f }; return diffuse;}// 黄金材质的镜面反射float *Util::goldSpecular(){ static float specular[4] = { 0.6283f, 0.5559f, 0.3661f, 1.0f }; return specular;}// 黄金材质的光泽度float Util::goldShininess(){ return 51.2f;}// 白银材质的环境光float *Util::silverAmbient(){ static float ambient[4] = { 0.1923f, 0.1923f, 0.1923f, 1.0f }; return ambient;}// 白银材质的漫反射float *Util::silverDiffuse(){ static float diffuse[4] = { 0.5075f, 0.5075f, 0.5075f, 1.0f }; return diffuse;}// 白银材质的镜面反射float *Util::silverSpecular(){ static float specular[4] = { 0.5083f, 0.5083f, 0.5083f, 1.0f }; return specular;}// 白银材质的光泽度float Util::silverShininess(){ return 51.2f;}// 青铜材质的环境光float *Util::bronzeAmbient(){ static float ambient[4] = { 0.2125f, 0.1275f, 0.054f, 1.0f }; return ambient;}// 青铜材质的漫反射float *Util::bronzeDiffuse(){ static float diffuse[4] = { 0.714f, 0.4284f, 0.18144f, 1.0f }; return diffuse;}// 青铜材质的镜面反射float *Util::bronzeSpecular(){ static float specular[4] = { 0.393548f, 0.271906f, 0.166721f, 1.0f }; return specular;}// 青铜材质的光泽度float Util::bronzeShininess(){ return 25.6f;} 这些代码仅仅提供了用于描述并存储场景中元素所需光照和材质特性的一种方式，仍然需要自己计算光照。 7.4 ADS光照计算 当绘制场景时，每个顶点坐标都会进行变换以将 3D 世界模拟到 2D 屏幕上。每个像素的颜色都是栅格化、纹理贴图以及插值的结果。 现在需要加入一个新的步骤来调整这些栅格化之后的像素颜色，以便反应场景中的光照和材质。 首先确定每个像素的反射强度 I： Iobserved=Iambient+Idiffuse+IspecularI_{observed} = I_{ambient} + I_{diffuse} + I_{specular} Iobserved​=Iambient​+Idiffuse​+Ispecular​ 其中环境光值为场景环境光与材质环境光分量的乘积（RGB分别乘积）： Iambient=LightambientMaterialambient={Iambientred=LightambientredMaterialambientredIambientgreen=LightambientgreenMaterialambientgreenIambientblue=LightambientblueMaterialambientblueI_{ambient}=Light_{ambient}\\ Material_{ambient}= \\begin{cases} I_{ambient}^{red}=Light_{ambient}^{red}Material_{ambient}^{red}\\\\ I_{ambient}^{green}=Light_{ambient}^{green}Material_{ambient}^{green}\\\\ I_{ambient}^{blue}=Light_{ambient}^{blue}Material_{ambient}^{blue} \\end{cases} Iambient​=Lightambient​Materialambient​=⎩⎪⎪⎨⎪⎪⎧​Iambientred​=Lightambientred​Materialambientred​Iambientgreen​=Lightambientgreen​Materialambientgreen​Iambientblue​=Lightambientblue​Materialambientblue​​ 其中漫反射分量基于光对于平面的入射角 θ\\thetaθ。 其中确定入射角 θ\\thetaθ 需要： 求从绘制向量到光源的向量（或与光照方向相反的向量） LLL 渲染物体表明的法向量 NNN 由{Idiffuse=cos⁡(θ)LightdiffuseMaterialdiffusecos⁡(θ)=N⋅L∣N∥L∣−π2≤θ≤π2得Idiffuse=LightdiffuseMaterialdiffusemax⁡(N⋅L∣N∥L∣,0)同样分别进行RGB运算由\\begin{cases} I_{diffuse}=\\cos(\\theta)Light_{diffuse}Material_{diffuse}\\\\ \\cos(\\theta)=\\frac{N\\cdot L}{\\vert N\\|L\\vert}\\\\ -\\frac{\\pi}{2}\\leq\\theta\\leq\\frac{\\pi}{2} \\end{cases}\\\\ 得I_{diffuse}=Light_{diffuse}\\ Material_{diffuse}\\ \\max(\\frac{N\\cdot L}{\\vert N\\|L\\vert},0)\\\\ 同样分别进行RGB运算 由⎩⎪⎪⎨⎪⎪⎧​Idiffuse​=cos(θ)Lightdiffuse​Materialdiffuse​cos(θ)=∣N∥L∣N⋅L​−2π​≤θ≤2π​​得Idiffuse​=Lightdiffuse​Materialdiffuse​max(∣N∥L∣N⋅L​,0)同样分别进行RGB运算 其中镜面反射分量除了与入射角相关，也与光在表面上的反射角以及观察点与反光表面之间的夹角相关。下图 R 表示光反射，V 表示观察向量（像素到眼睛）。 V 是从眼睛到像素的取反。 φ\\varphiφ 越小，镜面反射分量越大。 φ\\varphiφ 用于计算镜面反射分量的方式取决于物体的光泽度。光泽度越大越闪亮，则入射光更多反射给眼睛；光泽度较小，不那么闪亮，则镜面高光会散开。 反光度可以用衰减函数建模，衰减函数表示角度 φ\\varphiφ 增大时镜面反射分量衰减到0的速度。 使用 cos⁡n(φ)\\cos^n(\\varphi)cosn(φ) 进行衰减，指数越大，衰减速度越快。 nnn 又叫作材质的反光度因子。 反光度因子以光泽度形式给出。 镜面反射计算如下（实际运算使用RGB运算）： Ispecular=LightspecularMaterialspecularmax⁡((R⋅V∣R∥V∣)n,0)I_{specular}=Light_{specular}\\ Material_{specular}\\ \\max((\\frac{R\\cdot V}{\\vert R\\|V\\vert})^n,0)\\\\ Ispecular​=Lightspecular​Materialspecular​max((∣R∥V∣R⋅V​)n,0) 7.5 实现ADS光照 平滑着色方法： Gouraud 着色 Phong 着色 7.5.1 Gouraud 着色 这方法又称为双线性光强插值法 使用 3D 图形管线中的自动插值渲染，适用于现代显卡。过程如下： 确定每个顶点的颜色，并进行光照相关计算。 允许正常的栅格化过程在插入像素时对颜色也进行插值（同时也对光照进行插值）。 OpenGL 中，大多数光照计算都是顶点着色器中完成，片段着色器仅传递并展示自动插值的光照后的颜色。 顶点着色器 根据顶点计算 N、L、V 和 R 向量 计算 A、D、S分量 输出属性、光照后的颜色、gl_position 片段着色器 传入插值：颜色、位置 程序代码如下： Util类 // Util.h#pragma once#include GL/glew.h#include GLFW/glfw3.h#include SOIL2/soil2.h#include glm/glm.hpp#include glm/gtc/type_ptr.hpp#include string#include iostream#include fstream#include cmath#include vectorclass Util{public: static std::string readShaderSource(const std::string path); static void printShaderLog(GLuint shader); static void printProgramLog(GLuint program); static bool checkOpenGLerror(); static GLuint createShadeProgram(const std::string vpath, const std::string fpath); static GLuint loadTexture(const std::string imgPath); static float *goldAmbient(); static float *goldDiffuse(); static float *goldSpecular(); static float goldShininess(); static float *silverAmbient(); static float *silverDiffuse(); static float *silverSpecular(); static float silverShininess(); static float *bronzeAmbient(); static float *bronzeDiffuse(); static float *bronzeSpecular(); static float bronzeShininess();}; // Util.cpp#include \"Util.h\"/** 从文件中读取 GLSL 代码* @param path 文件路径*/std::string Util::readShaderSource(const std::string path){ std::string content = \"\"; std::ifstream fileStream(path, std::ios::in); std::string line = \"\"; while (!fileStream.eof()) { getline(fileStream, line); content.append(line + \" \"); } fileStream.close(); return content;}/** 当 GLSL 代码编译失败时，显示 OpenGL 日志内容* @param shader 着色器标识*/void Util::printShaderLog(GLuint shader){ int len = 0; int chWrittn = 0; char *log; glGetShaderiv(shader, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetShaderInfoLog(shader, len, chWrittn, log); std::cout \"Shader Info: \" log \" \"; delete[] log; }}/** 当 GLSL 链接失败时，显示 OpenGL 日志内容* @param program 着色器程序标识*/void Util::printProgramLog(GLuint program){ int len = 0; int chWrittn = 0; char *log; glGetProgramiv(program, GL_INFO_LOG_LENGTH, len); if (len 0) { log = new char[len]; glGetProgramInfoLog(program, len, chWrittn, log); std::cout \"Program Info: \" log \" \"; delete[] log; }}/** 检查 OpenGL 错误标志，即是否发生 OpenGL 错误*/bool Util::checkOpenGLerror(){ bool err = false; int glErr = glGetError(); while (glErr != GL_NO_ERROR) { std::cout \"glError: \" glErr \" \"; err = true; glErr = glGetError(); } return err;}/** 创建着色器程序* @param vpath 顶点着色器路径* @param fpath 片段着色器路径*/GLuint Util::createShadeProgram(const std::string vpath, const std::string fpath){ // 记录错误信息 GLint vertCompiled, fragCompiled, linked; // 顶点着色器 std::string vs = readShaderSource(vpath); // 片段着色器 std::string fs = readShaderSource(fpath); const char *vshaderSource = vs.c_str(); const char *fshaderSource = fs.c_str(); // 分别存入 vShader 和 fShader 变量 GLuint vShader = glCreateShader(GL_VERTEX_SHADER); GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER); // 将 GLSL 代码从字符串载入空着色器对象中 glShaderSource(vShader, 1, vshaderSource, NULL); glShaderSource(fShader, 1, fshaderSource, NULL); // 编译顶点着色器 glCompileShader(vShader); checkOpenGLerror(); glGetShaderiv(vShader, GL_COMPILE_STATUS, vertCompiled); if (vertCompiled == GL_FALSE) { std::cout \"vertex compilation failed \"; printShaderLog(vShader); } // 编译片段着色器 glCompileShader(fShader); checkOpenGLerror(); glGetShaderiv(fShader, GL_COMPILE_STATUS, fragCompiled); if (fragCompiled == GL_FALSE) { std::cout \"fragment compilation failed \"; printShaderLog(fShader); } GLuint vProgram = glCreateProgram(); glAttachShader(vProgram, vShader); glAttachShader(vProgram, fShader); glLinkProgram(vProgram); checkOpenGLerror(); glGetProgramiv(vProgram, GL_LINK_STATUS, linked); if (linked == GL_FALSE) { std::cout \"linking failed \"; printProgramLog(vProgram); } return vProgram; // 返回着色器程序ID}/** 从文件中读取纹理图像并返回纹理 ID* @param imgPath 图像文件路径*/GLuint Util::loadTexture(const std::string imgPath){ GLuint textureID; textureID = SOIL_load_OGL_texture(imgPath.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y); if (textureID == 0) std::cout \"Failed to load texture: \" imgPath \" \"; return textureID;}// 黄金材质的环境光float *Util::goldAmbient(){ static float ambient[4] = { 0.2473f, 0.1995f, 0.0745f, 1.0f }; return ambient;}// 黄金材质的漫反射float *Util::goldDiffuse(){ static float diffuse[4] = { 0.7516f, 0.6065f, 0.2265f, 1.0f }; return diffuse;}// 黄金材质的镜面反射float *Util::goldSpecular(){ static float specular[4] = { 0.6283f, 0.5559f, 0.3661f, 1.0f }; return specular;}// 黄金材质的光泽度float Util::goldShininess(){ return 51.2f;}// 白银材质的环境光float *Util::silverAmbient(){ static float ambient[4] = { 0.1923f, 0.1923f, 0.1923f, 1.0f }; return ambient;}// 白银材质的漫反射float *Util::silverDiffuse(){ static float diffuse[4] = { 0.5075f, 0.5075f, 0.5075f, 1.0f }; return diffuse;}// 白银材质的镜面反射float *Util::silverSpecular(){ static float specular[4] = { 0.5083f, 0.5083f, 0.5083f, 1.0f }; return specular;}// 白银材质的光泽度float Util::silverShininess(){ return 51.2f;}// 青铜材质的环境光float *Util::bronzeAmbient(){ static float ambient[4] = { 0.2125f, 0.1275f, 0.054f, 1.0f }; return ambient;}// 青铜材质的漫反射float *Util::bronzeDiffuse(){ static float diffuse[4] = { 0.714f, 0.4284f, 0.18144f, 1.0f }; return diffuse;}// 青铜材质的镜面反射float *Util::bronzeSpecular(){ static float specular[4] = { 0.393548f, 0.271906f, 0.166721f, 1.0f }; return specular;}// 青铜材质的光泽度float Util::bronzeShininess(){ return 25.6f;} main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint mvLoc, projLoc, nLoc;// 光源属性GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;// 材质属性GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;glm::vec3 currentLightPos, lightPosV; // 模型和视觉空间中的光照位置float lightPos[3]; // 光照位置的浮点数组// 初始化光照位置glm::vec3 initialLightLoc = glm::vec3(5.0f, 2.0f, 2.0f);// 白光特性float globalAmbient[4] = { 0.7f, 0.7f, 0.7f, 1.0f };float lightAmbient[4] = { 0.0f, 0.0f, 0.0f, 1.0f };float lightDiffuse[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightSpecular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float *matAmb = Util::goldAmbient();float *matDif = Util::goldDiffuse();float *matSpe = Util::goldSpecular();float matShi = Util::goldShininess();//Sphere model(48);Torus model(48, 0.5f, 0.2f);//ImportedModel model(\"unicorn.obj\");static void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void installLights(glm::mat4 vMatrix){ // 将光源位置转换为视图空间坐标，存入浮点数组 lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0)); lightPos[0] = lightPosV.x; lightPos[1] = lightPosV.y; lightPos[2] = lightPosV.z; // 在着色器获取光源位置和材质属性 globalAmbLoc = glGetUniformLocation(renderProgram, \"globalAmbient\"); ambLoc = glGetUniformLocation(renderProgram, \"light.ambient\"); diffLoc = glGetUniformLocation(renderProgram, \"light.diffuse\"); specLoc = glGetUniformLocation(renderProgram, \"light.specular\"); posLoc = glGetUniformLocation(renderProgram, \"light.position\"); mAmbLoc = glGetUniformLocation(renderProgram, \"material.ambient\"); mDifLoc = glGetUniformLocation(renderProgram, \"material.diffuse\"); mSpecLoc = glGetUniformLocation(renderProgram, \"material.specular\"); mShiLoc = glGetUniformLocation(renderProgram, \"material.shininess\"); // 在着色器中为光源与材质统一变量赋值 glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient); glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient); glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse); glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular); glProgramUniform3fv(renderProgram, posLoc, 1, lightPos); glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb); glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif); glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe); glProgramUniform1f(renderProgram, mShiLoc, matShi);}void makeVertexArray(){ std::vectorint ind = model.getIndices(); std::vectorglm::vec3 vert = model.getVertices(); std::vectorglm::vec2 tex = model.getTexCoords(); std::vectorglm::vec3 norm = model.getNormals(); std::vectorfloat pvalues; // 顶点位置 std::vectorfloat tvalues; // 纹理坐标 std::vectorfloat nvalues; // 法向量 for (int i = 0; i model.getNumVertices(); ++ i) { pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z); } glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); glGenBuffers(numVBO, vbo); // 顶点坐标放入缓冲区0 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW); // 纹理坐标放入缓冲区1 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW); // 法向量放入缓冲区2 glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW); // 顶点索引放入缓冲区3 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), ind[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray();}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); nLoc = glGetUniformLocation(renderProgram, \"norm_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f)); mMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f)); // 基于当前光源位置，初始化光照 currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z); installLights(vMat); mvMat = vMat * mMat; // 构建 MV 矩阵的逆转置矩阵，用于变换法向量 invTrMat = glm::transpose(glm::inverse(mvMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(1); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); //glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices()); // 利用索引 vbo3 来查找要绘制的顶点 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Light\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 注意： 定义函数 installLights() 将光源在视觉空间中的位置和材质的 ADS 特性读入相应的统一变量。 直接对法向量应用 MV 矩阵不能保证法向量依然与物体表面垂直。使用 MV 矩阵的逆转置矩阵，用于变换法向量。 变量 lightPosV 包含光源在相机空间中的位置，每帧只需要计算一次。 顶点着色器和片段着色器 // vertex.glsl#version 460 corestruct PositionalLight{ vec4 ambient; vec4 diffuse; vec4 specular; vec3 position;};struct Material{ vec4 ambient; vec4 diffuse; vec4 specular; float shininess;};layout(location = 0) in vec3 vertPos;layout(location = 1) in vec3 vertNormal;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix; // 用于变换法向量uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;out vec4 color;void main(){ // 将顶点位置和法向量转换到视觉空间 // 计算视觉空间光照向量（从顶点到光源） vec4 P = mv_matrix * vec4(vertPos, 1.0); vec3 N = normalize((norm_matrix * vec4(vertNormal, 0.0)).xyz); vec3 L = normalize(light.position - P.xyz); // 视觉向量等于视觉空间中负顶点位置 vec3 V = normalize(-P.xyz); // R 是 -L 的相对于表面向量 N 的镜像 vec3 R = reflect(-L, N); // 环境光、漫反射和镜面反射分量 vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz; vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * max(dot(N, L), 0.0); vec3 specular = pow(max(dot(R, V), 0.0f), material.shininess) * material.specular.xyz * light.specular.xyz; // 将颜色输出到片段着色器 gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0); color = vec4(ambient + diffuse + specular, 1.0);} 注意： 字段选择器符号“.xyz”，是将 vec4 转换为仅包含其前 3 个元素的等效 vec3 的“快捷方式”。 normalize() 用来将向量转换为单位长度。 reflect() 函数用与计算一个向量基于另一个向量的反射。 dot() 函数为点乘运算。 // fragment.glsl#version 460 corein vec4 color;out vec4 fragColor;void main(){ fragColor = color;} Gouraud 着色容易受到其他伪影影响。 如果镜面高光范围内一个模型顶点也没有，那么它可能不会被渲染出来。 镜面反射分量是依顶点计算的，因此，当模型的所有顶点都没有镜面反射分量时，其栅格化后的像素也不会有镜面反射效果。 7.5.2 Phong 着色 该算法的结构类似 Gouraud 着色算法，不同之处在于光照计算是按像素而非顶点完成的。 顶点着色器 计算向量 N、L、V 输出属性 N、L、V、gl_position 片段着色器 传入插值 N、L、V 计算 R、θ、φ 计算 ADS 分量 输出颜色 将之前在顶点着色器中实现的过程移到片段着色器中进行。 故 main.cpp和 Util 类无需改变，只需修改着色器的代码。 对于原始的 Phong 进行优化： RRR 的计算是非必须的。 角 φ\\varphiφ 可以通过 LLL 和 VVV 的角平分线向量 HHH 得到。 H=L+VH = L + VH=L+V θ=12φ\\theta = \\frac{1}{2}\\varphiθ=21​φ 用 α\\alphaα 代替 φ\\varphiφ 就已经可以获得足够好的结果。 最后镜面反射分量在光泽度乘 3.0 作为改善镜面高光的微调。 顶点着色器和片段着色器 // vertex.glsl#version 460 corestruct PositionalLight{ vec4 ambient; vec4 diffuse; vec4 specular; vec3 position;};layout(location = 0) in vec3 vertPos;layout(location = 1) in vec3 vertNormal;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix; // 用于变换法向量uniform PositionalLight light;out vec3 normals; // 视觉空间顶点法向量out vec3 lightDir; // 指向光源的向量out vec3 halfVector;// 角平分线向量 Hvoid main(){ vec3 _vertPos; // 视觉空间中的顶点位置 // 输出顶点位置、光照方向和法向量到光栅着色器进行插值 _vertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz; lightDir = light.position - _vertPos; normals = (norm_matrix * vec4(vertNormal, 1.0)).xyz; halfVector = (lightDir + (-_vertPos)).xyz; gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment.glsl#version 460 corestruct PositionalLight{ vec4 ambient; vec4 diffuse; vec4 specular; vec3 position;};struct Material{ vec4 ambient; vec4 diffuse; vec4 specular; float shininess;};uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;in vec3 normals;in vec3 lightDir;in vec3 halfVector;out vec4 fragColor;void main(){ // 归一化光照向量、法向量、平分线向量 vec3 L = normalize(lightDir); vec3 N = normalize(normals); vec3 H = normalize(halfVector); // 计算光照与平面法向量间的角度 float cosTheta = dot(L, N); // 计算法向量 N 与角平分线向量 H 之间的角度 float cosPhi = dot(H, N); // 按像素计算 ADS 分量，合并构建输出颜色 vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz; vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * max(cosTheta, 0.0); vec3 specular = light.specular.xyz * material.specular.xyz * pow(max(cosPhi, 0.0), material.shininess * 3.0); fragColor = vec4(ambient + diffuse + specular, 1.0);} 7.6 结合光照和纹理 结合光照和纹理的方式取决于物体的特性及其纹理的目的： 纹理图像很写实地反映了物体真实的表面外观； 物体同时具有材质和纹理； 材质包括阴影和反射信息； 有多种光或多个纹理 当物体拥有一个简单的纹理，同时进行光照时，简单的方法是： 在片段着色器中完全将材质特性去除； 使用纹理取样所得纹理颜色代替材质的 ADS 值。 对于闪亮表面： 纹理颜色影响了环境光和漫反射分量，而镜面反射颜色仅由光源决定。 fragColor = textureColor * (ambient + diffuse) + specular; 对于非闪亮表面： 镜面高光部分应当包含物体表面颜色。 fragColor = textureColor * (ambient + diffuse + specular); 对于物体既有 ADS 材质，又有纹理图像，加权求和。 textureColor = texture(samp, texCoord);lightColor = (ambLight * ambMaterial) + (diffLight * diffMaterial) + specLight;fragColor = 0.5 * textureColor + 0.5 * lightColor; 结合了光照、材质、纹理，并能够扩展到多个光源、多种材质的情况。 texture1Color = texture(sampler1, texCoord);texture2Color = texture(sampler2, texCoord);light1Color = (ambLight1 * ambMaterial) + (diffLight1 * diffMaterial) + specLight1;light2Color = (ambLight2 * ambMaterial) + (diffLight2 * diffMaterial) + specLight2;fragColor = 0.25 * texture1Color + 0.25 * texture2Color + 0.25 * light1Color + 0.25 * light2Color; 稍作尝试的一个例子： 对于这个例子的代码（ImportedModel 类和 Util 类同之前）： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint mvLoc, projLoc, nLoc;GLuint textureID;// 光源属性GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;// 材质属性GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;glm::vec3 currentLightPos, lightPosV; // 模型和视觉空间中的光照位置float lightPos[3]; // 光照位置的浮点数组// 初始化光照位置glm::vec3 initialLightLoc = glm::vec3(5.0f, 2.0f, 2.0f);// 白光特性float globalAmbient[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightAmbient[4] = { 0.0f, 0.0f, 0.0f, 1.0f };float lightDiffuse[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightSpecular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float *matAmb = Util::bronzeAmbient();float *matDif = Util::bronzeDiffuse();float *matSpe = Util::bronzeSpecular();float matShi = Util::bronzeShininess();//Sphere model(48);//Torus model(48, 0.5f, 0.2f);// 加载的模型还不能使用索引ImportedModel model(\"model/velociraptor.obj\");static void windowSizeCallback(GLFWwindow *window, int width, int height){ aspect = static_castfloat(width) / static_castfloat(height); glViewport(0, 0, width, height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void installLights(glm::mat4 vMatrix){ // 将光源位置转换为视图空间坐标，存入浮点数组 lightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0)); lightPos[0] = lightPosV.x; lightPos[1] = lightPosV.y * 10.0f * cos(glfwGetTime() * 2.0f); lightPos[2] = lightPosV.z; // 在着色器获取光源位置和材质属性 globalAmbLoc = glGetUniformLocation(renderProgram, \"globalAmbient\"); ambLoc = glGetUniformLocation(renderProgram, \"light.ambient\"); diffLoc = glGetUniformLocation(renderProgram, \"light.diffuse\"); specLoc = glGetUniformLocation(renderProgram, \"light.specular\"); posLoc = glGetUniformLocation(renderProgram, \"light.position\"); mAmbLoc = glGetUniformLocation(renderProgram, \"material.ambient\"); mDifLoc = glGetUniformLocation(renderProgram, \"material.diffuse\"); mSpecLoc = glGetUniformLocation(renderProgram, \"material.specular\"); mShiLoc = glGetUniformLocation(renderProgram, \"material.shininess\"); // 在着色器中为光源与材质统一变量赋值 glProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient); glProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient); glProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse); glProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular); glProgramUniform3fv(renderProgram, posLoc, 1, lightPos); glProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb); glProgramUniform4fv(renderProgram, mDifLoc, 1, matDif); glProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe); glProgramUniform1f(renderProgram, mShiLoc, matShi);}void makeVertexArray(){ //std::vectorint ind = model.getIndices(); std::vectorglm::vec3 vert = model.getVertices(); std::vectorglm::vec2 tex = model.getTexCoords(); std::vectorglm::vec3 norm = model.getNormals(); std::vectorfloat pvalues; // 顶点位置 std::vectorfloat tvalues; // 纹理坐标 std::vectorfloat nvalues; // 法向量 for (int i = 0; i model.getNumVertices(); ++ i) { pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z); } glGenVertexArrays(numVAO, vao); glBindVertexArray(vao[0]); glGenBuffers(numVBO, vbo); // 顶点坐标放入缓冲区0 glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW); // 纹理坐标放入缓冲区1 glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW); // 法向量放入缓冲区2 glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW); // 顶点索引放入缓冲区3 //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); //glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), ind[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){ renderProgram = Util::createShadeProgram(\"Phong/vertex.glsl\", \"Phong/fragment.glsl\"); cameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f; glfwGetFramebufferSize(window, width, height); aspect = static_castfloat(width) / static_castfloat(height); pMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f); makeVertexArray(); textureID = Util::loadTexture(\"textureImg/ice.jpg\"); glBindTexture(GL_TEXTURE_2D, textureID);}void display(GLFWwindow *window, double currentTime){ glClear(GL_DEPTH_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(renderProgram); mvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\"); projLoc = glGetUniformLocation(renderProgram, \"proj_matrix\"); nLoc = glGetUniformLocation(renderProgram, \"norm_matrix\"); vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ)); mMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, -1.0f, 0.0f)); mMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f)); mMat *= glm::scale(glm::mat4(1.0f), glm::vec3(5.0f, 5.0f, 5.0f)); // 基于当前光源位置，初始化光照 currentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z); installLights(vMat); mvMat = vMat * mMat; // 构建 MV 矩阵的逆转置矩阵，用于变换法向量 invTrMat = glm::transpose(glm::inverse(mvMat)); glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat)); glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat)); glUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat)); glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(1); glBindBuffer(GL_ARRAY_BUFFER, vbo[2]); glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(2); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, textureID); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glGenerateMipmap(GL_TEXTURE_2D); if (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")) { GLfloat anisoSetting = 0.0f; glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting); } glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices()); // 利用索引 vbo3 来查找要绘制的顶点 //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]); //glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){ if (!glfwInit()) exit(EXIT_FAILURE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); GLFWwindow *window = glfwCreateWindow(800, 600, \"Light\", NULL, NULL); glfwMakeContextCurrent(window); if (glewInit() != GLEW_OK) exit(EXIT_FAILURE); glfwSwapInterval(1); glfwSetWindowSizeCallback(window, windowSizeCallback); init(window); while (!glfwWindowShouldClose(window)) { display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} 顶点着色器和片段着色器 // vertex.glsl#version 460 corestruct PositionalLight{ vec4 ambient; vec4 diffuse; vec4 specular; vec3 position;};layout(location = 0) in vec3 vertPos;layout(location = 1) in vec2 texCoord;layout(location = 2) in vec3 vertNormal;layout(binding = 0) uniform sampler2D samp;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix; // 用于变换法向量uniform PositionalLight light;out vec3 normals; // 视觉空间顶点法向量out vec3 lightDir; // 指向光源的向量out vec3 halfVector;// 角平分线向量 Hout vec2 tc;void main(){ vec3 _vertPos; // 视觉空间中的顶点位置 // 输出顶点位置、光照方向和法向量到光栅着色器进行插值 _vertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz; lightDir = light.position - _vertPos; normals = (norm_matrix * vec4(vertNormal, 1.0)).xyz; halfVector = (lightDir + (-_vertPos)).xyz; gl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0); tc = texCoord;} // fragment.glsl#version 460 corestruct PositionalLight{ vec4 ambient; vec4 diffuse; vec4 specular; vec3 position;};struct Material{ vec4 ambient; vec4 diffuse; vec4 specular; float shininess;};layout(binding = 0) uniform sampler2D samp;uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;in vec2 tc;in vec3 normals;in vec3 lightDir;in vec3 halfVector;out vec4 fragColor;void main(){ // 归一化光照向量、法向量、视觉向量 vec3 L = normalize(lightDir); vec3 N = normalize(normals); vec3 H = normalize(halfVector); // 计算光照与平面法向量间的角度 float cosTheta = dot(L, N); // 计算法向量 N 与角平分线向量 H 之间的角度 float cosPhi = dot(H, N); // 按像素计算 ADS 分量，合并构建输出颜色 vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz; vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * max(cosTheta, 0.0); vec3 specular = light.specular.xyz * material.specular.xyz * pow(max(cosPhi, 0.0), material.shininess * 3.0); vec4 textureColor = texture(samp, tc); vec4 lightColor = light.ambient + light.diffuse + light.specular; vec4 stripLightColor = vec4(ambient + diffuse + specular, 1.0); fragColor = 0.3 * textureColor + 0.7 * stripLightColor;} 八、阴影 8.1 投影阴影 投影阴影：给定一个位于 (x1,y1,z1)(x_1, y_1, z_1)(x1​,y1​,z1​) 的点光源，一个需要渲染的物体（物体上的点 (xw,yw,zw)(x_w, y_w, z_w)(xw​,yw​,zw​)）和一个投射阴影的平面，可以通过生成一个变换矩阵： (xw,yw,zw)→(xS,0,zS)(x_w, y_w, z_w)\\rightarrow(x_S,0,z_S) (xw​,yw​,zw​)→(xS​,0,zS​) 通常使用暗色物体与地平面纹理混合作为阴影的纹理。 投影阴影易于实现，但仅适用于平坦表面。 8.2 阴影体 找到被物体阴影覆盖的阴影体，之后减少视体与阴影体相交部分中的多边形的颜色强度。 阴影体的优点在于其高度准确，比起其他方法来更不容易产生伪影。 几何着色器可以用于计算阴影体，模板缓冲区可以用于判断像素 是否在阴影体内。有些显卡对于特定的阴影体操作优化提供了硬件支持。 8.3 阴影贴图 阴影贴图的想法：光线无法“看到”的任何东西都在阴影中。也就是说，如果对象 1 阻挡光线到达对象 2，等同于光线不能“看到”对象 2 所以计算策略是：暂时将相机移动到光的位置，应用 Z-buffer 算法，然后使用生成的深度信息来计算。 由此可得，渲染场景需要两轮： 第一轮从光源角度渲染场景（不绘制）。对于每个像素，深度缓冲区包含光源与最近的对象之间的距离。 生成深度缓冲区。 将深度缓冲区复制到纹理对象。 当纹理对象用于储存阴影深度信息时，称其为阴影纹理。 将深度缓冲区复制到纹理中的过程称为“阴影贴图”。 第二轮从相机角度渲染场景（正常渲染）。对于每个像素，在阴影纹理中查找相应的位置。 如果相机到渲染点的距离大于从阴影纹理检索到的值，则在该像素处绘制的对象离光源的距离比当前离光源最近的对象离光源更远，得出该像素处于阴影中。 阴影的处理：仅渲染环境光，忽略漫反射和镜面反射分量。 8.3.1 第一轮——从光源位置绘制 第一轮中并不是真的在显示其中绘制场景，故仅需用到顶点着色器。 通过变换矩阵（构建观察矩阵）移动相机： 相机移动到光源的位置 相机方向朝向呈现的区域 第一轮需要处理的细节： 配置缓冲区和阴影纹理。 禁用颜色输出。 在光源处为视野中的物体构建一个 LookAt 矩阵。 启用 GLSL 第一轮着色器程序，准备接受 MVP 矩阵。 M：对象的模型矩阵 V：LookAt 矩阵作为观察矩阵 P：透视矩阵 该 MVP 矩阵 称为 shadowMVP。 为每个对象创建一个 shadowMVP 矩阵，并调用 glDrawArrays()。 顶点着色器变成： #version 460 corelayout(location = 0) in vec3 vertPos;uniform mat4 shadowMVP;void main(){\tgl_Position = shadowMVP * vec4(vertPos, 1.0);} 片段着色器变成： #version 460 corevoid main() {} 8.3.2 将深度缓冲区复制到纹理 OpenGL 提供了两种将深度缓冲区深度数据放入纹理单元的方法： 生成空阴影纹理，然后使用命令 glCopyTexImage2D() 将活动的深度缓冲区复制到阴影纹理中。 在第一轮中构建“自定义帧缓冲区”，并使用命令 glFrameBufferTexture2D() 将阴影纹理附加到上面。 使用该方法无须将深度缓冲区复制到纹理，因为缓冲区已经附加了纹理，深度信息由 OpenGL 自动放入纹理中。 8.3.3 第二轮——从相机位置绘制 第二轮需要渲染完整的场景、其中的所有物体以及光照、材质和装饰场景中物体的纹理，同时还确定阴影。 使用两个 MVP 矩阵： 一个将对象坐标转换为屏幕坐标的标准 MVP 矩阵（像之前一样）； 一个是第一轮生成的 shadowMVP 矩阵，用于从光源的角度进行渲染，即从阴影纹理中查找深度信息。 从纹理贴图查找像素时，应该处理 OpenGL 相机空间使用 [−1,1][-1,1][−1,1] 而纹理贴图使用 [0,1][0,1][0,1] 空间的问题： 使用额外的变换矩阵 BBB。 用于从相机空间到纹理空间的转换 B=[0.5000.500.500.5000.50.50001]B = \\begin{bmatrix} 0.5 0 0 0.5 \\\\ 0 0.5 0 0.5 \\\\ 0 0 0.5 0.5 \\\\ 0 0 0 1\\\\ \\end{bmatrix} B=⎣⎢⎢⎢⎡​0.5000​00.500​000.50​0.50.50.51​⎦⎥⎥⎥⎤​ 将 BBB 和 shadowMVP 矩阵相乘，得到 shadowMVP2 矩阵。 第二轮的大概操作： 构建变换矩阵 BBB，用于从光照空间转换到纹理空间。 启用阴影纹理，进行查找。 启用颜色输出。 启用 GLSL 第二轮渲染程序。 根据相机正常位置为对象构建 MVP 矩阵。 构建 shadowMVP2 矩阵。着色器用其查找阴影纹理中的像素坐标。 将生成的变换矩阵发送到着色器统一变量。 启用包含顶点、法向量和纹理坐标的缓冲区。 调用 glDrawArrays()。 着色器的工作： 顶点着色器将顶点位置从相机空间转换为光照空间，将结果发送到顶点属性中的片段着色器。 片段着色器调用 textureProj() 函数指示像素是否处于引用中（返回0或1）。如果位于阴影中，则剔除漫反射和镜面反射。 使用特殊采样器变量类型 sampler2DShadow，可以附加到程序中的阴影纹理中。 关注细节：正在渲染的像素和阴影纹理中的值的深度比较 在模型空间中使用顶点坐标，与 shadowMVP2 相乘生成阴影纹理坐标（对应于投影到光照空间中的顶点坐标，是之前从光源视角生成的）。 经过插值后的光照空间（3D）坐标 (x, y, z) 在片段着色器中使用情况： z 分量表示从光到像素的距离； (x, y) 分量用于检索存储在阴影纹理（2D）中的深度信息。 将该检索的值（到最靠近光的物体的距离）与 z 进行比较。 例子效果展示如下图： 代码： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"const int numVAO = 1, numVBO = 5;GLuint vao[numVAO], vbo[numVBO];GLuint renderProgram1, renderProgram2;int width, height;float aspect;GLuint mvLoc, projLoc, nLoc, sLoc;GLuint textureID;// 光源属性GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;// 材质属性GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;glm::vec3 currentLightPos, lightPosV;\t// 模型和视觉空间中的光照位置float lightPos[3];\t// 光照位置的浮点数组// 白光特性float globalAmbient[4] = { 0.7f, 0.7f, 0.7f, 1.0f };float lightAmbient[4] = { 0.0f, 0.0f, 0.0f, 1.0f };float lightDiffuse[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightSpecular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };// 材质struct Material{\tfloat *ambient, *diffuse, *specular;\tfloat shininess;};Material gold{ Util::goldAmbient(), Util::goldDiffuse(), Util::goldSpecular(), Util::goldShininess() };Material silver{ Util::silverAmbient(), Util::silverDiffuse(), Util::silverSpecular(), Util::silverShininess() };// 阴影相关int scSizeX, scSizeY;GLuint shadowTex, shadowBuffer;glm::mat4 lightVmatrix, lightPmatrix;glm::mat4 shadowMVP1, shadowMVP2;glm::mat4 b;// 模型相关//Sphere model(48);Torus model1(48, 0.6f, 0.4f);// 加载的模型还不能使用索引ImportedModel model2(\"model/pyr.obj\");// 位置相关glm::vec3 cameraLoc(0.0f, 0.0f, 6.0f);glm::vec3 lightLoc(-3.8f, 2.2f, 1.1f);glm::vec3 model1Loc(1.6f, 0.0f, -0.3f);glm::vec3 model2Loc(-1.0f, 0.1f, 0.3f);static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void installLights(GLuint renderProgram, glm::mat4 vMatrix, Material m){\t// 将光源位置转换为视图空间坐标，存入浮点数组\tlightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));\tlightPos[0] = lightPosV.x;\tlightPos[1] = lightPosV.y;\tlightPos[2] = lightPosV.z;\t// 在着色器获取光源位置和材质属性\tglobalAmbLoc = glGetUniformLocation(renderProgram, \"globalAmbient\");\tambLoc = glGetUniformLocation(renderProgram, \"light.ambient\");\tdiffLoc = glGetUniformLocation(renderProgram, \"light.diffuse\");\tspecLoc = glGetUniformLocation(renderProgram, \"light.specular\");\tposLoc = glGetUniformLocation(renderProgram, \"light.position\");\tmAmbLoc = glGetUniformLocation(renderProgram, \"material.ambient\");\tmDifLoc = glGetUniformLocation(renderProgram, \"material.diffuse\");\tmSpecLoc = glGetUniformLocation(renderProgram, \"material.specular\");\tmShiLoc = glGetUniformLocation(renderProgram, \"material.shininess\");\t// 在着色器中为光源与材质统一变量赋值\tglProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);\tglProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);\tglProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);\tglProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);\tglProgramUniform3fv(renderProgram, posLoc, 1, lightPos);\tglProgramUniform4fv(renderProgram, mAmbLoc, 1, m.ambient);\tglProgramUniform4fv(renderProgram, mDifLoc, 1, m.diffuse);\tglProgramUniform4fv(renderProgram, mSpecLoc, 1, m.specular);\tglProgramUniform1f(renderProgram, mShiLoc, m.shininess);}void makeVertexArray(){\t// model1的顶点构建\tstd::vectorint model1Ind = model1.getIndices();\tstd::vectorglm::vec3 vert = model1.getVertices();\tstd::vectorglm::vec3 norm = model1.getNormals();\tstd::vectorfloat model1Pvalues;\t// 顶点位置\tstd::vectorfloat model1Nvalues;\t// 法向量\tfor (int i = 0; i model1.getNumVertices(); ++ i)\t{ model1Pvalues.push_back(vert[i].x); model1Pvalues.push_back(vert[i].y); model1Pvalues.push_back(vert[i].z); model1Nvalues.push_back(norm[i].x); model1Nvalues.push_back(norm[i].y); model1Nvalues.push_back(norm[i].z);\t}\t// model2的顶点构建\tvert = model2.getVertices();\tnorm = model2.getNormals();\tstd::vectorfloat model2Pvalues;\t// 顶点位置\tstd::vectorfloat model2Nvalues;\t// 法向量\tfor (int i = 0; i model2.getNumVertices(); ++ i)\t{ model2Pvalues.push_back(vert[i].x); model2Pvalues.push_back(vert[i].y); model2Pvalues.push_back(vert[i].z); model2Nvalues.push_back(norm[i].x); model2Nvalues.push_back(norm[i].y); model2Nvalues.push_back(norm[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// model1\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, 4 * model1Pvalues.size(), model1Pvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, 4 * model1Nvalues.size(), model1Nvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * model1Ind.size(), model1Ind[0], GL_STATIC_DRAW);\t// model2\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglBufferData(GL_ARRAY_BUFFER, 4 * model2Pvalues.size(), model2Pvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[4]);\tglBufferData(GL_ARRAY_BUFFER, 4 * model2Nvalues.size(), model2Nvalues[0], GL_STATIC_DRAW);}void setupShadowBuffers(GLFWwindow *window){\tglfwGetFramebufferSize(window, width, height);\tscSizeX = width;\tscSizeY = height;\t// 创建自定义帧缓冲区\tglGenFramebuffers(1, shadowBuffer);\t// 创建阴影纹理并让它存储深度信息\tglGenTextures(1, shadowTex);\tglBindTexture(GL_TEXTURE_2D, shadowTex);\tglTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT32, scSizeX, scSizeY, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);}void init(GLFWwindow *window){\trenderProgram1 = Util::createShadeProgram(\"shadows/vertex1.glsl\", \"shadows/fragment1.glsl\");\trenderProgram2 = Util::createShadeProgram(\"shadows/vertex2.glsl\", \"shadows/fragment2.glsl\");\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();\tsetupShadowBuffers(window);\tb = glm::mat4( 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f);}void passOne(){\tglUseProgram(renderProgram1);\t// 绘制model1\tmMat = glm::translate(glm::mat4(1.0f), model1Loc);\tmMat = glm::rotate(mMat, 25.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\tshadowMVP1 = lightPmatrix * lightVmatrix * mMat;\tsLoc = glGetUniformLocation(renderProgram1, \"shadowMVP\");\tglUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP1));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglClear(GL_DEPTH_BUFFER_BIT);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[2]);\tglDrawElements(GL_TRIANGLES, model1.getNumIndices(), GL_UNSIGNED_INT, 0);\t// 绘制model2\tmMat = glm::translate(glm::mat4(1.0f), model2Loc);\tmMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\tmMat = glm::rotate(mMat, 40.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f));\tshadowMVP1 = lightPmatrix * lightVmatrix * mMat;\tglUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP1));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\tglDrawArrays(GL_TRIANGLES, 0, model2.getNumVertices());}void passTwo(){\tglUseProgram(renderProgram2);\tmvLoc = glGetUniformLocation(renderProgram2, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram2, \"proj_matrix\");\tnLoc = glGetUniformLocation(renderProgram2, \"norm_matrix\");\tsLoc = glGetUniformLocation(renderProgram2, \"shadowMVP\");\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));\t// 绘制model1\tmMat = glm::translate(glm::mat4(1.0f), model1Loc);\tmMat = glm::rotate(mMat, 25.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\tcurrentLightPos = glm::vec3(lightLoc);\tinstallLights(renderProgram2, vMat, gold);\tmvMat = vMat * mMat;\tinvTrMat = glm::transpose(glm::inverse(mvMat));\tshadowMVP2 = b * lightPmatrix * lightVmatrix * mMat;\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));\tglUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP2));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[1]);\tglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglClear(GL_DEPTH_BUFFER_BIT);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[2]);\tglDrawElements(GL_TRIANGLES, model1.getNumIndices(), GL_UNSIGNED_INT, 0);\t// 绘制model2\tmMat = glm::translate(glm::mat4(1.0f), model2Loc);\tmMat = glm::rotate(mMat, 30.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\tmMat = glm::rotate(mMat, 40.0f * 3.14159f / 180.0f, glm::vec3(0.0f, 1.0f, 0.0f));\tcurrentLightPos = glm::vec3(lightLoc);\tinstallLights(renderProgram2, vMat, silver);\tmvMat = vMat * mMat;\tinvTrMat = glm::transpose(glm::inverse(mvMat));\tshadowMVP2 = b * lightPmatrix * lightVmatrix * mMat;\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));\tglUniformMatrix4fv(sLoc, 1, GL_FALSE, glm::value_ptr(shadowMVP2));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);\tglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\tglDrawArrays(GL_TRIANGLES, 0, model2.getNumVertices());}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tcurrentLightPos = glm::vec3(lightLoc);\tlightVmatrix = glm::lookAt(currentLightPos, glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));\tlightPmatrix = glm::perspective(60.0f * 3.14159f / 180.0f, aspect, 0.1f, 1000.0f);\tglBindFramebuffer(GL_FRAMEBUFFER, shadowBuffer);\tglFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, shadowTex, 0);\tglDrawBuffer(GL_NONE);\tglEnable(GL_DEPTH_TEST);\tglEnable(GL_POLYGON_OFFSET_FILL);\tglPolygonOffset(2.0f, 4.0f);\tpassOne();\tglDisable(GL_POLYGON_OFFSET_FILL);\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_2D, shadowTex);\tglDrawBuffer(GL_FRONT);\tpassTwo();}int main(){\tif (!glfwInit())\texit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Light\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK)\texit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 第一轮的着色器 // vertex1.glsl#version 460 corelayout(location = 0) in vec3 vertPos;uniform mat4 shadowMVP;void main(){\tgl_Position = shadowMVP * vec4(vertPos, 1.0);} // fragment1.glsl#version 460 corevoid main(){} 第二轮的着色器 // vertex2.glsl#version 460struct PositionalLight{\tvec4 ambient, diffuse, specular;\tvec3 position;};struct Material{\tvec4 ambient, diffuse, specular;\tfloat shininess;};layout(location = 0) in vec3 vertPos;layout(location = 1) in vec3 vertNormal;out vec3 vNormal, vLightDir, vVertPos, vHalfVec;out vec4 shadowCoord;uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix;uniform mat4 shadowMVP;void main(){\t// 输出顶点位置\tvVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;\t// 获取一个从顶点到光线的向量并输出\tvLightDir = light.position - vVertPos;\t// 在视图空间中获得一个顶点法向量输出\tvNormal = (norm_matrix * vec4(vertNormal, 0.0)).xyz;\t// 计算顶点的半向量\tvHalfVec = (vLightDir - vVertPos).xyz;\tshadowCoord = shadowMVP * vec4(vertPos, 1.0);\tgl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment2.glsl#version 460 corestruct PositionalLight{\tvec4 ambient, diffuse, specular;\tvec3 position;};struct Material{\tvec4 ambient, diffuse, specular;\tfloat shininess;};in vec3 vNormal, vLightDir, vVertPos, vHalfVec;in vec4 shadowCoord;out vec4 fragColor;uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix;uniform mat4 shadowMVP;layout(binding = 0) uniform sampler2DShadow shadowTex;void main(){\tvec3 L = normalize(vLightDir);\tvec3 N = normalize(vNormal);\tvec3 V = normalize(-vVertPos);\tvec3 H = normalize(vHalfVec);\tfloat inShadow = textureProj(shadowTex, shadowCoord);\tfragColor = globalAmbient * material.ambient + light.ambient * material.ambient;\tif (inShadow != 0.0)\t{ fragColor += light.diffuse * material.diffuse * max(dot(L, N), 0.0) + light.specular * material.specular * pow(max(dot(H, N), 0.0), material.shininess * 3);\t}} 8.4 柔和阴影 使用百分比临近滤波 PCF 生成柔和阴影。 一种用于实现 PCF 的常见算法是： 对每个像素附近的 4 个纹元（纹理图像像素）进行采样，其中样本通过像素对应纹元的特定偏移量选择。 对于每个像素，都需要改变偏移量，并用新的偏移量确定采样的 4 个纹元。 使用交错的方式改变偏移量的方法被称为抖动，它旨在使柔和阴影的边界不会由于采样点不足而看起来“结块”。 假设有4种偏移模式，每次取一种计算像素 glFragCorrd mod 2 值选择当前偏移，结果可能为：(0,0)、(1,0)、(0,1)、(1,1)。 偏移模式通常在 x 和 y 方向上指定，具有-1.5、-0.5、+0.5和+1.5不同组合： 4种计算结果对应的偏移模式采样点如下表 计算结果 (0,0) (0,1) (1,0) (1,1) (sx−1.5,sy+1.5)(s_x-1.5,s_y+1.5)(sx​−1.5,sy​+1.5) (sx−1.5,sy+0.5)(s_x-1.5,s_y+0.5)(sx​−1.5,sy​+0.5) (sx−0.5,sy+1.5)(s_x-0.5,s_y+1.5)(sx​−0.5,sy​+1.5) (sx−0.5,sy+0.5)(s_x-0.5,s_y+0.5)(sx​−0.5,sy​+0.5) (sx−1.5,sy−0.5)(s_x-1.5,s_y-0.5)(sx​−1.5,sy​−0.5) (sx−1.5,sy−1.5)(s_x-1.5,s_y-1.5)(sx​−1.5,sy​−1.5) (sx−0.5,sy−0.5)(s_x-0.5,s_y-0.5)(sx​−0.5,sy​−0.5) (sx−0.5,sy−1.5)(s_x-0.5,s_y-1.5)(sx​−0.5,sy​−1.5) (sx+0.5,sy+1.5)(s_x+0.5,s_y+1.5)(sx​+0.5,sy​+1.5) (sx+0.5,sy+0.5)(s_x+0.5,s_y+0.5)(sx​+0.5,sy​+0.5) (sx+1.5,sy+1.5)(s_x+1.5,s_y+1.5)(sx​+1.5,sy​+1.5) (sx+1.5,sy+0.5)(s_x+1.5,s_y+0.5)(sx​+1.5,sy​+0.5) (sx+0.5,sy−0.5)(s_x+0.5,s_y-0.5)(sx​+0.5,sy​−0.5) (sx+0.5,sy−1.5)(s_x+0.5,s_y-1.5)(sx​+0.5,sy​−1.5) (sx+1.5,sy−0.5)(s_x+1.5,s_y-0.5)(sx​+1.5,sy​−0.5) (sx+1.5,sy−1.5)(s_x+1.5,s_y-1.5)(sx​+1.5,sy​−1.5) 假设随便一组，对其4个采样点分别调用 textureProj()，将得到的4个结果相加求平均，确定阴影中采样点的百分比，以此百分比作系数，确定渲染当前像素时要应用的漫反射和镜面反射分量。 采样点可以有多个，但渲染速度也会随之下降。 64个采样点柔和阴影效果如下： 仅需修改第二轮的片段着色器： fragment2.glsl #version 460 corestruct PositionalLight{\tvec4 ambient, diffuse, specular;\tvec3 position;};struct Material{\tvec4 ambient, diffuse, specular;\tfloat shininess;};in vec3 vNormal, vLightDir, vVertPos, vHalfVec;in vec4 shadowCoord;out vec4 fragColor;uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix;uniform mat4 shadowMVP;layout(binding = 0) uniform sampler2DShadow shadowTex;float lookup(float ox, float oy){\tfloat t = textureProj(shadowTex, shadowCoord + vec4(ox * 0.001 * shadowCoord.w, oy * 0.001 * shadowCoord.w, -0.01, 0.0));\treturn t;}void main(){\tfloat shadowFactor = 0.0;\tvec3 L = normalize(vLightDir);\tvec3 N = normalize(vNormal);\tvec3 V = normalize(-vVertPos);\tvec3 H = normalize(vHalfVec);\tfloat swidth = 2.5;\t// 可调整的阴影扩散量\t// 64 个采样点\tfloat endp = swidth * 3.0 + swidth / 2.0;\tfor (float m = -endp; m = endp; m += swidth) for (float n = -endp; n = endp; n += swidth) shadowFactor += lookup(m, n);\tshadowFactor /= 64.0;\tvec4 shadowColor = globalAmbient * material.ambient + light.ambient * material.ambient;\tvec4 lightedColor = light.diffuse * material.diffuse * max(dot(L, N), 0.0) + light.specular * material.specular * pow(max(dot(H, N), 0.0), material.shininess * 3.0);\tfragColor = vec4((shadowColor.xyz + shadowFactor * (lightedColor.xyz)), 1.0);} 有些时候，在场景中的某些对象拥有纹理时，添加阴影时必须确保片段着色器正确区分阴影纹理和其他纹理。一种简单的方法是将它们绑定到不同的纹理单元： layout(binding = 0) uniform sampler2DShadow shadowTex;layout(binding = 1) uniform sampler2D tex; 然后通过绑定值引用两个采样器。 当场景使用多个灯光时，则需要多个阴影纹理，即每个光源需要一个阴影纹理。 每个光源都需要单独执行第 1 轮渲染，并在第 2 轮渲染中合并结果。 九、天空和背景 9.1 天空盒 天空盒： 实例化一个立方体对象 将立方体的纹理设置为所需的环境 将立方体围绕相机设置 如何为地平线制作纹理： 使用一个包含6个面的纹理图像。 可使用 Terragen、Blender、PS等软件工具辅助构建贴图图像。 如何让天空盒看起来距离很远： 确保纹理表现看起来像远处的地平线。 禁用深度测试并先渲染天空盒，然后启用深度测试再渲染其他对象。 深度缓冲区的值仍全设为1.0（最远距离）。 使天空盒随着相机移动。 9.2 穹顶 与天空盒类似，不过使用带纹理的球体或半球体代替带纹理的立方体。 一样需要先禁用深度测试渲染穹顶，再将相机置于穹顶的中心位置。 穹顶相比天空盒： 优点：不易受到畸变和接缝的影响（尽管在纹理图像 中必须考虑极点处的球形畸变）。 缺点：球体或穹顶模型比立方体模型更复杂，穹顶有更多的顶点，其数量取决于期望的精度。 9.3 实现天空盒 9.3.1 从头开始构建天空盒 效果如下图： 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"const int numVAO = 1, numVBO = 5;GLuint vao[numVAO], vbo[numVBO];GLuint renderProgram;int width, height;float aspect;GLuint mvLoc, projLoc;GLuint textureID, skyboxTex;glm::mat4 pMat, vMat, mMat, mvMat;// 模型相关//Sphere model(48);Torus model(48, 0.5f, 0.2f);// 加载的模型还不能使用索引//ImportedModel model2(\"model/pyr.obj\");// 位置相关glm::vec3 cameraLoc(0.0f, 0.0f, 5.0f);glm::vec3 modelLoc(0.0f, -0.75, 0.0f);static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){\t// 立方体天空盒\tfloat cubeVertexPositions[108] =\t{ -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f\t};\tfloat cubeTextureCoord[72] =\t{ 1.00f, 0.666666f, 1.00f, 0.333333f, 0.75f, 0.333333f, 0.75f, 0.333333f, 0.75f, 0.666666f, 1.00f, 0.666666f, 0.75f, 0.333333f, 0.50f, 0.333333f, 0.75f, 0.666666f, 0.50f, 0.333333f, 0.50f, 0.666666f, 0.75f, 0.666666f, 0.50f, 0.333333f, 0.25f, 0.333333f, 0.50f, 0.666666f, 0.25f, 0.333333f, 0.25f, 0.666666f, 0.50f, 0.666666f, 0.25f, 0.333333f, 0.00f, 0.333333f, 0.25f, 0.666666f, 0.00f, 0.333333f, 0.00f, 0.666666f, 0.25f, 0.666666f, 0.25f, 0.333333f, 0.50f, 0.333333f, 0.50f, 0.000000f, 0.50f, 0.000000f, 0.25f, 0.000000f, 0.25f, 0.333333f, 0.25f, 1.000000f, 0.50f, 1.000000f, 0.50f, 0.666666f, 0.50f, 0.666666f, 0.25f, 0.666666f, 0.25f, 1.000000f,\t};\tstd::vectorint modelInd = model.getIndices();\tstd::vectorglm::vec3 vert = model.getVertices();\tstd::vectorglm::vec2 tex = model.getTexCoords();\tstd::vectorglm::vec3 norm = model.getNormals();\tstd::vectorfloat modelPvalues;\t// 顶点位置\tstd::vectorfloat modelTvalues;\t// 纹理坐标\tstd::vectorfloat modelNvalues;\t// 法向量\tfor (int i = 0; i model.getNumVertices(); ++ i)\t{ modelPvalues.push_back(vert[i].x); modelPvalues.push_back(vert[i].y); modelPvalues.push_back(vert[i].z); modelTvalues.push_back(tex[i].s); modelTvalues.push_back(tex[i].t); modelNvalues.push_back(norm[i].x); modelNvalues.push_back(norm[i].y); modelNvalues.push_back(norm[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// 天空盒\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, sizeof(cubeTextureCoord), cubeTextureCoord, GL_STATIC_DRAW);\t// model\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ARRAY_BUFFER, 4 * modelPvalues.size(), modelPvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglBufferData(GL_ARRAY_BUFFER, 4 * modelTvalues.size(), modelTvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * modelInd.size(), modelInd[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){\trenderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\");\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();\ttextureID = Util::loadTexture(\"textureImg/brick1.jpg\");\tskyboxTex = Util::loadTexture(\"textureImg/alien.jpg\");\tglBindTexture(GL_TEXTURE_2D, textureID);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));\t// 天空盒\tglUseProgram(renderProgram);\t// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置\tmMat = glm::translate(glm::mat4(1.0f), cameraLoc);\tmvMat = vMat * mMat;\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_2D, skyboxTex);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW); // 观察立方体内部，反转方向\tglDisable(GL_DEPTH_TEST);\t// 无深度测试下绘制天空盒\tglDrawArrays(GL_TRIANGLES, 0, 36);\tglEnable(GL_DEPTH_TEST);\t// 绘制场景对象\tglUseProgram(renderProgram);\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tmMat = glm::translate(glm::mat4(1.0f), modelLoc);\tmMat = glm::rotate(mMat, glm::radians(15.0f), glm::vec3(1.0f, 0.0f, 0.0f));\tmvMat = vMat * mMat;\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_2D, textureID);\tglClear(GL_DEPTH_BUFFER_BIT);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglDepthFunc(GL_LEQUAL);\tglDrawArrays(GL_TRIANGLES, 0, 36);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);\tglDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){\tif (!glfwInit())\texit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Skybox\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK)\texit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 顶点着色器和片段着色器 // vertex.glsl#version 460 corelayout(location = 0) in vec3 vertPos;layout(location = 1) in vec2 texCoord;out vec2 tc;uniform mat4 mv_matrix;uniform mat4 proj_matrix;void main(){\ttc = texCoord;\tgl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment.glsl#version 460 corein vec2 tc;out vec4 fragColor;layout(binding = 0) uniform sampler2D s;void main(){\tfragColor = texture(s, tc);} 9.3.2 使用OpenGL立方体贴图 OpenGL 纹理立方体贴图使用带有 3 个变量的纹理坐标 (s,t,r)(s, t, r)(s,t,r) 访问。 立方体贴图的另一个特性是，其中的图像以纹理图像的左上角作为纹理坐标 (0,0,0)(0, 0, 0)(0,0,0)。 另外定义函数 loadCubeMap() 函数读入6个单独的立方体面图像文件，以这种形式再调用 SOIL_load_OGL_cubemap() 进行构建纹理。该函数置于 Util 类中。 效果截图： 代码如下： 新增函数 GLuint Util::loadCubeMap(const std::string mapDirPath){\tGLuint textureRef;\tstd::string xp = mapDirPath + \"/xp.jpg\";\tstd::string xn = mapDirPath + \"/xn.jpg\";\tstd::string yp = mapDirPath + \"/yp.jpg\";\tstd::string yn = mapDirPath + \"/yn.jpg\";\tstd::string zp = mapDirPath + \"/zp.jpg\";\tstd::string zn = mapDirPath + \"/zn.jpg\";\ttextureRef = SOIL_load_OGL_cubemap(xp.c_str(), xn.c_str(), yp.c_str(), yn.c_str(), zp.c_str(), zn.c_str(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_MIPMAPS);\tif (textureRef == 0)\tstd::cout \"Failed to load texture: \" mapDirPath \" \";\treturn textureRef;} main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];GLuint renderProgram, renderProgramCubeMap;int width, height;float aspect;GLuint mvLoc, projLoc, vLoc;GLuint textureID, skyboxTex;glm::mat4 pMat, vMat, mMat, mvMat;// 模型相关//Sphere model(48);Torus model(48, 0.8f, 0.4f);// 加载的模型还不能使用索引//ImportedModel model2(\"model/pyr.obj\");// 位置相关glm::vec3 cameraLoc(0.0f, 0.0f, 5.0f);glm::vec3 modelLoc(0.0f, 0.0f, 0.0f);static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){\t// 立方体天空盒\tfloat cubeVertexPositions[108] =\t{ -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f\t};\tstd::vectorint modelInd = model.getIndices();\tstd::vectorglm::vec3 vert = model.getVertices();\tstd::vectorglm::vec2 tex = model.getTexCoords();\tstd::vectorglm::vec3 norm = model.getNormals();\tstd::vectorfloat modelPvalues;\t// 顶点位置\tstd::vectorfloat modelTvalues;\t// 纹理坐标\tstd::vectorfloat modelNvalues;\t// 法向量\tfor (int i = 0; i model.getNumVertices(); ++ i)\t{ modelPvalues.push_back(vert[i].x); modelPvalues.push_back(vert[i].y); modelPvalues.push_back(vert[i].z); modelTvalues.push_back(tex[i].s); modelTvalues.push_back(tex[i].t); modelNvalues.push_back(norm[i].x); modelNvalues.push_back(norm[i].y); modelNvalues.push_back(norm[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// 天空盒\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);\t// model\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, 4 * modelPvalues.size(), modelPvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ARRAY_BUFFER, 4 * modelTvalues.size(), modelTvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * modelInd.size(), modelInd[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){\trenderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\");\trenderProgramCubeMap = Util::createShadeProgram(\"vertexCubeMap.glsl\", \"fragmentCubeMap.glsl\");\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();\ttextureID = Util::loadTexture(\"textureImg/brick1.jpg\");\tskyboxTex = Util::loadCubeMap(\"textureImg/cubeMap\"); // 尝试混合立方体相邻的边以减少或消除接缝\tglEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);\tglBindTexture(GL_TEXTURE_2D, textureID);\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));\t// 天空盒\tglUseProgram(renderProgramCubeMap);\t// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置\tvLoc = glGetUniformLocation(renderProgramCubeMap, \"v_matrix\");\tglUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(vMat));\tprojLoc = glGetUniformLocation(renderProgramCubeMap, \"p_matrix\");\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTex);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglDisable(GL_DEPTH_TEST);\t// 无深度测试下绘制天空盒\tglDrawArrays(GL_TRIANGLES, 0, 36);\tglEnable(GL_DEPTH_TEST);\t// 绘制场景对象\tglUseProgram(renderProgram);\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tmMat = glm::translate(glm::mat4(1.0f), modelLoc);\tmMat = glm::rotate(mMat, glm::radians(35.0f), glm::vec3(1.0f, 0.0f, 0.0f));\tmvMat = vMat * mMat;\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_2D, textureID);\tglClear(GL_DEPTH_BUFFER_BIT);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglDepthFunc(GL_LEQUAL);\tglDrawArrays(GL_TRIANGLES, 0, 36);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);\tglDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){\tif (!glfwInit())\texit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Skybox\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK)\texit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 立方体贴图着色器 // vertexCubeMap.glsl#version 460 corelayout(location = 0) in vec3 vertPos;out vec3 tc;uniform mat4 v_matrix;uniform mat4 p_matrix;void main(){\ttc = vertPos;\tmat4 v3_matrix = mat4(mat3(v_matrix)); // 大小转换为 3×3，然后转换回 4×4。移除了平移分量，同时保留了旋转（平移值在转换矩阵的第四列中）\tgl_Position = p_matrix * v3_matrix * vec4(vertPos, 1.0);} // fragmentCubeMap.glsl#version 460 corein vec3 tc;out vec4 fragColor;layout(binding = 0) uniform samplerCube samp;void main(){\tfragColor = texture(samp, tc);} 描绘场景的着色器 // vertex.glsl#version 460 corelayout(location = 0) in vec3 vertPos;layout(location = 1) in vec2 texCoord;out vec2 tc;uniform mat4 mv_matrix;uniform mat4 proj_matrix;void main(){\ttc = texCoord;\tgl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment.glsl#version 460 corein vec2 tc;out vec4 fragColor;layout(binding = 0) uniform sampler2D s;void main(){\tfragColor = texture(s, tc);} 9.4 环境贴图 环境贴图：使用立方体贴图来构造反射对象本身。 在光照时计算过反射向量，现在使用反射向量从纹理贴图中查找值。 仍然需要两组着色器，一组用于立方体贴图，一组用于场景物体（环面）。 程序上： makeVertexArray() 函数中： 构建环面的法向量缓冲区 去掉环面的纹理坐标缓冲区 display() 函数中： 创建变换法向量的矩阵并关联到统一变量 激活环面法向量缓冲区 激活立方体贴图为环面的纹理 顶点着色器中： 输出变换的顶点和法向量，用于计算反射向量 片段着色器中： 计算反射向量 从立方体贴图使用反射向量检索输出颜色 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];GLuint renderProgram, renderProgramCubeMap;int width, height;float aspect;GLuint mvLoc, projLoc, vLoc, nLoc;GLuint skyboxTex;float rotAmt;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;// 模型相关//Sphere model(48);Torus model(48, 0.8f, 0.4f);// 加载的模型还不能使用索引//ImportedModel model2(\"model/pyr.obj\");// 位置相关glm::vec3 cameraLoc(0.0f, 0.0f, 5.0f);glm::vec3 modelLoc(0.0f, 0.0f, 0.0f);static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void makeVertexArray(){\t// 立方体天空盒\tfloat cubeVertexPositions[108] =\t{ -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f\t};\tstd::vectorint modelInd = model.getIndices();\tstd::vectorglm::vec3 vert = model.getVertices();\tstd::vectorglm::vec2 tex = model.getTexCoords();\tstd::vectorglm::vec3 norm = model.getNormals();\tstd::vectorfloat modelPvalues;\t// 顶点位置\tstd::vectorfloat modelTvalues;\t// 纹理坐标\tstd::vectorfloat modelNvalues;\t// 法向量\tfor (int i = 0; i model.getNumVertices(); ++ i)\t{ modelPvalues.push_back(vert[i].x); modelPvalues.push_back(vert[i].y); modelPvalues.push_back(vert[i].z); modelTvalues.push_back(tex[i].s); modelTvalues.push_back(tex[i].t); modelNvalues.push_back(norm[i].x); modelNvalues.push_back(norm[i].y); modelNvalues.push_back(norm[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// 天空盒\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);\t// model\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, 4 * modelPvalues.size(), modelPvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ARRAY_BUFFER, 4 * modelTvalues.size(), modelTvalues[0], GL_STATIC_DRAW);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * modelInd.size(), modelInd[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){\trenderProgram = Util::createShadeProgram(\"vertex.glsl\", \"fragment.glsl\");\trenderProgramCubeMap = Util::createShadeProgram(\"vertexCubeMap.glsl\", \"fragmentCubeMap.glsl\");\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();\tskyboxTex = Util::loadCubeMap(\"textureImg/lakeCubeMap\");\tglEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));\t// 天空盒\tglUseProgram(renderProgramCubeMap);\t// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置\tvLoc = glGetUniformLocation(renderProgramCubeMap, \"v_matrix\");\tglUniformMatrix4fv(vLoc, 1, GL_FALSE, glm::value_ptr(vMat));\tprojLoc = glGetUniformLocation(renderProgramCubeMap, \"p_matrix\");\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTex);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglDisable(GL_DEPTH_TEST);\t// 无深度测试下绘制天空盒\tglDrawArrays(GL_TRIANGLES, 0, 36);\tglEnable(GL_DEPTH_TEST);\t// 绘制场景对象\tglUseProgram(renderProgram);\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tnLoc = glGetUniformLocation(renderProgram, \"norm_matrix\");\trotAmt = currentTime * 0.5f;\tmMat = glm::translate(glm::mat4(1.0f), modelLoc);\tmMat = glm::rotate(mMat, rotAmt, glm::vec3(1.0f, 0.0f, 0.0f));\tmvMat = vMat * mMat;\tinvTrMat = glm::transpose(glm::inverse(mvMat));\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\t// 环面纹理现在是立方体贴图\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTex);\tglClear(GL_DEPTH_BUFFER_BIT);\tglEnable(GL_CULL_FACE);\tglFrontFace(GL_CCW);\tglDepthFunc(GL_LEQUAL);\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);\tglDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){\tif (!glfwInit())\texit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Skybox\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK)\texit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 描绘场景的着色器 // vertex.glsl#version 460 corelayout(location = 0) in vec3 vertPos;layout(location = 1) in vec3 normal;out vec3 vNormal;out vec3 vVertPos;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix;void main(){\tvVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;\tvNormal = (norm_matrix * vec4(normal, 0.0)).xyz;\tgl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment.glsl#version 460 corein vec3 vVertPos;in vec3 vNormal;out vec4 fragColor;layout(binding = 0) uniform samplerCube t;void main(){\tvec3 r = -reflect(normalize(-vVertPos), normalize(vNormal));\tfragColor = texture(t, r);} 环境贴图的主要限制之一是它只能构建反射立方体贴图内容的对象。 在场景中渲染的其他对象并不会出现在使用贴图模拟反射的对象中。 可以使用模板缓冲区或其他教程实现反射出多个物体的效果。 使用 SOIL2 可以很方便加载纹理贴图，但也有其他方法： 使用 stb_image.h： 包含头文件 使用 glGenTextures() 为立方体贴图创建纹理及其 ID 使用 glBindTexture() 指定纹理 ID 和 GL_TEXTURE_CUBE_MAP 使用 stbi_load() 加载纹理文件 使用 glTexImage2D() 将图像分配给立方体的各个面 SOIL2 以及包含文件 stb_image.h 也许Terragen对于制作贴图不错。 十、增强表面细节 10.1 凹凸贴图 如果想让一个物体看起来好像有凹凸，一种方法是计算表面确实凹凸不平时其上的法向量，然后模拟法向量。 使用正弦函数生成凹凸不平的法向量。 顶点着色器需要将未经变换的顶点传递给片段着色器 效果如图： 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 4;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint mvLoc, projLoc, nLoc;// 光源属性GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;// 材质属性GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;glm::vec3 currentLightPos, lightPosV; // 模型和视觉空间中的光照位置float lightPos[3]; // 光照位置的浮点数组// 初始化光照位置glm::vec3 initialLightLoc = glm::vec3(5.0f, 2.0f, 2.0f);// 白光特性float globalAmbient[4] = { 0.7f, 0.7f, 0.7f, 1.0f };float lightAmbient[4] = { 0.0f, 0.0f, 0.0f, 1.0f };float lightDiffuse[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightSpecular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float *matAmb = Util::silverAmbient();float *matDif = Util::silverDiffuse();float *matSpe = Util::silverSpecular();float matShi = Util::silverShininess();//Sphere model(48);Torus model(48, 0.5f, 0.2f);//ImportedModel model(\"unicorn.obj\");static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void installLights(glm::mat4 vMatrix){\t// 将光源位置转换为视图空间坐标，存入浮点数组\tlightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));\tlightPos[0] = lightPosV.x;\tlightPos[1] = lightPosV.y;\tlightPos[2] = lightPosV.z;\t// 在着色器获取光源位置和材质属性\tglobalAmbLoc = glGetUniformLocation(renderProgram, \"globalAmbient\");\tambLoc = glGetUniformLocation(renderProgram, \"light.ambient\");\tdiffLoc = glGetUniformLocation(renderProgram, \"light.diffuse\");\tspecLoc = glGetUniformLocation(renderProgram, \"light.specular\");\tposLoc = glGetUniformLocation(renderProgram, \"light.position\");\tmAmbLoc = glGetUniformLocation(renderProgram, \"material.ambient\");\tmDifLoc = glGetUniformLocation(renderProgram, \"material.diffuse\");\tmSpecLoc = glGetUniformLocation(renderProgram, \"material.specular\");\tmShiLoc = glGetUniformLocation(renderProgram, \"material.shininess\");\t// 在着色器中为光源与材质统一变量赋值\tglProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);\tglProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);\tglProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);\tglProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);\tglProgramUniform3fv(renderProgram, posLoc, 1, lightPos);\tglProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);\tglProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);\tglProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);\tglProgramUniform1f(renderProgram, mShiLoc, matShi);}void makeVertexArray(){\tstd::vectorint ind = model.getIndices();\tstd::vectorglm::vec3 vert = model.getVertices();\tstd::vectorglm::vec2 tex = model.getTexCoords();\tstd::vectorglm::vec3 norm = model.getNormals();\tstd::vectorfloat pvalues; // 顶点位置\tstd::vectorfloat tvalues; // 纹理坐标\tstd::vectorfloat nvalues; // 法向量\tfor (int i = 0; i model.getNumVertices(); ++ i)\t{ pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// 顶点坐标放入缓冲区0\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW);\t// 纹理坐标放入缓冲区1\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW);\t// 法向量放入缓冲区2\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW);\t// 顶点索引放入缓冲区3\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), ind[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){\trenderProgram = Util::createShadeProgram(\"bumpMap/vertex.glsl\", \"bumpMap/fragment.glsl\");\tcameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tglUseProgram(renderProgram);\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tnLoc = glGetUniformLocation(renderProgram, \"norm_matrix\");\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));\tmMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));\tmMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\t// 基于当前光源位置，初始化光照\tcurrentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);\tinstallLights(vMat);\tmvMat = vMat * mMat;\t// 构建 MV 矩阵的逆转置矩阵，用于变换法向量\tinvTrMat = glm::transpose(glm::inverse(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\t//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());\t// 利用索引 vbo3 来查找要绘制的顶点\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);\tglDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){\tif (!glfwInit()) exit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Bumps\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK) exit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 顶点着色器和片段着色器 // vertex.glsl#version 460 corestruct PositionalLight{\tvec4 ambient;\tvec4 diffuse;\tvec4 specular;\tvec3 position;};layout(location = 0) in vec3 vertPos;layout(location = 1) in vec3 vertNormal;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix;uniform PositionalLight light;out vec3 varyingNormal;out vec3 varyingLightDir;out vec3 varyingVertPos;out vec3 originalVertex;void main(){\tvaryingVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;\tvaryingLightDir = light.position - varyingVertPos;\tvaryingNormal = (norm_matrix * vec4(vertNormal, 0.0)).xyz;\toriginalVertex = vertPos;\tgl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment.glsl#version 460 corestruct PositionalLight{\tvec4 ambient;\tvec4 diffuse;\tvec4 specular;\tvec3 position;};struct Material{\tvec4 ambient;\tvec4 diffuse;\tvec4 specular;\tfloat shininess;};uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;in vec3 varyingNormal;in vec3 varyingLightDir;in vec3 varyingVertPos;in vec3 originalVertex;out vec4 fragColor;void main(){\tvec3 L = normalize(varyingLightDir);\tvec3 N = normalize(varyingNormal);\tvec3 V = normalize(-varyingVertPos);\tfloat a = 0.25; // 凸起深度\tfloat b = 100.0;\t// 凸起宽度\tfloat x = originalVertex.x;\tfloat y = originalVertex.y;\tfloat z = originalVertex.z;\tN.x = varyingNormal.x + a * sin(b * x);\tN.y = varyingNormal.y + a * sin(b * y);\tN.z = varyingNormal.z + a * sin(b * z);\tN = normalize(N);\tvec3 R = normalize(reflect(-L, N));\t// 计算光照与平面法向量间的角度\tfloat cosTheta = dot(L, N);\t// 计算法向量 N 与角平分线向量 H 之间的角度\tfloat cosPhi = dot(V, R);\tfragColor = globalAmbient * material.ambient + light.ambient * material.diffuse + light.diffuse * material.diffuse * max(cosTheta, 0.0) + light.specular * material.specular * pow(max(cosPhi, 0.0), material.shininess);} 10.2 法线贴图 凹凸贴图可以使用查找表来替换法向量的形式替代。 以查找表的方法实现凹凸细节叫作法线贴图。 可以将法向量存储在彩色图像文件中，恰好 RGB 三通道对应向量的 xyz。 RGB 值以字节形式存储，通常为 [0,1][0,1][0,1]。 向量限制在 [−1,+1][-1,+1][−1,+1]。 {R=(Nx+1)/2G=(Ny+1)/2B=(Nz+1)/2\\begin{cases} R=(N_x+1)/2 \\\\ G=(N_y+1)/2 \\\\ B=(N_z+1)/2 \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​R=(Nx​+1)/2G=(Ny​+1)/2B=(Nz​+1)/2​ 法线贴图使用一个图像（称为法线图）文件，该图像文件包含在光照下所期望表面外观的法向量。 法向量的 x 和 y 分量表示其被扰动后与“垂直”方向的偏差，z 分量设置为 1。 严格垂直的向量（即没有偏差）将表示为 (0,0,1)(0, 0, 1)(0,0,1)。 但发现图查找到的法向量不能直接使用，因为并没有考虑法向量在物体上的位置以及在相机空间种的方向。 建立转换矩阵，将法向量转换到相机空间。 在对象顶点出，考虑对象的切平面，取切平面两个相互垂直的向量（切向量和副切向量），可以通过计算切向量和法向量的叉积构建副切向量。 如果模型没有定义切向量，还需计算切向量。 对于那些表面无法求导、无法精确求解切向量的模型，其切向量可以通过近似得到。 切向量一样通过 VBO 传递到顶点着色器中。 一旦在相机空间中得到法向量、切向量和副切向量，就可以构造矩阵（称为 TBN 矩阵）。 该矩阵用于将从法线贴图中检索到的法向量转换为在相机空间中相对于物体表面的法向量。 在片段着色器中，新法向量的计算在 calcNewNormal() 函数中完成。 该函数包含 dot(tangent, normal) 的计算确保切向量垂直于法向量。新的切向量和法向量的叉积就是副切向量。 制作法线图可以通过 GIMP 和 PS 等工具完成。 法线贴图例子 法线图 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 5;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint mvLoc, projLoc, nLoc;// 光源属性GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;// 材质属性GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;glm::vec3 currentLightPos, lightPosV; // 模型和视觉空间中的光照位置float lightPos[3]; // 光照位置的浮点数组// 初始化光照位置glm::vec3 initialLightLoc = glm::vec3(-5.0f, 2.0f, 5.0f);// 白光特性float globalAmbient[4] = { 0.7f, 0.7f, 0.7f, 1.0f };float lightAmbient[4] = { 0.0f, 0.0f, 0.0f, 1.0f };float lightDiffuse[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightSpecular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float *matAmb = Util::goldAmbient();float *matDif = Util::goldDiffuse();float *matSpe = Util::goldSpecular();float matShi = Util::goldShininess();Sphere model(48);//Torus model(48, 0.5f, 0.2f);//ImportedModel model(\"unicorn.obj\");GLuint texture;static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void installLights(glm::mat4 vMatrix){\t// 将光源位置转换为视图空间坐标，存入浮点数组\tlightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));\tlightPos[0] = lightPosV.x;\tlightPos[1] = lightPosV.y;\tlightPos[2] = lightPosV.z;\t// 在着色器获取光源位置和材质属性\tglobalAmbLoc = glGetUniformLocation(renderProgram, \"globalAmbient\");\tambLoc = glGetUniformLocation(renderProgram, \"light.ambient\");\tdiffLoc = glGetUniformLocation(renderProgram, \"light.diffuse\");\tspecLoc = glGetUniformLocation(renderProgram, \"light.specular\");\tposLoc = glGetUniformLocation(renderProgram, \"light.position\");\tmAmbLoc = glGetUniformLocation(renderProgram, \"material.ambient\");\tmDifLoc = glGetUniformLocation(renderProgram, \"material.diffuse\");\tmSpecLoc = glGetUniformLocation(renderProgram, \"material.specular\");\tmShiLoc = glGetUniformLocation(renderProgram, \"material.shininess\");\t// 在着色器中为光源与材质统一变量赋值\tglProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);\tglProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);\tglProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);\tglProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);\tglProgramUniform3fv(renderProgram, posLoc, 1, lightPos);\tglProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);\tglProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);\tglProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);\tglProgramUniform1f(renderProgram, mShiLoc, matShi);}void makeVertexArray(){\tstd::vectorint ind = model.getIndices();\tstd::vectorglm::vec3 vert = model.getVertices();\tstd::vectorglm::vec2 tex = model.getTexCoords();\tstd::vectorglm::vec3 norm = model.getNormals();\tstd::vectorglm::vec3 tang = model.getTangents();\tstd::vectorfloat pvalues; // 顶点位置\tstd::vectorfloat tvalues; // 纹理坐标\tstd::vectorfloat nvalues; // 法向量\tstd::vectorfloat tanvalues; // 切线\tfor (int i = 0; i model.getNumVertices(); ++ i)\t{ pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z); tanvalues.push_back(tang[i].x); tanvalues.push_back(tang[i].y); tanvalues.push_back(tang[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// 顶点坐标放入缓冲区0\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW);\t// 纹理坐标放入缓冲区1\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW);\t// 法向量放入缓冲区2\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW);\t// 切向量放入缓冲区3\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglBufferData(GL_ARRAY_BUFFER, 4 * tanvalues.size(), tanvalues[0], GL_STATIC_DRAW);\t// 顶点索引放入缓冲区4\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), ind[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){\trenderProgram = Util::createShadeProgram(\"normalMap/vertex.glsl\", \"normalMap/fragment.glsl\");\tcameraX = 0.0f, cameraY = 0.0f, cameraZ = 4.0f;\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();\ttexture = Util::loadTexture(\"normalMap/castleroofNORMAL.jpg\");}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tglUseProgram(renderProgram);\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tnLoc = glGetUniformLocation(renderProgram, \"norm_matrix\");\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));\tmMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -1.0f));\tmMat = glm::rotate(mMat, 35.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\t// 基于当前光源位置，初始化光照\tcurrentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);\tinstallLights(vMat);\tmvMat = vMat * mMat;\t// 构建 MV 矩阵的逆转置矩阵，用于变换法向量\tinvTrMat = glm::transpose(glm::inverse(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(2);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[3]);\tglVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(3);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_2D, texture);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\t//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());\t// 利用索引 vbo3 来查找要绘制的顶点\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);\tglDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){\tif (!glfwInit()) exit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Bumps\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK) exit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 球体类新增 // Sphere.cppvoid Sphere::init(int _prec){\tnumVertices = (_prec + 1) * (_prec + 1);\tnumIndices = _prec * _prec * 6;\tfor (int i = 0; i numVertices; ++ i)\t{ vertices.push_back(glm::vec3()); texCoords.push_back(glm::vec2()); normals.push_back(glm::vec3()); tangents.push_back(glm::vec3());\t}\tfor (int i = 0; i numIndices; ++ i) indices.push_back(0);\t// 计算三角形顶点\tfor (int i = 0; i = _prec; ++ i) for (int j = 0; j = _prec; ++ j) { float y = static_castfloat(cos(toRadians(180.0f - i * 180.0f / _prec))); float x = - static_castfloat(cos(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y)))); float z = static_castfloat(sin(toRadians(j * 360.0f / _prec)) * fabs(cos(asin(y)))); vertices[i * (_prec + 1) + j] = glm::vec3(x, y, z); // 计算切向量（新增） if (((x == 0) and (y == 1) and (z == 0)) or ((x == 0) and (y == -1) and (z == 0))) tangents[i * (_prec + 1) + j] = glm::vec3(0.0f, 0.0f, -1.0f); else tangents[i * (_prec + 1) + j] = glm::cross(glm::vec3(0.0f, 1.0f, 0.0f), glm::vec3(x, y, z)); // 新增上述计算切向量 texCoords[i * (_prec + 1) + j] = glm::vec2(j * 1.0f / _prec, i * 1.0f / _prec); normals[i * (_prec + 1) + j] = glm::vec3(x, y, z); } // ...}std::vectorglm::vec3 Sphere::getTangents(){\treturn tangents;} 顶点着色器和片段着色器 // vertex.glsl#version 460 corestruct PositionalLight{\tvec4 ambient;\tvec4 diffuse;\tvec4 specular;\tvec3 position;};layout(location = 0) in vec3 vertPos;layout(location = 1) in vec2 texCoord;layout(location = 2) in vec3 vertNormal;layout(location = 3) in vec3 vertTangent;uniform mat4 mv_matrix;uniform mat4 proj_matrix;uniform mat4 norm_matrix;\t// 用于变换法向量uniform PositionalLight light;out vec3 varyingLightDir;out vec3 varyingVertPos;out vec3 varyingNormal;out vec3 varyingTangent;out vec3 originalVertex;out vec2 tc;out vec3 varyingHalfVector;void main(){\tvaryingVertPos = (mv_matrix * vec4(vertPos, 1.0)).xyz;\tvaryingLightDir = light.position - varyingVertPos;\ttc = texCoord;\toriginalVertex = vertPos;\tvaryingNormal = (norm_matrix * vec4(vertNormal, 0.0)).xyz;\tvaryingTangent = (norm_matrix * vec4(vertTangent, 0.0)).xyz;\tvaryingHalfVector = normalize(normalize(varyingLightDir) + normalize(-varyingVertPos)).xyz;\tgl_Position = proj_matrix * mv_matrix * vec4(vertPos, 1.0);} // fragment.glsl#version 460 corestruct PositionalLight{\tvec4 ambient;\tvec4 diffuse;\tvec4 specular;\tvec3 position;};struct Material{\tvec4 ambient;\tvec4 diffuse;\tvec4 specular;\tfloat shininess;};layout(binding = 0) uniform sampler2D nromsamp;uniform vec4 globalAmbient;uniform PositionalLight light;uniform Material material;in vec3 varyingLightDir;in vec3 varyingNormal;in vec3 varyingVertPos;in vec3 varyingTangent;in vec3 originalVertPos;in vec2 tc;in vec3 varyingHalfVector;out vec4 fragColor;vec3 calcNewNormal(){\tvec3 normal = normalize(varyingNormal);\tvec3 tangent = normalize(varyingTangent);\ttangent = normalize(tangent - dot(tangent, normal) * normal);\tvec3 bitangent = cross(normal, tangent);\tmat3 tbn = mat3(tangent, bitangent, normal);\tvec3 retrievedNormal = texture(nromsamp, tc).xyz;\tvec3 newNormal = tbn * retrievedNormal;\tnewNormal = normalize(newNormal);\treturn newNormal;}void main(){\tvec3 L = normalize(varyingLightDir);\tvec3 N = calcNewNormal();\tvec3 R = normalize(reflect(-L, N));\tvec3 H = normalize(varyingHalfVector);\t// 计算光照与平面法向量间的角度\tfloat cosTheta = dot(L, N);\t// 计算法向量 N 与角平分线向量 H 之间的角度\tfloat cosPhi = dot(H, N);\tfragColor = globalAmbient * material.ambient + light.ambient * material.ambient + light.diffuse * material.diffuse * max(0.0, cosTheta) + light.specular * material.specular * pow(max(0.0, cosPhi), material.shininess);} 可以使用纹理加法线贴图，使得模型更逼真。 法线贴图也可以使用多级渐远纹理贴图改善效果。 法线贴图的各向异性过滤更有效，它不但减少了闪烁的伪影，同时还保留了细节。 10.3 高度贴图 使用纹理图像来存储高度值，然后使用该高度值来提升（或降低）顶点位置。 含有高度信息的图像称为高度图。 使用高度图更改对象的顶点的方法称为高度贴图。 黑色为高度低，白色为高度高。 效果展示： 用于展示的高度图和纹理图如下： 高度图 纹理图 代码如下： main.cpp #include iostream// 导入 GLEW 库#include GL/glew.h// 导入 GLFW 库#include GLFW/glfw3.h// 导入 GLM 库#include glm/glm.hpp#include \"Util.h\"#include stack#include \"Sphere.h\"#include \"Torus.h\"#include \"ImportedModel.h\"GLuint renderProgram;const int numVAO = 1, numVBO = 3;GLuint vao[numVAO], vbo[numVBO];int width, height;float aspect;double cameraX, cameraY, cameraZ;GLuint mvLoc, projLoc, nLoc;// 光源属性GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;// 材质属性GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;glm::vec3 currentLightPos, lightPosV; // 模型和视觉空间中的光照位置float lightPos[3]; // 光照位置的浮点数组// 初始化光照位置glm::vec3 initialLightLoc = glm::vec3(-5.0f, 2.0f, 5.0f);// 白光特性float globalAmbient[4] = { 0.7f, 0.7f, 0.7f, 1.0f };float lightAmbient[4] = { 0.0f, 0.0f, 0.0f, 1.0f };float lightDiffuse[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float lightSpecular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };float *matAmb = Util::goldAmbient();float *matDif = Util::goldDiffuse();float *matSpe = Util::goldSpecular();float matShi = Util::goldShininess();//Sphere model(48);//Torus model(48, 0.5f, 0.2f);ImportedModel model(\"heightMap/grid.obj\");GLuint heightMap;GLuint texture;static void windowSizeCallback(GLFWwindow *window, int width, int height){\taspect = static_castfloat(width) / static_castfloat(height);\tglViewport(0, 0, width, height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);}void installLights(glm::mat4 vMatrix){\t// 将光源位置转换为视图空间坐标，存入浮点数组\tlightPosV = glm::vec3(vMatrix * glm::vec4(currentLightPos, 1.0));\tlightPos[0] = lightPosV.x;\tlightPos[1] = lightPosV.y;\tlightPos[2] = lightPosV.z;\t// 在着色器获取光源位置和材质属性\tglobalAmbLoc = glGetUniformLocation(renderProgram, \"globalAmbient\");\tambLoc = glGetUniformLocation(renderProgram, \"light.ambient\");\tdiffLoc = glGetUniformLocation(renderProgram, \"light.diffuse\");\tspecLoc = glGetUniformLocation(renderProgram, \"light.specular\");\tposLoc = glGetUniformLocation(renderProgram, \"light.position\");\tmAmbLoc = glGetUniformLocation(renderProgram, \"material.ambient\");\tmDifLoc = glGetUniformLocation(renderProgram, \"material.diffuse\");\tmSpecLoc = glGetUniformLocation(renderProgram, \"material.specular\");\tmShiLoc = glGetUniformLocation(renderProgram, \"material.shininess\");\t// 在着色器中为光源与材质统一变量赋值\tglProgramUniform4fv(renderProgram, globalAmbLoc, 1, globalAmbient);\tglProgramUniform4fv(renderProgram, ambLoc, 1, lightAmbient);\tglProgramUniform4fv(renderProgram, diffLoc, 1, lightDiffuse);\tglProgramUniform4fv(renderProgram, specLoc, 1, lightSpecular);\tglProgramUniform3fv(renderProgram, posLoc, 1, lightPos);\tglProgramUniform4fv(renderProgram, mAmbLoc, 1, matAmb);\tglProgramUniform4fv(renderProgram, mDifLoc, 1, matDif);\tglProgramUniform4fv(renderProgram, mSpecLoc, 1, matSpe);\tglProgramUniform1f(renderProgram, mShiLoc, matShi);}void makeVertexArray(){\tstd::vectorglm::vec3 vert = model.getVertices();\tstd::vectorglm::vec2 tex = model.getTexCoords();\tstd::vectorglm::vec3 norm = model.getNormals();\tstd::vectorfloat pvalues; // 顶点位置\tstd::vectorfloat tvalues; // 纹理坐标\tstd::vectorfloat nvalues; // 法向量\tfor (int i = 0; i model.getNumVertices(); ++ i)\t{ pvalues.push_back(vert[i].x); pvalues.push_back(vert[i].y); pvalues.push_back(vert[i].z); tvalues.push_back(tex[i].s); tvalues.push_back(tex[i].t); nvalues.push_back(norm[i].x); nvalues.push_back(norm[i].y); nvalues.push_back(norm[i].z);\t}\tglGenVertexArrays(numVAO, vao);\tglBindVertexArray(vao[0]);\tglGenBuffers(numVBO, vbo);\t// 顶点坐标放入缓冲区0\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglBufferData(GL_ARRAY_BUFFER, 4 * pvalues.size(), pvalues[0], GL_STATIC_DRAW);\t// 纹理坐标放入缓冲区1\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglBufferData(GL_ARRAY_BUFFER, 4 * tvalues.size(), tvalues[0], GL_STATIC_DRAW);\t// 法向量放入缓冲区2\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglBufferData(GL_ARRAY_BUFFER, 4 * nvalues.size(), nvalues[0], GL_STATIC_DRAW);}void init(GLFWwindow *window){\trenderProgram = Util::createShadeProgram(\"heightMap/vertex.glsl\", \"heightMap/fragment.glsl\");\tcameraX = 0.03f; cameraY = 0.03f; cameraZ = 0.8f;\tglfwGetFramebufferSize(window, width, height);\taspect = static_castfloat(width) / static_castfloat(height);\tpMat = glm::perspective(1.0472f, aspect, 0.1f, 1000.0f);\tmakeVertexArray();\ttexture = Util::loadTexture(\"textureImg/ice.jpg\");\theightMap = Util::loadTexture(\"heightMap/height.jpg\");}void display(GLFWwindow *window, double currentTime){\tglClear(GL_DEPTH_BUFFER_BIT);\tglClear(GL_COLOR_BUFFER_BIT);\tglUseProgram(renderProgram);\tmvLoc = glGetUniformLocation(renderProgram, \"mv_matrix\");\tprojLoc = glGetUniformLocation(renderProgram, \"proj_matrix\");\tnLoc = glGetUniformLocation(renderProgram, \"norm_matrix\");\tvMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));\tmMat = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));\tmMat = glm::rotate(mMat, 15.0f * 3.14159f / 180.0f, glm::vec3(1.0f, 0.0f, 0.0f));\t// 基于当前光源位置，初始化光照\tcurrentLightPos = glm::vec3(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);\tinstallLights(vMat);\tmvMat = vMat * mMat;\t// 构建 MV 矩阵的逆转置矩阵，用于变换法向量\tinvTrMat = glm::transpose(glm::inverse(mvMat));\tglUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));\tglUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));\tglUniformMatrix4fv(nLoc, 1, GL_FALSE, glm::value_ptr(invTrMat));\tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(0);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[1]);\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(1);\tglBindBuffer(GL_ARRAY_BUFFER, vbo[2]);\tglVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0);\tglEnableVertexAttribArray(2);\tglActiveTexture(GL_TEXTURE0);\tglBindTexture(GL_TEXTURE_2D, texture);\tglActiveTexture(GL_TEXTURE1);\tglBindTexture(GL_TEXTURE_2D, heightMap);\tglEnable(GL_DEPTH_TEST);\tglDepthFunc(GL_LEQUAL);\tglDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());\t// 利用索引 vbo3 来查找要绘制的顶点\t//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);\t//glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);}int main(){\tif (!glfwInit()) exit(EXIT_FAILURE);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\tGLFWwindow *window = glfwCreateWindow(800, 600, \"Bumps\", NULL, NULL);\tglfwMakeContextCurrent(window);\tif (glewInit() != GLEW_OK) exit(EXIT_FAILURE);\tglfwSwapInterval(1);\tglfwSetWindowSizeCallback(window, windowSizeCallback);\tinit(window);\twhile (!glfwWindowShouldClose(window))\t{ display(window, glfwGetTime()); glfwSwapBuffers(window); glfwPollEvents();\t}\tglfwDestroyWindow(window);\tglfwTerminate();\treturn 0;} 顶点着色器和片段着色器 // vertex.glsl#version 430layout(location = 0) in vec3 vertPos;layout(location = 1) in vec2 texCoord;layout(location = 2) in vec3 vertNormal;layout(binding = 1) uniform sampler2D h; // 高度图out vec2 tc;uniform mat4 mv_matrix;uniform mat4 proj_matrix;void main(){\tvec4 p = vec4(vertPos, 1.0) + vec4((vertNormal * ((texture(h, texCoord).r) / 5.0f)), 1.0f);\ttc = texCoord;\tgl_Position = proj_matrix * mv_matrix * p;} // fragment.glsl#version 460 corein vec2 tc;out vec4 fragColor;layout(binding = 0) uniform sampler2D t;\t// 纹理void main(){\tfragColor = texture(t, tc);} 凹凸贴图或法线贴图的一个基本限制是： 虽然能够在所渲染对象的内部提供表面细节， 但是物体轮廓（外边界）无法显示这些细节（仍保持平滑）。 高度贴图在用于实际修改顶点位置时修复了这个缺陷，但它也有其自身的局限性。","tags":["CPP","OpenGL"],"categories":["笔记"]},{"title":"OpenCV图像处理基础学习记录","path":"/2024/basicOpenCV/","content":"关键词：C++、OpenCV、图像处理 一、Visual Studio2022配置OpencCV 1.1 下载OpenCV并安装 可以直接前往OpenCV官网进行下载资源。 有两种形式可以下载安装： Windows的exe可执行文件安装。 exe文件安装后有OpenCV静态库和动态库文件，可以直接链接到VS使用，整体更方便。 Sources源码安装。 下载源码后需要自己编译生成OpenCV的静态库和动态库。 1.2 VS中配置OpenCV 我下载的OpenCV版本为4.5.2，目录在： D:\\opencv4.5.2 在VS中新建项目，右键项目点击属性，做以下操作： VC++ 目录 → 包含目录添加OpenCV的include目录。例如，我的操作是把 D:\\opencv4.5.2\\build\\include 添加到包含目录。 VC++ 目录 → 库目录添加OpenCV的x64/vc15/lib目录。例如，我的操作是把 D:\\opencv4.5.2\\build\\x64\\vc15\\lib 添加到库目录。 链接器 → 输入 → 附加依赖项添加OpenCV的动态库。例如，我的操作是：debug版本添加 opencv_world452d.lib，release版本添加 opencv_world452.lib。 1.3 测试OpenCV 新建Cpp文件，复制以下代码： #include opencv2/opencv.hppint main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::imshow(\"a\", image); cv::waitKey(0); return 0;} 编译链接测试，若能运行，则说明配置正确。 二、基本操作 2.1 读写图像 2.1.1 相关函数 读取图像 函数原型： Mat imread(const String filename, int flags = IMREAD_COLOR) 第一参数为图像路径，第二参数为加载图像的形式（默认加载彩色图像）。 第二参数可选参数有三种： 0 或 IMREAD_GRAYSCALE ，表示加载灰度图像。 1 或 IMREAD_COLOR ，表示加载彩色图像（默认）。 -1 或 IMREAD_UNCHANGED ，表示加载包括alpha通道。 创建窗口 函数原型： void namedWindow(const String winname, int flags = WINDOW_AUTOSIZE) 第一参数为窗口名字，第二参数为窗口形式。 窗口形式常用有两种： WINDOW_AUTOSIZE 表示固定大小（默认）。 WINDOW_NORMAL 表示可调节大小。 显示图像 函数原型： void imshow(const String winname, InputArray mat) 第一参数为窗口名字，第二参数为图像对象名称。 写入图像 函数原型： bool imwrite( const String filename, InputArray img, const std::vectorint params = std::vectorint()) 第一参数为存储图像路径，第二参数为图像对象名称，其余参数不重要。 等待延时 函数原型： int waitKey(int delay = 0) 参数为延时的毫秒数，默认为0，即无限时等待键盘输入。 窗口销毁 函数原型： void destroyWindow(const String winname) 参数为销毁的窗口名称，一般情况下系统会自动回收。 2.1.2 示例代码 #include opencv2/opencv.hppint main(){ // 读取现有图像 cv::Mat image = cv::imread(\"src/test.jpg\"); // 以png格式写入图像 cv::imwrite(\"src/test.png\", image); // 创建窗口并显示图像 cv::namedWindow(\"test window\", cv::WINDOW_NORMAL); cv::imshow(\"test window\", image); cv::waitKey(0); cv::destroyWindow(\"test window\"); return 0;} 2.2 读写视频 2.2.1 相关概念 VideoCapture类 VideoCapture类提供了有关视频的操作： cv::VideoCapture cap(0); 创建VideoCapture实例，使用构造函数，传入参数0表示设备0。 bool isOpened() 确认摄像头是否开启成功。 bool grab() 确认摄像头在运行中是否捕获到帧。 bool read(OutputArray image) 将视频捕获对象中捕获到的图像输出到image中。 转化图像颜色通道 函数原型： void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0) 第一参数是输入图像，第二参数是输出图像，第三参数是转化图像颜色通道代码，第四参数暂不管。 转化图像颜色通道代码有许多，通常用到： COLOR_BGR2GRAY ：由OpenCV的BGR通道转为灰度通道。 COLOR_BGR2BGRA ：由OpenCV的BGR通道添加了Alpha通道。 读取、显示视频 与使用摄像头的思路类似，将捕获设备改为捕获本地文件。 cv::VideoCapture cap(\"src/test.mp4\"); 显示与使用摄像头的思路类似，捕获视频每一帧并展示图像对象。 写入视频 定义编解码器并创建VideoWriter对象进行保存。 int fourcc = cv::VideoWriter::fourcc('X', 'V', 'I', 'D'); // 编解码器cv::VideoWriter out(\"output.avi\", fourcc, 20.0, cv::Size(640, 480)); VideoWriter的其中一个构造函数原型如下： VideoWriter(const String filename, int fourcc, double fps, Size frameSize, bool isColor = true) 2.2.2 示例代码 #include opencv2/opencv.hpp#include iostreamint main(){ cv::VideoCapture cap(0); cv::Mat img; int fourcc = cv::VideoWriter::fourcc('X', 'V', 'I', 'D'); cv::VideoWriter out(\"output.avi\", fourcc, 20.0, cv::Size(640, 480)); while (cap.isOpened()) { if (!cap.grab()) { std::cout \"摄像头错误\" std::endl; break; } out.write(img); cap.read(img); cv::imshow(\"video\", img); if (cv::waitKey(1) == 'q') break; } cap.release(); // 释放视频捕获对象 out.release(); // 释放视频写入对象 cv::destroyWindow(\"video\"); return 0;} 2.3 图像的基本操作 2.3.1 创建空白图像 使用 Mat 创建图像矩阵的常用形式： 创建空图像，大小为0： cv::Mat image1; 指定矩阵大小，指定数据类型 cv::Mat image2(100, 100, CV_8U); 创建100行×100列的矩阵，数据类型为无符号8位int，即灰度图像。 还有一种常用的类型CV_8UC3，表示三通道无符号8位int。 指定矩阵大小，指定数据类型，设置初始值 cv::Mat image3(100, 100, CV_8U, 100) 创建100行×100列的矩阵，数据类型为无符号8位int灰度图像，灰度值为100。 对于三通道图像，应使用Scalar()： cv::Mat image(640, 640, CV_8UC3, cv::Scalar(100, 100, 0)); 2.3.2 获取图像信息 获取行列数、通道数 直接访问Mat类成员rows、cols和函数channels()返回图像的行、列和通道数。可以通过通道数判断是灰度图像（通道为1）还是彩色图像（通道为3）。 std::cout \"图像的行：\" image.rows std::endl;std::cout \"图像的列：\" image.cols std::endl;std::cout \"通道数：\" image.channels() std::endl; 访问像素点的BGR值 通过Vec3b数据类型访问返回像素点的BGR值，注意，前者是行数，后者是列数。 int blue = image.atcv::Vec3b(100, 100)[0];// 索引值0表示索引BGR值中的B，也就是蓝色通道的数值int green = image.atcv::Vec3b(100, 100)[1];int red = image.atcv::Vec3b(100, 100)[2]; 同理进行修改： image.atcv::Vec3b(100, 100)[0] = 201;// 将坐标(100, 100)的像素点蓝色数值改为201 当然大面积的修改才会明显，通过循环进行： for(int i = 0; i 100; ++ i) for (int j = 0; j 100; ++ j) image.atcv::Vec3b(i, j)[0] = 100; 如果修改BGR值，则组成Vec3b类型： for(int i = 0; i 100; ++ i) for (int j = 0; j 100; ++ j) image.atcv::Vec3b(i, j) = cv::Vec3b(255, 0, 0); 2.3.3 标记区域 创建tmp变量，获取图像行从200到1000，列从200到1000的区域。将图像行从1200到2000，列从1200到2000的区域变成tmp cv::Mat image = cv::imread(\"src/test.jpg\");cv::Mat tmp = image(cv::Range(100, 200), cv::Range(100, 200));tmp.copyTo(image(cv::Range(200, 300), cv::Range(200, 300))); 2.3.4 遍历图像 循环行和列遍历图像 对于OpenCV的Mat，其顺序是行和列。与C++的二维数组类似，遍历： for(int i = 0; i 100; ++ i) for (int j = 0; j 100; ++ j) image.atcv::Vec3b(i, j) = cv::Vec3b(255, 0, 0); 指针扫描 #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat img = cv::imread(\"src/test.jpg\"); cv::Mat output_img; output_img = cv::Mat(img.size(), img.type()); // 复制画布 output_img = img.clone(); // 克隆像素值 int r = img.rows, c = img.cols, channels = img.channels(); for (int j = 0; j r; j ++) { const uchar *now = img.ptruchar(j); // 原图当前行指针 uchar *output = output_img.ptruchar(j); // 输出图像当前行指针 // 实际上每一列都由通道数三个数据组成，所以实际上列数应该是通道数×列 for (int i = channels; i c * channels; i ++) { output[i] = cv::saturate_castuchar(5 * now[i]); // saturate_cast保证了计算结果仍在0~255之间 } } cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img); cv::imshow(\"after\", output_img); cv::waitKey(0); cv::destroyAllWindows(); return 0;} 2.4 绘图入门 2.4.1 静态绘制 绘制线 函数原型： void line(InputOutputArray img, Point pt1, Point pt2, const Scalar color,int thickness = 1, int lineType = LINE_8, int shift = 0) 参数分别为：图像对象、始点坐标、终点坐标、颜色、线粗细、线类型…… 使用示例： cv::line(image, cv::Point(0, 0), cv::Point(512, 512), cv::Scalar(255, 0, 0), 5); 绘制矩形 函数原型： void rectangle(InputOutputArray img, Rect rec, const Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0) 参数分别为：图像对象、矩形框、颜色、边框线粗细、边框线类型…… 矩形框的四个参数分别为：x坐标、y坐标、宽、高。 使用示例： cv::rectangle(image, cv::Rect(0, 0, 100, 100), cv::Scalar(0, 255, 255), 5); 绘制圆 函数原型： void circle(InputOutputArray img, Point center, int radius, const Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0) 参数分别为：图像对象、圆心、半径、颜色、边框线粗细、边框线类型…… 使用示例： cv::circle(image, cv::Point(319, 319), 50, cv::Scalar(0, 0, 255), 5); 绘制椭圆 函数原型： void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0) 参数分别为：图像对象、中心点、长短轴、初始旋转角度、椭圆开始角度、椭圆结束角度、颜色、边框线粗细、边框线类型……边框线粗细为-1表示内填充。 使用示例： cv::ellipse(image, cv::Point(319, 119), cv::Size(100, 50), 0, 180, 360, 255, -1); 绘制多边形 函数原型： void polylines(InputOutputArray img, const Point* const* pts, const int* npts, int ncontours, bool isClosed, const Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0 ) 参数分别为：图像对象、const修饰的指向多边形数组的指针、多边形顶点个数的数组名、绘制多边形的个数、是否闭合、颜色、边框粗细、边框线类型 使用示例： // 构造多边形的端点形成的点类型数组。cv::Point pts[] = { cv::Point(10, 5), cv::Point(20, 30), cv::Point(70, 20), cv::Point(50, 10) };// const修饰的多边形数组指针const cv::Point *ppt[1] = { pts };// 多边形顶点个数的数组名int npt[] = { 4 };cv::polylines(image, ppt, npt, 1, true, cv::Scalar(0, 255, 255)); 添加文本 函数原型： void putText( InputOutputArray img, const String text, Point org, int fontFace, double fontScale, Scalar color, int thickness = 1, int lineType = LINE_8, bool bottomLeftOrigin = false ) 参数分别为：图像对象、文本内容、文字在图像中的左下角坐标、字体、字体大小、字体颜色、字体粗细、描绘字体的线类型…… 使用示例： cv::putText(image, \"OpenCV\", cv::Point(10, 500), cv::FONT_HERSHEY_SIMPLEX, 4, cv::Scalar(255, 255, 255), 2, cv::LINE_AA); 整体绘制展示 #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image(640, 640, CV_8UC3); cv::line(image, cv::Point(0, 0), cv::Point(512, 512), cv::Scalar(255, 0, 0), 5); cv::rectangle(image, cv::Rect(0, 0, 100, 100), cv::Scalar(0, 255, 255), 5); cv::circle(image, cv::Point(319, 319), 50, cv::Scalar(0, 0, 255), 5); cv::ellipse(image, cv::Point(319, 119), cv::Size(100, 50), 0, 180, 360, 255, -1); cv::Point pts[] = { cv::Point(10, 5), cv::Point(20, 30), cv::Point(70, 20), cv::Point(50, 10) }; const cv::Point *ppt[1] = { pts }; int npt[] = { 4 }; cv::polylines(image, ppt, npt, 1, true, cv::Scalar(0, 255, 255)); cv::putText(image, \"OpenCV\", cv::Point(10, 500), cv::FONT_HERSHEY_SIMPLEX, 4, cv::Scalar(255, 255, 255), 2, cv::LINE_AA); cv::namedWindow(\"img\", cv::WINDOW_NORMAL); cv::imshow(\"img\", image); cv::waitKey(0); return 0;} 2.4.2 鼠标绘制 #include opencv2/opencv.hpp#include iostreamcv::Mat image(640, 640, CV_8UC3); // 画布bool drawing = false; // 是否绘画bool mode = true; // 矩形绘制还是圆形绘制int ix, iy = -1;int r, g, b, t = 0;// 绘画函数void draw(int event, int x, int y, int flags, void *param){ if (event == cv::EVENT_LBUTTONDOWN) // 当鼠标按下时 { drawing = true; // 启动绘画 ix = x; // 获取起点坐标 iy = y; } else if (event == cv::EVENT_MOUSEMOVE) // 当鼠标移动时 { if (drawing) // 处于绘画状态 { if (mode) // 矩形绘制时 { cv::rectangle(image, cv::Point(ix, iy), cv::Point(x, y), cv::Scalar(b, g, r), t * 20); } else // 圆形绘制时 { cv::circle(image, cv::Point(x, y), 5, cv::Scalar(b, g, r), t * 20); } } } else if (event == cv::EVENT_LBUTTONUP) // 当鼠标松开时 { drawing = false; // 关闭绘画 if (mode) // 补上最后一笔， x和y是当前的坐标 { cv::rectangle(image, cv::Point(ix, iy), cv::Point(x, y), cv::Scalar(b, g, r), t * 20); } else { cv::circle(image, cv::Point(x, y), 5, cv::Scalar(b, g, r), t * 20); } }}int main(){ cv::namedWindow(\"image\", cv::WINDOW_NORMAL); cv::setMouseCallback(\"image\", draw); // 绑定画布和回调函数 cv::createTrackbar(\"R\", \"image\", 0, 255); // 轨迹栏 cv::createTrackbar(\"G\", \"image\", 0, 255); cv::createTrackbar(\"B\", \"image\", 0, 255); cv::createTrackbar(\"Thickness\", \"image\", 0, 5); while (true) { cv::imshow(\"image\", image); int k = cv::waitKey(1) 0xFF; if (k == 'q') { break; } else if (k == 'm') { mode = !mode; } r = cv::getTrackbarPos(\"R\", \"image\"); // 刷新绘图属性 g = cv::getTrackbarPos(\"G\", \"image\"); b = cv::getTrackbarPos(\"B\", \"image\"); t = cv::getTrackbarPos(\"Thickness\", \"image\"); } cv::destroyAllWindows(); return 0;} 三、灰度变换 3.1 灰度变换原理 通过变换函数T将原图像像素灰度值r映射为灰度值s： s=T(r)s=T(r) s=T(r) 3.2 灰度反转 灰度反转：将图像亮暗对调，可以增强图像中的暗色区域细节。 s=T(r)=L−1−r，其中L为图像灰度级，0255灰度图像的灰度级为256s = T(r) = L - 1 - r，其中L为图像灰度级，0~255灰度图像的灰度级为256 s=T(r)=L−1−r，其中L为图像灰度级，0255灰度图像的灰度级为256 进行 s=T(r)=256−1−rs = T(r) = 256 - 1 - rs=T(r)=256−1−r 代码： #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat output_image, image_gray; cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image_gray); output_image = image_gray.clone(); for (int i = 0; i image_gray.rows; ++ i) for (int j = 0; j image_gray.cols; ++ j) output_image.atuchar(i, j) = 255 - image_gray.atuchar(i, j); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", output_image); cv::waitKey(0); return 0;} 效果展示： 3.3 对数变换 对数变换：扩展图像中的暗像素值，压缩高灰度值。 s=T(r)=clog⁡(1+r)s = T(r) = c\\log(1 + r) s=T(r)=clog(1+r) 其中有一个图像归一化的过程，使用函数： void normalize( InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0, int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray()) 参数如下： src：输入数组； dst：与输入数组一样大的输出数组； alpha：范数值，在范围归一化的情况下归一化到或较低的范围边界，即下限。 beta： 在范围归一化的情况下的上范围边界，即上限；它不用于范数归一化，只用于NORM_MINMAX中。 norm_type：规范化选择的公式类型类型。 dtype：如果为负，则输出在大小、深度、通道数都等于输入；否则，它具有与src相同的通道数，深度不同，深度=CV_MAT_DEPTH。 mask：掩码。选择感兴趣区域，选定后只能对该区域进行操作。 而归一化选择的数学公式（norm_type）有，设数组元素为A1，…，AnA_1，…，A_nA1​，…，An​： NORM_L1 P=Ai∑Ai×alphaP = \\frac {A_i} {\\sum A_i}\\times alpha P=∑Ai​Ai​​×alpha NORM_INF P=Aimax⁡Ai×alphaP = \\frac {A_i} {\\max A_i}\\times alpha P=maxAi​Ai​​×alpha NORM_L2 P=AkAi2×alphaP = \\frac {A_k} {\\sqrt {A_i^2} }\\times alpha P=Ai2​​Ak​​×alpha NORM_MINMAX：AK∉max⁡Ai,min⁡Ai。当AK等于max⁡Ai时，p=1；当Ak等于min⁡Ai时，p=0A_K otin{\\max A_i},\\min A_i。当A_K等于\\max A_i时，p=1；当A_k等于\\min A_i时，p=0AK​∈/​maxAi​,minAi​。当AK​等于maxAi​时，p=1；当Ak​等于minAi​时，p=0 P=Akmax⁡Ai−min⁡Ai×∣alpha−beta∣+min(alpha,beta)P = \\frac {A_k} {\\max A_i - \\min A_i}\\times \\vert{alpha - beta}\\vert + min(alpha, beta) P=maxAi​−minAi​Ak​​×∣alpha−beta∣+min(alpha,beta) 同时需要注意的是alpha和beta的取值顺序与归一化结果无关。即alpha=255，beta=0和alpha=0，beta=255最后的归一化结果是相同的。 与之相关还有一个函数，其常用于将CV_16S、CV_32F等其他类型的输出图像转变成CV_8U型的图像： void convertScaleAbs(InputArray src, OutputArray dst, double alpha = 1, double beta = 0) 参数如下： src：输入数组。 dst：输出数组。 alpha：可选比例系数。 beta：添加到缩放值的可选增量，即偏移量。 该函数也可用于对整个图像数组中的每一个元素进图像增强等相关先行操作的快速运算： dsti=saturateuchar(∣alpha×srci+beta∣)dst_i = saturate_{uchar}(\\vert alpha\\times src_i + beta \\vert) dsti​=saturateuchar​(∣alpha×srci​+beta∣) 进行s=T(r)=4log⁡(1+r)s = T(r) = 4\\log(1 + r)s=T(r)=4log(1+r) 的代码： #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat output_image, image_gray; cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image_gray); output_image = image_gray.clone(); for (int i = 0; i image_gray.rows; ++ i) for (int j = 0; j image_gray.cols; ++ j) output_image.atuchar(i, j) = 4 * log((double) image_gray.atuchar(i, j)) + 1; // 图像归一化，将数值变回0~255 cv::normalize(output_image, output_image, 0, 255, cv::NORM_MINMAX); // 将数据类型变回CV_8U，似乎忽略此句也可 cv::convertScaleAbs(output_image, output_image); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", output_image); cv::waitKey(0); return 0;} 效果展示： 3.4 幂律（伽马变换） 伽马变换：与对数函数变换类似。 s=T(r)=c×rγs = T(r) = c\\times r^γ s=T(r)=c×rγ 进行s=T(r)=4×r0.9s = T(r) = 4\\times r^{0.9}s=T(r)=4×r0.9 代码： #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat output_image, image_gray; cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image_gray); output_image = image_gray.clone(); for (int i = 0; i image_gray.rows; ++ i) for (int j = 0; j image_gray.cols; ++ j) output_image.atuchar(i, j) = 4 * pow((double)image_gray.atuchar(i, j), 0.9); cv::normalize(output_image, output_image, 0, 255, cv::NORM_MINMAX); cv::convertScaleAbs(output_image, output_image); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", output_image); cv::waitKey(0); return 0;} 效果展示： 四、直方图处理 4.1 图像直方图 非归一化直方图： h(rk)=nk，其中rk为图像像素灰度值，nk为图像中灰度值rk对应的像素个数h(r_k) = n_k，其中r_k为图像像素灰度值，n_k为图像中灰度值r_k对应的像素个数 h(rk​)=nk​，其中rk​为图像像素灰度值，nk​为图像中灰度值rk​对应的像素个数 归一化直方图： p(rk)=nkMN，其中M和N为图像行数和列数。p(r_k) = \\frac {n_k} {MN}，其中M和N为图像行数和列数。 p(rk​)=MNnk​​，其中M和N为图像行数和列数。 计算直方图与一些函数相关： void calcHist( const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform = true, bool accumulate = false ) 参数如下： images：源数组指针，它们都应该具有相同的深度，CV_8U, CV_16U或CV_32F，以及相同的大小。它们中的每一个都可以有任意数量的通道。 nimages：源图像的数量。 channels：需要统计直方图的第几通道。通道的数量必须与直方图的维度相匹配。第一个数组通道的编号从0到images[0].channels()-1，第二个数组通道的编号从images[0].channels()到images[0].channels() + images[1].channels()-1，以此类推。 mask：掩码。选择感兴趣区域，选定后只能对该区域进行操作。 hist：直方图计算的输出值。 dims：输出直方图的维度（由channels指定）。 histSize：直方图中每个dims维度需要分成多少个区间（直方图竖条的个数）。 ranges：统计像素值的区间。 uniform=true：是否对得到的直方图进行归一化处理。 accumulate=false：在多个图像时是否累计计算像素值的个数。 获取图像的直方图代码： #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat hist, image_gray; cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY); cv::namedWindow(\"img\", cv::WINDOW_NORMAL); cv::imshow(\"img\", image_gray); int hsize = 256; // 直方图区间数 float ranges[] = { 0, 256 }; // 统计像素值的区间 const float *hRanges = { ranges }; // 计算直方图的输出值 cv::calcHist(image_gray, 1, 0, cv::Mat(), hist, 1, hsize, hRanges, true, false); int hist_h = 300, hist_w = 512; // 直方图图像高和宽 int bin_w = hist_w / hsize; // 区间 // 直方图图像 cv::Mat histImage(hist_h, hist_w, CV_8UC3, cv::Scalar(255, 255, 255)); // 直方图输出值归一化到0~255 cv::normalize(hist, hist, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat()); for (int i = 1; i hsize; i ++) cv::line(histImage, cv::Point((i - 1) * bin_w, hist_h - cvRound(hist.atfloat(i - 1))), cv::Point((i) *bin_w, hist_h - cvRound(hist.atfloat(i))), cv::Scalar(100, 100, 100), 2); cv::imshow(\"pic\", histImage); cv::waitKey(0); return 0;} 效果展示： 4.2 直方图均衡化 通过均衡化处理可以使得图像的直方图分布变得较广较平均。 经过公式： sk=(L−1)∑j=0kPr(rj)，k=0,1…,L−1s_k = (L - 1)\\sum_{j=0}^kP_r(r_j)，k = 0,1…,L-1 sk​=(L−1)j=0∑k​Pr​(rj​)，k=0,1…,L−1 其中，sks_ksk​是变换后的灰度级，Pr(rj)P_r(r_j)Pr​(rj​)是灰度级为rjr_jrj​的直方图值。 涉及一个函数： void equalizeHist( InputArray src, OutputArray dst ) 该函数参数十分简单，只有输入图像矩阵和输出图像矩阵，即可进行图像直方图的均衡化。 代码： #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat hist, hist1, image_gray, image_; cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY); cv::namedWindow(\"img_before\", cv::WINDOW_NORMAL); cv::namedWindow(\"img_after\", cv::WINDOW_NORMAL); cv::imshow(\"img_before\", image_gray); // 直方图均衡化 cv::equalizeHist(image_gray, image_); cv::imshow(\"img_after\", image_); int hsize = 256; // 直方图区间数 float ranges[] = { 0, 256 }; // 统计像素值的区间 const float *hRanges = { ranges }; // 计算直方图的输出值 cv::calcHist(image_gray, 1, 0, cv::Mat(), hist, 1, hsize, hRanges, true, false); cv::calcHist(image_, 1, 0, cv::Mat(), hist1, 1, hsize, hRanges, true, false); int hist_h = 300, hist_w = 512; // 直方图图像高和宽 int bin_w = hist_w / hsize; // 区间 // 直方图图像 cv::Mat histImage(hist_h, hist_w, CV_8UC3, cv::Scalar(255, 255, 255)); cv::Mat histImage1(hist_h, hist_w, CV_8UC3, cv::Scalar(255, 255, 255)); // 直方图输出值归一化到0~255 cv::normalize(hist, hist, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat()); cv::normalize(hist1, hist1, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat()); for (int i = 1; i hsize; i ++) { cv::line(histImage, cv::Point((i - 1) * bin_w, hist_h - cvRound(hist.atfloat(i - 1))), cv::Point((i) *bin_w, hist_h - cvRound(hist.atfloat(i))), cv::Scalar(100, 100, 100), 2); cv::line(histImage1, cv::Point((i - 1) * bin_w, hist_h - cvRound(hist1.atfloat(i - 1))), cv::Point((i) *bin_w, hist_h - cvRound(hist1.atfloat(i))), cv::Scalar(100, 100, 100), 2); } cv::imshow(\"before\", histImage); cv::imshow(\"after\", histImage1); cv::waitKey(0); return 0;} 效果展示： 4.3 直方图匹配 将需要处理的图像匹配另一幅直方图形状。 由于直方图均衡化映射函数T为单调递增，即变换后的直方图可以经过逆变换回到原直方图。 得到直方图匹配的步骤： 计算输入图像的直方图 P(r)P(r)P(r) ，并进行直方图均衡化，得到均衡化后的灰度 sks_ksk​ 。 根据公式计算 G(zq)G(z_q)G(zq​) 并存储。 G(zq)=(L−1)∑i=0qPz(zj)G(z_q) = (L - 1)\\sum_{i = 0}^qP_z(z_j) G(zq​)=(L−1)i=0∑q​Pz​(zj​) 对 sks_ksk​ 的每个值，都找到 zqz_qzq​ 对应的值，使得 G(zq)G(z_q)G(zq​) 最接近 sks_ksk​ ，并存储从s到z的映射。 从步骤3中找到映射，将 sks_ksk​ 的值映射到直方图指定图像中值为 zqz_qzq​ 的对应像素，形成直方图。 涉及映射Look up Table（LUT）函数： void LUT(InputArray src, InputArray lut, OutputArray dst) 参数如下： src：表示输入图像。 lut：表示查找表。 dst：表示输出图像。 代码：white.jpg为纯白图像 #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat image1 = cv::imread(\"src/test.jpg\"), image2 = cv::imread(\"src/white.jpg\"); cv::Mat image1_gray, image2_gray, hist1, hist2, image_; cv::cvtColor(image1, image1_gray, cv::COLOR_BGR2GRAY); cv::cvtColor(image2, image2_gray, cv::COLOR_BGR2GRAY); cv::namedWindow(\"img1_gray\", cv::WINDOW_NORMAL); cv::namedWindow(\"img2_gray\", cv::WINDOW_NORMAL); cv::imshow(\"img1_gray\", image1_gray); cv::imshow(\"img2_gray\", image2_gray); // 图像1和图像2进行均衡化 cv::equalizeHist(image1_gray, image1_gray); cv::equalizeHist(image2_gray, image2_gray); // 求图像1和图像2均衡化后的直方图 int hsize = 256; float ranges[] = { 0, 256 }; const float *hranges = { ranges }; cv::calcHist(image1_gray, 1, 0, cv::Mat(), hist1, 1, hsize, hranges, true, false); cv::calcHist(image2_gray, 1, 0, cv::Mat(), hist2, 1, hsize, hranges, true, false); // 计算两个均衡化图像直方图的累积概率 float hist1_rate[256] = { hist1.atfloat(0) }; float hist2_rate[256] = { hist2.atfloat(0) }; for (int i = 1; i 256; i ++) { hist1_rate[i] = (hist1_rate[i - 1] + hist1.atfloat(i)); hist2_rate[i] = (hist2_rate[i - 1] + hist2.atfloat(i)); } for (int i = 0; i 256; i ++) { hist1_rate[i] /= (image1_gray.rows * image1_gray.cols); hist2_rate[i] /= (image2_gray.rows * image2_gray.cols); } // 两个累计概率之间的差值，用于找到最接近的点 float diff[256][256]; for (int i = 0; i 256; i ++) for (int j = 0; j 256; j ++) diff[i][j] = fabs(hist1_rate[i] - hist2_rate[j]); cv::Mat lut(1, 256, CV_8U); for (int i = 0; i 256; i ++) { // 查找源灰度级为i的映射灰度和i的累积概率差最小(灰度接近)的规定化灰度 float min = diff[i][0]; int idx = 0; for (int j = 0; j 256; j ++) { if(min diff[i][j]) { min = diff[i][j]; idx = j; } } lut.atuchar(i) = idx; } cv::LUT(image1_gray, lut, image_); cv::namedWindow(\"image_\", cv::WINDOW_NORMAL); cv::imshow(\"image_\", image_); cv::waitKey(0); return 0;} 效果展示： 五、空间滤波基础 讨论使用空间滤波器进行图像处理。 5.1 线性空间滤波 线性空间滤波器在图像f和滤波器核w之间执行乘积之和运算。 滤波器核（或称核）是一个阵列，其大小定义了运算的邻域，其系数决定了该滤波器的性质。 在上图的任何一点(x, y)处，滤波器的响应g(x, y)是核系数与核所覆盖图像像素的乘积之和： g(x,y)=w(−1,−1)f(x−1,y−1)+w(−1,0)f(x−1,y)+…+w(1,1)f(x+1,y+1)g(x,y) = w(-1,-1)f(x-1,y-1)+w(-1,0)f(x-1,y)+…+w(1,1)f(x+1, y+1) g(x,y)=w(−1,−1)f(x−1,y−1)+w(−1,0)f(x−1,y)+…+w(1,1)f(x+1,y+1) 坐标x和y变化时，核的中心逐个像素移动，并在移动过程中生成了滤波后的图像g。 核中心系数w(0,0)对其于(x,y)处的像素，当大小为m×n的核，假设m=2a+1，n=2b+1，a和b非负。这意味着这是两个坐标方向上奇数大小的核。 一般而言，大小为m×n的核对大小为M×N的图像的线性空间滤波可以表示为： g(x,y)=∑s=−aa∑t=−bbw(s,t)f(x+s,y+t)g(x,y) = \\sum_{s=-a}^a\\sum_{t=-b}^bw(s,t)f(x+s,y+t) g(x,y)=s=−a∑a​t=−b∑b​w(s,t)f(x+s,y+t) 在上式中，x和y发生变化时，核的原点可以访问图像的每个像素。当x和y不变时，上式即乘积之和，只适合任意奇数大小的核。 5.2 空间相关与卷积 对于式子： g(x,y)=∑s=−aa∑t=−bbw(s,t)f(x+s,y+t)g(x,y) = \\sum_{s=-a}^a\\sum_{t=-b}^bw(s,t)f(x+s,y+t) g(x,y)=s=−a∑a​t=−b∑b​w(s,t)f(x+s,y+t) 化简为一维讨论： g(x)=∑s=−aaw(s)f(x+s)g(x) = \\sum_{s=-a}^aw(s)f(x+s) g(x)=s=−a∑a​w(s)f(x+s) 举一个一维例子：核w为 1 2 4 2 8 相关 是滤波器核相对于图像的位移的函数，即相关的第一个值对应于核的零位移，第二个值对应于核的1单位位移。 卷积 是滤波器核先进行预旋转，再进行相对于图像位移的函数。 ①该核大小为 1×51\\times 51×5，那么有a=2，b=0。 ②w中心系数要与f的原点重合。 ③w的一部分在f之外，求和不能运算，所以进行零补充（零补充不是唯一选择）。如果核大小为1×m，那么在两侧都需要补 (m−1)/2(m-1)/2(m−1)/2 个0。 接下来根据移动和式计算： g(x)=∑s=−aaw(s)f(x+s)g(0)=∑s=−22w(s)f(s+0)=0g(1)=∑s=−22w(s)f(s+1)=8g(2)=∑s=−22w(s)f(s+2)=2g(3)=∑s=−22w(s)f(s+3)=4g(4)=∑s=−22w(s)f(s+4)=2g(5)=∑s=−22w(s)f(s+5)=1g(6)=∑s=−22w(s)f(s+6)=0g(7)=∑s=−22w(s)f(s+7)=0g(x) = \\sum_{s=-a}^aw(s)f(x+s)\\\\ g(0) = \\sum_{s=-2}^2w(s)f(s+0) = 0\\\\ g(1) = \\sum_{s=-2}^2w(s)f(s+1) = 8\\\\ g(2) = \\sum_{s=-2}^2w(s)f(s+2) = 2\\\\ g(3) = \\sum_{s=-2}^2w(s)f(s+3) = 4\\\\ g(4) = \\sum_{s=-2}^2w(s)f(s+4) = 2\\\\ g(5) = \\sum_{s=-2}^2w(s)f(s+5) = 1\\\\ g(6) = \\sum_{s=-2}^2w(s)f(s+6) = 0\\\\ g(7) = \\sum_{s=-2}^2w(s)f(s+7) = 0\\\\ g(x)=s=−a∑a​w(s)f(x+s)g(0)=s=−2∑2​w(s)f(s+0)=0g(1)=s=−2∑2​w(s)f(s+1)=8g(2)=s=−2∑2​w(s)f(s+2)=2g(3)=s=−2∑2​w(s)f(s+3)=4g(4)=s=−2∑2​w(s)f(s+4)=2g(5)=s=−2∑2​w(s)f(s+5)=1g(6)=s=−2∑2​w(s)f(s+6)=0g(7)=s=−2∑2​w(s)f(s+7)=0 另外，把一个元素是1，其余元素是0的函数称为 离散单位冲激函数。而核与离散单位冲激函数进行 相关 时，会在这个冲激的位置产生核的旋转版本。 广泛地说，一个函数与一个冲激进行卷积时，在冲激所在的位置产生这个函数的副本。 将一维推广到二维图像，对于大小为m×n的核，需要在图像的顶部核底部至少补 (m−1)/2(m-1)/2(m−1)/2 行0，在左侧和右侧至少补 (n−1)/2(n-1)/2(n−1)/2 列0。 假设m和n都为3： 二维下的旋转180°等效于核关于其一个轴旋转，再关于另一个轴旋转。 回头再看冲激函数，其坐标 (x0,y0)(x_0,y_0)(x0​,y0​) 处的离散冲激强度（振幅）A定义为： δ(x−x0,y−y0)={A,x0=x和y0=y0,其他δ(x-x_0,y-y_0)=\\left\\{ \\begin{matrix} A,x_0=x和y_0=y\\\\ 0,其他 \\end{matrix} \\right. δ(x−x0​,y−y0​)={A,0,​x0​=x和y0​=y其他​ 小结 大小为m×n的核w与图像f(x,y)的相关： w☆f(x,y)=(w☆f)(x,y)=∑s=−aa∑t=−bbw(s,t)f(x+s,y+t)w☆f(x,y)=(w☆f)(x,y)=\\sum_{s=-a}^a\\sum_{t=-b}^bw(s,t)f(x+s,y+t) w☆f(x,y)=(w☆f)(x,y)=s=−a∑a​t=−b∑b​w(s,t)f(x+s,y+t) 大小为m×n的核w与图像f(x,y)的卷积： w★f(x,y)=(w★f)(x,y)=∑s=−aa∑t=−bbw(s,t)f(x−s,y−t)w★f(x,y)=(w★f)(x,y)=\\sum_{s=-a}^a\\sum_{t=-b}^bw(s,t)f(x-s,y-t) w★f(x,y)=(w★f)(x,y)=s=−a∑a​t=−b∑b​w(s,t)f(x−s,y−t) 当卷积其中的一个函数旋转180°后，减号对应其f和w的坐标，也可以完成乘积之和处理即线性空间滤波。 相关和卷积运算满足的性质： 性质 卷积 相关 交换律 f★g = g★f 不成立 结合律 f★(g★h) = (f★g)★h 不成立 分配律 f★(g+h)=(f★g)+(f★h) f☆(g+h)=(f☆g)+(f☆h) 5.3 低通空间滤波器 5.3.1 盒式滤波器、均值滤波器 均值滤波就是将区域内的像素灰度值的平均值作为中心像素的灰度值。 一个3×3的均值滤波器核如： 11119×111111\\qquad 1\\qquad1\\qquad1\\\\ \\frac 19\\times 1\\qquad 1\\qquad1\\\\ \\qquad 1\\qquad1\\qquad1 11191​×111111 OpenCV提供了一个均值滤波（盒式滤波器）函数； void blur(InputArray src, OutputArray dst, Size ksize, Point anchor = Point(-1,-1), int borderType = BORDER_DEFAULT) 参数如下： src：输入图像; 它可以有任意数量的通道，这些通道是独立处理的，但深度应该是CV_8U, CV_16U, CV_16S, CV_32F或CV_64F。 dst：输出与src相同大小和类型的图像。 ksize：核大小，cv::Size类型。 anchor：锚点，默认值Point(-1，-1)表示锚点位于内核中心。 borderType：int类型，用于推断图像外部像素的某种边界模式，一般不管。 代码： #include opencv2/opencv.hpp#include iostream// 手动实现盒式均值滤波器void filter(int filter_size, cv::Mat image_input, cv::Mat image_output){ image_output = image_input.clone(); int k = (filter_size - 1) / 2; // 实现对齐核中心元素 for (int i = k; i image_input.rows - k; i ++) { for (int j = k; j image_input.cols - k; j ++) { int sum = 0; // 计算相关 for (int m = -k; m k + 1; m ++) for (int n = -k; n k + 1; n ++) sum += image_input.atuchar(i + m, j + n); image_output.atuchar(i, j) = round(sum / (filter_size * filter_size)); } }}int main(){ cv::Mat image = cv::imread(\"src/test.jpg\", 0); cv::Mat image_output, image_output2; cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // CV自带的均值滤波器，核大小为7 cv::blur(image, image_output, cv::Size(7, 7)); // 自己实现的均值滤波器，核大小为7 filter(7, image, image_output2); // 对比CV自带的均值滤波器与自己实现的均值滤波器性能表现 cv::namedWindow(\"after1\", cv::WINDOW_NORMAL); cv::imshow(\"after1\", image_output); cv::namedWindow(\"after2\", cv::WINDOW_NORMAL); cv::imshow(\"after2\", image_output2); cv::waitKey(0); return 0;} 效果展示： 也许上述效果不明显，可以进行彩色图像，增加杂波，再进行均值滤波器处理。 代码： #include opencv2/opencv.hpp#include iostream#include random// 随机将n个像素值变成白点，构成噪声void Salt(cv::Mat image, int n){ // 生成随机数 std::default_random_engine generater; std::uniform_int_distributionintrandomRow(0, image.rows - 1); std::uniform_int_distributionintrandomCol(0, image.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = randomRow(generater); j = randomCol(generater); if (image.channels() == 1) image.atuchar(i, j) = 255; if (image.channels() == 3) { image.atcv::Vec3b(i, j)[0] = 255; image.atcv::Vec3b(i, j)[1] = 255; image.atcv::Vec3b(i, j)[2] = 255; } }}// 手动实现均值滤波器，BGR三通道都进行均值滤波void filter(int filter_size, cv::Mat image_input, cv::Mat image_output){ image_output = image_input.clone(); int k = (filter_size - 1) / 2; for (int i = k; i image_input.rows - k; i ++) { for (int j = k; j image_input.cols - k; j ++) { int sum1 = 0, sum2 = 0, sum3 = 0; for (int m = -k; m k + 1; m ++) { for (int n = -k; n k + 1; n ++) { sum1 += image_input.atcv::Vec3b(i + m, j + n)[0]; sum2 += image_input.atcv::Vec3b(i + m, j + n)[1]; sum3 += image_input.atcv::Vec3b(i + m, j + n)[2]; } } image_output.atcv::Vec3b(i, j)[0] = round(sum1 / (filter_size * filter_size)); image_output.atcv::Vec3b(i, j)[1] = round(sum2 / (filter_size * filter_size)); image_output.atcv::Vec3b(i, j)[2] = round(sum3 / (filter_size * filter_size)); } }}int main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat image_output, image_output2; Salt(image, 100000); // 随机生成10w个白点构成噪声 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); cv::blur(image, image_output, cv::Size(7, 7)); filter(7, image, image_output2); cv::namedWindow(\"after1\", cv::WINDOW_NORMAL); cv::imshow(\"after1\", image_output); cv::namedWindow(\"after2\", cv::WINDOW_NORMAL); cv::imshow(\"after2\", image_output2); cv::waitKey(0); return 0;} 5.3.2 高斯滤波器 在统计学与概率论中，高斯函数是正态分布（高斯分布）的密度函数。一维的高斯表达式如下： f(x)=ae−(x−μ)22σ2f(x)=ae^{-\\frac{(x-μ)^2} {2σ^2} }\\\\ f(x)=ae−2σ2(x−μ)2​ 其中a、μ、σ为实数常数，a0；a表示曲线的高度，μ表示曲线在x轴的中心，σ与半峰全宽有关。 而二维高斯表达式如下： G(x,y)=12πσ2e−−(x2+y2)2σ2G(x,y)=\\frac{1} {2\\piσ^2}e^{-\\frac{-(x^2+y^2)} {2σ^2} } G(x,y)=2πσ21​e−2σ2−(x2+y2)​ 故高斯核为： w(s,t)=G(s,t)=Ke−s2+t22σ2G(r)=Ke−r22σ2，当r=(s2+t2)12w(s,t)=G(s,t)=Ke^{-\\frac{s^2+t^2} {2σ^2} }\\\\ G(r)=Ke^{-\\frac{r^2} {2σ^2} }，当r=(s^2+t^2)^{\\frac 12} w(s,t)=G(s,t)=Ke−2σ2s2+t2​G(r)=Ke−2σ2r2​，当r=(s2+t2)21​ OpenCV提供了一个高斯滤波器函数； void GaussianBlur( InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ) 参数如下： src：输入图像; 它可以有任意数量的通道，这些通道是独立处理的，但深度应该是CV_8U, CV_16U, CV_16S, CV_32F或CV_64F。 dst：输出与src相同大小和类型的图像。 ksize：核大小，cv::Size类型。 sigmaX：高斯核函数在X方向上的标准偏差。 sigmaY：高斯核函数在Y方向上的标准偏差。如果sigmaY为0，则将其设为sigmaX；如果sigmaX核sigmaY都为0，则有ksize.width核ksize.height计算。 borderType：int类型，用于推断图像外部像素的某种边界模式，一般不管。 代码： #include opencv2/opencv.hpp#include iostream#include random#include cmath// 随机将n个像素值变成白点，构成噪声void Salt(cv::Mat image, int n){ // 生成随机数 std::default_random_engine generater; std::uniform_int_distributionintrandomRow(0, image.rows - 1); std::uniform_int_distributionintrandomCol(0, image.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = randomRow(generater); j = randomCol(generater); if (image.channels() == 1) image.atuchar(i, j) = 255; if (image.channels() == 3) { image.atcv::Vec3b(i, j)[0] = 255; image.atcv::Vec3b(i, j)[1] = 255; image.atcv::Vec3b(i, j)[2] = 255; } }}// 手动实现高斯滤波器，BGR三通道都进行高斯滤波void filter1(int filter_size, cv::Mat image_input, cv::Mat image_output){ image_output = image_input.clone(); int k = (filter_size - 1) / 2; for (int i = k; i image_input.rows - k; i ++) { for (int j = k; j image_input.cols - k; j ++) { double sum1 = 0.0, sum2 = 0.0, sum3 = 0.0; double sum1_ = 0.0, sum2_ = 0.0, sum3_ = 0.0; double sigma = 7, g; // sigma可修改 for (int m = -k; m k + 1; m ++) { for (int n = -k; n k + 1; n ++) { g = exp(-(m * m + n * n) / (2 * sigma * sigma)); sum1 += g * image_input.atcv::Vec3b(i + m, j + n)[0]; sum1_ += g; sum2 += g * image_input.atcv::Vec3b(i + m, j + n)[1]; sum2_ += g; sum3 += g * image_input.atcv::Vec3b(i + m, j + n)[2]; sum3_ += g; } } image_output.atcv::Vec3b(i, j)[0] = (int) round(sum1 / sum1_); image_output.atcv::Vec3b(i, j)[1] = (int) round(sum2 / sum2_); image_output.atcv::Vec3b(i, j)[2] = (int) round(sum3 / sum3_); } }}int main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat image_output, image_output2; Salt(image, 100000); // 随机生成10w个白点构成噪声 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); cv::GaussianBlur(image, image_output, cv::Size(7, 7), 2, 2); filter1(7, image, image_output2); cv::namedWindow(\"after1\", cv::WINDOW_NORMAL); cv::imshow(\"after1\", image_output); cv::namedWindow(\"after2\", cv::WINDOW_NORMAL); cv::imshow(\"after2\", image_output2); cv::waitKey(0); return 0;} 效果展示： 5.3.3 中值滤波 中值滤波就是取周围邻域像素灰度值（或GRB值）的中值作为中心像素灰度值结果。 OpenCV提供了一个中值滤波器函数； void medianBlur(InputArray src, OutputArray dst, int ksize) 参数如下： src：输入图像; 输入1、3或4通道图像，当ksize为3或5时，图像深度应该是CV_8U、CV_16U或CV_32F，对于更大的孔径尺寸，只能是CV_8U。 dst：输出与src相同大小和类型的图像。 ksize：核大小。 代码： #include opencv2/opencv.hpp#include iostream#include random#include cmath// 随机将n个像素值变成白点，构成噪声void Salt(cv::Mat image, int n){ // 生成随机数 std::default_random_engine generater; std::uniform_int_distributionintrandomRow(0, image.rows - 1); std::uniform_int_distributionintrandomCol(0, image.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = randomRow(generater); j = randomCol(generater); if (image.channels() == 1) image.atuchar(i, j) = 255; if (image.channels() == 3) { image.atcv::Vec3b(i, j)[0] = 255; image.atcv::Vec3b(i, j)[1] = 255; image.atcv::Vec3b(i, j)[2] = 255; } }}// 找中值cv::Vec3b MedianFinding(cv::Mat mat, int filter_size){ cv::Vec3b tmp; cv::Vec3b m; for (int i = 1; i = filter_size - 1; i++) { for (int j = 1; j = filter_size - i; j++) { if (mat.atcv::Vec3b(j - 1)[0] mat.atcv::Vec3b(j)[0]) { tmp = mat.atcv::Vec3b(j - 1); mat.atcv::Vec3b(j - 1) = mat.atcv::Vec3b(j); mat.atcv::Vec3b(j) = tmp; } } } return m = mat.atcv::Vec3b((filter_size + 1) / 2);}// 手动实现中值滤波器，BGR三通道都进行中值滤波void filter2(int filter_size, cv::Mat image_input, cv::Mat image_output){ image_output = image_input.clone(); int k = (filter_size - 1) / 2; cv::Mat arry(1, filter_size * filter_size, CV_8UC3); for (int i = k; i image_input.rows - k; i ++) { for (int j = k; j image_input.cols - k; j ++) { int mid = 0; for (int m = -k; m k + 1; m ++) { for (int n = -k; n k + 1; n ++) { arry.atcv::Vec3b(mid) = image_input.atcv::Vec3b(i + m, j + n); mid ++; } } image_output.atcv::Vec3b(i, j) = MedianFinding(arry, filter_size * filter_size); } }}int main(){ cv::Mat image = cv::imread(\"src/test.jpg\"); cv::Mat image_output, image_output2; Salt(image, 100000); // 随机生成10w个白点构成噪声 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); cv::medianBlur(image, image_output, 7); filter2(7, image, image_output2); // 个人体验速度较慢 cv::namedWindow(\"after1\", cv::WINDOW_NORMAL); cv::imshow(\"after1\", image_output); cv::namedWindow(\"after2\", cv::WINDOW_NORMAL); cv::imshow(\"after2\", image_output2); cv::waitKey(0); return 0;} 效果展示： 5.4 高通空间滤波器 5.4.1 基础 锐化的作用时突出灰度中的过渡。 平滑可以类似为积分运算，那么锐化则可以类似为微分运算。图像模糊在空间域中可以通过平均（平滑）一个邻域中的像素实现。而图像微分将会增强边缘和其他不连续（如噪声）。 数字函数的导数是用差分定义，一阶导数的任何定义都要满足： 恒定灰度区域的一阶导数必须为零。 灰度台阶或斜坡开始处的一阶导数必须非零。 灰度斜坡上的一阶导数必须非零。 类似有二阶导数的任何定义都要满足： 恒定灰度区域的二阶导数必须为零。 灰度台阶或斜坡的开始处和结束处的二阶导数必须非零。 灰度斜坡上的二阶导数必须为零。 而处理图像时，变化发生的最短距离也就是像素间的距离。 一维函数 f(x)f(x)f(x) 的一阶导数的一个基本定义是差分： dfdx=f(x+1)−f(x)\\frac {\\mathrm{d}f} {\\mathrm{d}x}=f(x+1)-f(x) dxdf​=f(x+1)−f(x) 二维函数 f(x,y)f(x,y)f(x,y) 的二阶导数定义为差分： ∂2f∂x2=f(x+1)+f(x−1)−2f(x)\\frac {\\partial^2 f} {\\partial x^2}=f(x+1)+f(x-1)-2f(x) ∂x2∂2f​=f(x+1)+f(x−1)−2f(x) 先用一维函数举例： 一维函数导数满足上述性质，类比一维函数可知二维函数。数字图像的边缘在灰度上通常类似于斜坡过渡，图像的一阶导数会产生较宽的边缘；另外，二阶导数会产生宽度为1像素并由零分隔的双边缘。所以， 与一阶导数相比，二阶导数可增强更精细的细节，而实现二阶导数所需的运算量也更少。 5.4.2 拉普拉斯锐化滤波 最简单的各向同性导数算子（核）是拉普拉斯。 对于两个变量的函数 f(x,y)f(x,y)f(x,y) ，定义为： ∇2f=∂2f∂x2+∂2f∂y2 abla^2f=\\frac {\\partial^2f} {\\partial x^2} + \\frac {\\partial^2f} {\\partial y^2} ∇2f=∂x2∂2f​+∂y2∂2f​ 拉普拉斯是线性算子。在x方向有： ∂2f∂x2=f(x+1,y)+f(x−1,y)−2f(x,y)\\frac{\\partial^2f} {\\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y) ∂x2∂2f​=f(x+1,y)+f(x−1,y)−2f(x,y) 在y方向有： ∂2f∂x2=f(x,y+1)+f(x,y−1)−2f(x,y)\\frac{\\partial^2f} {\\partial x^2}=f(x,y+1)+f(x,y-1)-2f(x,y) ∂x2∂2f​=f(x,y+1)+f(x,y−1)−2f(x,y) 由上面三个式子可得两个变量的拉普拉斯是： ∇2f(x,y)=f(x+1,y)+f(x−1,y)+f(x,y+1)+f(x,y−1)−4f(x,y) abla^2f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y) ∇2f(x,y)=f(x+1,y)+f(x−1,y)+f(x,y+1)+f(x,y−1)−4f(x,y) 该公式可以使用卷积运算，上式的拉普拉斯核为： 0 1 0 1 -4 1 0 1 0 (a) 这个也叫四邻域核，还有八邻域核： 1 1 1 1 -8 1 1 1 1 (b) 两个其他的核（系数反转）： 0 -1 0 -1 4 -1 0 -1 0 © -1 -1 -1 -1 8 -1 -1 -1 -1 (d) 但是不能直接使用拉普拉斯，它会突出图像中急剧灰度过渡，不强调缓慢变化的灰度区域，往往会产生具有灰色边缘线核其他不连续的图像。所以需要 将拉普拉斯图像和原图像相加恢复背景特征。 使用拉普拉斯锐化图像： g(x,y)=f(x,y)+c[∇2f(x,y)]g(x,y)=f(x,y)+c[ abla^2f(x,y)] g(x,y)=f(x,y)+c[∇2f(x,y)] f(x,y)为输入图像，g(x,y)为锐化后图像。若使用核(a)或核(b)，取c=-1；若使用核©或核(d)，取c=1。 代码： #include opencv2/opencv.hpp#include iostream// 四邻域拉普拉斯核void filter_4(cv::Mat input, cv::Mat output){ output = input.clone(); int la; for (int i = 1; i input.rows - 1; i ++) for (int j = 1; j input.cols - 1; j ++) { la = input.atuchar(i + 1, j) + input.atuchar(i - 1, j) + input.atuchar(i, j + 1) + input.atuchar(i, j - 1) - 4 * input.atuchar(i, j); output.atuchar(i, j) = cv::saturate_castuchar(output.atuchar(i, j) - la); }}// 八邻域拉普拉斯核void filter_8(cv::Mat input, cv::Mat output){ output = input.clone(); int la; for (int i = 1; i input.rows - 1; i ++) for (int j = 1; j input.cols - 1; j ++) { la = input.atuchar(i - 1, j - 1) + input.atuchar(i - 1, j) + input.atuchar(i - 1, j + 1) + input.atuchar(i, j - 1) + input.atuchar(i, j + 1) + input.atuchar(i + 1, j - 1) + input.atuchar(i + 1, j) + input.atuchar(i + 1, j + 1) - 8 * input.atuchar(i, j); output.atuchar(i, j) = cv::saturate_castuchar(output.atuchar(i, j) - la); }}int main(){ cv::Mat image = cv::imread(\"src/test.jpg\", 0); cv::Mat image_output, image_output2; cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); filter_4(image, image_output); filter_8(image, image_output2); cv::namedWindow(\"after1\", cv::WINDOW_NORMAL); cv::imshow(\"after1\", image_output); cv::namedWindow(\"after2\", cv::WINDOW_NORMAL); cv::imshow(\"after2\", image_output2); cv::waitKey(0); return 0;} 拉普拉斯锐化滤波对于灰度图像的影响十分明显，但是对于彩色图像影响一般。如果想改为适用于彩色图像，只需将数据类型从 uchar 改为 cv::Vec2b。 效果展示： 5.4.3 一阶导数锐化——梯度 一阶导数是用梯度幅度实现。图像f在坐标(x,y)处的梯度定义为二维列向量： ∇f≡grad(f)=[gxgy]=[∂f/∂x∂f/∂y] abla f\\equiv grad(f)=\\left[\\begin{matrix}g_x \\\\ g_y\\end{matrix}\\right]=\\left[\\begin{matrix}\\partial f/\\partial x \\\\ \\partial f/\\partial y\\end{matrix}\\right] ∇f≡grad(f)=[gx​gy​​]=[∂f/∂x∂f/∂y​] 这个向量指向f的最大变化率方向。 向量 ∇f abla f∇f 的幅度（长度）表示为M(x,y)（有时候用 ∣∣∇f∣∣\\vert\\vert abla f\\vert\\vert∣∣∇f∣∣ ），其中 M(x,y)=∣∣∇f∣∣=mag(∇f)=gx2+gy2M(x,y)=\\vert\\vert abla f\\vert\\vert=mag( abla f)=\\sqrt{g_x^2+g_y^2} M(x,y)=∣∣∇f∣∣=mag(∇f)=gx2​+gy2​​ 是梯度向量方向的变化率在(x,y)处的值，方向为： α(x,y)=tan⁡−1[gy(x,y)gx(x,y)]\\alpha(x,y)=\\tan^{-1}\\left[\\begin{matrix}\\frac{g_y(x,y)} {g_x(x,y)}\\end{matrix}\\right] α(x,y)=tan−1[gx​(x,y)gy​(x,y)​​] 而M(x,y)是与原图像大小相同的图像，也称为梯度图像。 梯度常用于检测边缘，在边缘检测会详细介绍。 六、频率域滤波 6.1 傅里叶变换 6.1.1 傅里叶级数 傅里叶级数：任何周期函数都可表示为不同频率的正弦函数和或余弦函数和，其中每个正弦函数和或余弦函数和都有不同的系数。 f(t)=∑n=−∞∞cnej2πnTtf(t)=\\sum_{n=-\\infty}^\\infty c_ne^{j\\frac {2\\pi n} {T}t} f(t)=n=−∞∑∞​cn​ejT2πn​t 其中， cn=1T∫−T/2T/2f(t)e−j2πnTtdt,n=0,±1,±2,…c_n=\\frac 1T\\int_{-T/2}^{T/2}f(t)e^{-j\\frac {2\\pi n} {T}t}dt,n=0,\\pm 1,\\pm 2,… cn​=T1​∫−T/2T/2​f(t)e−jT2πn​tdt,n=0,±1,±2,… 是系数。此篇j表示虚数单位： j2=−1j^2=-1j2=−1 。 6.1.2 傅里叶变换 傅里叶变换：（曲线下方面积有限的）非周期函数也能用正弦函数和/或余弦函数乘以加权函数的积分来表示 这表明用傅里叶级数或变换表示的函数可由逆过程完全重建（复原），而不丢失信息；允许我们工作在傅里叶域，然后返回到函数的原始域中，而不会丢失任何信息。 计算机慢慢出现了快速傅里叶变换算法（FFT），使用FFT进行频率域处理比不可分离核的空间域处理要快。 6.1.3 冲激函数及其取样（筛选）性质 连续变量t在t=0处的单位冲激表示为 δ(t)\\delta(t)δ(t) ，其定义为： δ(t)={∞,t=00,t≠0\\delta(t)=\\begin{cases} \\infty,t=0\\\\ 0, t eq 0 \\end{cases} δ(t)={∞,0,​t=0t​=0​ 该定义被限制满足： ∫−∞∞δ(t)dt=1\\int_{-\\infty}^{\\infty}\\delta(t)dt=1 ∫−∞∞​δ(t)dt=1 当t解释为时间时，冲激可视作幅度为无线、持续时间为0、具有单位面积的尖峰信号。 冲激具有关于积分的所谓 取样性质 ： ∫−∞∞f(t)δ(t)dt=f(0)\\int_{-\\infty}^{\\infty}f(t)\\delta(t)dt=f(0) ∫−∞∞​f(t)δ(t)dt=f(0) 对其一般化，任意一点 t0t_0t0​ 的冲激表示为 δ(t−t0)\\delta(t-t_0)δ(t−t0​) ，有： ∫−∞∞f(t)δ(t−t0)dt=f(t0)\\int_{-\\infty}^{\\infty}f(t)\\delta(t-t_0)dt=f(t_0) ∫−∞∞​f(t)δ(t−t0​)dt=f(t0​) 举一个小例子，取 f(t)=cos⁡(t)f(t)=\\cos(t)f(t)=cos(t) ，则使用冲激 δ(t−π)\\delta(t-\\pi)δ(t−π) 得到取样 f(π)=cos⁡(π)=−1f(\\pi)=\\cos(\\pi)=-1f(π)=cos(π)=−1 。 冲激串则是无穷多个冲激 ΔT\\Delta TΔT 单位的和： sΔT(t)=∑k=−∞∞δ(t−kΔT)s_{\\Delta T}(t)=\\sum_{k=-\\infty}^{\\infty}\\delta(t-k\\Delta T) sΔT​(t)=k=−∞∑∞​δ(t−kΔT) 单位离散冲激 δ(x)\\delta(x)δ(x) 在离散系统的作用域处理连续变量时冲激 δ(t)\\delta(t)δ(t) 作用相同，定义为： δ(x)={1,x=00,x≠0\\delta(x)=\\begin{cases} 1,x=0\\\\ 0, x eq 0 \\end{cases} δ(x)={1,0,​x=0x​=0​ 该定义被限制的离散等效形式为： ∑x=−∞∞δ(x)=1\\sum_{x=-\\infty}^{\\infty}\\delta(x) = 1 x=−∞∑∞​δ(x)=1 离散变量的取样性质的形式为： ∑x=−∞∞f(x)δ(x)=f(0)\\sum_{x=-\\infty}^{\\infty}f(x)\\delta(x)=f(0) x=−∞∑∞​f(x)δ(x)=f(0) 一般式为： ∑x=−∞∞f(x)δ(x−x0)=f(x0)\\sum_{x=-\\infty}^{\\infty}f(x)\\delta(x-x_0)=f(x_0) x=−∞∑∞​f(x)δ(x−x0​)=f(x0​) 小结： 项 连续变量t 离散变量x 在0处的单位冲激 δ(t)={∞,t=00,t≠0\\delta(t)=\\begin{cases}\\infty,t=0\\\\0, t eq 0\\end{cases}δ(t)={∞,0,​t=0t​=0​ δ(x)={1,x=00,x≠0\\delta(x)=\\begin{cases}1,x=0\\\\0, x eq 0\\end{cases}δ(x)={1,0,​x=0x​=0​ 单位冲激满足 ∫−∞∞δ(t)dt=1\\int_{-\\infty}^{\\infty}\\delta(t)dt=1∫−∞∞​δ(t)dt=1 ∑x=−∞∞δ(x)=1\\sum_{x=-\\infty}^{\\infty}\\delta(x) = 1∑x=−∞∞​δ(x)=1 取样性质 ∫−∞∞f(t)δ(t)dt=f(0)\\int_{-\\infty}^{\\infty}f(t)\\delta(t)dt=f(0)∫−∞∞​f(t)δ(t)dt=f(0) ∑x=−∞∞f(x)δ(x)=f(0)\\sum_{x=-\\infty}^{\\infty}f(x)\\delta(x)=f(0)∑x=−∞∞​f(x)δ(x)=f(0) 取样性质一般化 ∫−∞∞f(t)δ(t−t0)dt=f(t0)\\int_{-\\infty}^{\\infty}f(t)\\delta(t-t_0)dt=f(t_0)∫−∞∞​f(t)δ(t−t0​)dt=f(t0​) ∑x=−∞∞f(x)δ(x−x0)=f(x0)\\sum_{x=-\\infty}^{\\infty}f(x)\\delta(x-x_0)=f(x_0)∑x=−∞∞​f(x)δ(x−x0​)=f(x0​) 冲激串： sΔT(t)=∑k=−∞∞δ(t−kΔT)s_{\\Delta T}(t)=\\sum_{k=-\\infty}^{\\infty}\\delta(t-k\\Delta T) sΔT​(t)=k=−∞∑∞​δ(t−kΔT) 6.1.4 连续单变量函数的傅里叶变换 连续变量t的连续函数f(t)的傅里叶变换 ℑ{f(t)}\\Im\\{f(t)\\}ℑ{f(t)} 表示，它定义为： ℑ{f(t)}=∫−∞∞f(t)e−j2πμtdt\\Im\\{f(t)\\}=\\int_{-\\infty}^{\\infty}f(t)e^{-j2\\pi \\mu t}dt ℑ{f(t)}=∫−∞∞​f(t)e−j2πμtdt 上式中， μ\\muμ 为连续变量，积分变量为t，所以 ℑ{f(t)}\\Im\\{f(t)\\}ℑ{f(t)} 只是 μ\\muμ 的函数，即 ℑ{f(t)}=F(μ)\\Im\\{f(t)\\}=F(\\mu)ℑ{f(t)}=F(μ) ，所以 f(t)f(t)f(t) 的傅里叶变换也可以写为： F(μ)=∫−∞∞f(t)e−j2πμtdt①F(\\mu)=\\int_{-\\infty}^{\\infty}f(t)e^{-j2\\pi \\mu t}dt \\quad ① F(μ)=∫−∞∞​f(t)e−j2πμtdt① 相反，已知 F(μ)F(\\mu)F(μ) 是可以通过傅里叶反变换得到 f(t)f(t)f(t) ，为： f(t)=∫−∞∞F(μ)ej2πμtdt②f(t)=\\int_{-\\infty}^{\\infty}F(\\mu)e^{j2\\pi \\mu t}dt\\quad ② f(t)=∫−∞∞​F(μ)ej2πμtdt② 称①式和②式共同构成傅里叶变换对，通常表示为 f(t)⇔F(μ)f(t) \\Leftrightarrow F(\\mu)f(t)⇔F(μ) 。双箭头表明傅里叶正变换得到右侧表达式，而左侧表达式是取右侧表达式的傅里叶反变换得到。 利用欧拉公式 ejθ=cos⁡θ+jsin⁡θe^{j\\theta}=\\cos\\theta+j\\sin\\thetaejθ=cosθ+jsinθ ，将式①变成 F(μ)=∫−∞∞f(t)[cos⁡(2πμt)−jsin⁡(2πμt)]dtF(\\mu)=\\int_{-\\infty}^{\\infty}f(t)[\\cos(2\\pi\\mu t)-j\\sin(2\\pi\\mu t)]dt F(μ)=∫−∞∞​f(t)[cos(2πμt)−jsin(2πμt)]dt 可以看到，如果f(t)为实数，则变换通常是复数。傅里叶变换式f(t)乘以正弦函数的展开式，而其中正弦函数的频率由 μ\\muμ 值决定。因此积分后留下的唯一变量是频率，故称傅里叶变换域是频率域。 讨论中， ttt 可以表示任何连续变量，并且频率变量 μ\\muμ 的单位取决于 ttt 的单位。 举个例子： 对盒式函数进行傅里叶变换，有 F(μ)=∫−∞∞f(t)e−j2πμtdt=∫−W/2W/2Ae−j2πμtdt=−Aj2πμ[e−j2πμt]−W/2W/2=−Aj2πμ[e−jπμW−ejπμW]=Aj2πμ[ejπμW−e−jπμW]=AWsin⁡(πμW)πμWF(\\mu)=\\int_{-\\infty}^{\\infty}f(t)e^{-j2\\pi\\mu t}dt=\\int_{-W/2}^{W/2}Ae^{-j2\\pi\\mu t}dt\\\\ =\\frac {-A} {j2\\pi\\mu}\\Big[e^{-j2\\pi\\mu t}\\Big]^{W/2}_{-W/2}=\\frac {-A} {j2\\pi\\mu}\\Big[e^{-j\\pi\\mu W}-e^{j\\pi\\mu W}\\Big]\\\\ =\\frac {A} {j2\\pi\\mu}\\Big[e^{j\\pi\\mu W}-e^{-j\\pi\\mu W}\\Big]=AW\\frac {\\sin(\\pi\\mu W)} {\\pi\\mu W} F(μ)=∫−∞∞​f(t)e−j2πμtdt=∫−W/2W/2​Ae−j2πμtdt=j2πμ−A​[e−j2πμt]−W/2W/2​=j2πμ−A​[e−jπμW−ejπμW]=j2πμA​[ejπμW−e−jπμW]=AWπμWsin(πμW)​ 上式用到了 sin⁡θ=(ejθ−e−jθ)/2j\\sin\\theta=(e^{j\\theta}-e^{-j\\theta})/2jsinθ=(ejθ−e−jθ)/2j 傅里叶变换中包含复数项，这是为了显示变换的幅值（一个实量）的一种约定。这个幅值称为傅里叶频谱或频谱： ∣F(μ)∣=AW∣sin⁡(πμW)πμW∣\\vert F(\\mu)\\vert=AW\\vert\\frac{\\sin(\\pi\\mu W)} {\\pi\\mu W}\\vert ∣F(μ)∣=AW∣πμWsin(πμW)​∣ F(μ)F(\\mu)F(μ) 与频率的关系曲线如下： 该曲线的关键性质： F(μ)F(\\mu)F(μ) 和 ∣F(μ)∣\\vert F(\\mu)\\vert∣F(μ)∣ 的零值都与盒式函数的宽度W成反比； 到原点的距离越大，旁瓣的高度随到原点的举例增加而减小； 函数向μ的正负方向无限扩展。 再举一个冲激傅里叶变换的例子。 位于原点的单位冲激的傅里叶变换由上面式①得： ℑ{δ(t)}=F(μ)=∫−∞∞f(t)e−j2πμtdt=∫∞∞δ(t)e−j2πμtdt=e−j2πμ0=e0=1\\Im \\{\\delta(t)\\}=F(\\mu)=\\int_{-\\infty}^{\\infty}f(t)e^{-j2\\pi \\mu t}dt=\\int_{\\infty}^{\\infty}\\delta(t)e^{-j2\\pi\\mu t}dt=e^{-j2\\pi\\mu_0}=e^0=1 ℑ{δ(t)}=F(μ)=∫−∞∞​f(t)e−j2πμtdt=∫∞∞​δ(t)e−j2πμtdt=e−j2πμ0​=e0=1 这就是空间域原点位置的一个冲激的傅里叶变换，在频率域中是一个常数。 当 t=t0t=t_0t=t0​ 处一个冲击傅里叶变换是： ℑ{δ(t)}=F(μ)=∫∞∞δ(t−t0)e−j2πμtdt=∫−∞∞e−j2πμtδ(t−t0)dt=e−j2πμt0\\Im \\{\\delta(t)\\}=F(\\mu)=\\int_{\\infty}^{\\infty}\\delta(t-t_0)e^{-j2\\pi\\mu t}dt=\\int_{-\\infty}^{\\infty}e^{-j2\\pi\\mu t}\\delta(t-t_0)dt=e^{-j2\\pi\\mu t_0} ℑ{δ(t)}=F(μ)=∫∞∞​δ(t−t0​)e−j2πμtdt=∫−∞∞​e−j2πμtδ(t−t0​)dt=e−j2πμt0​ 上式使用了取样一般化性质。 e−j2πμt0e^{-j2\\pi\\mu t_0}e−j2πμt0​ 表示中心在复平面原点的一个单位圆。 观察式①式② F(μ)=∫−∞∞f(t)e−j2πμtdtf(t)=∫−∞∞F(μ)ej2πμtdtF(\\mu)=\\int_{-\\infty}^{\\infty}f(t)e^{-j2\\pi \\mu t}dt \\\\ f(t)=\\int_{-\\infty}^{\\infty}F(\\mu)e^{j2\\pi \\mu t}dt\\quad F(μ)=∫−∞∞​f(t)e−j2πμtdtf(t)=∫−∞∞​F(μ)ej2πμtdt 发现只有指数符号不同。因此如果函数f(t)有傅里叶变换F(μ)，那么求该函数在点t的值F(t)时，一定有变换f(-μ)。利用这种对称性质，将冲激 δ(t−t0)\\delta(t-t_0)δ(t−t0​) 的傅里叶变换 e−j2πμt0e^{-j2\\pi\\mu t_0}e−j2πμt0​ 得到函数 e−j2πμt0e^{-j2\\pi\\mu t_0}e−j2πμt0​ 的变换为 δ(−μ−t0)\\delta(-\\mu-t_0)δ(−μ−t0​) 。令 −t0=a-t_0=a−t0​=a ，可得 ej2πate^{j2\\pi a t}ej2πat 的变换是 δ(−μ+a)=δ(μ+a)\\delta(-\\mu+a)=\\delta(\\mu+a)δ(−μ+a)=δ(μ+a) 冲激串 sΔT(t)s_{\\Delta T}(t)sΔT​(t) 是周期为 ΔT\\Delta TΔT 的周期函数： sΔT(t)=∑k=−∞∞δ(t−kΔT)s_{\\Delta T}(t)=\\sum_{k=-\\infty}^{\\infty}\\delta(t-k\\Delta T) sΔT​(t)=k=−∞∑∞​δ(t−kΔT) 因此可以表示为傅里叶级数： sΔT(t)=∑k=−∞∞cnej2πnΔTt,cn=1ΔT∫−ΔT/2ΔT/2SΔT(t)e−j2πnΔTtdts_{\\Delta T}(t)=\\sum_{k=-\\infty}^{\\infty}c_ne^{j\\frac{2\\pi n} {\\Delta T}t},\\\\ c_n=\\frac{1} {\\Delta T}\\int_{-\\Delta T/2}^{\\Delta T/2}S_{\\Delta T}(t)e^{-j\\frac{2\\pi n} {\\Delta T}t}dt sΔT​(t)=k=−∞∑∞​cn​ejΔT2πn​t,cn​=ΔT1​∫−ΔT/2ΔT/2​SΔT​(t)e−jΔT2πn​tdt 由于区间 [−ΔT/2,ΔT/2]\\big[-\\Delta T/2,\\Delta T/2\\big][−ΔT/2,ΔT/2] 上积分仅包含原点的冲激，故上式简化为： cn=1ΔT∫−ΔT/2ΔT/2δ(t)e−j2πnΔTtdt=1ΔTe0=1ΔTc_n=\\frac{1} {\\Delta T}\\int_{-\\Delta T/2}^{\\Delta T/2}\\delta(t)e^{-j\\frac{2\\pi n} {\\Delta T}t}dt=\\frac{1} {\\Delta T}e^0=\\frac{1} {\\Delta T} cn​=ΔT1​∫−ΔT/2ΔT/2​δ(t)e−jΔT2πn​tdt=ΔT1​e0=ΔT1​ 于是傅里叶级数变成： sΔT(t)=1ΔT∑n=−∞∞ej2πnΔTts_{\\Delta T}(t)=\\frac{1} {\\Delta T}\\sum_{n=-\\infty}^{\\infty}e^{j\\frac{2\\pi n} {\\Delta T}t} sΔT​(t)=ΔT1​n=−∞∑∞​ejΔT2πn​t 由 ℑ{δ(t−t0)}=e−j2πμt0\\Im \\{\\delta(t-t_0)\\}=e^{-j2\\pi\\mu t_0}ℑ{δ(t−t0​)}=e−j2πμt0​ ，得到： ℑ{ej2πnΔTt}=δ(μ−nΔT)\\Im \\{e^{j\\frac{2\\pi n} {\\Delta T}t}\\}=\\delta(\\mu-\\frac{n} {\\Delta T}) ℑ{ejΔT2πn​t}=δ(μ−ΔTn​) 再由于和的傅里叶变换等于各分量的傅里叶变换之和，所以周期冲激串的傅里叶变换 S(μ)S(\\mu)S(μ) 是： S~(μ)=ℑ{sΔT(t)}=ℑ{1ΔT∑n=−∞∞ej2πnΔTt}=1ΔTℑ{∑n=−∞∞ej2πnΔTt}=1ΔT∑n=−∞∞δ(μ−nΔT)\\tilde{S}(\\mu)=\\Im\\{s_{\\Delta T}(t)\\}=\\Im\\{\\frac{1} {\\Delta T}\\sum_{n=-\\infty}^{\\infty}e^{j\\frac{2\\pi n} {\\Delta T}t}\\}=\\frac{1} {\\Delta T}\\Im\\{\\sum_{n=-\\infty}^{\\infty}e^{j\\frac{2\\pi n} {\\Delta T}t}\\}=\\frac{1} {\\Delta T}\\sum_{n=-\\infty}^{\\infty}\\delta(\\mu-\\frac{n} {\\Delta T}) S~(μ)=ℑ{sΔT​(t)}=ℑ{ΔT1​n=−∞∑∞​ejΔT2πn​t}=ΔT1​ℑ{n=−∞∑∞​ejΔT2πn​t}=ΔT1​n=−∞∑∞​δ(μ−ΔTn​) 上述结果可得，周期为 ΔT\\Delta TΔT 的冲激串的傅里叶变换仍然是冲激串，其周期变为 1/ΔT1/\\Delta T1/ΔT。 6.1.5 傅里叶变换与卷积 卷积：空间域中两个函数的卷积的傅里叶变换，等于频率域中两个函数的傅里叶变换的乘积。 设f(t)和h(t)为两个连续函数，F(t)和H(t)为f(t)和h(t)的傅里叶变换，则有： (f★h)(t)⇔(H⋅F)(μ)(f⋅h)(t)⇔(H★F)(μ)(f★h)(t)\\Leftrightarrow(H\\cdot F)(\\mu)\\\\ (f\\cdot h)(t)\\Leftrightarrow(H★F)(\\mu) (f★h)(t)⇔(H⋅F)(μ)(f⋅h)(t)⇔(H★F)(μ) 6.1.6 取样和取样函数的傅里叶变换 取样：对连续函数转换为一系列的离散值。 f~(t)=f(t)sΔT(t)=∑n=−∞∞f(t)δ(t−nΔT)\\tilde{f}(t)=f(t)s_{\\Delta T}(t)=\\sum_{n=-\\infty}^{\\infty}f(t)\\delta(t-n\\Delta T) f~​(t)=f(t)sΔT​(t)=n=−∞∑∞​f(t)δ(t−nΔT) fk=∫−∞∞f(t)δ(t−kΔT)dt=f(kΔT)f_k=\\int_{-\\infty}^{\\infty}f(t)\\delta(t-k\\Delta T)dt=f(k\\Delta T) fk​=∫−∞∞​f(t)δ(t−kΔT)dt=f(kΔT) 对取样后的函数 f~(t)\\tilde{f}(t)f~​(t) 的傅里叶变换 F~(μ)\\tilde{F}(\\mu)F~(μ) 是： F~(μ)=ℑ{f~(t)}=ℑ{f(t)sΔT(t)}=(F★S)(μ)\\tilde{F}(\\mu)=\\Im\\{\\tilde{f}(t)\\}=\\Im\\{f(t)s_{\\Delta T}(t)\\}=(F★S)(\\mu) F~(μ)=ℑ{f~​(t)}=ℑ{f(t)sΔT​(t)}=(F★S)(μ) 其中， S(μ)S(\\mu)S(μ) 是冲激串的傅里叶变换： S(μ)=1ΔT∑n=−∞∞δ(μ−nΔT)S(\\mu)=\\frac{1} {\\Delta T}\\sum_{n=-\\infty}^{\\infty}\\delta(\\mu-\\frac{n} {\\Delta T}) S(μ)=ΔT1​n=−∞∑∞​δ(μ−ΔTn​) 直接得 F(μ)F(\\mu)F(μ) 和 S(μ)S(\\mu)S(μ) 的卷积： F~(μ)=(F★S)(μ)=∫−∞∞F(τ)S(μ−τ)dτ=1ΔT∫−∞∞F(τ)∑n=−∞∞δ(μ−τ−nΔT)dτ=1ΔT∑n=−∞∞∫−∞∞F(τ)δ(μ−τ−nΔT)dτ=1ΔT∑n=−∞∞F(μ−nΔT)\\tilde{F}(\\mu)=(F★S)(\\mu)=\\int_{-\\infty}^{\\infty}F(\\tau)S(\\mu-\\tau)d\\tau\\\\ =\\frac{1} {\\Delta T}\\int_{-\\infty}^{\\infty}F(\\tau)\\sum_{n=-\\infty}^{\\infty}\\delta\\big(\\mu-\\tau-\\frac{n} {\\Delta T}\\big)d\\tau\\\\ =\\frac{1} {\\Delta T}\\sum_{n=-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}F(\\tau)\\delta\\big(\\mu-\\tau-\\frac{n} {\\Delta T}\\big)d\\tau\\\\ =\\frac{1} {\\Delta T}\\sum_{n=-\\infty}^{\\infty}F(\\mu-\\frac{n} {\\Delta T}) F~(μ)=(F★S)(μ)=∫−∞∞​F(τ)S(μ−τ)dτ=ΔT1​∫−∞∞​F(τ)n=−∞∑∞​δ(μ−τ−ΔTn​)dτ=ΔT1​n=−∞∑∞​∫−∞∞​F(τ)δ(μ−τ−ΔTn​)dτ=ΔT1​n=−∞∑∞​F(μ−ΔTn​) 6.1.7 单变量离散傅里叶变换DFT 一维离散傅里叶变换： Fm=∑n=0M−1fne−j2πmn/M,m=0,1,2…,M−1F_m=\\sum_{n=0}^{M-1}f_ne^{-j2\\pi mn/M},m=0,1,2…,M-1 Fm​=n=0∑M−1​fn​e−j2πmn/M,m=0,1,2…,M−1 一维离散傅里叶逆变换： fn=1M∑m=0M−1Fmej2πmn/M,n=0,1,2…,M−1f_n=\\frac{1} {M}\\sum_{m=0}^{M-1}F_me^{j2\\pi mn/M},n=0,1,2…,M-1 fn​=M1​m=0∑M−1​Fm​ej2πmn/M,n=0,1,2…,M−1 6.1.8 二变量离散傅里叶变换 二维离散傅里叶变换： F(μ,ν)=∑x=0M−1∑y=0N−1f(x,y)e−j2π(μx/M+νy/N)F(\\mu, u)=\\sum_{x=0}^{M-1}\\sum_{y=0}^{N-1}f(x,y)e^{-j2\\pi(\\mu x/M+ u y/N)} F(μ,ν)=x=0∑M−1​y=0∑N−1​f(x,y)e−j2π(μx/M+νy/N) 二维离散傅里叶逆变换： f(x,y)=1MN∑x=0M−1∑y=0N−1F(μ,ν)ej2π(μx/M+νy/N)f(x,y)=\\frac{1} {MN}\\sum_{x=0}^{M-1}\\sum_{y=0}^{N-1}F(\\mu, u)e^{j2\\pi(\\mu x/M+ u y/N)} f(x,y)=MN1​x=0∑M−1​y=0∑N−1​F(μ,ν)ej2π(μx/M+νy/N) 6.1.9 代码 先了解以下函数： int getOptimalDFTSize(int vecsize) vecsize为向量尺寸大小，该函数用于返回给定向量尺寸经过DFT变换后结果的最优尺寸大小。 void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar value = Scalar()) 该函数用于扩充图像边界，参数如下： src：输入图像； dst：输出与输入图像相同类型图像； top、bottom、left、right：在图像的四个方向上扩充像素值； borderType：边界类型，常见取值为BORDER_CONSTANT； value：边界类型为BORDER_CONSTANT时表示边界值。 void dft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0) 该函数为OpenCV提供的傅里叶变换函数，参数如下： src：输入图像； dst：输出图像； flags：转换标识符，默认为0。也有以下取值，DFT_INVERSE（用一维或二维逆变换取代默认的正向变换）、DFT_SCALE（缩放比例标识符，根据数据元素个数平均求出缩放结果）、DFT_ROWS（对输入矩阵的每行进行正向或反向傅里叶变换）、DFT_COMPLEX_OUTPUT（对一维或二维实数数组进行正向变换，结果是复数阵列，是默认）、DFT_REAL_OUTPUT（对一维或二维复数数组进行逆向变换）； nonzeroRows：当其不为0时函数会假设输入数组（没有设置DFT_INVERSE）的第一行或第一个输出数组（设置了DFT_INVERSE）包含非零值。 void magnitude(InputArray x, InputArray y, OutputArray magnitude) 该函数用于计算二维矢量的幅值，参数如下： x：浮点型数组的x坐标矢量，即实部； y：浮点型数组的y坐标矢量，必须和x尺寸相同； magnitude：与x类型和尺寸相同的输出数组； 其计算公式为： dst(I)=x(I)2+y(I)2dst(I)=\\sqrt{x(I)^2+y(I)^2} dst(I)=x(I)2+y(I)2​ #include opencv2/opencv.hpp#include iostream#include cmathvoid DFT(cv::Mat input, cv::Mat output, cv::Mat trf_img){ // 拓展图像矩阵，为2，3，5的倍数时运算速度快 int m = cv::getOptimalDFTSize(input.rows); int n = cv::getOptimalDFTSize(input.cols); cv::copyMakeBorder(input, input, 0, m - input.rows, 0, n - input.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0)); // 创建planes存储复数的实部和虚部 cv::Mat planes[] = { cv::Mat_float(input), cv::Mat::zeros(input.size(),CV_32F) }; // 从多个单通道数组中创建一个多通道数组trf_img。 // 函数Merge将几个数组合并为一个多通道阵列，即输出数组的每个元素将是输入数组元素的级联 cv::merge(planes, 2, trf_img); // 进行傅里叶变换 cv::dft(trf_img, trf_img); // 将trf_img拆分到planes数组 cv::split(trf_img, planes); // 计算复数的幅值，即频谱图，保存在output cv::magnitude(planes[0], planes[1], output); // 赋值计算过大，进行处理 output += cv::Scalar(1); //像素加一防止log(0) log(output, output); // 进行对数运算 cv::normalize(output, output, 0, 1, cv::NORM_MINMAX); // 归一化 // 剪切和重分布幅度图像限 output = output(cv::Rect(0, 0, output.cols -2, output.rows -2)); // 重新排列傅里叶图像中的象限，使原点位于图像中心 int cx = output.cols / 2; int cy = output.rows / 2; cv::Mat q0(output, cv::Rect(0, 0, cx, cy)); cv::Mat q1(output, cv::Rect(cx, 0, cx, cy)); cv::Mat q2(output, cv::Rect(0, cy, cx, cy)); cv::Mat q3(output, cv::Rect(cx, cy, cx, cy)); // 交换象限中心化 cv::Mat tmp; q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2);}int main(){ cv::Mat image = cv::imread(\"src/test.jpg\", 0); cv::Mat image_output, image_trf; cv::namedWindow(\"灰度图\", cv::WINDOW_NORMAL); cv::imshow(\"灰度图\", image); DFT(image, image_output, image_trf); cv::namedWindow(\"频谱图\", cv::WINDOW_NORMAL); cv::imshow(\"频谱图\", image_output); cv::waitKey(0); return 0;} 效果展示： 6.2 频谱图 频谱图有以下规律： 频谱图从中心点到四周，频率越来越大； 频谱图中心点一般最亮，与原图像平均亮度相关； 频率域滤波就是改变频谱图中高频率或者低频率的值. 频谱图中的点关于中心点对称，对称的两点表示某个频率的波。 两个对称点离中心点的距离代表频率的高低，离中心点越远代表的频率越高。 两个对称点的亮度表示波的幅值，越亮幅值越大。 图像中，低频率代表灰度变化缓慢的信息；高频率代表变化剧烈的信息，如边缘及噪声等。在6中，低频区越亮代表变化缓慢的区域较多，高频区越亮代表图像细节很多。 对称点所在直线的方向为波的方向，与原图中对应的线性信息垂直。如下图，图中有一组平行的线，在频谱图垂直方向也有一条较亮的线（可用于方向滤波，增强或者滤除某个方向的线性特征）。 6.3 低通滤波 6.3.1 理想低通滤波 通过设置频率半径，半径内的频率大小不变，半径外的频率置为0，保留了低频区，滤除了高频区。 传递函数为： H(u,v)={1,D(u,v)≤D00,D(u,v)D0H(u,v)= \\begin{cases} 1,\\quad D(u,v)\\leq D_0\\\\ 0, \\quad D(u,v)D_0 \\end{cases} H(u,v)={1,D(u,v)≤D0​0,D(u,v)D0​​ 其中， D0D_0D0​ 是一个正常数， D(u,v)D(u,v)D(u,v) 是频率域中点(u,v)到P×Q频率矩形中心的距离， D(u,v)=[(u−P/2)2+(v−Q/2)2]1/2D(u,v)=[(u-P/2)^2+(v-Q/2)^2]^{1/2}D(u,v)=[(u−P/2)2+(v−Q/2)2]1/2 。 理想低通滤波器由于进行傅里叶变换和傅里叶逆变换时的差异，会导致振铃效应，一般很少使用。 振铃效应：指输出图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡 代码： // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"#include \"Salt.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); Salt(image, 100000); // 添加100k个噪点 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 // 理想低通滤波 cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 120; // 滤波半径 for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) if ((i - cx) * (i - cx) + (j - cy) * (j - cy) r * r) { trf_real.atfloat(i, j) = 0; trf_imag.atfloat(i, j) = 0; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 为了更好的效果，手动添加噪声： // Salt.h#pragma once#include opencv2/opencv.hpp#include randomvoid Salt(cv::Mat input, int n); // 噪声文件Salt.cpp#include \"Salt.h\"void Salt(cv::Mat input, int n){ std::default_random_engine generator; std::uniform_int_distributionintrow(0, input.rows - 1); std::uniform_int_distributionintcol(0, input.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = row(generator); j = col(generator); if (input.channels() == 1) input.atuchar(i, j) = 255; else if (input.channels() == 3) input.atcv::Vec3b(i, j) = cv::Vec3b(255, 255, 255); }} 对图像傅里叶变换： // DFT.h#pragma once#include opencv2/opencv.hpp#include cmathvoid DFT(cv::Mat input, cv::Mat output, cv::Mat trf_arr); // DFT.cpp#include \"DFT.h\"void DFT(cv::Mat input, cv::Mat output, cv::Mat trf_arr){ // 扩展图像，优化速度 int n = cv::getOptimalDFTSize(input.rows); int m = cv::getOptimalDFTSize(input.cols); cv::copyMakeBorder(input, input, 0, n - input.rows, 0, m - input.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0)); // 用于存储傅里叶变换的实部和虚部 cv::Mat planes[] = { cv::Mat_float(input), cv::Mat::zeros(input.size(), CV_32F) }; cv::merge(planes, 2, trf_arr); cv::dft(trf_arr, trf_arr); cv::split(trf_arr, planes); cv::Mat trf_img_real = planes[0]; cv::Mat trf_img_imag = planes[1]; // 计算复数的幅值，保存在output中 cv::magnitude(planes[0], planes[1], output); // 优化幅值大小 output += cv::Scalar(1); log(output, output); cv::normalize(output, output, 0, 1, cv::NORM_MINMAX); output = output(cv::Rect(0, 0, output.cols -2, output.rows -2)); int cx = output.cols / 2, cy = output.rows / 2; cv::Mat q0(output, cv::Rect(0, 0, cx, cy)), q1(output, cv::Rect(cx, 0, cx, cy)); cv::Mat q2(output, cv::Rect(0, cy, cx, cy)), q3(output, cv::Rect(cx, cy, cx, cy)); cv::Mat tmp; // 交换区域使得原点位于中心 q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2); // 复数的实数部分交换 cv::Mat q00(trf_img_real, cv::Rect(0, 0, cx, cy)); // 左上区域 cv::Mat q01(trf_img_real, cv::Rect(cx, 0, cx, cy)); // 右上区域 cv::Mat q02(trf_img_real, cv::Rect(0, cy, cx, cy)); // 左下区域 cv::Mat q03(trf_img_real, cv::Rect(cx, cy, cx, cy)); // 右下区域 q00.copyTo(tmp); q03.copyTo(q00); tmp.copyTo(q03); //左上与右下进行交换 q01.copyTo(tmp); q02.copyTo(q01); tmp.copyTo(q02); //右上与左下进行交换 // 复数的虚数部分交换 cv::Mat q10(trf_img_imag, cv::Rect(0, 0, cx, cy)); // 左上区域 cv::Mat q11(trf_img_imag, cv::Rect(cx, 0, cx, cy)); // 右上区域 cv::Mat q12(trf_img_imag, cv::Rect(0, cy, cx, cy)); // 左下区域 cv::Mat q13(trf_img_imag, cv::Rect(cx, cy, cx, cy)); // 右下区域 q10.copyTo(tmp); q13.copyTo(q10); tmp.copyTo(q13); //左上与右下进行交换 q11.copyTo(tmp); q12.copyTo(q11); tmp.copyTo(q12); //右上与左下进行交换 planes[0] = trf_img_real; planes[1] = trf_img_imag; cv::merge(planes, 2, trf_arr); // 将傅里叶变换的复数结果保存在trf_arr} 效果展示： 6.3.2 高斯低通滤波 高斯低通滤波器的传递函数为： H(u,v)=e−D2(u,v)/2σ2H(u,v)=e^{-D^2(u,v)/2\\sigma^2} H(u,v)=e−D2(u,v)/2σ2 其中， D(u,v)D(u,v)D(u,v) 是P×Q频率矩形中心到矩形中包含的任意一点(u,v)的距离，令 σ=D0\\sigma=D_0σ=D0​ ， H(u,v)=e−D2(u,v)/2D02H(u,v)=e^{-D^2(u,v)/2D_0^2} H(u,v)=e−D2(u,v)/2D02​ 那么 D0D_0D0​ 是截止频率（设置半径）。当 D(u,v)=D0D(u,v)=D_0D(u,v)=D0​ 时，高斯低通滤波器传递函数下降到其最大值1.0的0.607。 由于高斯函数的傅里叶变换还是高斯函数，所以高斯低通滤波器没有振铃效应。 代码： DFT.h、DFT.cpp、Salt.h、Salt.cpp同上。 // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"#include \"Salt.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); Salt(image, 100000); // 添加100k个噪点 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 // 高斯低通滤波 cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 80; // 滤波半径 float h; for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { h = exp(-((i - cx) * (i - cx) + (j - cy) * (j - cy)) / (2.0 * r * r)); trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 效果展示： 6.3.4 巴特沃斯低通滤波 巴特沃斯低通滤波器的传递函数为： H(u,v)=11+[D(u,v)/D0]2nH(u,v)=\\frac {1} {1+[D(u,v)/D_0]^{2n} } H(u,v)=1+[D(u,v)/D0​]2n1​ 其中， D(u,v)D(u,v)D(u,v) 是P×Q频率矩形中心到矩形中包含的任意一点(u,v)的距离， D0D_0D0​ 是截止频率（设置半径）， nnn 是巴特沃斯滤波器的阶数。 1阶巴特沃斯滤波器既没有振铃效应也没有负值；2阶巴特沃斯滤波器有轻微振铃效应和较小的负值，但比理想低通滤波器好；高阶巴特沃斯滤波器具有非常明显的振铃效应。2阶和3阶的巴特沃斯滤波器较为合适。 代码： DFT.h、DFT.cpp、Salt.h、Salt.cpp同上。 // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"#include \"Salt.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); Salt(image, 100000); // 添加100k个噪点 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 // 巴特沃斯低通滤波 cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 120; // 滤波半径 float h; float n = 3; // 巴特沃斯滤波器阶数 float d; // 任意点到中心的距离 for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { d = (i - cx) * (i - cx) + (j - cy) * (j - cy); h = 1.0 / (1 + pow((d / (r * r)), 2 * n)); trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 效果展示： 6.4 高通滤波 6.4.1 理想高通滤波 通过设置频率半径，半径外的频率大小不变，半径内的频率置为0，保留了高频区，滤除了低频区。 而边缘和其他灰度的急剧变化与高频分量有关，故高通滤波器可以实现边缘锐化。 传递函数为： H(u,v)={0,D(u,v)≤D01,D(u,v)D0H(u,v)= \\begin{cases} 0,\\quad D(u,v)\\leq D_0\\\\ 1, \\quad D(u,v)D_0 \\end{cases} H(u,v)={0,D(u,v)≤D0​1,D(u,v)D0​​ 其中， D0D_0D0​ 是一个正常数， D(u,v)D(u,v)D(u,v) 是频率域中点(u,v)到P×Q频率矩形中心的距离， D(u,v)=[(u−P/2)2+(v−Q/2)2]1/2D(u,v)=[(u-P/2)^2+(v-Q/2)^2]^{1/2}D(u,v)=[(u−P/2)2+(v−Q/2)2]1/2 。 代码（DFT代码文件见最后）： // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 // 理想高通滤波 cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 120; // 滤波半径 for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) if ((i - cx) * (i - cx) + (j - cy) * (j - cy) r * r) { trf_real.atfloat(i, j) = 0; trf_imag.atfloat(i, j) = 0; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 效果展示： 6.4.2 高斯高通滤波 高斯低通滤波器的传递函数为： HLP(u,v)=e−D2(u,v)/2σ2H_{LP}(u,v)=e^{-D^2(u,v)/2\\sigma^2} HLP​(u,v)=e−D2(u,v)/2σ2 则高斯高通滤波器传递函数为： HHP=1−HLP(u,v)=1−e−D2(u,v)/2D02H_{HP}=1-H_{LP}(u,v)=1-e^{-D^2(u,v)/2D_0^2} HHP​=1−HLP​(u,v)=1−e−D2(u,v)/2D02​ 其中， D(u,v)D(u,v)D(u,v) 为中心点到任一点的距离， D0D_0D0​ 为设置半径。 代码（DFT代码文件见最后）： // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 // 高斯高通滤波 cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 120; // 滤波半径 float h, d; // h 为计算量，d 为到中心点的距离 for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { d = (i - cx) * (i - cx) + (j - cy) * (j - cy); h = 1 - exp(-d / (2.0 * r * r)); trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 效果展示： 6.4.3 巴特沃斯高通滤波 巴特沃斯高铁滤波器的传递函数为： H(u,v)=11+[D0/D(u,v)]2nH(u,v)=\\frac {1} {1+[D_0/D(u,v)]^{2n} } H(u,v)=1+[D0​/D(u,v)]2n1​ 其中， D(u,v)D(u,v)D(u,v) 是P×Q频率矩形中心到矩形中包含的任意一点(u,v)的距离， D0D_0D0​ 是截止频率（设置半径）， nnn 是巴特沃斯滤波器的阶数。 代码（DFT代码文件见最后）： // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 // 巴特沃斯高通滤波 cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 120; // 滤波半径 float h, d; // h 为计算量，d为到中心点的距离 float n = 3; // 巴特沃斯滤波器阶数 for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { d = (i - cx) * (i - cx) + (j - cy) * (j - cy); h = 1.0 / (1 + pow(((r * r) / d), 2 * n)); trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 效果展示： 6.4.4 拉普拉斯滤波 频率域中拉普拉斯滤波传递函数为： H(u,v)=−4π2(u2+v2)=−4π2[(u−P/2)2+(v−Q/2)2]=−4π2D2(u,v)H(u,v)=-4\\pi^2(u^2+v^2)=-4\\pi^2[(u-P/2)^2+(v-Q/2)^2]=-4\\pi^2D^2(u,v) H(u,v)=−4π2(u2+v2)=−4π2[(u−P/2)2+(v−Q/2)2]=−4π2D2(u,v) 其中， D(u,v)D(u,v)D(u,v) 为中心点到任一点的距离。 具体增强实现： g(x,y)=f(x,y)+c∇2f(x,y),∇2f(x,y)=ℑ−1[H(u,v)F(u,v)]g(x,y)=f(x,y)+c abla^2f(x,y), abla^2f(x,y)=\\Im^{-1}[H(u,v)F(u,v)] g(x,y)=f(x,y)+c∇2f(x,y),∇2f(x,y)=ℑ−1[H(u,v)F(u,v)] 其中， F(u,v)F(u,v)F(u,v) 是 f(x,y)f(x,y)f(x,y) 的傅里叶变换。 代码： // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 DFT(image, output, trf); // 对图像进行傅里叶变换 /*————————————————————————————拉普拉斯滤波————————————————————————————*/ cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y float h, d; // h 为计算量，d为到中心点的距离 float pi = 3.1415926; for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { d = (i - cx) * (i - cx) + (j - cy) * (j - cy); h = -4 * pi * pi * d; trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); /*————————————————————————————标记，实现g(x,y)————————————————————————————*/ iDft[0].convertTo(iDft[0], CV_8U, 255 / 1.0, 0); cv::Mat result(iDft[0].size(), CV_8U); for (int i = 0; i iDft[0].rows; i ++) for (int j = 0; j iDft[0].cols; j ++) result.atuchar(i, j) = cv::saturate_castuchar(image.atuchar(i, j) + iDft[0].atuchar(i, j)); cv::namedWindow(\"result\", cv::WINDOW_NORMAL); cv::imshow(\"result\", result); cv::waitKey(0); return 0;} 效果展示： 6.4.5 高频强调滤波器 还可以设置可调参数，进行调整影响。高频强调滤波的通用公式是： g(x,y)=ℑ−1{[k1+k2HHP]F(u,v)}g(x,y)=\\Im^{-1}\\bigg\\{\\big[k_1+k_2H_{HP}\\big]F(u,v)\\bigg\\} g(x,y)=ℑ−1{[k1​+k2​HHP​]F(u,v)} 其中， k1≥0k_1\\geq0k1​≥0 偏移传递函数的值，以便使直流项不为零， k20k_20k2​0 控制高频的贡献， HHPH_{HP}HHP​ 为高通滤波器传递函数， F(u,v)F(u,v)F(u,v) 为图像 f(u,v)f(u,v)f(u,v) 的傅里叶变换。 部分代码示例： for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { d = (i - cx) * (i - cx) + (j - cy) * (j - cy); // 高斯高频强调滤波器 h = 0.5 + 0.75 * (1 - exp(-d / (2.0 * r * r))); trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } 附DFT代码 // DFT.h#pragma once#include opencv2/opencv.hpp#include cmathvoid DFT(cv::Mat input, cv::Mat output, cv::Mat trf_arr); // DFT.cpp#include \"DFT.h\"void DFT(cv::Mat input, cv::Mat output, cv::Mat trf_arr){ // 扩展图像，优化速度 int n = cv::getOptimalDFTSize(input.rows); int m = cv::getOptimalDFTSize(input.cols); cv::copyMakeBorder(input, input, 0, n - input.rows, 0, m - input.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0)); // 用于存储傅里叶变换的实部和虚部 cv::Mat planes[] = { cv::Mat_float(input), cv::Mat::zeros(input.size(), CV_32F) }; cv::merge(planes, 2, trf_arr); cv::dft(trf_arr, trf_arr); cv::split(trf_arr, planes); cv::Mat trf_img_real = planes[0]; cv::Mat trf_img_imag = planes[1]; // 计算复数的幅值，保存在output中 cv::magnitude(planes[0], planes[1], output); // 优化幅值大小 output += cv::Scalar(1); log(output, output); cv::normalize(output, output, 0, 1, cv::NORM_MINMAX); output = output(cv::Rect(0, 0, output.cols -2, output.rows -2)); int cx = output.cols / 2, cy = output.rows / 2; cv::Mat q0(output, cv::Rect(0, 0, cx, cy)), q1(output, cv::Rect(cx, 0, cx, cy)); cv::Mat q2(output, cv::Rect(0, cy, cx, cy)), q3(output, cv::Rect(cx, cy, cx, cy)); cv::Mat tmp; // 交换区域使得原点位于中心 q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2); // 复数的实数部分交换 cv::Mat q00(trf_img_real, cv::Rect(0, 0, cx, cy)); // 左上区域 cv::Mat q01(trf_img_real, cv::Rect(cx, 0, cx, cy)); // 右上区域 cv::Mat q02(trf_img_real, cv::Rect(0, cy, cx, cy)); // 左下区域 cv::Mat q03(trf_img_real, cv::Rect(cx, cy, cx, cy)); // 右下区域 q00.copyTo(tmp); q03.copyTo(q00); tmp.copyTo(q03); //左上与右下进行交换 q01.copyTo(tmp); q02.copyTo(q01); tmp.copyTo(q02); //右上与左下进行交换 // 复数的虚数部分交换 cv::Mat q10(trf_img_imag, cv::Rect(0, 0, cx, cy)); // 左上区域 cv::Mat q11(trf_img_imag, cv::Rect(cx, 0, cx, cy)); // 右上区域 cv::Mat q12(trf_img_imag, cv::Rect(0, cy, cx, cy)); // 左下区域 cv::Mat q13(trf_img_imag, cv::Rect(cx, cy, cx, cy)); // 右下区域 q10.copyTo(tmp); q13.copyTo(q10); tmp.copyTo(q13); //左上与右下进行交换 q11.copyTo(tmp); q12.copyTo(q11); tmp.copyTo(q12); //右上与左下进行交换 planes[0] = trf_img_real; planes[1] = trf_img_imag; cv::merge(planes, 2, trf_arr); // 将傅里叶变换的复数结果保存在trf_arr} 6.5 同态滤波 通过一个滤波器传递函数H(u,v)，使用不同可控方法影响低频分量和高频分量。 6.5.1 基本原理 图像f(x,y)可以表示为其照射分量i(x,y)和反射分量r(x,y)的乘积。 图像中，认为低频分量与照射分量相联系，高频分量与反射分量相联系。 f(x,y)=i(x,y)r(x,y)f(x,y)=i(x,y)r(x,y) f(x,y)=i(x,y)r(x,y) 乘积的傅里叶变换不是傅里叶变换的乘积。 ℑ[f(x,y)]≠ℑ[i(x,y)]ℑ[r(x,y)]\\Im [f(x,y)] eq \\Im[i(x,y)]\\Im[r(x,y)] ℑ[f(x,y)]​=ℑ[i(x,y)]ℑ[r(x,y)] 故令 z(x,y)=ln⁡f(x,y)=ln⁡i(x,y)+ln⁡r(x,y)z(x,y)=\\ln f(x,y)=\\ln i(x,y)+\\ln r(x,y)z(x,y)=lnf(x,y)=lni(x,y)+lnr(x,y) ，有 ℑ[z(x,y)]=ℑ[ln⁡f(x,y)]=ℑ[ln⁡i(x,y)]+ℑ[ln⁡r(x,y)]\\Im[z(x,y)]=\\Im[\\ln f(x,y)]=\\Im[\\ln i(x,y)]+\\Im[\\ln r(x,y)] ℑ[z(x,y)]=ℑ[lnf(x,y)]=ℑ[lni(x,y)]+ℑ[lnr(x,y)] Z(u,v)=Fi(u,v)+Fr(u,v)Z(u,v)=F_i(u,v)+F_r(u,v) Z(u,v)=Fi​(u,v)+Fr​(u,v) 其中， Fi(u,v)F_i(u,v)Fi​(u,v) 和 Fr(x,y)F_r(x,y)Fr​(x,y) 分别是 ln⁡i(x,y)\\ln i(x,y)lni(x,y) 和 ln⁡r(x,y)\\ln r(x,y)lnr(x,y) 的傅里叶变换。 使用滤波器传递函数 H(u,v)H(u,v)H(u,v) 对 Z(u,v)Z(u,v)Z(u,v) 滤波，有 S(u,v)=H(u,v)Z(u,v)=H(u,v)Fi(u,v)+H(u,v)Fr(u,v)S(u,v)=H(u,v)Z(u,v)=H(u,v)F_i(u,v)+H(u,v)F_r(u,v) S(u,v)=H(u,v)Z(u,v)=H(u,v)Fi​(u,v)+H(u,v)Fr​(u,v) 空间域中滤波后的图像是 s(x,y)=ℑ−1[S(u,v)]=ℑ−1[H(u,v)Fi(u,v)]+ℑ−1[H(u,v)Fr(u,v)]s(x,y)=\\Im^{-1}[S(u,v)]=\\Im^{-1}[H(u,v)F_i(u,v)]+\\Im^{-1}[H(u,v)F_r(u,v)] s(x,y)=ℑ−1[S(u,v)]=ℑ−1[H(u,v)Fi​(u,v)]+ℑ−1[H(u,v)Fr​(u,v)] 最后通过取滤波后的结果的指数形成输出图像 g(x,y)=es(x,y)=eℑ−1[H(u,v)Fi(u,v)]eℑ−1[H(u,v)Fr(u,v)]g(x,y)=e^{s(x,y)}=e^{\\Im^{-1}[H(u,v)F_i(u,v)]}e^{\\Im^{-1}[H(u,v)F_r(u,v)]} g(x,y)=es(x,y)=eℑ−1[H(u,v)Fi​(u,v)]eℑ−1[H(u,v)Fr​(u,v)] 记 i0(x,y)=ei′(x,y)=eℑ−1[H(u,v)Fi(u,v)]i_0(x,y)=e^{i'(x,y)}=e^{\\Im^{-1}[H(u,v)F_i(u,v)]} i0​(x,y)=ei′(x,y)=eℑ−1[H(u,v)Fi​(u,v)] 为输出图像的照射分量， 记 r0(x,y)=er′(x,y)=eℑ−1[H(u,v)Fr(u,v)]r_0(x,y)=e^{r'(x,y)}=e^{\\Im^{-1}[H(u,v)F_r(u,v)]} r0​(x,y)=er′(x,y)=eℑ−1[H(u,v)Fr​(u,v)] 为输出图像的反射分量。 上述滤波方法过程如下图： 6.5.2 以高斯高通滤波器举例 一般高斯高通滤波器函数： H(u,v)=1−e−D2(u,v)/2D02H(u,v)=1-e^{-D^2(u,v)/2D^2_0} H(u,v)=1−e−D2(u,v)/2D02​ 使用稍微变化的GHPF（Gaussian high-pass filter）： H(u,v)=(γH−γL)[1−e−cD2(u,v)/D02]+γLH(u,v)=(\\gamma_H-\\gamma_L)\\big[1-e^{-cD^2(u,v)/D_0^2}\\big]+\\gamma_L H(u,v)=(γH​−γL​)[1−e−cD2(u,v)/D02​]+γL​ 其中，D(u,v)D(u,v)D(u,v) 为中心点到任一点的距离， D0D_0D0​ 为设置半径， γL\\gamma_LγL​ 和 γH\\gamma_HγH​ 为规定频率范围，常数c控制函数的偏斜度，类似于高频强调函数。 变化后的GHPF图像如下： 明显地，减少了低频分量的影响，增加了高频分量的影响。 代码： // main.cpp#include iostream#include opencv2/opencv.hpp#include \"DFT.h\"int main(){ cv::Mat image, output, trf; image = cv::imread(\"src/test.jpg\", 0); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", image); // 显示原图 /* ——————————对数变换—————————— */ cv::Mat image_(image.size(), CV_32F); for (int i = 0; i image.rows; i ++) for (int j = 0; j image.cols; j ++) image_.atfloat(i, j) = log(image.atuchar(i, j) + 0.1); DFT(image_, output, trf); // 对图像进行傅里叶变换 /* ——————————滤波—————————— */ cv::Mat planes[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::split(trf, planes); //分离通道，获取实部虚部 cv::Mat trf_real = planes[0]; cv::Mat trf_imag = planes[1]; int cx = trf_real.rows / 2; // 求中心坐标x int cy = trf_real.cols / 2; // 求中心坐标y int r = 10; // 滤波半径 float h, d; // h 为计算量，d 为到中心点的距离 float rh = 3, rl = 0.5, c = 5; // 高频点、低频点、c值 for (int i = 0; i trf_real.rows; i ++) for (int j = 0; j trf_real.cols; j ++) { d = (i - cx) * (i - cx) + (j - cy) * (j - cy); h = (rh - rl) * (1 - exp(-c * d / (r * r))) + rl; trf_real.atfloat(i, j) *= h; trf_imag.atfloat(i, j) *= h; } planes[0] = trf_real; planes[1] = trf_imag; cv::Mat trf_ilpf; cv::merge(planes, 2, trf_ilpf); cv::Mat iDft[] = { cv::Mat_float(output), cv::Mat::zeros(output.size(), CV_32F) }; cv::idft(trf_ilpf, trf_ilpf); // 傅里叶逆变换 cv::split(trf_ilpf, iDft); // 分离通道 cv::magnitude(iDft[0], iDft[1], iDft[0]); //计算复数的幅值，保存在iDft[0] cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); /* ——————————指数恢复数值并归一化—————————— */ cv::exp(iDft[0], iDft[0]); cv::normalize(iDft[0], iDft[0], 0, 1, cv::NORM_MINMAX); iDft[0].convertTo(iDft[0], CV_8U, 255 / 1.0, 0); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", iDft[0]); cv::waitKey(0); return 0;} 效果展示： // DFT.h#pragma once#include opencv2/opencv.hpp#include cmathvoid DFT(cv::Mat input, cv::Mat output, cv::Mat trf_arr); // DFT.cpp#include \"DFT.h\"void DFT(cv::Mat input, cv::Mat output, cv::Mat trf_arr){ // 扩展图像，优化速度 int n = cv::getOptimalDFTSize(input.rows); int m = cv::getOptimalDFTSize(input.cols); cv::copyMakeBorder(input, input, 0, n - input.rows, 0, m - input.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0)); // 用于存储傅里叶变换的实部和虚部 cv::Mat planes[] = { cv::Mat_float(input), cv::Mat::zeros(input.size(), CV_32F) }; cv::merge(planes, 2, trf_arr); cv::dft(trf_arr, trf_arr); cv::split(trf_arr, planes); cv::Mat trf_img_real = planes[0]; cv::Mat trf_img_imag = planes[1]; // 计算复数的幅值，保存在output中 cv::magnitude(planes[0], planes[1], output); // 优化幅值大小 output += cv::Scalar(1); log(output, output); cv::normalize(output, output, 0, 1, cv::NORM_MINMAX); output = output(cv::Rect(0, 0, output.cols -2, output.rows -2)); int cx = output.cols / 2, cy = output.rows / 2; cv::Mat q0(output, cv::Rect(0, 0, cx, cy)), q1(output, cv::Rect(cx, 0, cx, cy)); cv::Mat q2(output, cv::Rect(0, cy, cx, cy)), q3(output, cv::Rect(cx, cy, cx, cy)); cv::Mat tmp; // 交换区域使得原点位于中心 q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2); // 复数的实数部分交换 cv::Mat q00(trf_img_real, cv::Rect(0, 0, cx, cy)); // 左上区域 cv::Mat q01(trf_img_real, cv::Rect(cx, 0, cx, cy)); // 右上区域 cv::Mat q02(trf_img_real, cv::Rect(0, cy, cx, cy)); // 左下区域 cv::Mat q03(trf_img_real, cv::Rect(cx, cy, cx, cy)); // 右下区域 q00.copyTo(tmp); q03.copyTo(q00); tmp.copyTo(q03); //左上与右下进行交换 q01.copyTo(tmp); q02.copyTo(q01); tmp.copyTo(q02); //右上与左下进行交换 // 复数的虚数部分交换 cv::Mat q10(trf_img_imag, cv::Rect(0, 0, cx, cy)); // 左上区域 cv::Mat q11(trf_img_imag, cv::Rect(cx, 0, cx, cy)); // 右上区域 cv::Mat q12(trf_img_imag, cv::Rect(0, cy, cx, cy)); // 左下区域 cv::Mat q13(trf_img_imag, cv::Rect(cx, cy, cx, cy)); // 右下区域 q10.copyTo(tmp); q13.copyTo(q10); tmp.copyTo(q13); //左上与右下进行交换 q11.copyTo(tmp); q12.copyTo(q11); tmp.copyTo(q12); //右上与左下进行交换 planes[0] = trf_img_real; planes[1] = trf_img_imag; cv::merge(planes, 2, trf_arr); // 将傅里叶变换的复数结果保存在trf_arr} 七、噪声模型及估计和滤波方法 噪声分量的灰度值可视为随机变量，故讨论概率密度函数。 7.1 噪声模型 7.1.1 高斯噪声 概率密度函数（PDF，Probability Density Function）： p(z)=12πσe−(z−z‾)2/2σ2,−∞z∞p(z)=\\frac {1} {\\sqrt{2\\pi}\\sigma}e^{-(z-\\overline{z})^2/2\\sigma^2},-\\inftyz\\infty p(z)=2π​σ1​e−(z−z)2/2σ2,−∞z∞ 其中， zzz 表示灰度， z‾\\overline{z}z 表示 zzz 的均值， σ\\sigmaσ 是 zzz 的标准差。 7.1.2 瑞利噪声 PDF为： p(z)={2b(z−a)e−(z−a)2/b,z≥a0,zap(z)=\\begin{cases} \\frac{2} {b}(z-a)e^{-(z-a)^2/b},z\\geq a\\\\ 0,za \\end{cases} p(z)={b2​(z−a)e−(z−a)2/b0​,z≥a,za​ 当z由瑞利PDF表征时，均值为 z‾=a+πb/4\\overline{z}=a+\\sqrt{\\pi b/4}z=a+πb/4​ ，方差为 σ2=b(4−π)4\\sigma^2=\\frac{b(4-\\pi)} {4}σ2=4b(4−π)​ 。 7.1.3 爱尔兰（伽马）噪声 PDF为： p(z)={abzb−1(b−1)!e−az,z≥00,z0p(z)=\\begin{cases} \\frac{a^bz^{b-1} } {(b-1)!}e^{-az},z\\geq 0\\\\ 0,z0 \\end{cases} p(z)={(b−1)!abzb−1​e−az0​,z≥0,z0​ 其中，ab，z的均值为 z‾=ab\\overline{z}=\\frac{a} {b}z=ba​ ，方差为 σ2=ba2\\sigma^2=\\frac{b} {a^2}σ2=a2b​ 7.1.4 指数噪声 PDF为： p(z)={ae−az,z≥00,z0p(z)=\\begin{cases} ae^{-az},z\\geq 0\\\\ 0,z0 \\end{cases} p(z)={ae−az0​,z≥0,z0​ 其中，a0，z的均值为 z‾=1a\\overline{z}=\\frac{1} {a}z=a1​ ，方差为 σ2=1a2\\sigma^2=\\frac{1} {a^2}σ2=a21​ 。其为爱尔兰PDF在b=1时的特殊情况。 7.1.5 均匀噪声 PDF为： p(z)={1b−a,a≤z≤b0,其他p(z)=\\begin{cases} \\frac{1} {b-a},a\\leq z\\leq b\\\\ 0,其他 \\end{cases} p(z)={b−a1​0​,a≤z≤b,其他​ 其中，z的均值为 z‾=a+b2\\overline{z}=\\frac{a+b} {2}z=2a+b​ ，方差为 σ2=(b−a)212\\sigma^2=\\frac{(b-a)^2} {12}σ2=12(b−a)2​ 7.1.6 椒盐噪声 PDF为： p(z)={Ps,z=2k−1Pp,z=01−(Ps+Pp),z=Vp(z)=\\begin{cases} P_s,z=2^k-1\\\\ P_p,z=0\\\\ 1-(P_s+P_p),z=V \\end{cases} p(z)=⎩⎪⎪⎨⎪⎪⎧​Ps​Pp​1−(Ps​+Pp​)​,z=2k−1,z=0,z=V​ 其中，V是区间 0V2k−10V2^k-10V2k−1 内的任意整数，k是数字图像中灰度值的比特数。像素被盐粒或胡椒噪声污染的概率P为 P=Ps+PpP=P_s+P_pP=Ps​+Pp​ 。P为噪声密度。 椒盐噪声的均值为 z‾=(0)Pp+K(1−Ps−Pp)+(2k−1)Ps\\overline{z}=(0)P_p+K(1-P_s-P_p)+(2^k-1)P_sz=(0)Pp​+K(1−Ps​−Pp​)+(2k−1)Ps​ ， 方差为 σ2=(0−z‾)2Pp+(K−z‾)2(1−Ps−Pp)+(2k−1)Ps\\sigma^2=(0-\\overline{z})^2P_p+(K-\\overline{z})^2(1-P_s-P_p)+(2^k-1)P_sσ2=(0−z)2Pp​+(K−z)2(1−Ps​−Pp​)+(2k−1)Ps​ 。 7.2 判别噪声类别 椒盐噪声可以肉眼区分。 其他噪声需要取图像中灰度较为平滑的区域，使用灰度分布图判断。 由上图可知，选取较为平滑的区域，高斯噪声后的直方图与高斯噪声PDF类似，而均匀噪声后的直方图与均匀噪声PDF类似。 上图代码实现 有关函数： void fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange = false); 该函数属于OpenCV 4的RNG类，是一个非静态成员函数，因此在使用的时候不能像使用正常函数一样的直接使用，而需要首先创建一个RNG类的变量，之后通过访问这个变量中函数进行调用这个函数。 该函数参数如下： mat：用于存放随机数的矩阵，目前只支持低于5通道的矩阵。 distType：随机数分布形式选择标志，目前生成的随机数支持均匀分布（RNG::UNIFORM，0）和高斯分布（RNG::NORMAL，1）。 a：确定分布规律的参数。当选择均匀分布时，该参数表示均匀分布的最小下限；当选择高斯分布时，该参数表示高斯分布的均值。 b：确定分布规律的参数。当选择均匀分布时，该参数表示均匀分布的最大上限；当选择高斯分布时，该参数表示高斯分布的标准差。 saturateRange：预饱和标志，仅用于均匀分布。 #include iostream#include opencv2/opencv.hpp// 添加高斯噪声void GaussianNoise(cv::Mat input, cv::Mat output){ cv::RNG rng; cv::Mat noice = input.clone(); output = input.clone(); rng.fill(noice, cv::RNG::NORMAL, 10, 50); // 使用NORMAL参数添加高斯噪声 output = input + noice;}// 添加均匀噪声void UniformNoise(cv::Mat input, cv::Mat output){ cv::RNG rng; cv::Mat noice = input.clone(); output = input.clone(); rng.fill(noice, cv::RNG::UNIFORM, 10, 50); // 使用UNIFORM参数添加高斯噪声 output = input + noice;}void getHist(cv::Mat input, cv::Mat histImage){ // 划出感兴趣区域 cv::Mat ioa(cv::Mat::zeros(input.size(), CV_8U)); for (int i = 0; i 100; i ++) for (int j = 900; j 1000; j ++) ioa.atuchar(i, j) = 255; // 框出感兴趣区域 cv::rectangle(input, cv::Rect(900, 0, 100, 100), cv::Scalar(0, 0, 255), 5); /* ————————计算并绘制直方图———————— */ cv::Mat hist; int hsize = 256; // 直方图区间数 float ranges[] = { 0, 256 }; // 统计像素值的区间 const float *hRanges = { ranges }; // 计算直方图的输出值 cv::calcHist(input, 1, 0, ioa, hist, 1, hsize, hRanges, true, false); int hist_h = 300, hist_w = 512; // 直方图图像高和宽 int bin_w = hist_w / hsize; // 区间 // 直方图图像 histImage = cv::Mat(hist_h, hist_w, CV_8UC3, cv::Scalar(255, 255, 255)); // 直方图输出值归一化到0~255 cv::normalize(hist, hist, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat()); for (int i = 1; i hsize; i ++) cv::line(histImage, cv::Point((i - 1) * bin_w, hist_h - cvRound(hist.atfloat(i - 1))), cv::Point((i) *bin_w, hist_h - cvRound(hist.atfloat(i))), cv::Scalar(100, 100, 100), 2);}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2, hi1, hi2, hi; GaussianNoise(input, output1); UniformNoise(input, output2); getHist(input, hi); getHist(output1, hi1); getHist(output2, hi2); cv::namedWindow(\"原图\", cv::WINDOW_NORMAL); cv::imshow(\"原图\", input); cv::namedWindow(\"原图直方图\", cv::WINDOW_NORMAL); cv::imshow(\"原图直方图\", hi); cv::namedWindow(\"高斯噪声后图\", cv::WINDOW_NORMAL); cv::imshow(\"高斯噪声后图\", output1); cv::namedWindow(\"均匀噪声后图\", cv::WINDOW_NORMAL); cv::imshow(\"均匀噪声后图\", output2); cv::namedWindow(\"高斯噪声后直方图\", cv::WINDOW_NORMAL); cv::imshow(\"高斯噪声后直方图\", hi1); cv::namedWindow(\"均匀噪声后直方图\", cv::WINDOW_NORMAL); cv::imshow(\"均匀噪声后直方图\", hi2); cv::waitKey(0); return 0;} 7.3 常见的空间滤波方法 7.3.1 均值滤波器 算术均值滤波器：也是盒式滤波器，平滑图像中的局部变化，会降低噪声，也会模糊图像。 几何均值滤波器：比算术均值滤波器相比丢失细节少。 谐波平均滤波器：适合处理高斯噪声及盐粒噪声，但不能处理胡椒噪声。 逆谐波均值滤波器：调节阶数有不同的效果。 7.3.2 统计排序滤波器 中值滤波器：处理单极、双极冲激噪声更好，也能有效降低某些随机噪声，丢失细节更少。 最大最小值滤波器：分别减少暗点和亮点，如胡椒噪声和盐粒噪声。可通过最大值滤波器削减胡椒噪声，通过最小值滤波器削减盐粒噪声。 中点滤波器：适合处理随机分布的噪声，如高斯噪声和均匀噪声。 修正阿尔法均值滤波器：适合处理多种混合噪声，如高斯噪声和椒盐噪声。 7.3.3 自适应滤波器 自适应局部降噪滤波器：与均值滤波器比结果更清晰。 自适应中值滤波器：平滑时保留图像细节。 八、滤波器 8.1 均值滤波器 8.1.1 算术平均滤波器 算术均值滤波器：也是盒式滤波器，平滑图像中的局部变化，会降低噪声，也会模糊图像。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 表示中心为(x,y)、大小为m×n的矩形子图像窗口的一组坐标， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=1mn∑(r,c)∈Sxyg(r,c)\\hat f(x,y)=\\frac{1} {mn}\\sum_{(r,c)\\in S_{xy} }g(r,c) f^​(x,y)=mn1​(r,c)∈Sxy​∑​g(r,c) 代码（Salt的相关代码见最后）： 相关函数： void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar value = Scalar()) 该函数用于扩充图像边界，参数如下： src：输入图像； dst：输出与输入图像相同类型图像； top、bottom、left、right：在图像的四个方向上扩充像素值； borderType：边界类型。取值BORDER_CONSTANT为复制指定常量扩展边界；取值为BORDER_REPLICATE为自我复制扩展边界；取值为BORDER_REFLECT为通过镜像复制扩展边界；取值为BORDER_WRAP为复制对边像素扩展边界； value：边界类型为BORDER_CONSTANT时表示边界值。 #include iostream#include opencv2/opencv.hpp#include \"Salt.h\"void ArithmeticMeanFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); // 以镜像复制扩充边界 cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int sum = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) sum += input.atuchar(i + x, j + y); // 计算算术均值 output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = round(sum / (m * n)); }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); // 自实现方法 ArithmeticMeanFilter(input, output1, 7, 7); // OpenCV盒式滤波器 cv::blur(input, output2, cv::Size(7, 7)); cv::namedWindow(\"after1\", cv::WINDOW_NORMAL); cv::imshow(\"after1\", output1); cv::namedWindow(\"after2\", cv::WINDOW_NORMAL); cv::imshow(\"after2\", output2); cv::waitKey(0); return 0;} 效果展示： 8.1.2 几何均值滤波器 几何均值滤波器：比算术均值滤波器相比丢失细节少。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 表示中心为(x,y)、大小为m×n的矩形子图像窗口的一组坐标， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=[∏(r,c)∈Sxyg(r,c)]1mn\\hat f(x,y)=\\bigg[\\prod_{(r,c)\\in S_{xy} }g(r,c)\\bigg]^{\\frac {1} {mn} } f^​(x,y)=[(r,c)∈Sxy​∏​g(r,c)]mn1​ 代码（Salt的相关代码见最后）： #include iostream#include opencv2/opencv.hpp#include \"Salt.h\"void GeometricMeanFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); // 以镜像复制扩充边界 cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); double k = m * n; for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { double sum = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) sum += log10(input.atuchar(i + x, j + y) + 0.1); // 使用对数进行运算指数，避免数值过大 sum /= k; output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = round(pow(10, sum)); }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); // 自实现方法 GeometricMeanFilter(input, output1, 7, 7); // OpenCV盒式滤波器 cv::blur(input, output2, cv::Size(7, 7)); cv::namedWindow(\"几何均值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"几何均值滤波器\", output1); cv::namedWindow(\"算术均值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"算术均值滤波器\", output2); cv::waitKey(0); return 0;} 效果展示： 8.1.3 谐波均值滤波器 谐波平均滤波器：适合处理高斯噪声及盐粒噪声，但不能处理胡椒噪声。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 表示中心为(x,y)、大小为m×n的矩形子图像窗口的一组坐标， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=mn∑(r,c)∈Sxy1g(r,c)\\hat f(x,y)=\\frac{mn} {\\sum_{(r,c)\\in S_{xy} }\\frac{1} {g(r,c)} } f^​(x,y)=∑(r,c)∈Sxy​​g(r,c)1​mn​ 代码（Salt的相关代码见最后）： #include iostream#include opencv2/opencv.hpp#include \"Salt.h\"void HarmonicMeanFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); // 以镜像复制扩充边界 cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); double k = m * n; for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { double sum = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) sum += 1.0 / (input.atuchar(i + x, j + y) + 0.1); sum = k / sum; output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = sum; }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); // 自实现方法 HarmonicMeanFilter(input, output1, 7, 7); // OpenCV盒式滤波器 cv::blur(input, output2, cv::Size(7, 7)); cv::namedWindow(\"谐波均值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"谐波均值滤波器\", output1); cv::namedWindow(\"算术均值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"算术均值滤波器\", output2); cv::waitKey(0); return 0;} 效果展示： 8.1.4 反谐波均值滤波器 反谐波均值滤波器：调节阶数有不同的效果，适用于降低或消除椒盐噪声，当阶数Q为正时，可消除胡椒噪声；当阶数Q为负时，可消除盐粒噪声；Q=0时简化为算术平均滤波器；Q=-1时简化为谐波平均滤波器。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 表示中心为(x,y)、大小为m×n的矩形子图像窗口的一组坐标， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=∑(r,c)∈Sxyg(r,c)Q+1∑(r,c)∈Sxyg(r,c)Q\\hat f(x,y)=\\frac{\\sum_{(r,c)\\in S_{xy} }g(r,c)^{Q+1} } {\\sum_{(r,c)\\in S_{xy} }g(r,c)^Q} f^​(x,y)=∑(r,c)∈Sxy​​g(r,c)Q∑(r,c)∈Sxy​​g(r,c)Q+1​ 代码（Salt的相关代码见最后）： #include iostream#include opencv2/opencv.hpp#include \"Salt.h\"void AntiharmonicAveragingFilter(cv::Mat input, cv::Mat output, int m, int n, int q){ output = input.clone(); // 以镜像复制扩充边界 cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { double sum1 = 0, sum2 = 0, sum; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { sum1 += pow(input.atuchar(i + x, j + y), q + 1); sum2 += pow(input.atuchar(i + x, j + y), q); } sum = sum1 / sum2; output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = cv::saturate_castuchar(sum); }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); // 自实现方法 AntiharmonicAveragingFilter(input, output1, 7, 7, 2); AntiharmonicAveragingFilter(input, output2, 7, 7, -2); cv::namedWindow(\"反谐波均值滤波器：Q=2\", cv::WINDOW_NORMAL); cv::imshow(\"反谐波均值滤波器：Q=2\", output1); cv::namedWindow(\"反谐波均值滤波器：Q=-2\", cv::WINDOW_NORMAL); cv::imshow(\"反谐波均值滤波器：Q=-2\", output2); cv::waitKey(0); return 0;} 效果展示： #pragma once#include opencv2/opencv.hpp#include randomvoid Salt(cv::Mat input, int n); //Salt.cpp#include \"Salt.h\"void Salt(cv::Mat input, int n){ std::default_random_engine generator; std::uniform_int_distributionintrow(0, input.rows - 1); std::uniform_int_distributionintcol(0, input.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = row(generator); j = col(generator); if (input.channels() == 1) input.atuchar(i, j) = 255; else if (input.channels() == 3) input.atcv::Vec3b(i, j) = cv::Vec3b(255, 255, 255); }} 8.2 统计排序滤波器 8.2.1 中值滤波器 处理单极、双极冲激噪声更好，也能有效降低某些随机噪声，丢失细节更少。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 是中心为(x,y)的子图像， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=median(r,c)∈Sxy{g(r,c)}\\hat f(x,y)=median_{(r,c)\\in S_{xy} }\\{g(r,c)\\} f^​(x,y)=median(r,c)∈Sxy​​{g(r,c)} 代码实现： #include iostream#include vector#include opencv2/opencv.hpp#include \"Salt.h\"void MedianFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); int num = m * n; std::vectoruchar arry(num); cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int h = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { arry[h] = input.atuchar(i + x, j + y); h += 1; } std::sort(arry.begin(), arry.end()); output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = arry[(num - 1) / 2]; }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); // 自实现中值滤波器 MedianFilter(input, output1, 7, 7); // OpenCV自带中值滤波器 cv::medianBlur(input, output2, 7); cv::namedWindow(\"自实现中值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"自实现中值滤波器\", output1); cv::namedWindow(\"OpenCV自带中值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"OpenCV自带中值滤波器\", output2); cv::waitKey(0); return 0;} 效果展示： 8.2.2 最大值滤波器 滤波窗口的最大值作为滤波结果，可通过最大值滤波器削减胡椒噪声，也可削弱明色区域相邻的暗色区域。其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 是中心为(x,y)的子图像， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=max⁡(r,c)∈Sxy{g(r,c)}\\hat f(x,y)=\\max_{(r,c)\\in S_{xy} }\\{g(r,c)\\} f^​(x,y)=(r,c)∈Sxy​max​{g(r,c)} 代码实现： #include iostream#include vector#include opencv2/opencv.hpp#include \"Salt.h\"void MaxFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); int num = m * n; std::vectoruchar arry(num); cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int h = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { arry[h] = input.atuchar(i + x, j + y); h += 1; } std::sort(arry.begin(), arry.end()); output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = arry[num - 1]; }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output; Salt(input, 100000); // 给图片添加10w个黑色噪点（胡椒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); MaxFilter(input, output, 7, 7); cv::namedWindow(\"最大值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"最大值滤波器\", output); cv::waitKey(0); return 0;} 效果展示： 8.2.3 最小值滤波器 滤波窗口的最小值作为滤波结果，可通过最小值滤波器削减盐粒噪声，也可削弱暗色区域相邻的明色区域。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 是中心为(x,y)的子图像， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=min⁡(r,c)∈Sxy{g(r,c)}\\hat f(x,y)=\\min_{(r,c)\\in S_{xy} }\\{g(r,c)\\} f^​(x,y)=(r,c)∈Sxy​min​{g(r,c)} 代码实现： #include iostream#include vector#include opencv2/opencv.hpp#include \"Salt.h\"void MinFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); int num = m * n; std::vectoruchar arry(num); cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int h = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { arry[h] = input.atuchar(i + x, j + y); h += 1; } std::sort(arry.begin(), arry.end()); output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = arry[0]; }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); MinFilter(input, output, 7, 7); cv::namedWindow(\"最小值滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"最小值滤波器\", output); cv::waitKey(0); return 0;} 效果展示： 8.2.4 中点滤波器 滤波窗口的最大值和最小值的均值作为滤波结果，适合处理随机分布的噪声，如高斯噪声和均匀噪声。表达式如下，其中 f^\\hat ff^​ 为复原的图像， SxyS_{xy}Sxy​ 是中心为(x,y)的子图像， g(x,y)g(x,y)g(x,y) 为被污染的图像： f^(x,y)=12[max⁡(r,c)∈Sxy{g(r,c)}+min⁡(r,c)∈Sxy{g(r,c)}]\\hat f(x,y)=\\frac 12\\bigg[\\max_{(r,c)\\in S_{xy} }\\{g(r,c)\\}+\\min_{(r,c)\\in S_{xy} }\\{g(r,c)\\}\\bigg] f^​(x,y)=21​[(r,c)∈Sxy​max​{g(r,c)}+(r,c)∈Sxy​min​{g(r,c)}] 代码实现： #include iostream#include vector#include opencv2/opencv.hpp#include \"Salt.h\"void MidPointFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); int num = m * n; std::vectoruchar arry(num); cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int h = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { arry[h] = input.atuchar(i + x, j + y); h += 1; } std::sort(arry.begin(), arry.end()); output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = round((arry[0] + arry[num - 1]) / 2); }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); MidPointFilter(input, output, 7, 7); cv::namedWindow(\"中点滤波器\", cv::WINDOW_NORMAL); cv::imshow(\"中点滤波器\", output); cv::waitKey(0); return 0;} 效果展示： 不太适合盐粒噪声 8.2.5 修正阿尔法均值滤波器 假设要在邻域 SxyS_{xy}Sxy​ 内删除 g(r,c)g(r,c)g(r,c) 的 ddd 个最低灰度值和 ddd 个最高灰度值。令 g(r,c)g(r,c)g(r,c) 表示S中剩下的 mn−2dmn-2dmn−2d 个像素，通过平均这些剩余像素所形成的滤波器，称为修正阿尔法均值滤波器。 当 d=0d=0d=0 时简化为算术平均滤波器，当 d=(mn−1)/2d=(mn-1)/2d=(mn−1)/2 时变成中值滤波器，当 ddd 为其他值时适合处理多种混合噪声，如高斯噪声和椒盐噪声。 f^(x,y)=1mn−2d∑(r,c)∈SxygR(r,c)\\hat f(x,y)=\\frac{1} {mn-2d}\\sum_{(r,c)\\in S_{xy} }g_R(r,c) f^​(x,y)=mn−2d1​(r,c)∈Sxy​∑​gR​(r,c) 代码实现： #include iostream#include vector#include opencv2/opencv.hpp#include \"Salt.h\"void ModifiedAlphaMeanFilter(cv::Mat input, cv::Mat output, int m, int n, int d){ output = input.clone(); int num = m * n; std::vectoruchar arry(num); cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int h = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x ++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { arry[h] = input.atuchar(i + x, j + y); h += 1; } std::sort(arry.begin(), arry.end()); int sum = 0; for (int k = d; k num - d - 1; k ++) sum += arry[k]; output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = round(sum / (num - 2 * d)); }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; Salt(input, 100000); // 给图片添加10w个白色噪点（盐粒噪声） cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); ModifiedAlphaMeanFilter(input, output1, 7, 7, 3); ModifiedAlphaMeanFilter(input, output2, 7, 7, 9); cv::namedWindow(\"修正阿尔法均值滤波器：d=3\", cv::WINDOW_NORMAL); cv::imshow(\"修正阿尔法均值滤波器：d=3\", output1); cv::namedWindow(\"修正阿尔法均值滤波器：d=9\", cv::WINDOW_NORMAL); cv::imshow(\"修正阿尔法均值滤波器：d=9\", output2); cv::waitKey(0); return 0;} 效果展示： //Salt.h#pragma once#include opencv2/opencv.hpp#include randomvoid Salt(cv::Mat input, int n); #include \"Salt.h\"void Salt(cv::Mat input, int n){ std::default_random_engine generator; std::uniform_int_distributionintrow(0, input.rows - 1); std::uniform_int_distributionintcol(0, input.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = row(generator); j = col(generator); if (input.channels() == 1) input.atuchar(i, j) = 255; //试验最大值滤波器时取为0 else if (input.channels() == 3) input.atcv::Vec3b(i, j) = cv::Vec3b(255, 255, 255); //试验最大值滤波器时取为(0,0,0) }} 8.3 自适应滤波器 8.3.1 自适应局部降噪滤波器 滤波器对中心(x,y)的一个邻域 SxyS_{xy}Sxy​ 进行操作， 噪声图像g(x,y)，噪声方差 ση2\\sigma_\\eta^2ση2​ ； SxyS_{xy}Sxy​ 中像素的平均灰度 z‾Sxy\\overline{z}_{S_{xy} }zSxy​​ ， SxyS_{xy}Sxy​ 中像素灰度的局部方差 σSxy2\\sigma^2_{S_{xy} }σSxy​2​ ； 希望滤波器满足： 噪声为0时，(x,y)处的值g等于f。若噪声图像方差 ση2=0\\sigma^2_\\eta=0ση2​=0 ，则滤波器仅返回(x,y)处的值g。 高局部方差通常与边缘相关，且应保留这些边缘。若局部方差 σSxy2\\sigma^2_{S_{xy} }σSxy​2​ 与 ση2\\sigma_\\eta^2ση2​ 高度相关，则滤波器返回(x,y)处一个接近于g的值。 当局部区域的性质与整个图像的性质相同时，则两个方差相等，滤波器返回 SxyS_{xy}Sxy​ 中像素的算术平均值，平均运算降低局部噪声。 处理步骤： 计算噪声图像方差 ση2\\sigma^2_\\etaση2​ ； 计算滤波器窗口内像素的均值 zSsyz_{S_{sy} }zSsy​​ 和方差 σSxy2\\sigma^2_{S_{xy} }σSxy​2​ ； 利用下式计算： f^(x,y)=g(x,y)−ση2σSxy2[g(x,y)−zSxy‾],ση2σSxy2≤1\\hat{f}(x,y)=g(x,y)-\\frac{\\sigma^2_{\\eta} } {\\sigma^2_{S_{xy} }}\\big[g(x,y)-\\overline{z_{S_{xy} }}\\big],\\frac{\\sigma^2_{\\eta} } {\\sigma^2_{S_{xy} }}\\leq1 f^​(x,y)=g(x,y)−σSxy​2​ση2​​[g(x,y)−zSxy​​​],σSxy​2​ση2​​≤1 代码： 涉及OpenCV函数： void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask=noArray()); 参数分别为： src：输入矩阵 mean：输出均值 stddev：输出标准差 mask：可选参数，掩码 #include iostream#include opencv2/opencv.hpp// 添加高斯噪声void GaussianNoise(cv::Mat input, cv::Mat output){ cv::RNG rng; cv::Mat noice = input.clone(); output = input.clone(); rng.fill(noice, cv::RNG::NORMAL, 10, 20); // 使用NORMAL参数添加高斯噪声 output = input + noice;}void AdaptiveLocalNoiseReductionFilter(cv::Mat input, cv::Mat output, int m, int n){ output = input.clone(); cv::Mat arry(1, m * n, CV_8U); // 局部矩阵 cv::copyMakeBorder(input, input, (m - 1) / 2, (m - 1) / 2, (n - 1) / 2, (n - 1) / 2, cv::BORDER_REFLECT); cv::Mat mean1, stddev1, mean2, stddev2; cv::meanStdDev(input, mean1, stddev1); // 获取矩阵平均值和标准差 double _stddev1, _mean2, _stddev2; // 图像标准差、局部均值和局部标准差 _stddev1 = stddev1.atdouble(0, 0); for (int i = (m - 1) / 2; i input.rows - (m - 1) / 2; i ++) for (int j = (n - 1) / 2; j input.cols - (n - 1) / 2; j ++) { int h = 0; for (int x = -(m - 1) / 2; x = (m - 1) / 2; x ++) for (int y = -(n - 1) / 2; y = (n - 1) / 2; y ++) { arry.atuchar(h) = input.atuchar(i + x, j + y); h ++; } cv::meanStdDev(arry, mean2, stddev2); _stddev2 = stddev2.atdouble(0, 0); _mean2 = mean2.atdouble(0, 0); double k = (_stddev1 * _stddev1) / (_stddev2 * _stddev2 + 0.00001); if (k = 1) output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = input.atuchar(i, j) - k * (input.atuchar(i, j) - _mean2); else output.atuchar(i - (m - 1) / 2, j - (n - 1) / 2) = _mean2; }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output; GaussianNoise(input, input); //添加高斯噪声 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); AdaptiveLocalNoiseReductionFilter(input, output, 7, 7); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", output); cv::waitKey(0); return 0;} 效果展示： 8.3.2 自适应中值滤波器 通过判断，将中值或者原像素灰度值作为结果。记以下符号： zminz_{min}zmin​ 是 SxyS_{xy}Sxy​ 中的最小灰度值；zmaxz_{max}zmax​ 是 SxyS_{xy}Sxy​ 中的最大灰度值；zmedz_{med}zmed​ 是 SxyS_{xy}Sxy​ 中灰度值的中值； zxyz_{xy}zxy​ 是坐标 (x,y)(x,y)(x,y) 处的灰度值， SmaxS_{max}Smax​ 是 SxyS_{xy}Sxy​ 允许的最大尺寸。 代码： #include iostream#include vector#include opencv2/opencv.hpp#include \"Salt.h\"// 添加高斯噪声void GaussianNoise(cv::Mat input, cv::Mat output){ cv::RNG rng; cv::Mat noice = input.clone(); output = input.clone(); rng.fill(noice, cv::RNG::NORMAL, 10, 50); // 使用NORMAL参数添加高斯噪声 output = input + noice;}// 求输出值uchar AdaptiveMedian(cv::Mat input, int i, int j, int filter_size, int maxsize){ int num = filter_size * filter_size; std::vectoruchar arry(num); int h = 0; for (int x = -(filter_size - 1) / 2; x = (filter_size - 1) / 2; x ++) for (int y = -(filter_size - 1) / 2; y = (filter_size - 1) / 2; y ++) { arry[h] = input.atuchar(i + x, j + y); h ++; } sort(arry.begin(), arry.end()); int z_min = arry[0]; int z_med = arry[(num - 1) / 2]; int z_max = arry[num - 1]; int z_xy = input.atuchar(i, j); if (z_med z_min and z_med z_max) { if (z_xy z_min and z_xy z_max) return z_xy; else return z_med; } else { filter_size += 2; if (filter_size = maxsize) return AdaptiveMedian(input, i, j, filter_size, maxsize); else return z_med; }}// 自适应中值滤波器void AdaptiveMedianFilter(cv::Mat input, cv::Mat output, int maxsize){ output = input.clone(); cv::copyMakeBorder(input, input, (maxsize - 1) / 2, (maxsize - 1) / 2, (maxsize - 1) / 2, (maxsize - 1) / 2, cv::BORDER_REFLECT); for (int i = (maxsize - 1) / 2; i input.rows - (maxsize - 1) / 2; i ++) for (int j = (maxsize - 1) / 2; j input.cols - (maxsize - 1) / 2; j ++) { int filter_size = 3; // 开始时滤波器尺寸 output.atuchar(i - (maxsize - 1) / 2, j - (maxsize - 1) / 2) = AdaptiveMedian(input, i, j, filter_size, maxsize); }}int main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat output1, output2; cv::Mat noise1 = input.clone(), noise2 = input.clone(); GaussianNoise(input, noise1); // 添加高斯噪声 Salt(input, noise2, 100000); // 添加盐粒噪声 cv::namedWindow(\"高斯噪声\", cv::WINDOW_NORMAL); cv::imshow(\"高斯噪声\", noise1); cv::namedWindow(\"盐粒噪声\", cv::WINDOW_NORMAL); cv::imshow(\"盐粒噪声\", noise2); AdaptiveMedianFilter(noise1, output1, 7); AdaptiveMedianFilter(noise2, output2, 7); cv::namedWindow(\"降低高斯噪声\", cv::WINDOW_NORMAL); cv::imshow(\"降低高斯噪声\", output1); cv::namedWindow(\"降低盐粒噪声\", cv::WINDOW_NORMAL); cv::imshow(\"降低盐粒噪声\", output2); cv::waitKey(0); return 0;} // Salt.h#pragma once#include opencv2/opencv.hpp#include randomvoid Salt(cv::Mat input, cv::Mat output, int n); // Salt.cpp#include \"Salt.h\"void Salt(cv::Mat input, cv::Mat output, int n){ output = input.clone(); std::default_random_engine generator; std::uniform_int_distributionintrow(0, input.rows - 1); std::uniform_int_distributionintcol(0, input.cols - 1); int i, j; for (int k = 0; k n; k ++) { i = row(generator); j = col(generator); if (input.channels() == 1) output.atuchar(i, j) = 255; else if (input.channels() == 3) output.atcv::Vec3b(i, j) = cv::Vec3b(255, 255, 255); }} 效果展示； 对于盐粒噪声有奇效 九、彩色图像处理基础 9.1 彩色图像基础 颜色的特性可以表达成亮度、色调和饱和度。 亮度：即强度，如灰度值 色调：混合在光波中的主导光波属性，即被观察者感知的主导色。 饱和度：相对的纯度，或与一种色调混合的白光量。比如浅红色（红色+白色）是不饱和的，白色越多，越不饱和。 色度=色调+饱和度，颜色=亮度+色度色度=色调+饱和度，颜色=亮度+色度 色度=色调+饱和度，颜色=亮度+色度 9.2 彩色图像模型 常见的彩色图像模型有： RGB（红绿蓝）：一般用于彩色显示器和彩色摄影机。 CMY（青、深红、黄）和CMYK（青、深红、黄、黑）：一般用于彩色打印。 HSI（色调、饱和度、亮度）：描述和解释颜色 9.3 RGB模型与HSI模型之间的转换 9.3.1 从RGB到HSI 此处HSI的计算假设RGB已被归一化到[0,1]，且θ是相对于HSI空间的红色轴测量，得到的HSI结果也在区间[0,1]中。 H色调分量计算： H={θifB≤G360−θifBGH=\\begin{cases} \\theta if\\ B\\leq G\\\\ 360-\\theta if\\ B G \\end{cases} H={θ360−θ​ifB≤GifBG​ θ=cos−112[(R−G)+(R+B)][(R−G)2+(R−B)(G−B)]1/2\\theta=cos^{-1}\\frac{\\frac{1} {2}[(R-G)+(R+B)]} {[(R-G)^2+(R-B)(G-B)]^{1/2} } θ=cos−1[(R−G)2+(R−B)(G−B)]1/221​[(R−G)+(R+B)]​ S饱和度分量计算： S=1−3R+G+B[min⁡(R,G,B)]S=1-\\frac{3} {R+G+B}[\\min(R,G,B)] S=1−R+G+B3​[min(R,G,B)] I亮度分量计算： I=13(R+G+B)I=\\frac 13(R+G+B) I=31​(R+G+B) 9.3.2 从HSI到RGB 值区间同上[0,1] 先计算H色调值，再根据H的范围使用不同的公式。 把H值从[0,1]转换到[0,360]： H=H×360°H=H\\times 360° H=H×360° 根据H的范围使用不同计算公式： 当 H∈[0,120)H\\in[0,120)H∈[0,120) ，即RG扇区： {B=I(1−S)R=I[1+Scos⁡Hcos⁡(60°−H)]G=3I−(R+B)\\left\\{ \\begin{matrix} B=I(1-S) \\\\ R=I[1+\\frac{S\\cos H} {\\cos(60°-H)}]\\\\ G=3I-(R+B) \\end{matrix} \\right. ⎩⎪⎨⎪⎧​BRG​===​I(1−S)I[1+cos(60°−H)ScosH​]3I−(R+B)​ 当 H∈[120,240)H\\in[120,240)H∈[120,240) ，即GB扇区： {H=H−120°B=I(1−S)R=I[1+Scos⁡Hcos⁡(60°−H)]G=3I−(R+B)\\left\\{ \\begin{matrix} H=H-120°\\\\ B=I(1-S) \\\\ R=I[1+\\frac{S\\cos H} {\\cos(60°-H)}]\\\\ G=3I-(R+B) \\end{matrix} \\right. ⎩⎪⎪⎪⎨⎪⎪⎪⎧​HBRG​====​H−120°I(1−S)I[1+cos(60°−H)ScosH​]3I−(R+B)​ 当 H∈[240,360]H\\in[240,360]H∈[240,360] ，即GB扇区： {H=H−240°B=I(1−S)R=I[1+Scos⁡Hcos⁡(60°−H)]G=3I−(R+B)\\left\\{ \\begin{matrix} H=H-240°\\\\ B=I(1-S) \\\\ R=I[1+\\frac{S\\cos H} {\\cos(60°-H)}]\\\\ G=3I-(R+B) \\end{matrix} \\right. ⎩⎪⎪⎪⎨⎪⎪⎪⎧​HBRG​====​H−240°I(1−S)I[1+cos(60°−H)ScosH​]3I−(R+B)​ 十、图像形态学处理 10.1 腐蚀 定义B对A的腐蚀为： A⊖B={z∣(B)z⊆A}A\\ominus B = \\{z|(B)_z\\subseteq A\\} A⊖B={z∣(B)z​⊆A} 其中，A是前景像素的一个集合，B是一个结构元，z项是前景像素值。 腐蚀的目的是去除图像中的某些部分以及会缩小细化目标。 但是，对于白色背景，黑色目标变大；对于黑色背景，白色目标变小。 可以理解为结构元像素是白色的，腐蚀是腐蚀图像中的白色像素，白色像素被腐蚀，则黑色元素膨胀。 代码如下： 相关函数有： double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type); // 二值化 参数列表有： src：输入数组(多通道，8位或32位浮点)。 dst：与src相同大小和类型、相同通道数的输出数组。 thresh：阈值. maxval：dst图像中的最大值。 type：阈值。 type可选有： cv::THRESH_BINARY，效果： dst(x,y)={maxval,ifsrc(x,y)thresh0,otherwisedst(x,y)= \\begin{cases} maxval,\\quad if\\ src(x,y) thresh\\\\ 0, \\quad otherwise \\end{cases} dst(x,y)={maxval,ifsrc(x,y)thresh0,otherwise​ cv::THRESH_BINARY_INV，效果： dst(x,y)={0,ifsrc(x,y)threshmaxval,otherwisedst(x,y)= \\begin{cases} 0,\\quad if\\ src(x,y) thresh\\\\ maxval, \\quad otherwise \\end{cases} dst(x,y)={0,ifsrc(x,y)threshmaxval,otherwise​ cv::THRESH_TRUNC，效果： dst(x,y)={threshold,ifsrc(x,y)threshsrc(x,y),otherwisedst(x,y)= \\begin{cases} threshold,\\quad if\\ src(x,y) thresh\\\\ src(x,y), \\quad otherwise \\end{cases} dst(x,y)={threshold,ifsrc(x,y)threshsrc(x,y),otherwise​ cv::THRESH_TOZERO，效果： dst(x,y)={src(x,y),ifsrc(x,y)thresh0,otherwisedst(x,y)= \\begin{cases} src(x,y),\\quad if\\ src(x,y) thresh\\\\ 0, \\quad otherwise \\end{cases} dst(x,y)={src(x,y),ifsrc(x,y)thresh0,otherwise​ cv::THRESH_TOZERO_INV，效果： dst(x,y)={0,ifsrc(x,y)threshsrc(x,y),otherwisedst(x,y)= \\begin{cases} 0,\\quad if\\ src(x,y) thresh\\\\ src(x,y), \\quad otherwise \\end{cases} dst(x,y)={0,ifsrc(x,y)threshsrc(x,y),otherwise​ cv::THRESH_OTSU，效果：标志，使用Otsu算法选择最优阈值。 cv::THRESH_TRIANGLE，效果：标志，使用三角算法选择最优阈值。 cv::THRESH_MASK。 Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1,-1)); // 构造结构元函数 参数列表有： shape：结构元形状，0表示矩形，1表示十字架，2表示椭圆。 ksize：结构元大小。 anchor：结构元中心点所在位置。 void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar borderValue = morphologyDefaultBorderValue()); 参数列表有： src：输入图像，通道的数量可以是任意的，但深度应该是CV_8U, CV_16U, CV_16S, CV_32F或CV_64F。 dst：输出与src相同大小和类型的图像。 kernel：用于腐蚀的结构元。 anchor：中心点在元素中的位置。 iterations：应用侵蚀的次数。 borderType：推断图像外部像素的边界模式。 borderValue：当边界为常数时的边界值。 #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat image_bw, image_erosion; // 二值化图像和腐蚀后的图像 cv::threshold(input, image_bw, 100, 255, cv::THRESH_BINARY); // 二值化 cv::Mat se = cv::getStructuringElement(0, cv::Size(3, 3)); // 腐蚀核 cv::erode(image_bw, image_erosion, se, cv::Point(-1, -1), 3); // 腐蚀 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); cv::namedWindow(\"二值化后\", cv::WINDOW_NORMAL); cv::imshow(\"二值化后\", image_bw); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", image_erosion); cv::waitKey(0); return 0;} 效果展示： 10.2 膨胀 定义B对A的腐蚀为： A⊕B={z∣[(B^)z∩A]⊆A}A\\oplus B = \\{z|[(\\hat{B})_z\\cap A]\\subseteq A \\} A⊕B={z∣[(B^)z​∩A]⊆A} 其中，A是前景像素的一个集合，B是一个结构元，z项是前景像素值。 腐蚀的目的是增大图像中的目标，或者填充、连接某些目标。 但是，对于白色背景，黑色目标变小；对于黑色背景，白色目标变大。 可以理解为结构元像素是白色的，膨胀是膨胀图像中的白色像素，白色像素被膨胀，则黑色元素腐蚀。 代码如下： 相关函数有： void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar borderValue = morphologyDefaultBorderValue()); 参数列表有： src：输入图像，通道的数量可以是任意的，但深度应该是CV_8U, CV_16U, CV_16S, CV_32F或CV_64F。 dst：输出与src相同大小和类型的图像。 kernel：用于腐蚀的结构元。 anchor：中心点在元素中的位置。 iterations：应用侵蚀的次数。 borderType：推断图像外部像素的边界模式。 borderValue：当边界为常数时的边界值。 #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/test.jpg\", 0); cv::Mat image_bw, image_dilate; // 二值化图像和膨胀后的图像 cv::threshold(input, image_bw, 100, 255, cv::THRESH_BINARY); // 二值化 cv::Mat se = cv::getStructuringElement(0, cv::Size(3, 3)); // 膨胀核 cv::dilate(image_bw, image_dilate, se, cv::Point(-1, -1), 3); // 膨胀 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::imshow(\"before\", input); cv::namedWindow(\"二值化后\", cv::WINDOW_NORMAL); cv::imshow(\"二值化后\", image_bw); cv::namedWindow(\"after\", cv::WINDOW_NORMAL); cv::imshow(\"after\", image_dilate); cv::waitKey(0); return 0;} 效果展示： 10.3 开运算与闭运算 结构元B对集合A的开运算定义为： A∘B=(A⊖B)⊕BA\\circ B=(A\\ominus B)\\oplus B A∘B=(A⊖B)⊕B 即B对A先腐蚀，接着B对腐蚀结果膨胀。 作用是：平滑物体轮廓、断开狭窄的狭颈、消除细长的突出和物体。 结构元B对集合A的闭运算定义为： A∙B=(A⊕B)⊖BA\\bullet B=(A\\oplus B)\\ominus B A∙B=(A⊕B)⊖B 即B对A先膨胀，接着B对膨胀结果腐蚀。 作用是：弥合狭窄的狭颈或断裂处、消除小孔、填补轮廓缝隙。 代码如下： #include opencv2/opencv.hppvoid imageOpenOperation(cv::Mat input, cv::Mat output){ output = input.clone(); cv::Mat se = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3)); cv::erode(input, output, se); cv::dilate(output, output, se);}void imageCloseOperation(cv::Mat input, cv::Mat output){ output = input.clone(); cv::Mat se = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3)); cv::dilate(input, output, se); cv::erode(output, output, se);}int main(){ cv::Mat input = cv::imread(\"src/pic2.png\", 0); cv::Mat img_bw, result1, result2; // 二值化后的图像、开运算结果、比运算结果 cv::threshold(input, img_bw, 100, 255, cv::THRESH_BINARY); // 二值化 imageOpenOperation(img_bw, result1); imageCloseOperation(img_bw, result2); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"开运算后\", cv::WINDOW_NORMAL); cv::namedWindow(\"闭运算后\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img_bw); cv::imshow(\"开运算后\", result1); cv::imshow(\"闭运算后\", result2); cv::waitKey(0); return 0;} 10.4 morphologyEx()函数的运用 膨胀腐蚀、开运算闭运算、击中-击不中变换、顶帽变换与底帽变换、形态学梯度 10.4.1 相关函数原型 void morphologyEx( InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar borderValue = morphologyDefaultBorderValue() ); 参数如下： src：输入图像，图像数据类型必须为CV_8U, CV_16U, CV_16S, CV_32F or CV_64F中的一种。 dst：输出图像，数据类型与大小和输入图像一样。 op：形态学处理的类型。 MORPH_ERODE = 0：腐蚀处理 MORPH_DILATE = 1：膨胀处理 MORPH_OPEN = 2：开运算处理 MORPH_CLOSE = 3：闭运算处理 MORPH_GRADIENT = 4：形态学梯度 MORPH_TOPHAT = 5：顶帽变换 MORPH_BLACKHAT = 6：黑帽变换 MORPH_HITMISS = 7 ：击中-击不中变换 kernel：结构元矩阵。 iterations：腐蚀膨胀处理的次数，默认值为1；如果是开运算闭运算，次数表示先腐蚀或者膨胀几次，再膨胀腐蚀几次，而不是开运算闭运算几次。 borderType：图像边框插值类型，默认类型为固定值填充。 borderValue：边界值（如果是恒定边界）。默认值具有特殊含义。 10.4.2 进行腐蚀膨胀 #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/pic2.png\", 0); cv::Mat img_bw, result1, result2; cv::threshold(input, img_bw, 100, 255, cv::THRESH_BINARY); // 二值化 cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3)); cv::morphologyEx(img_bw, result1, 0, kernel); // 腐蚀 cv::morphologyEx(img_bw, result2, 1, kernel); // 膨胀 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"腐蚀结果\", cv::WINDOW_NORMAL); cv::namedWindow(\"膨胀结果\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img_bw); cv::imshow(\"腐蚀结果\", result1); cv::imshow(\"膨胀结果\", result2); cv::waitKey(0); return 0;} 效果展示： 10.4.3 进行开运算和闭运算 #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/pic2.png\", 0); cv::Mat img_bw, result1, result2; cv::threshold(input, img_bw, 100, 255, cv::THRESH_BINARY); // 二值化 cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3)); cv::morphologyEx(img_bw, result1, 2, kernel); // 开运算 cv::morphologyEx(img_bw, result2, 3, kernel); // 闭运算 cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"开运算结果\", cv::WINDOW_NORMAL); cv::namedWindow(\"闭运算结果\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img_bw); cv::imshow(\"开运算结果\", result1); cv::imshow(\"闭运算结果\", result2); cv::waitKey(0); return 0;} 效果展示： 10.4.4 击中-击不中变换 原理： I⊛B={z∣(B)z⊆I}I\\circledast B=\\{z|(B)_z\\subseteq I\\} I⊛B={z∣(B)z​⊆I} 可以检测图像中满足结构元B的所有像素点，如： 图中结构元B中深色像素为前景，白色表示为背景， × 表示不关心像素（即不影响结果）。 击中-击不中变换是形状检测的基本工具，寻找与结构元相符合的像素。 在击中击不中变换的结构元中，-1表示背景，1表示前景，0表示不关心。 代码如下： #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/rice.jpg\", 0); cv::Mat img_bw, result; cv::threshold(input, img_bw, 100, 255, cv::THRESH_BINARY); // 二值化 cv::Mat kernel = (cv::Mat_float(3, 3) 1, 1, -1, 1, 1, -1, 1, 1, -1); cv::morphologyEx(img_bw, result, 7, kernel); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"击中-击不中变换结果\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img_bw); cv::imshow(\"击中-击不中变换结果\", result); cv::waitKey(0); return 0;} 效果展示： 10.4.5 顶帽变换与底帽变换 顶帽变换（礼帽变换） 是原图像与开运算结果图之差。 作用：提取出细线状的部分或者噪声。 底帽变换（黑帽变换） 是闭运算与原图像结果图之差。 作用：得到图像内部的小孔，或前景色的小黑点。 代码如下： #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/rice.jpg\", 0); cv::Mat img_bw, result1, result2; cv::threshold(input, img_bw, 100, 255, cv::THRESH_BINARY); cv::Mat kernel = cv::getStructuringElement(0, cv::Size(5, 5)); cv::morphologyEx(img_bw, result1, 5, kernel); cv::morphologyEx(img_bw, result2, 6, kernel); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"顶帽变换结果\", cv::WINDOW_NORMAL); cv::namedWindow(\"底帽变换结果\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img_bw); cv::imshow(\"顶帽变换结果\", result1); cv::imshow(\"底帽变换结果\", result2); cv::waitKey(0); return 0;} 效果截图： 10.4.6 形态学梯度 膨胀图与腐蚀图之差； 对二值图进行这一操作可以得到图像中白色区域的边界，因此可以用形态学梯度来保留物体的边界轮廓。 代码如下： #include opencv2/opencv.hppint main(){ cv::Mat input = cv::imread(\"src/pic2.png\", 0); cv::Mat img_bw, result; cv::threshold(input, img_bw, 100, 255, cv::THRESH_BINARY_INV); cv::Mat kernel = cv::getStructuringElement(0, cv::Size(5, 5)); cv::morphologyEx(img_bw, result, 4, kernel); cv::namedWindow(\"before\", cv::WINDOW_NORMAL); cv::namedWindow(\"形态学梯度结果\", cv::WINDOW_NORMAL); cv::imshow(\"before\", img_bw); cv::imshow(\"形态学梯度结果\", result); cv::waitKey(0); return 0;} 效果截图： 10.5 提取连通域 连通域：指图像中具有相同像素值且位置相邻的像素组成的区域。 10.5.1 connectedComponents函数 int connectedComponents(InputArray image, OutputArray labels, int connectivity = 8, int ltype = CV_32S); 参数如下： image：输入图像，待标记8位单通道图像。 labels：输出图像，目标标记图像。 connectivity：连通域大小，四连通域还是八连通域。 输出类型：CV32S 和 CV_16U ，默认是 CV_32S 。 返回连通域个数。 代码如下： #include opencv2/opencv.hpp#include iostreamint main(){ cv::Mat input = cv::imread(\"src/rice.jpg\"); cv::Mat img_bw, connectimg; cv::cvtColor(input, img_bw, cv::COLOR_BGR2GRAY); cv::threshold(img_bw, img_bw, 100, 255, cv::THRESH_BINARY_INV); // 做一些膨胀和腐蚀使得图像连通域明显 cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5)); cv::erode(img_bw, img_bw, element, cv::Point(-1, -1), 2); cv::dilate(img_bw, img_bw, element, cv::Point(-1, -1), 2); int num = cv::connectedComponents(img_bw, connectimg, 8, CV_16U); std::cout \"连通域个数：\" num std::endl; cv::namedWindow(\"原图\", cv::WINDOW_NORMAL); cv::imshow(\"原图\", img_bw); //以不同颜色标记出不同的连通域 cv::Mat result = cv::Mat::zeros(img_bw.size(), CV_8UC3); //定义标记结果图像 //定义五种颜色 std::vectorcv::Vec3b color; color.push_back(cv::Vec3b(0, 0, 255)); color.push_back(cv::Vec3b(0, 255, 0)); color.push_back(cv::Vec3b(255, 0, 0)); color.push_back(cv::Vec3b(0, 255, 255)); color.push_back(cv::Vec3b(255, 255, 0)); for (int i = 0; i result.cols; i ++) { for (int j = 0; j result.rows; j ++) { int label = connectimg.atuint16_t(i, j); if (label == 0) { continue; //背景的黑色不改变 } result.atcv::Vec3b(i, j) = color[label % 5]; } } cv::namedWindow(\"标记连通域后\", cv::WINDOW_NORMAL); cv::imshow(\"标记连通域后\", result); cv::waitKey(0); return 0;} 效果截图： 注：黑色也算一个连通域 10.5.2 connectedComponentsWithStats函数 函数： int connectedComponentsWithStats(InputArray image, OutputArray labels, OutputArray stats, OutputArray centroids, int connectivity = 8, int ltype = CV_32S); 参数如下： image：要标记的8位单通道图像 labels：目标标签图像 stats：每个标签的统计输出，是一个5列的矩阵，每一行对应每个连通区域的外接矩形的左上角坐标x、y，以及外接矩形的宽高width、height和面积area。 centroids：连通域中心点，数据类型CV_64F。 connectivity：8或4分别用于八连通域和四连通域。 ltype输出图像标签类型。目前支持CV_32S和CV_16U。 返回连通域个数。 其中， stats包含了标签为i的连通域的一些信息，可以如下访问标签为i的连通域的面积： stats.atint(i, CC_STAT_AREA) 连通域外接矩形的参数： // 矩形左上角xx = stats.atint(max_idx, cv::CC_STAT_LEFT);// 矩形左上角yy = stats.atint(max_idx, cv::CC_STAT_TOP);// 矩形高h = stats.atint(max_idx, cv::CC_STAT_HEIGHT);// 矩形宽w = stats.atint(max_idx, cv::CC_STAT_WIDTH); 十一、图像分割 11.1 图像边缘检测 11.1.1边缘检测的步骤 为了降低噪声，对图像进行平滑处理。 检测边缘点。 边缘定位。 11.1.2 图像梯度 计算图像f在任意位置(x, y)处的边缘强度和方向的工具是梯度。 定义梯度为向量： ∇f(x,y)≡grad[f(x,y)]≡[gx(x,y)gy(x,y)]=[∂f(x,y)∂x∂f(x,y)∂y] abla f(x,y)\\equiv grad[f(x,y)]\\equiv \\left[ \\begin{matrix} g_x(x,y)\\\\ g_y(x,y)\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} \\frac{\\partial f(x,y)} {\\partial x}\\\\ \\frac{\\partial f(x,y)} {\\partial y}\\\\ \\end{matrix} \\right] ∇f(x,y)≡grad[f(x,y)]≡[gx​(x,y)gy​(x,y)​]=[∂x∂f(x,y)​∂y∂f(x,y)​​] 根据梯度向量求点(x,y)处方向变化率的值： M(x,y)=∣∣∇f(x,y)∣∣=gx2(x,y)+gy2(x,y)M(x,y) = \\vert\\vert abla f(x,y)\\vert\\vert=\\sqrt{g_x^2(x,y)+g_y^2(x,y)} M(x,y)=∣∣∇f(x,y)∣∣=gx2​(x,y)+gy2​(x,y)​ 其中M(x,y)称为图像f的梯度图像。 上式变化率方向为： α(x,y)=tan⁡−1[gy(x,y)gx(x,y)]\\alpha(x,y)=\\tan^{-1}\\Big[\\frac{g_y(x,y)} {g_x(x,y)}\\Big] α(x,y)=tan−1[gx​(x,y)gy​(x,y)​] 常见梯度算子有： 前向差分：有一维核也有二维核（Roberts核） gx(x,y)=∂f(x,y)∂x=f(x+1,y)−f(x,y)g_x(x,y)=\\frac{\\partial f(x,y)} {\\partial x}=f(x+1,y)-f(x,y) gx​(x,y)=∂x∂f(x,y)​=f(x+1,y)−f(x,y) gy(x,y)=∂f(x,y)∂y=f(x,y+1)−f(x,y)g_y(x,y)=\\frac{\\partial f(x,y)} {\\partial y}=f(x,y+1)-f(x,y) gy​(x,y)=∂y∂f(x,y)​=f(x,y+1)−f(x,y) 中心有限差分：常见有Prewitt核核Sobel核 11.1.3 点检测 使用拉普拉斯核进行孤立点检测。 11.1.4 线检测 同样可以使用拉普拉斯核进行线检测，但也有规定方向的线检测。 11.1.5 Roberts边缘检测 部分代码如下： cv::Mat kernel1 = (cv::Mat_float(2, 2) -1, 0, 0, 1 );cv::Mat kernel2 = (cv::Mat_float(2, 2) 0, -1, 1, 0 );cv::filter2D(src, dst1, -1, kernel1); // 方向1cv::filter2D(src, dst2, -1, kernel2); // 方向2cv::convertScaleAbs(dst1, dst1); // 取绝对值cv::convertScaleAbs(dst2, dst2); // 取绝对值dst = dst1 + dst2; // 合并 11.1.6 Prewitt边缘检测 部分代码如下： cv::Mat kernel1 = (cv::Mat_float(3, 3) -1, -1, -1, 0, 0, 0, 1, 1, 1);cv::Mat kernel2 = (cv::Mat_float(3, 3) -1, 0, 1, -1, 0, 1, -1, 0, 1);cv::filter2D(src, dst1, -1, kernel1); // 方向1cv::filter2D(src, dst2, -1, kernel2); // 方向2cv::convertScaleAbs(dst1, dst1); // 取绝对值cv::convertScaleAbs(dst2, dst2); // 取绝对值dst = dst1 + dst2; // 合并 11.1.7 Sobel边缘检测 部分代码如下： cv::Mat kernel1 = (cv::Mat_float(3, 3) -1, -2, -1, 0, 0, 0, 1, 2, 1);cv::Mat kernel2 = (cv::Mat_float(3, 3) -1, 0, 1, -2, 0, 2, -1, 0, 1);cv::filter2D(src, dst1, -1, kernel1); // 方向1cv::filter2D(src, dst2, -1, kernel2); // 方向2cv::convertScaleAbs(dst1, dst1); // 取绝对值cv::convertScaleAbs(dst2, dst2); // 取绝对值dst = dst1 + dst2; // 合并 11.1.8 Kirsch边缘检测 部分代码如下： cv::Mat kernel1 = (cv::Mat_float(3, 3) -3, -3, 5, -3, 0, 5, -3, -3, 5);cv::Mat kernel2 = (cv::Mat_float(3, 3) 5, -3, -3, 5, 0, -3, 5, -3, -3);cv::Mat kernel3 = (cv::Mat_float(3, 3) 5, 5, 5, -3, 0, -3, -3, -3, -3);cv::Mat kernel4 = (cv::Mat_float(3, 3) -3, -3, -3, -3, 0, -3, 5, 5, 5);cv::Mat kernel5 = (cv::Mat_float(3, 3) -3, 5, 5, -3, 0, 5, -3, -3, -3);cv::Mat kernel6 = (cv::Mat_float(3, 3) 5, 5, -3, 5, 0, -3, -3, -3, -3);cv::Mat kernel7 = (cv::Mat_float(3, 3) -3, -3, -3, -3, 0, 5, -3, 5, 5);cv::Mat kernel8 = (cv::Mat_float(3, 3) -3, -3, -3, 5, 0, -3, 5, 5, -3);cv::filter2D(src, dst1, -1, kernel1); // 方向1cv::filter2D(src, dst2, -1, kernel2); // 方向2cv::filter2D(src, dst3, -1, kernel3); // 方向3cv::filter2D(src, dst4, -1, kernel4); // 方向4cv::filter2D(src, dst5, -1, kernel5); // 方向5cv::filter2D(src, dst6, -1, kernel6); // 方向6cv::filter2D(src, dst7, -1, kernel7); // 方向7cv::filter2D(src, dst8, -1, kernel8); // 方向8cv::convertScaleAbs(dst1, dst1);cv::convertScaleAbs(dst2, dst2);cv::convertScaleAbs(dst3, dst3);cv::convertScaleAbs(dst4, dst4);cv::convertScaleAbs(dst5, dst5);cv::convertScaleAbs(dst6, dst6);cv::convertScaleAbs(dst7, dst7);cv::convertScaleAbs(dst8, dst8);dst = src.clone();for (int i = 0; i src.rows; i++) for (int j = 0; j src.cols; j++) { int arr[] = { dst1.atuchar(i, j), dst2.atuchar(i, j) , dst3.atuchar(i, j), dst4.atuchar(i, j), dst5.atuchar(i, j) , dst6.atuchar(i, j), dst7.atuchar(i, j), dst8.atuchar(i, j) }; std::sort(arr, arr + 8); int max_num = arr[7]; dst.atuchar(i, j) = max_num; // 取8个方向的最大值作为结果 } 11.1.9 LOG边缘检测 高斯拉普拉斯LOG函数： ∇2G(x,y)=(x2+y2−2σ2σ4)e−x2+y22σ2 abla^2G(x,y)=(\\frac{x^2+y^2-2\\sigma^2} {\\sigma^4})e^{-\\frac{x^2+y^2} {2\\sigma^2} } ∇2G(x,y)=(σ4x2+y2−2σ2​)e−2σ2x2+y2​ 其由拉普拉斯算子核高斯函数组成： 拉普拉斯算子：∇2f=∂2f∂x2+∂2f∂y2拉普拉斯算子： abla^2f=\\frac{\\partial^2f} {\\partial x^2} + \\frac{\\partial^2f} {\\partial y^2} 拉普拉斯算子：∇2f=∂x2∂2f​+∂y2∂2f​ 高斯函数：G(x,y)=e−x2+y22σ2高斯函数：G(x,y)=e^{-\\frac{x^2+y^2} {2\\sigma^2} } 高斯函数：G(x,y)=e−2σ2x2+y2​ ∇2G(x,y)=∂2G(x,y)∂x2+∂2G(x,y)∂y2 abla^2G(x,y)=\\frac{\\partial^2G(x,y)} {\\partial x^2} + \\frac{\\partial^2G(x,y)} {\\partial y^2} ∇2G(x,y)=∂x2∂2G(x,y)​+∂y2∂2G(x,y)​ 构建LOG核的方法有两种： 由LOG函数进行计算（取样后要标定系数使系数和为0）； 构建高斯核，接着用拉普拉斯核进行卷积得到LOG核。 由于拉普拉斯和高斯是线性运算，使用LOG对图像进行边缘检测也有两种方法： 直接用LOG核对图像进行卷积。 g(x,y)=[∇2G(x,y)]⋆f(x,y)g(x,y)=[ abla^2G(x,y)]\\star f(x,y) g(x,y)=[∇2G(x,y)]⋆f(x,y) 先对图像进行高斯滤波，再对滤波后图像进行拉普拉斯变换。 g(x,y)=∇2[G(x,y)⋆f(x,y)]g(x,y)= abla^2[G(x,y)\\star f(x,y)] g(x,y)=∇2[G(x,y)⋆f(x,y)] 代码如下： #include opencv2/opencv.hppvoid LOG1(cv::Mat input, cv::Mat output){ output = input.clone(); cv::Mat kernel = (cv::Mat_float(5, 5) 0, 0, 1, 0, 0, 0, 1, 2, 1, 0, 1, 2, -16, 2, 1, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0); // LOG核 cv::filter2D(input, output, -1, kernel);}void LOG2(cv::Mat input, cv::Mat output){ output = input.clone(); cv::GaussianBlur(input, output, cv::Size(5, 5), 1, 1); cv::Laplacian(output, output, input.depth(), 3, 1, 0, cv::BORDER_DEFAULT);}int main(){ cv::Mat src = cv::imread(\"src/lena.jpg\"); cv::Mat dst1, dst2; cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); LOG1(src, dst1); LOG2(src, dst2); cv::namedWindow(\"原图\", cv::WINDOW_NORMAL); cv::namedWindow(\"LOG1\", cv::WINDOW_NORMAL); cv::namedWindow(\"LOG2\", cv::WINDOW_NORMAL); cv::imshow(\"原图\", src); cv::imshow(\"LOG1\", dst1); cv::imshow(\"LOG2\", dst2); cv::waitKey(0); return 0;} 效果截图： 11.1.10 Canny边缘检测 Canny检测是传统边缘检测算子中最优秀的，基于： 低错误率。所有边缘都应该找到，没有虚假边缘。 准确的定位边缘。检测到的边缘是接近真实的边缘。 单个边缘点响应。只返回单点厚度的结果。 Canny边缘检测的步骤 ①使用高斯滤波器平滑图像 void Gaussfilter(cv::Mat input, cv::Mat output, int size, double sigma){ // 处理核大小 if (size 3) size = 3; else size = static_castint((size / 2) * 2 + 1); // 创建高斯核 double **Gausskernel = new double *[size]; for (int i = 0; i size; i ++) Gausskernel[i] = new double[size]; int center = size / 2; double sum = 0; for (int i = 0; i size; i ++) for (int j = 0; j size; j ++) { Gausskernel[i][j] = exp(-((i - center) * (i - center) + (j - center) * (j - center)) / (2 * sigma * sigma)); sum += Gausskernel[i][j]; } sum = 1.0 / sum; for (int i = 0; i size; i ++) for (int j = 0; j size; j ++) Gausskernel[i][j] *= sum; // 高斯滤波 output = input.clone(); for (int i = center; i input.rows - center; i ++) for (int j = center; j input.cols - center; j ++) { double sum = 0; for (int x = -center; x = center; x ++) for (int y = -center; y = center; y ++) sum += Gausskernel[x + center][y + center] * input.atuchar(i + x, j + y); output.atuchar(i, j) = sum; } // 释放空间 for (int i = 0; i size; i ++) delete[] Gausskernel[i]; delete[] Gausskernel;} ②计算梯度幅值和边缘方向 使用Prewitt算子计算梯度。 计算梯度也有两种方式： G=Gx2+Gy2G=\\sqrt{G_x^2+G_y^2} G=Gx2​+Gy2​​ G=Gx+GyG=G_x+G_y G=Gx​+Gy​ 根据边缘方向的法线方向确定边缘方向： α(x,y)=arctan⁡[Gy(x,y)Gx(x,y)]\\alpha(x,y)=\\arctan\\Big[\\frac{G_y(x,y)} {G_x(x,y)}\\Big] α(x,y)=arctan[Gx​(x,y)Gy​(x,y)​] 然后根据法线方向将边缘分为四个方向：水平、垂直、45°、-45°。有： 当法线方向为-22.5°~22.5°，或-157.5°~157.5°，则认为边缘为水平边缘； 当法线方向为22.5°~67.5°，或-112.5°~-157.5°，则认为边缘为-45°边缘； 当法线方向为67.5°~112.5°，或-67.5°~-112.5°，则认为边缘为垂直边缘； 当法线方向为112.5°~157.5°，或-22.5°~-67.5°，则认为边缘为45°边缘； void GradDire(cv::Mat input, cv::Mat Gradimg, cv::Mat Direimg){ Gradimg = cv::Mat(input.size(), CV_16U, cv::Scalar(0)); Direimg = cv::Mat(input.size(), CV_8U, cv::Scalar(0)); for (int i = 1; i input.rows - 1; i++) for (int j = 1; j input.cols - 1; j++) { // 计算梯度及梯度幅值 int gx = input.atuchar(i + 1, j - 1) + input.atuchar(i + 1, j) + input.atuchar(i + 1, j + 1) - input.atuchar(i - 1, j - 1) - input.atuchar(i - 1, j) - input.atuchar(i - 1, j + 1); int gy = input.atuchar(i - 1, j + 1) + input.atuchar(i, j + 1) + input.atuchar(i + 1, j + 1) - input.atuchar(i - 1, j - 1) - input.atuchar(i, j - 1) - input.atuchar(i + 1, j - 1); int sum = gx + gy; Gradimg.atushort(i, j) = std::abs(sum); // 方向图像，图像中的坐标轴，1-水平，2-45°，3-垂直，4--45° double dire = atan2(gy, gx) * 180 / 3.1415926; if (dire = -67.5 or dire 67.5) Direimg.atuchar(i, j) = 1; else if (dire -67.5 and dire -22.5) Direimg.atuchar(i, j) = 2; else if (dire -22.5 and dire 22.5) Direimg.atuchar(i, j) = 3; else Direimg.atuchar(i, j) = 4; }} ③非极大值抑制 非极大值抑制原理为：在一个3*3的邻域内，根据边缘法线方向，与法线方向上其他两个邻点的梯度幅值比较大小，若该点大于另外两个邻点，则认为该点是边缘点，否则抑制。 void NonMaxSuppression(cv::Mat Gradimg, cv::Mat Direimg, cv::Mat Suppimg){ Suppimg = cv::Mat(Gradimg.size(), Gradimg.type(), cv::Scalar(0)); for (int i = 1; i Gradimg.rows - 1; i++) for (int j = 1; j Gradimg.cols - 1; j++) { switch (Direimg.atuchar(i, j)) { case 1: if (Gradimg.atushort(i, j) = Gradimg.atushort(i, j - 1) Gradimg.atushort(i, j) = Gradimg.atushort(i, j + 1)) Suppimg.atushort(i, j) = Gradimg.atushort(i, j); else Suppimg.atushort(i, j) = 0; break; case 2: if (Gradimg.atushort(i, j) = Gradimg.atushort(i + 1, j - 1) Gradimg.atushort(i, j) = Gradimg.atushort(i - 1, j + 1)) Suppimg.atushort(i, j) = Gradimg.atushort(i, j); else Suppimg.atushort(i, j) = 0; break; case 3: if (Gradimg.atushort(i, j) = Gradimg.atushort(i - 1, j) Gradimg.atushort(i, j) = Gradimg.atushort(i + 1, j)) Suppimg.atushort(i, j) = Gradimg.atushort(i, j); else Suppimg.atushort(i, j) = 0; break; case 4: if (Gradimg.atushort(i, j) = Gradimg.atushort(i - 1, j - 1) Gradimg.atushort(i, j) = Gradimg.atushort(i + 1, j + 1)) Suppimg.atushort(i, j) = Gradimg.atushort(i, j); else Suppimg.atushort(i, j) = 0; break; default: break; } }} ④使用双阈值处理和连通性分析检测和链接边缘 只设置一个阈值时，若阈值设置太低，则会出现假边缘；若阈值设置太高，则一些弱边缘会被丢弃。 步骤： 设置两个阈值：高阈值Th和低阈值Tl，一般高比低为2:1到3:1。 分别用这两个阈值对非极大值抑制图像进行阈值处理得到二值图像BWh和BWl，其中BWl的非零像素包含BWh。 分为强边缘图像和弱边缘图像，令BWl = BWh - BWl。此时认为BWh为强边缘图像，BWl为弱边缘图像。 标记弱边缘图像的真实边缘：在BWh中定位下一个没有被访问过的边缘像素P；在BWl中，认为P点坐标的8邻域内的弱边缘像素为真实边缘病标记；若BWh中所有像素均被访问，则结束，否则继续标记。 void doubleThread(cv::Mat Suppimg, cv::Mat Edgeimg, int Tl, int Th){ if (Th Tl) std::swap(Th, Tl); cv::Mat bw_h = cv::Mat(Suppimg.size(), CV_8UC1, cv::Scalar(0)); cv::Mat bw_l = cv::Mat(Suppimg.size(), CV_8UC1, cv::Scalar(0)); for (int i = 0; i Suppimg.rows; i++) for (int j = 0; j Suppimg.cols; j++) { if (Suppimg.atushort(i, j) = Th) bw_h.atuchar(i, j) = 255; else bw_h.atuchar(i, j) = 0; if (Suppimg.atushort(i, j) = Tl and Suppimg.atushort(i, j) Th) bw_l.atuchar(i, j) = 255; else bw_l.atuchar(i, j) = 0; } Edgeimg = bw_h.clone(); for (int i = 1; i Suppimg.rows - 1; i++) for (int j = 1; j Suppimg.cols - 1; j++) if (bw_h.atuchar(i, j) == 255) { if (bw_l.atuchar(i - 1, j - 1) == 255) Edgeimg.atuchar(i - 1, j - 1) = 255; if (bw_l.atuchar(i - 1, j) == 255) Edgeimg.atuchar(i - 1, j) = 255; if (bw_l.atuchar(i - 1, j + 1) == 255) Edgeimg.atuchar(i - 1, j + 1) = 255; if (bw_l.atuchar(i, j - 1) == 255) Edgeimg.atuchar(i, j - 1) = 255; if (bw_l.atuchar(i, j + 1) == 255) Edgeimg.atuchar(i, j + 1) = 255; if (bw_l.atuchar(i + 1, j - 1) == 255) Edgeimg.atuchar(i + 1, j - 1) = 255; if (bw_l.atuchar(i + 1, j) == 255) Edgeimg.atuchar(i + 1, j) = 255; if (bw_l.atuchar(i + 1, j + 1) == 255) Edgeimg.atuchar(i + 1, j + 1) = 255; }} Canny函数 手搓的Canny函数： void Canny_Edge(cv::Mat input, cv::Mat output, int th, int tl, int size, double sigma){ cv::Mat Gaussimg, Gradimg, Direimg, Suppimg, Edgeimg; Gaussfilter(input, Gaussimg, size, sigma); GradDire(Gaussimg, Gradimg, Direimg); NonMaxSuppression(Gradimg, Direimg, Suppimg); doubleThread(Suppimg, Edgeimg, tl, th); output = Edgeimg;} OpenCV自带的Canny函数； void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize = 3, bool L2gradient = false); 参数； image：8比特输入图像。 edges：输出边缘图，单通道8位图像，与图像大小相同。 threshold1：滞后过程的第一个阈值。 threshold2：滞后过程的第二个阈值。 apertureSize：Sobel算子大小。 L2gradient：计算图像梯度复制的标识。 效果截图 int main(){ cv::Mat src = cv::imread(\"src/lena.jpg\"); cv::Mat dst1, dst2; cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); Canny_Edge(src, dst1, 50, 20, 3, 1); cv::Canny(src, dst2, 50, 20, 3, 1); cv::namedWindow(\"手搓Canny\", cv::WINDOW_NORMAL); cv::namedWindow(\"Canny函数\", cv::WINDOW_NORMAL); cv::imshow(\"手搓Canny\", dst1); cv::imshow(\"Canny函数\", dst2); cv::waitKey(0); return 0;} 11.2 图像阈值分割 图像分割都是基于图像像素的灰度值，通过一个阈值T将图像中的像素分为两类或多类。 阈值分割的基本原理： g(x,y)={1,iff(x,y)T0,iff(x,y)≤Tg(x,y)=\\begin{cases} 1,\\quad if\\ f(x,y)T\\\\ 0, \\quad if\\ f(x,y)\\leq T \\end{cases} g(x,y)={1,iff(x,y)T0,iff(x,y)≤T​ 一般的图像阈值分割方法都主要在于去通过图像自身信息去计算寻找合适的阈值。 11.2.1 全局阈值分割 迭代阈值分割 计算步骤： 为全局阈值T选择一个初始的估计值，一般是图像平均灰度值。 使用初始值T进行阈值分割，此时图像分为大于阈值的像素组G1和小于阈值的像素组G2； 分别计算属于G1、G2图像像素的平均灰度值m1和m2； 针对m1和m2计算一个新的阈值 T=m1+m22T=\\frac{m1 + m2} {2}T=2m1+m2​ ； 重复2到4，直到连续迭代中计算的连续两个T的差小于某个预定义的值为止。 代码如下： #include opencv2/opencv.hppvoid imageIterativeThresholdSegmentation(cv::Mat input, cv::Mat output){ cv::Mat src = input.clone(); if (src.channels() == 3) cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); double T = 0, preT = 0; for (int i = 0; i src.rows; i ++) for (int j = 0; j src.cols; j ++) T += src.atuchar(i, j); T = 1.0 * T / (src.rows * src.cols); while (std::abs(preT - T) 0.5) { preT = T; int mean1 = 0, mean2 = 0, cnt1 = 0, cnt2 = 0; for (int i = 0; i src.rows; i ++) for (int j = 0; j src.cols; j ++) { if (src.atuchar(i, j) T) mean1 += src.atuchar(i, j), cnt1 ++; else mean2 += src.atuchar(i, j), cnt2 ++; } mean1 = 1.0 * mean1 / cnt1; mean2 = 1.0 * mean2 / cnt2; T = (mean1 + mean2) / 2; } cv::threshold(src, output, T, 255, cv::THRESH_BINARY);}int main(){ cv::Mat src = cv::imread(\"src/lena.jpg\"); cv::Mat dst1; cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); imageIterativeThresholdSegmentation(src, dst1); cv::namedWindow(\"src\", cv::WINDOW_NORMAL); cv::namedWindow(\"dst1\", cv::WINDOW_NORMAL); cv::imshow(\"src\", src); cv::imshow(\"dst1\", dst1); cv::waitKey(0); return 0;} 效果截图： OTSU大津法阈值分割 计算步骤： 计算图像灰度直方图的零阶累积距（累加直方图）： zeroCumuMoment(k)=∑i=1khistogram(i),k∈[0,255]zeroCumuMoment(k)=\\sum_{i=1}^khistogram(i),k\\in[0,255] zeroCumuMoment(k)=i=1∑k​histogram(i),k∈[0,255] 计算灰度直方图的一阶累积距： oneCumuMoment(k)=∑i=1k(i∗histogram(i)),k∈[0,255]oneCumuMoment(k)=\\sum_{i=1}^k(i*histogram(i)),k\\in[0,255] oneCumuMoment(k)=i=1∑k​(i∗histogram(i)),k∈[0,255] 计算输入图像的总体灰度平均值mean，也就是k=255时的一阶累积距： mean=oneCumuMoment(255)mean=oneCumuMoment(255) mean=oneCumuMoment(255) 计算每一个灰度级作为阈值时，前景区域的平均灰度、背景区域的平均灰度与整体图像平均灰度的方差，方差计算： σ2(k)=(mean∗zeroCumuMoment(k)−oneCumuMoment(k))2zeroCumuMoment(k)∗(1−zeroCumuMoment(k)),k∈[0,255]\\sigma^2(k)=\\frac{(mean*zeroCumuMoment(k)-oneCumuMoment(k))^2} {zeroCumuMoment(k)*(1-zeroCumuMoment(k))},k\\in[0,255] σ2(k)=zeroCumuMoment(k)∗(1−zeroCumuMoment(k))(mean∗zeroCumuMoment(k)−oneCumuMoment(k))2​,k∈[0,255] 找到最大的 σ2(k)\\sigma^2(k)σ2(k) ，即是所求的阈值： thresh=max⁡(σ2(k)),k∈[0,255]thresh=\\max(\\sigma^2(k)),k\\in[0,255] thresh=max(σ2(k)),k∈[0,255] 代码如下： #include opencv2/opencv.hppvoid imageotsuThresholdSegmentation(cv::Mat input, cv::Mat output){ cv::Mat src = input.clone(); if (src.channels() == 3) cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); // 计数灰度直方图各像素值 int hist[256] = { 0 }; for (int i = 0; i src.rows; i ++) for (int j = 0; j src.cols; j ++) hist[src.atuchar(i, j)] ++; // 计算灰度直方图各像素概率 double phist[256] = { 0 }; for (int i = 0; i 256; i ++) phist[i] = 1.0 * hist[i] / (src.rows * src.cols); double zeroCumuMoment[256] = { 0 }, oneCumuMoment[256] = { 0 }; // 计算灰度直方图的零阶累积距和一阶累积距 zeroCumuMoment[0] = phist[0]; oneCumuMoment[0] = 0 * phist[0]; for (int i = 1; i 256; i ++) { zeroCumuMoment[i] = zeroCumuMoment[i - 1] + phist[i]; oneCumuMoment[i] = oneCumuMoment[i - 1] + i * phist[i]; } double mean = oneCumuMoment[255]; double _max = -1; int threshold = 0; for (int i = 0; i 256; i ++) { double tmp = mean * zeroCumuMoment[i] - oneCumuMoment[i]; double tmp1 = zeroCumuMoment[i] * (1 - zeroCumuMoment[i]); double ans = tmp * tmp / tmp1; if (_max ans) { _max = ans; threshold = i; } } cv::threshold(src, output, threshold, 255, cv::THRESH_BINARY);}int main(){ cv::Mat src = cv::imread(\"src/lena.jpg\"); cv::Mat dst1; cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); imageotsuThresholdSegmentation(src, dst1); cv::namedWindow(\"src\", cv::WINDOW_NORMAL); cv::namedWindow(\"dst1\", cv::WINDOW_NORMAL); cv::imshow(\"src\", src); cv::imshow(\"dst1\", dst1); cv::waitKey(0); return 0;} 11.2.2 可变阈值处理 将图像划分为多个局部，对于每个局部都采取阈值分割，使得效果更好。 11.2.3 更多 使用超像素分割图像 使用图割分割区域 使用形态学分水岭分割区域","tags":["CPP","OpenCV","图像处理"],"categories":["笔记"]},{"title":"个人整理的C++学习路线","path":"/2023/cpproad/","content":"个人整理的C++大概学习路线 关键词：C++ by：Fingsinz，Reference：C++ Developer Roadmap C++ 语言介绍 什么是C++ C++作为C编程语言的扩展，提供了类和继承等面向对象的特性。 C++被广泛应用于游戏开发、系统编程、嵌入式系统和高性能计算等各种应用中。 C++是一种静态类型语言，这意味着变量的类型是在编译过程中确定的，并且C++有一个称为C++标准库的扩展库，它为各种任务提供了一组丰富的函数、算法和数据结构。 为什么使用C++ 高性能：C++旨在提供高性能和高效率。它提供了对系统资源的细粒度控制，使优化软件变得更容易。 可移植性：不同的计算机体系结构和操作系统都支持C++，允许您编写在各种平台上运行的可移植代码，而无需进行重大修改。 面向对象编程：C++支持面向对象编程(OOP)——一种允许您使用类和对象设计程序的范例，从而实现更好的代码组织和可重用性。 支持低级和高级编程：C++允许您编写低级代码，如内存操作，以及高级抽象，如创建类和使用标准模板库(STL)。 丰富的库支持：C++提供了大量的库和工具，如标准模板库(STL)、Boost和Qt等，它们可以帮助您开发项目并使其更高效。 兼容C语言：C++可以与C结合使用，提供两种语言的功能，并允许您重用现有的C代码。通过合并C++特性，您可以增强代码并改进其功能。 活跃的社区支持：C++已经存在了很长一段时间，并且拥有一个庞大而活跃的用户社区，他们为语言的发展做出了贡献，表达了新的想法，并参与了有助于语言进一步发展的讨论。这让你更容易找到解决问题的方法。 C和C++的区别 语法语义区别、代码可重用性和模块化、错误处理 C++版本 C++0x：指的是C++ 11的工作名称，在其最终发布之前，它以前被称为C++ 0x。C++ 11是2011年发布的C++语言标准的主要修订版，它为该语言带来了几个新特性和改进。 auto、基于范围的循环：for(int i : array)、匿名Lambda函数、nullptr、右值引用和移动语义、可变模板、静态判断assert、支持线程 C++14：指的是2014年发布的C++版本。 范式Lambda、decltype关键字、可变模板 C++17：也称为C++ 1z，是2017年12月发布的C++编程语言版本。 if中的初始化：if(auto x = map.find(key); x != map.end())、结构化绑定声明、inline变量、折叠表达式、constexpr if 语句、改进Lambda表达式、标准文件系统库、string_view标准库、对标准库算法支持并行运算 C++20：C++ 20是2020年发布的C++版本。 concept关键字；基于范围的处理序列；协同程序；constexpr和consteval关键字：带有constexpr标记的函数可以在编译时或运行时执行，而带有consteval标记的函数只能在编译时执行；最新C++ 配置C++开发环境 安装C++ 在开始用C++编程之前，您需要在系统上安装一个编译器。编译器是一个将你写的C++代码转换成计算机可以运行的可执行文件的程序。 编译器 编译器是一种计算机程序，它将用一种编程语言编写的源代码翻译成另一种语言，通常是机器代码或汇编代码，可以由计算机处理器直接执行。在c++环境中，编译器将您编写的c++源代码转换为可执行程序。 常见编译器 GNU Compiler Collection（GCC）、Clang、Microsoft Visual C++（MSVC）、Intel C++ Compiler（ICC） 编译器状态：C++的编译过程可以分为四个主要阶段：预处理、编译、汇编和链接。每个阶段执行一个特定的任务，最终将源代码转换为可执行程序。 预处理（Preprocessing）：第一个阶段是源代码的预处理。预处理器在实际编译过程之前修改源代码。在这个阶段，将展开包含的头文件，替换宏，并处理条件编译语句。 编译（Compilation）：第二阶段是实际编译经过预处理的源代码。编译器将修改后的源代码转换为中间表示形式，通常特定于目标处理器体系结构。此步骤还包括执行语法检查、语义分析，并为源代码中遇到的任何问题生成错误消息。 汇编（Assembly）：第三阶段是将编译器的中间表示转换成汇编语言。此阶段使用特定于目标处理器体系结构的助记符和语法生成汇编代码。然后，汇编程序将该汇编代码转换为目标代码(机器代码)。 链接（Link）：第四阶段是将目标代码与必要的库和其他目标文件链接起来。在此阶段，链接器合并多个目标文件和库，解析来自其他模块或库的外部引用，为函数和变量分配内存地址，并生成可在目标平台上运行的可执行文件。 编辑器、集成开发环境（IDE） 代码编辑器是专门为编辑、管理和编写源代码而设计的程序。它们提供了广泛的功能，使开发过程更容易和更快。 Visual Studio、Visual Studio Code、CLion、Sublime Text、CodeBlock 运行第一个C++程序 Hello_World.cpp 基础语法 基础操作 算术运算符：+、-、*、/、%、++、-- 逻辑运算符：and（）、or（||）、not（!） 位运算符：、|、^、~、、 条件：if/switch 循环：for/while 函数 函数声明：仅有返回类型、函数名称和参数。 函数定义：具有详细的函数体。 函数原型：函数原型是没有函数体的函数声明，它告诉编译器函数的名称、返回类型和参数。 普通函数：函数是执行特定任务的一组语句，在程序中组织为一个单独的单元。 标准库函数、自定义函数 运算符函数 C++中的运算符是对数据执行各种操作的符号，如算术、比较和逻辑操作。它们用于操作和计算表达式和变量。 赋值运算符；逻辑运算符；关系运算符；算术运算符 Lamda匿名函数 数据类型 静态数据类型 意味着变量的数据类型是在编译时，在程序执行之前确定的。 动态数据类型 意味着在运行时确定变量的数据类型。 void*指针：void*指针是一种泛型指针，可以指向任何数据类型的对象。它们可以用于存储对任何类型对象的引用，而无需知道对象的特定类型。 std::any（C++17）：std::any类，它代表了任何类型的单个值的广义类型安全容器。 void*指针和std::any都有性能影响，因为在运行时进行了额外的类型检查和类型转换。它们应该谨慎使用，只有在绝对必要的时候才使用。 运行时类型标识RTTI 允许在程序执行期间获取对象的类型信息。这在使用动态类型时非常有用，因为对象的类型可以在运行时更改。 typeid操作符、dynamic_cast操作符 使用RTTI可能会有一些性能开销，因为它需要在运行时存储和处理编译器生成的额外信息。 指针和引用 普通指针：字符指针、整型指针、浮点型指针、结构体指针、函数指针…… 原始指针 原始指针是直接保存内存地址的低级结构。它们可以用于手动分配内存、创建动态数组和有效地传递值等。 new/delete操作符 内存泄漏 智能指针 unique_ptr、shared_ptr、weak_ptr 内存模型 栈内存、堆内存、数据段、代码段 对象生存期 静态存储持续期、线程存储持续期、自动存储持续期、动态存储持续期 引用 结构体和类 面向对象编程：类、封装、继承多态 静态多态 静态多态性，也称为编译时多态性，是一种在编译时而不是在运行时解析类型和方法调用的多态性。这通常是通过使用C++中的函数重载和模板来实现的。 函数重载：一种创建具有相同名称但不同参数列表的多个函数的方法。编译器根据调用函数时使用的参数类型和数量确定要调用的正确函数。 模板：允许创建泛型函数或类。特定类型的实际代码是在编译时生成的，这避免了运行时多态的开销。模板的使用是c++中实现静态多态性的主要技术。 动态多态 动态多态性是通过虚函数实现的，虚函数是用virtual关键字标记的基类的成员函数。在基类中指定虚函数时，可以在任何派生类中重写虚函数，以提供不同的实现。 虚函数：在基类的方法声明中使用virtual关键字。这告诉编译器该方法应该被视为虚方法，允许它被派生类覆盖。 虚表：虚表(或Vtable)是C++编译器用来支持动态多态性的一种机制。在动态多态性中，根据实际的对象类型，在运行时调用适当的函数。 多继承：一个类可以从多个父类继承特征（数据成员和成员函数），一个类可以有多个基类。 菱形继承：一个类派生自两个或多个类，而这些类又派生自一个公共基类 构建代码库 代码分割、代码风格、头文件和Cpp文件、头文件警卫、命名空间 作用域 全局作用域、局部作用域、名称空间作用域、类作用域 前向声明：类前向声明、函数前向声明、枚举和typedef前向声明 语言概念 习惯术语 auto关键字：用于自动类型推导。 类型转换：static_cast、const_cast、dynamic_cast、reinterpret_cast 未定义行为：指由于违反语言规则而无法预测程序行为的情况。 参数依赖查找、命名修饰、宏定义、定义并初始化（资源获取即初始化RAII）、指针到实现（Pimpl）、奇异递归模板模式（CRTP）、不可复制/不可移动、擦除、复制和交换、惰性复制 调试器 理解调试信息：错误、警告、通知 调试器符号：内部调试符号、外部调试符号。 WinDbg：一个功能强大的Windows应用程序调试器。 GDB：GNU Project Debugger，一个功能强大的命令行调试器。 构建系统 Cmake、Makefile、Ninja 异常处理 异常 try关键字：定义应该监视异常的代码块 catch关键字：指定要捕获的异常类型以及异常发生时应执行的代码块。 throw关键字：抛出一个异常，该异常将被捕获并由适当的捕获块处理 noexcept关键字：指定一个函数，该函数不会抛出异常，也不会在其作用域中抛出异常时终止程序。 标准异常 std::exception：所有标准异常的基类。 std::logic_error：表示程序可以静态检测到的错误。 std::runtime_error：表示程序执行期间发生的错误。 退出代码 退出码，也称为“返回码”或“状态码”，是程序完成执行后返回给调用环境(通常是操作系统)的数值。这些代码用于指示程序执行的成功或失败。 0是成功执行的标准退出代码，而非零退出代码通常表示错误或其他异常情况。非零退出码的实际含义在不同的应用程序或系统之间可能有所不同。 在C++中，您可以使用return语句从main函数返回退出代码，也可以使用exit()函数，它是C++标准库的一部分。 访问冲突 访问冲突是程序试图访问非法内存位置时发生的一种特定类型的错误。 可能引起原因：取消引用空指针或无效指针；访问数组越界；对由用户或操作系统释放的内存进行阅读或写。 标准模板库STL 标准输入输出流 iostream是C++标准库中的一个头文件，它提供了基本输入和输出(I/O)操作的功能。I/O流促进了程序与各种源(如控制台、文件或其他程序)之间的通信。 处理日期和时间 使用chrono库来处理日期和时间，它是标准库(Standard library, STL)的一部分。chrono库提供了各种数据类型和函数来表示和操作时间持续时间、时间点和时钟。 算法 C++中的标准模板库(Standard Template Library, STL)提供了一组泛型算法，用于处理各种容器类。这些算法是作为函数实现的，可以应用于不同的数据结构，如数组、向量、列表等。算法的主要头文件是algorithm 迭代器 迭代器是C++标准库(STL)中的对象，帮助我们遍历数组、列表和向量等容器。本质上，它们充当容器类和算法之间的桥梁。迭代器的行为类似于指针，但提供了一种更通用和抽象的方式来访问容器中的元素。 输入迭代器、输出迭代器、前向迭代器、反向迭代器、双向迭代器、随机访问迭代器 容器 Pair对、Vector向量、List列表、String字符串、Stack栈、Queue队列、Deque双向队列、Priority_queue优先队列、Set集合（unordered_set、multiset、unordered_multiset）、Map映射（unordered_map、multimap、unordered_multimap）、Bitset压位 多线程 多线程是指在单个进程或程序中并发执行多个线程。它允许并行执行多个任务，从而提高了应用程序的性能和效率。 线程创建、带参数线程、互斥锁和锁 模板编程 可变模板 可变模板是C++ 11中的一个特性，它允许定义具有可变数量参数的模板。当您需要编写一个可以接受不同数量和类型参数的函数或类时，这尤其有用。 模板专门化 全模板专门化：完全模板专门化允许在与特定类型参数集一起使用时为模板提供特定的实现或行为。 部分模板专门化：允许为可能的类型参数的子集专门化模板。当希望为特定类型组提供自定义实现，而不必为该组中的所有类型定义单独的专门化时，它特别有用。 类型特征 类型特征是C++中的一组模板类，可以帮助获取有关类型属性、行为或特征的信息。它们可以在type_traits头文件中找到。通过使用Type Traits，可以根据给定类型的属性来调整代码，甚至可以在模板代码中为类型参数强制执行特定的属性。 替换失败不是错误（SFINAE） SFINAE是C++模板元编程中的一个原则，它允许编译器在替换过程中特定模板特化失败时选择适当的函数或类。术语“替换失败”是指编译器试图将模板参数替换为函数模板或类模板的过程。如果替换导致错误，编译器不会将特定的专门化视为候选专门化，而是继续搜索有效的专门化。 SFINAE背后的关键思想是，如果发生替换错误，它将被静默地忽略，编译器将继续探索其他模板专门化或重载。这允许编写更灵活和通用的代码，因为它使能够针对不同的场景拥有多个专门化。 包管理 包管理器是自动化安装、升级和管理编程语言(如C++)软件(库、框架和其他依赖项)过程的工具 vcpkg、Spack、Conan、NuGet 库和框架编程 在使用C++时，可能需要使用外部库来协助完成各种任务。库是预编译的代码片段，可以在程序中重用，以执行特定任务或提供特定功能。在C++中，库可以是静态库(.lib)或动态库(Windows中的.dll, Unix/Linux中的.so)。 静态库：在编译时被合并到程序中。它们与代码链接，创建更大的可执行文件，但在运行时不需要任何外部文件。 动态库：动态库是在运行时加载的，这意味着可执行文件只包含对这些库的引用。这些库需要在运行程序的系统上可用。 C++库 OpenCV、POCO、protobuf、gRPC、Tensorflow、pybind11、spdlog、OpenCL、ranges_v3、fmt、Boost 框架 gtest/gmock、Qt、Catch2、Orbit Profiler、PyTorch C++","tags":["CPP"],"categories":["经验之谈"]},{"title":"利用Ping指令进行基本网络检测","path":"/2023/15/","content":"利用Ping指令对本地IP、网关和远程网站等进行基本网络检测 关键词：网络 测试TCP/IP协议栈 ping 127.0.0.1 127.0.0.1 是你本地主机的环回地址，实际上只要是 127.0.0.1 到 127.255.255.254 都是本地主机环回地址。 作用：用于检查本地主机TCP/IP协议栈是否正常。 测试本地网卡 打开cmd（命令提示符），输入： ipconfig 记住自己的本地ip，接着输入： ping [本地ip] 作用：用于检查本地网卡工作是否正常。 测试与网关的链路 打开cmd（命令提示符），输入： ipconfig 记住自己的默认网关，接着输入： ping [默认网关] 用于检查本地主机与网关的链路是否正常。 测试与外网远程网站的链路 以连通百度网站为测试： 打开cmd（命令提示符），输入： ping www.baidu.com 用于检查本地主机与外网远程网站的链路是否正常。","tags":["网络"],"categories":["日常"]},{"title":"Python语言入门学习教程","path":"/2023/python-language-learning/","content":"个人整理面向入门基础级别的Python语言学习教程。 关键词：Python 一. Python的基本观念 1.1 什么是Python语言 Python是一种 直译的 、 面向对象的 、 拥有许多函数库 的语言。 直译表明它不需要经过像C语言一样的编译过程，直接由直译器运行。这有好处也有坏处，好处是方便简洁直接运行；坏处是没有编译器的错误检查，即运行到某行才知道错误。 面向对象表明它是一门高级语言，具有抽象化的概念（也就是对象），能完成众多工作。Python中一切都是对象，而对象的函数称作方法。 拥有许多函数库表明它有很多内置的套件或者是模块，开源且每个人可贡献，我们直接import调用这些模块即可完成一些复杂的任务。 由于Python的模块众多，此教程只介绍最基本的语法，模块的使用建议查看模块的帮助文档，建议善于查阅资料 当然Python也具有垃圾回收的功能，即程序执行时直译器会主动回收不再需要的动态内存空间，减少程序员犯错的机会。 Python也经历了很多版本的迭代，从最初的Python 2.0到Python 3.0、Python 3.x。Python 3在开发时与Python 2不兼容，所以可以认为是两个独立的版本，但后面官方把Python 3.x版本的特性移植到Python 2.6/2.7x中。本教程的演示代码经过Python 3.11.4测试。 1.2 怎么写Python程序 首先具备Python的直译器，即下载安装Python。官网选择尽量较新的Python版本下载。打开下载的Python安装包，选择Customize installation客制化安装，记得勾选下面的“Add python.exe to PATH”。接着默认勾选pip：包管理器，下载包时使用。建议勾选上，再接着更改安装路径，建议安装在非系统盘。最后等待安装完成即可。具体可参考这篇博客 接着编写Python并执行，Python的后缀名为 .py 。在此介绍两种方式编写Python：记事本和Visual Studio Code。 记事本方式：新建记事本，命名为 xxx.py ，在里面编写Python代码，之后启用命令提示符cmd使用python命令直译运行。 Visual Studio Code方式：直接编写代码运行。 在Python中，使用 # 作为整行注释符号，三个单引号或双引号作为整段注释符号。 同时，Python不像C语言，Python的每句最后不需要添加分号 ; ，还把相同的缩进作为一整个语句块，这些特性会在后面的代码慢慢体现。 1.3 import模块 想使用 Python 源文件或者特殊模块，只需在另一个源文件里执行 import 语句，语法如下： import module1[, module2[,... moduleN] 比如引入系统模块： impory sys 在此基础教程上，一般不需要使用import便可满足使用。但是在开发程序时，需要其他模块的支持，便需要 import 。 from … import ：语句从模块中导入一个指定的部分到当前命名空间中，语法如下： from modname import name1[, name2[, ... nameN]] from … import * ：把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 在模块间，需要清楚本模块和引入模块的运行。如果想在模块被引入时，模块中的某一程序块不执行，可以用 __name__ 属性来使该程序块仅在该模块自身运行时执行。 举个例子，有两个Python文件： # a.pyif __name__ == '__main__': print('a.py的main中运行')else: print('a.py的非main中运行') # b.pyimport aprint('b.py运行') 运行a.py输出： a.py的main中运行 运行b.py输出： a.py的非main中运行b.py运行 二. 函数 2.1 函数的基本结构 函数的结构应当如下，包括 函数名字function_name 、 参数arguments 和 函数主体Body 。 def function_name(arguments):\t# body1\t# body2 def ：函数代码块的开头，后接函数名字、参数列表和函数主体。 函数名字：标记一个函数的名字。 参数列表：当函数被调用时，可以向参数传递值。参数列表包括函数参数的顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数内容以冒号 : 开始，并且具有相同的缩进。函数主体包含一组定义函数执行任务的语句。若有返回值的函数使用 return 返回，没有 return 相当于返回 None 。函数主体中遇到返回表示结束函数。 2.2 函数的定义 Python与C语言不一样，不存在函数提前声明一说。即想要调用某函数，必先在前面定义该函数，并不存在调用前先使用函数声明而调用后再函数定义。 定义一个函数十分简单，就如： def add(a, b):\treturn a + b 2.3 传递参数和调用函数 直接使用函数名加上传递参数即可调用函数。当函数不需要传递参数时： def doNothing():\t# do NothingdoNothing()\t# 函数调用 在Python中，变量是没有类型的，而对象有不同类型的区分。当函数需要传递参数时，参数列表就简单写个变量名： def add(a, b):\treturn a + bc = add(1, 2)\t# c = 3 Python中一切都是对象。 参数传递时，是按 对象 讨论的，分为可变对象传递和不可变对象传递。 不可变对象传递（如整数、字符串、元组传递）时，类似于C语言的值传递，传递的只是一个值，并没有影响对象本身。如果在函数中修改对象的值，则是新生成一个对象。 可变对象传递（如列表、字典传递）时，类似于C语言的地址传递，或者说引用传递，修改对象的值，外部的对象也受影响。 调用函数时可使用的正式参数类型有：必需参数、关键字参数、默认参数和不定长参数。 必需参数须以正确的顺序传入函数。调用时的数量必须和定义时的一样。 def add(a, b):\treturn a + bc = add(1)\t# 错误，必需参数不一致。 关键字参数允许函数调用时参数的顺序与声明时不一致。 def sub(a, b):\treturn a - bc = sub(b = 2, a = 1)\t# c = -1 默认参数会在没有传递参数时使用。 def sub1(a, b = 1):\treturn a - bc = sub1(1)\t# 第二参数没有传递，默认b = 1，c = 0 不定长参数使得一个函数能处理比当初声明时更多的参数。格式如下，加了 * 的参数会以元组的形式导入，加了 ** 的参数会以字典的形式导入；如果单独出现星号 * ，则星号 后的参数必须用关键字传入。不定长参数不过多介绍。 def functionname1(formal_args, *var ):\t# 元组形式 # bodydef functionname2(formal_args, **var ):\t# 字典形式 # bodydef f(a,b,*,c):\t# *后参数必须以关键字传入。 return a+b+cf(1, 2, c = 3) Python 3.8新增了强制位置参数，举例但不过多介绍。 def f(a, b, /, c, d, *, e, f):\treturn a + b + c + d + e + ff(10, 20, 30, d = 40, e = 50, f = 60)# 形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参 2.4 内置函数 内置函数有： abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() reload() delattr() hash() memoryview() set() 2.5 匿名函数 Python 使用 lambda 来创建匿名函数。匿名函数即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 其语法如下： lambda [arg1 …] : expression 举个例子： add = lambda a, b : a + bc = add(1, 2)\t# c = 3 三. Python的变量与基本运算 3.1 什么是变量 变量是没有类型的，它仅仅是一个对象的引用。而对象具有数据类型。 变量命名应当合法且易懂 必须由英文字母、_（下画线）或中文字开头，建议使用英文字母； 变量名称只能由英文字母、数字、_（下画线）或中文字所组成； 英文字母大小写是敏感的，例如，Name与name被视为不同变量名称； Python的系统或函数保留字不能用作变量名称。 系统保留字有：and、as、assert、break、class、continue、def、del、elif、else、except、False、finally、for、from、global、if、import、in、is、lambda、none、nonlocal、not、or、pass、raise、return、True、try、while、with、yield。 如果变量尚未进行设定值或暂时不想存储任何数据，可将值设为 None ，其类型为 NoneType 。 Python的变量同样具有作用域，即变量的使用范围。作用域一共有四种： Local：局部作用域 Enclosing：闭包函数外的函数中 如果在一个函数的内部定义了另一个函数，外部的叫他外函数，内部的叫他内函数。闭包就是在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。 Global：全局作用域 Built-in：内建作用域 使用变量时，以 L – E – G –B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。看一个例子： x = 5\t# x 是全局变量def fun1():\tx = 4\t# x 是局部变量\tdef fun2():\t# 构成闭包 x = 3\t# x 是闭包环境变量\treturn fun2\tdef fun3():\tglobal x\t# 告诉直译器变量x应该从全局中寻找，x 是全局变量\treturn x 由此，使用 global 关键字可以在局部内声明并使用一个全局变量 3.2 运算符 3.2.1 算术运算符 四则运算： + 、 - 、 * 、 / 。 取余运算： % ，计算除法运算中的余数。 整除运算： // ，计算除法运算中的整数部分。 次幂运算： ** ，计算次幂。 3.2.2 赋值运算符 赋值运算： = ，为变量设定值，并由其引申得下表。 运算符 实例 说明 += a += b a = a + b -= a -= b a = a - b *= a *= b a = a * b /= a /= b a = a / b %= a %= b a = a % b //= a //= b a = a // b **= a **= b a = a ** b 等号具有多重使用方式 x = y = z = 10 # 连等，合法x, y, z = 10, 20, 30 # 多重指定赋值，合法x, y = y, x # 交换，合法 3.2.3 比较运算符 关系运算符 说明 实例 说明 大于 a b 检查a是否大于b 小于 a b 检查a是否小于b = 大于等于 a = b 检查a是否大于或等于b = 小于等于 a = b 检查a是否小于或等于b == 等于 a == b 检查a是否等于b != 不等于 a != b 检查a是否不等于b 3.2.4 位运算符 位运算符是对数据转化为二进制，再逐位进行运算。如6010=00111100260_{10} = 00111100_{2}6010​=001111002​，再对每一位进行逻辑运算。 运算符 描述 实例 按位与运算符，对两个操作数的每一位执行逻辑与操作 A B \\| 按位或运算符，对两个操作数的每一位执行逻辑或操作 A \\| B ^ 按位异或运算符，对两个操作数的每一位执行逻辑异或操作 A ^ B ~ 按位取反运算符，对两个操作数的每一位执行逻辑取反操作 ~A 将操作数的所有位向左移动指定的位数。左移n位相当于乘以2的n次方 A n 将操作数的所有位向右移动指定的位数。右移n位相当于除以2的n次方 A n 3.2.5 逻辑运算符 运算符 描述 实例 and 逻辑与运算符，如果两个操作数都非零，则条件为真。 A and B or 逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真 A or B not 逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 not A 3.2.6 成员运算符 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 3.2.7 身份运算符 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 3.2.8 删除变量 使用 del 删除变量，回收所占的内存空间。 x = 10del x# 后面不能再使用x 3.3 Python的断行 Python的语句可以不使用 ; ，但也可以 ; 进行语句分割。总体上不推荐使用。 Python中若语句过长，可以使用 \\ 或 # 进行分行。 z = (a +\\ b +\\ c)y = (d + # 可做注释 e + # 可做注释 f ) 四. Python的基本数据类型 4.1 type()函数 type() 可以返回变量的数据类型。如 x = 10type(x) # class 'int' 4.2 数值数据类型 4.2.1 什么是数值数据类型 数值数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。 Python 支持三种不同的数值类型： 整型(int)：通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。 浮点型(float)：浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数(comple)：复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 4.2.2 数值类型的运算 普通的算术运算可以运行在数值数据类型中： a = 1b = 2a + ba - ba * ba / ba // ba ** ba % b 当浮点数与整数运算时，同样会进行隐式类型转换为更高级的浮点数。 同样也可以使用强制类型转换： int() 、 float() 。 a = 10float(a)b = 5.5int(b) 4.2.3 数值类型的方法 进制转换类型方法： 转二进制： bin() 转八进制： oct() 转十六进制： hex() 数学方法： abs(x)\t：返回数字的绝对值，如 abs(-10) 返回 10 ceil(x) ：返回数字的上入整数，如 math.ceil(4.1) 返回 5 exp(x)\t：返回e的x次幂(ex),如 math.exp(1) 返回2.718281828459045 fabs(x) ：以浮点数形式返回数字的绝对值，如 math.fabs(-10) 返回10.0 floor(x) ：返回数字的下舍整数，如 math.floor(4.9) 返回 4 log(x)\t：如 math.log(math.e) 返回1.0， math.log(100,10) 返回2.0 log10(x) ：返回以10为基数的x的对数，如 math.log10(100) 返回 2.0 max(x1, x2,...) ：返回给定参数的最大值，参数可以为序列。 min(x1, x2,...) ：返回给定参数的最小值，参数可以为序列。 modf(x) ：返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) ：相当于 x**y 运算后的值。 round(x [,n])\t：返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) ：返回数字x的平方根。 除此之外还有三角函数、随机数函数等…… 4.3 布尔值数据类型 Python的布尔值（Boolean）数据类型具有两种值：True（真）或False（假）。数据类型代号是bool。 x = Truetype(x) # class 'bool' 如果使用类型转换，True对应1，False对应0。 4.4 字符串数据类型 4.4.1 什么是字符串数据类型 Python的字符串没有严格规定是单引号还是双引号，只要匹配即可。其数据类型代号是str。如果字符串中有单引号，为了避免出错，使用双引号。 x = 'python'y = \"Tom's house\"type(x) # class 'str' 如果字符串长度大于一行，可以使用三个单引号或三个双引号包夹。 x = '''xxxxxxxxxxxxxxxxx\txxxxxxxxxxxxxxxx''' Python 不支持单字符类型，单字符在Python中也是作为一个字符串使用。 4.4.1 字符串的运算 字符串的连接可以直接使用 + 运算。 x = '1'y = '2'z = x + y # z为12 字符串可以直接使用 * 运算，表示复制该字符串多少次 x = '1'z = x * 5 # z为11111，是字符串 字符串可以使用 [] 索引获取字符串中的字符，从0数起，-1 为从末尾的开始位置。 0 1 2 3 4 h e l l o -5 -4 -3 -2 -1 str = \"hello\"str[2] # l 字符串可以使用 [:] 截取字符串的一部分，遵循左闭右开，-1 为从末尾的开始位置。。 str = \"hello\"str[2:4] # ll 可以使用 in 或 not in 判断某字符是否在字符串中。 str = \"hello\"'h' in str # 为真'h' not in str\t# 为假 4.4.2 字符串的类型转换 强制转换为字符串： str() 函数。 x = 111\t# x为111，是整型y = 222\t# y为222，是整型z = str(111) + str(222) # z为111222，是字符串 字符串强制转换为整数： int() 函数。 x = '111'\t# x为111，是字符串y = '222'\t# y为222，是字符串z = int(111) + int(222) # z为333，是整型 字符串转换为码值： chr(x) 函数返回x的ASCII码值， ord(x) 函数返回x的Unicode码值。 4.4.3 转义字符 转义字符 转义字符 十六进制值 意义 \\' 27 单引号 \\\" 22 双引号 \\\\ 5C 反斜杠 \\a 07 响铃 \\b 08 BackSpace键 \\f 0C 换页 0A 换行 \\o 八进制表示 \\x 十六进制表示 \\r 0D 光标移到最左 \\t 09 Tab键 \\v 0B 垂直定位 在字符串前加 r ，可以让转义字符不被转义。 str1 = \"Hello World\"\t# 换行符生效str2 = r\"Hello World\"\t# 换行符不生效，原样输出 4.4.4 字符串的函数方法 字符串的函数方法有许多，此处列出常用的几个。 count(str, beg=0,end=len(string))，返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数。 endswith(suffix, beg=0, end=len(string))，检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False。 expandtabs(tabsize=8)，把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 find(str, beg=0, end=len(string))，检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1。 index(str, beg=0, end=len(string))，跟find()方法一样，只不过如果str不在字符串中会报一个异常。 isalnum()，如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。 isalpha()，如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。 isdigit()，如果字符串只包含数字则返回 True 否则返回 False。 isnumeric()，如果字符串中只包含数字字符，则返回 True，否则返回 False。 isspace()，如果字符串中只包含空白，则返回 True，否则返回 False。 join(seq)，以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串。 len(string)，返回字符串长度。 ljust(width[, fillchar])，返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower()，转换字符串中所有大写字符为小写。 max(str)，返回字符串 str 中最大的字母。 min(str)，返回字符串 str 中最小的字母。 replace(old, new [, max])，把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string))，类似于 find()函数，不过是从右边开始查找。 rindex( str, beg=0, end=len(string))，类似于 index()，不过是从右边开始。 rjust(width,[, fillchar])，返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串。 rstrip()，删除字符串末尾的空格或指定字符。 split(str=\"\", num=string.count(str))，以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串。 startswith(substr, beg=0,end=len(string))，检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 upper()，转换字符串中的小写字母为大写 具体的函数解释用法可以边用边搜索。 五. Python的输入和输出 5.1 辅助帮助说明输出 使用 help() 函数可以列出Python指令或函数的使用说明。 5.2 输出 5.2.1 通过print()函数输出 该函数的语法格式为： print(*args, sep=' ', end=' ', file=None, flush=False) *args ：输出的数据，可以输出多个，使用逗号隔开。 sep ：表示输出多个数据时的分隔字符，默认是空格。 end ：当数据输出结束时插入的字符，默认是插入换行。 file ：数据输出位置，默认是sys.stdout，也就是屏幕。 flush ：是否清除数据流的缓冲区，默认是不清除。 x = 10y = 1.5print(x * y, end='\\t')\t# 输出x乘y，以Tab作为结束print(x, y, sep=',')\t# 输出x和y，以“,”为分隔符 输出结果：15.0 10,1.5 5.2.2 格式化print()的输出 可以使用这样的格式输出： print(\"输出格式字符串\" % (变量)) ，输出格式字符串中，与C语言类似。 %d 表示格式化整数输出。 %f 表示格式化浮点数输出。 %x 表示格式化16进制数输出。 %o 表示格式化8进制数输出。 %s 表示格式化字符串输出。 x = 10y = 9.9print(\"%d\\t%f\\t%s\" % (x, x, x))print(\"%d\\t%f\\t%s\" % (y, y, y)) 输出结果：10 10.000000 109 9.900000 9.9 与C语言类似，在控制浮点数的输出时，有如下语法： %nd ：格式化整数输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带正号表明输出在左边加上符号，若n带负号表示数据靠左输出。 x = 11111print(\"|%2d| |%+2d| |%-2d| |%6d| |%+6d| |%-6d| \" % (x, x, x, x, x, x))# 输出结果：|11111| |+11111| |11111| | 11111| |+11111| |11111 | %no ：格式化八进制输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带正号表明输出在左边加上符号，若n带负号表示数据靠左输出。 %nx ：格式化十六进制输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带正号表明输出在左边加上符号，若n带负号表示数据靠左输出。 %ns ：格式化八进制输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带负号表示数据靠左输出。 x = \"Hello\"print(\"|%2s| |%-2s| |%6s| |%-6s|\" % (x, x, x, x))# 输出结果：|Hello| |Hello| | Hello| |Hello | %m.nf ：格式化浮点数输出。m表示保留多少格数输出（包括小数点），n表示小数部分保留位数。若带上正号表明输出在左边加上符号，若带上符号表明数据靠左输出。 x = 3.14159x = 3.14159print(\"|%5f| |%10f| |%5.2f| |%+5.2f| |%-5.2f|\" % (x, x, x, x, x))# 输出结果：|3.141590| | 3.141590| | 3.14| |+3.14| |3.14 | 5.2.3 format()函数 使用 format() 函数的输出格式为： print(\"输出格式字符串\" .format(变量, ...)) 输出格式字符串中输出变量的位置使用 {} 表示。 {} 中填入 !a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化。 格式内容如下 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:02d} 05 数字补零（填充左边，宽度为2） 5 {:x4d} 5xxx 数字补x（填充右边，宽度为4） 10 {:x4d} 10xx 数字补x（填充右边，宽度为4） 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:10d} 13 右对齐，宽度为10 13 {:10d} 13 左对齐，宽度为10 13 {:^10d} 13 中间对齐，宽度为10 11 {:b} 1011 二进制表示 11 {:d} 11 十进制表示 11 {:o} 13 八进制表示 11 {:x} b 十六进制表示 11 {:#x} 0xb 十六进制表示 11 {:#X} 0xB 十六进制表示 5.2.4 dir()函数 通过 dir() 函数可以列出Python的函数。 其格式为： dir(__builtins__) 。 a = 10print(dit(a)) # 列出int的所有函数 再结合 help() 函数即可了解每个函数的意义。 5.3 输入 通过 input() 函数输入一行文本。 该函数的格式为： value = input(\"promt:\") value：输入数据存入到该变量中，不论输入什么，value都是字符串数据类型，需要进行处理。 promt：输入提示词。 a = input(\"请输入一个数字：\")print(\"输入的数字是{}，其类型是{}\".format(a, type(a)))b = int(input(\"请输入一个数字：\"))print(\"输入的数字是{}，其类型是{}\".format(b, type(b)))# 运行窗口：# 请输入一个数字：6# 输入的数字是6，其类型是class 'str'# 请输入一个数字：6# 输入的数字是6，其类型是class 'int' 六. Python的条件结构 6.1 if语句 if语句的基本语法如下： if (条件判断):\t程序代码块 如果条件判断是True，则执行程序代码区块，如果条件判断是False,则不执行程序代码区块。如果程序代码区块只有一道指令，可将上述语法写成： if(条件判断): 程序代码 实际上，Python的条件结构可以不带 () ，但此教程带上了 () ，为了看起来更清晰。 在Python内是使用缩进方式区隔if语句的程序代码区块，编辑程序时可以用Tab键内缩或是直接内缩4个字符空间，表示这是if语句的程序代码区块。 age = 18if (age = 18):\tprint(\"你成年了\")\tprint(\"你的年龄是{}\".format(age)) 实际上不一定非得缩进4格字符空间，任意相同缩进的连续语句都可看作是同一代码块。 6.2 if-else语句 程序设计时更常用的功能是条件判断为True时执行某一个程序代码区块，当条件判断为False时执行另一段程序代码区块，此时可以使用if…else语句，它的语法格式如下： if (条件判断):\t程序代码块一else:\t程序代码块二 如果条件判断是True,则执行程序代码区块一，如果条件判断是False,则执行程序代码区块二。 6.3 if-elif-else语句 当程序进行多重判断时，可以使用if-elif-else语句，它的语法格式如下： if (条件判断一):\t程序代码块一elif (条件判断二):\t程序代码块二……else:\t程序代码块n 如果条件判断一是True则执行程序代码区块一，然后离开条件判断。否则检查条件判断二，如果是True则执行程序代码区块二，然后离开条件判断。如果条件判断是False则持续进行检查，上述elif的条件判断可以不断扩充，如果所有条件判断是False则执行程序代码区块。 举个例子，分数采取A、B、C、D、F，通常90-100分是A，80-89分是B，70-79分是C，60-69分是D，低于60分是F。 score = int(input(\"请输入你的分数：\"))if (score = 90 and score = 100):\tprint(\"你的成绩是A\")elif (score = 80 and score = 89):\tprint(\"你的成绩是B\")elif (score = 70 and score = 79):\tprint(\"你的成绩是C\")elif (score = 60 and score = 69):\tprint(\"你的成绩是D\")else:\tprint(\"你的成绩是F\") 6.4 嵌套的if语句 if语句中有其他的if语句，称作if的嵌套。 if (条件判断一):\tif (条件判断A): 程序代码块A\telse: 程序代码块Belse:\t程序代码块二 七. Python的循环结构 7.1 for循环 for循环的一般格式如下： for variable in sequence: # statementselse: # statements for循环可以遍历任何可迭代对象，如一个列表、元组或者一个字符串。 这个“sequence”可以配合 range() 函数使用，完成一个计数作用： for number in range(1, 6):\tprint(number)# 输出：# 1# 2# 3# 4# 5 注意， range() 函数区间左闭右开，其作用是生成一个数列，它有以下形式： range(6)\t# 生成0到5，步长为1的数列range(1, 5)\t# 生成1到4，步长为1的数列range(0, 10, 3)\t# 生成0到9，步长为3的数列 同时，for循环可以使用else语句： for item in iterable: # 循环主体else: # 循环结束后执行的代码 当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。可以查看下面这两个例子： for x in range(6): # do Nothingelse: print(\"Finally finished!\")for x in range(6): if x == 6: breakelse: print(\"Finally finished!\") 输出结果：Finally finished! 7.2 while循环 while 语句的一般形式如下： while( condition is true ):\tsentences; 此处 condition 为表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。循环体可以是一条语句，也可以是一个语句块（用花括号包起来）。 while 循环的特点是先判断条件表达式，后执行循环体语句。 while 语句的运行顺序是：从上至下，先判断条件表达式是否为真，为真则执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。 while 括号里的 condition 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。 同时，while循环也可以使用else语句： while condition: # statementselse: # statements 举个栗子： count = 0while count 5: print (count, \" 小于 5\") count = count + 1else: print (count, \" 大于或等于 5\") 输出结果：0 小于 51 小于 52 小于 53 小于 54 小于 55 大于或等于 5 7.3 break、continue和pass break 语句可以跳出 for 和 while 的循环体。如果从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 continue 语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 pass 语句不做任何事情，一般用做占位语句。 for i in range(100):\tpassprint(\"finish\")# 输出：finish 八. Python面向对象 8.1 面向对象的相关概念 这里有一些关于面向对象的概念： 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 8.2 类的定义 语法格式如下： class ClassName: statement-1 . . . statement-N 比如，我有一个类，它是描述狗的： class Dog:\tweight = None\t# 类的公有属性，此处是狗的体重\tcolor = None\t# 类的公有属性，此处是狗的颜色\t__name = None\t# 类的私有属性，此处是狗的名字\tdef sound(self):\t# 类的方法，此处是发出声音方法 print(\"汪\")dog = Dog()\t# 类的实例化dog.sound()\t# 类的实例调用类的方法 对于属性而言，公有属性一般是基本属性，在类外部可以直接访问（比如 dog.weight ）；私有属性不可以在类外部访问（比如 dog.__name 是不允许的），在类内部的属性中使用时 self.__name 。同理方法也有公有和私有之分，私有方法以两个下划线开头。 对于类的方法而言，与普通的函数只有一个特别的区别，就是类的方法必须有一个额外的第一个参数名称, 按照惯例它的名称是 self 。 self 代表了类的实例，代表当前对象的地址。 实际上也不非得是 self ，全部换成别的也行。 8.3 类的方法 8.3.1 构造方法 构造方法的函数名为 __init__ ，语法像这样： def __init__(self):\tself.data = None 类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如上面的狗类，给他完善一下： class Dog:\tweight = None\t# 类的属性，此处是狗的体重\tcolor = None\t# 类的属性，此处是狗的颜色\tdef __init__(self, w, c): self.weight = w self.color = c\tdef sound(self):\t# 类的方法，此处是发出声音方法 print(\"汪\")\tdef about(self): print(\"这是一只{}色的狗，重量是{}kg\".format(self.color, self.weight))dog = Dog(10, '黑')\t# 类的实例化，并且实例化时设定属性值dog.about()\t# 输出关于狗狗的信息dog.sound()\t# 类的实例调用类的方法 8.3.2 其他方法 有构造方法，自然也有析构方法，他们是对立的。析构方法是释放对象时使用。一般隐式自动调用，函数名为 __del__ 。 类还有一些方法： __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__ : 按照索引获取值 __len__ : 获得长度 __cmp__ : 比较运算 __call__ : 函数调用 __add__ : 加运算 __sub__ : 减运算 __mul__: 乘运算 __truediv__: 除运算 __mod__: 求余运算 __pow__: 乘方 8.4 类的继承 类的继承允许一个子类继承另一个类（称作父类），继承父类的属性和方法。集成的语法如下： class DerivedClassName(BaseClassName): statement-1 . . . statement-N 拿回上面的例子，狗类应该是继承自动物类的，因为狗包含在动物里。而动物都有重量这个属性；在狗类里，除了继承重量这一属性，还可以添加新的属性，比如颜色： class Animal:\tweight = None\t# 类的属性，此处是动物的体重，未知设为None\tdef __init__(self, w): self.weight = wclass Dog(Animal):\t# 狗类继承动物类\tcolor = None\t# 类的属性，此处添加狗的颜色，未知设为None\tdef __init__(self, w, c): self.weight = w self.color = c\tdef sound(self):\t# 类的方法，此处是发出声音方法 print(\"汪\")\tdef about(self): print(\"这是一只{}色的狗，重量是{}kg\".format(self.color, self.weight))dog = Dog(10, '黑')\t# 类的实例化，并且实例化时设定属性值dog.about()\t# 输出关于狗狗的信息dog.sound()\t# 类的实例调用类的方法 实际上，还可以继承多个父类，语法如下： class DerivedClassName(Base1, Base2, Base3): statement-1 . . . statement-N 如狗类从动物类里继承得到重量这一属性，同时也可以从花类里继承得到颜色这一属性，虽然会有点怪，但这确实可以。 class Animal:\tweight = None\t# 类的属性，此处是动物的体重，未知设为None\tdef __init__(self, w): self.weight = wclass Flower:\tcolor = None\t# 类的属性，此处是花的颜色，未知设为None\tdef __init__(self, c): self.color = cclass Dog(Animal, Flower):\tdef __init__(self, w, c): self.weight = w self.color = c\tdef sound(self):\t# 类的方法，此处是发出声音方法 print(\"汪\")\tdef about(self): print(\"这是一只{}色的狗，重量是{}kg\".format(self.color, self.weight))dog = Dog(10, '黑')\t# 类的实例化，并且实例化时设定属性值dog.about()\t# 输出关于狗狗的信息dog.sound()\t# 类的实例调用类的方法 即使狗类里面没有属性，但是通过继承可以得到想要的属性。 但是如果继承太多，方法名字重复了或者父类提供的方法不能满足需求，可以进行方法重写。 class Animal:\tweight = None\t# 类的属性，此处是动物的体重，未知设为None\tdef __init__(self, w): self.weight = w\tdef about(self): print(\"这只动物的重量是{}kg\".format(self.weight))class Flower:\tcolor = None\t# 类的属性，此处是花的颜色，未知设为None\tdef __init__(self, c): self.color = c\tdef about(self): print(\"这朵花的颜色是{}色\".format(self.color))class Dog(Animal, Flower):\tdef __init__(self, w, c): self.weight = w self.color = c\tdef about(self): print(\"这是一只{}色的狗，重量是{}kg\".format(self.color, self.weight))animal = Animal(20)flower = Flower('红')dog = Dog(10, '黑')\t# 类的实例化，并且实例化时设定属性值animal.about()flower.about()dog.about()\t# 输出关于狗狗的信息 上述代码则对 about() 函数进行了重写，以满足狗类的需求。 重写方法或者重写运算符可以实现一些特殊的功能。 但是对于构造函数，子类不重写 __init__() ，实例化子类时，会自动调用父类定义的 __init__() 。如果重写了 __init__ 时，实例化子类，就不会调用父类已经定义的 __init__ 。还有一种情况，如果重写了 __init__() 函数，仍想调用父类构造方法时，可以这样写： super(子类, self).__init__(...)# 或者是：父类名称.__init__(self, ...) 九. 列表 List 9.1 什么是列表 Python的列表可以存储相同数据类型的数据，也可以存储不同数据类型的数据。 定义列表的语法格式为： listName = [元素1, …, 元素n] 列表的每一个数据称作元素，置于括号 [] 中，用逗号隔开。 其中空列表为没有任何元素的列表。 同样，当我们不需要这个列表时，使用 del 删除列表。 9.2 列表的运算和方法 9.2.1 输出列表 当我们有一个列表时，直接使用print()函数即可输出整个列表。 list = [1, 2, 3]print(list)# 输出结果：[1, 2, 3] 9.2.2 读取、修改和删除列表元素 可以通过列表名称与索引读取列表元素的内容，元素的索引值从0开始。修改同理，只需要更改存储的数据即可。 当索引值为负值时，表示从列表结尾数起，-1为最后一个元素，-2为最后第2个元素。 list = [1, 3, 5, 7]print(list[2]) # 5list[2] = 6print(list) # [1, 3, 6, 7] 同时可以使用 in 运算符判断某元素是否在列表中： list = [1, 3, 5, 7]print(3 in list) # True 如果希望删除列表的元素，同样使用 del 进行。 del list[i] ：删除索引为i的元素。 del list[start:end] ：删除索引从start到end-1的所有元素。 del list[start:end:step] ：每隔step，删除索引从start到end-1的元素。 list = [1, 3, 5, 7, 9]print(list)\t# [1, 3, 5, 7, 9]del list[2]print(list)\t# [1, 3, 7, 9]del list[2:4]print(list)\t# [1, 3] 9.2.3 列表切片 在设计程序时，常会需要取得列表前几个元素、后几个元素、某区间元素或是依照一定规则排序的元素，所取得的系列元素也可称子列表，这个过程也称列表切片(list slices)。 list[start:end] ：读取从索引start到(end-1)索引的列表元素。 list[:n] ：取得列表前n个。 list[n:] ：取得列表索引n到最后。 list[-n:] ：取得列表后n名。 list[:] ：取得所有元素。 list[start:end:step] ：每隔step,读取从索引start到(end-l) 索引的列表元素。 9.2.4 列表的统计方法 max() ：取得列表的最大值。 list = [1, 2, 3]print(max(list)) # 3 min() ：取得列表的最小值。 list = [1, 2, 3]print(min(list)) # 1 sum() ：取得列表的总和。 list = [1, 2, 3]print(sum(list)) # 6 9.2.5 列表的元素个数 len() ：判断列表中元素个数。 list = [1, 2, 3]print(len(list)) # 3 也可通过 len() 函数判断列表是否为空。 9.2.6 列表的加法、乘法 列表与列表相加表示列表的结合。 list1 = [1, 2, 3]list2 = [4, 5, 6]print(list1 + list2) # [1, 2, 3, 4, 5, 6] 列表与数字相乘表示列表元素重复多少次。 list = [1, 2, 3]print(list * 3) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 9.3 列表的其他方法 list.append(obj) ：在列表末尾添加新的对象。 list.count(obj) ：统计某个元素在列表中出现的次数。 list.extend(seq) ：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。 list.index(obj) ：从列表中找出某个值第一个匹配项的索引位置。 list.insert(index, obj) ：将对象插入列表。 list.pop([index=-1]) ：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 list.remove(obj) ：移除列表中某个值的第一个匹配项。 list.reverse() ：反向列表中元素。 list.sort(key=None, reverse=False) ：对原列表进行排序。 list.clear() ：清空列表。 list.copy() ：返回复制后的新列表。有兴趣可了解深拷贝和浅拷贝。 具体的函数解释用法可以边用边搜索。 十. 元组 Tuple 10.1 什么是元组 Python的元组与列表类似，不同之处在于元组的元素 不能修改 。元组使用小括号 ( ) ，列表使用方括号 [ ] 。 定义元组的语法格式为： tupName = (元素1, 元素2, ...) 元组的每一个数据称作元素，置于括号 () 中，用逗号隔开。如果元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用。 tup = (1,) 其中空元组为没有任何元素的元组。 同样，当我们不需要这个元组时，使用 del 删除元组。 10.2 元组的运算和方法 10.2.1 输出元组 当我们有一个元组时，直接使用print()函数即可输出整个元组。 tup = (1, 2)print(tup) 10.2.2 读取元组元素 元组同样通过下标索引访问元组中的值。与列表类似。 但通过索引修改元组元素的操作是不被允许的，但是可以通过 + 进行元组的拼接。 tup1 = (1, 2)tup2 = ('x', 'y')tup3 = tup1 + tup2print(tup3) 同时也不允许删除元组中的元素值，只能通过 del 删除整个元组。 10.2.3 元组截取 因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素。 tup[start:end] ：读取从索引start到(end-1)索引的列表元素。 tup[:n] ：取得列表前n个。 tup[n:] ：取得列表索引n到最后。 tup[-n:] ：取得列表后n名。 tup[:] ：取得所有元素。 tup[start:end:step] ：每隔step,读取从索引start到(end-l) 索引的列表元素。 10.2.4 列表的统计函数 max() ：取得元组的最大值。 tup = (1, 2, 3)print(max(tup)) # 3 min() ：取得元组的最小值。 tup = (1, 2, 3)print(min(tup)) # 1 10.2.5 元组的元素个数 函数 len() 计算元组中元素个数。 10.2.6 元组的加法、乘法 元组支持 + 、 += 、 * 运算。 tup1 = (1, 2)tup2 = ('x', 'y')tup3 = tup1 + tup2print(tup3) tup3 就是一个新的元组，它包含了 tup1 和 tup2 中的所有元素。 tup1 = (1, 2)tup2 = ('x', 'y')tup1 += tup2print(tup1) tup1 就变成了一个新的元组，它包含了 tup1 和 tup2 中的所有元素。 tup1 = (1, 2)print(tup1 * 4) 乘法的作用依然是复制。 十一. 字典 Dict 11.1 什么是字典 字典是另一种可变容器模型，由键值对组成，且可存储任意类型对象。 字典的每个键值对用冒号 : 分割，每个对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示： d = {key1 : value1, key2 : value2, ...} 需要注意的是，键值对的键必须是唯一的，值可以不唯一。 创建时如果同一个键被赋值两次，后一个值会被记住。 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。 同时创建空字典时，可以使用 d = {} 直接创建，也可以使用 d= dict() 函数创建。所以字典的名字不能取dict。 11.2 字典的运算和方法 11.2.1 输出字典 直接使用 print() 输出： d = {'apple' : '苹果', 'banana' : '香蕉'}print(d) 11.2.2 读取、修改和删除字典 与列表、元组使用索引值不同，字典需要把键放到方括号中。如果访问了字典里没有的键，就会报错。 d = {'apple' : '苹果', 'banana' : '香蕉'}print(d['apple']) 修改字典内容也是直接使用键访问设定新值： d = {'apple' : '苹果', 'banana' : '香蕉'}print(d)d['apple'] = '大苹果'print(d) 向字典添加新内容的方法是增加新的键值对： d = {'apple' : '苹果', 'banana' : '香蕉'}print(d)d['mango'] = '芒果'print(d) 删除已有键值对如下： d = {'apple' : '苹果', 'banana' : '香蕉'}del d['apple'] 字典还有删除整个字典和清空字典的功能： d = {'apple' : '苹果', 'banana' : '香蕉'}d = clear()\t# 清空字典del d\t# 删除字典 11.2.3 字典的键值对数 函数 len() 计算字典中键值对数。 11.3 字典的方法 dict.clear() ：删除字典内所有元素 dict.copy() ：返回一个字典的复制 dict.fromkeys() ：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 dict.get(key, default=None) ：返回指定键的值，如果键不在字典中返回 default 设置的默认值 key in dict ：如果键在字典dict里返回true，否则返回false dict.items() ：以列表返回一个视图对象 dict.keys() ：返回一个视图对象 dict.setdefault(key, default=None) ：和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default dict.update(dict2) ：把字典dict2的键/值对更新到dict里 dict.values() ：返回一个视图对象 pop(key[,default]) ：删除字典key（键）所对应的值，返回被删除的值。 popitem() ：返回并删除字典中的最后一对键和值。 十二. 集合 Set 12.1 什么是集合 集合（set）是一个无序的不重复元素序列。集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。 可以使用大括号 { } 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 set() 函数创建集合。创建一个空集合必须用 set() ，因为 { } 是用来创建一个空字典。 parame1 = {value01,value02,...}# 或者parame2 = set(value) 12.2 集合基本操作 12.2.1 添加元素 s.add(x) ，将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。 s.update(x) 也可以添加元素，且参数可以是列表，元组，字典等。 s = {1, 3}s.add(2)s.update([4,6], [5])print(s) 12.2.2 移除元素 s.remove(x) ，将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。 s.discard(x) ，将元素 x 从集合 s 中移除，如果元素不存在，不会发生错误。 s.pop() ，随机删除集合中的一个元素。 12.2.3 计算集合元素个数 len(s) ，计算集合 s 元素的个数。 12.2.4 清空集合 s.clear() ，清空集合 s 。 12.2.5 判断元素是否在集合中 x in s ，存在返回True，不存在返回False。 12.3 集合的方法 add() ：为集合添加元素 clear() ：移除集合中的所有元素 copy() ：拷贝一个集合 difference() ：返回多个集合的差集 difference_update() ，移除集合中的元素，该元素在指定的集合也存在。 discard() ，删除集合中指定的元素 intersection() ，返回集合的交集 intersection_update() ，返回集合的交集。 isdisjoint() ，判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() ，判断指定集合是否为该方法参数集合的子集。 issuperset() ，判断该方法的参数集合是否为指定集合的子集 pop() ，随机移除元素 remove() ，移除指定元素 symmetric_difference() ，返回两个集合中不重复的元素集合。 symmetric_difference_update() ，移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() ，返回两个集合的并集 update() ，给集合添加元素 具体使用解释可自行搜索。 十三. 迭代器和生成器 13.1 迭代器 迭代器是一个可以 记住遍历的位置 的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法： iter() ：创建一个迭代器对象。 next() ：返回下一个迭代器对象。 字符串，列表或元组对象都可用于创建迭代器。 举个例子： list = [1, 2, 3, 4]it = iter(list)for x in it:\tprint(x, end=\" \")#输出结果：1 2 3 4 还可以把一个类作为一个迭代器使用，需要实现 __iter__() 和 __next__() 方法。此处举例：创建一个返回数字的迭代器，初始值为 1，逐步递增 1。 class MyNumbers:\tdef __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x 当迭代完成时，会触发 StopIteration ，可以在 __next__() 中设置。 class MyNumbers:\tdef __iter__(self): self.a = 1 return self def __next__(self): if self.a = 20: x = self.a self.a += 1 return x else:\t# 设置迭代完成条件 raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter: print(x) 13.2 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。 然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。 调用一个生成器函数，返回的是一个迭代器对象。 下面是一个简单的示例，展示了生成器函数的使用： def countdown(n): while n 0: yield n n -= 1 # 创建生成器对象generator = countdown(5) # 通过迭代生成器获取值print(next(generator)) # 输出: 5print(next(generator)) # 输出: 4print(next(generator)) # 输出: 3 # 使用 for 循环迭代生成器for value in generator: print(value) # 输出: 2 1 再举一个例子，计算斐波那契数列： import sys def fibonacci(n): # 生成器函数计算斐波那契 a, b, counter = 0, 1, 0 while True: if (counter n): return yield a # 在此返回数列的项 a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=\" \") except StopIteration: sys.exit() 十四. 推导式 14.1 列表推导式 格式为： # [表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]# 或者 # [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition] out_exp_res：列表生成元素表达式，可以是有返回值的函数。 for out_exp in input_list：迭代input_list将out_exp传入到out_exp_res表达式中。 if condition: 条件语句，可以过滤列表中不符合条件的值。 推导出来是一个列表。 举个例子，求30以内能被4整除的整数： ans = [i for i in range(30) if i % 4 == 0]print(ans) 再举个例子，求列表中长度大于3的字符串并大写： list = [\"aaa\", \"aasdad\", \"asdw\", \"wadhjuio\"]str = [x.upper() for x in list if len(x) 3]print(str) 14.2 字典推导式 格式为： { key_expr: value_expr for value in collection }# 或{ key_expr: value_expr for value in collection if condition } 原理与列表推导式类似，推导出来的是一个字典。看一个例子，给出三个数字作为键，以对应的平方作为值，创建字典： list = [4, 2, 8]d = {i : i * i for i in list}print(d) 再来一个例子，以列表中偶数索引为键，奇数索引为值创建字典： list = ['apple', '苹果', 'banana', '香蕉']d = {list[i] : list[i + 1] for i in range(0, len(list), 2) if i len(list) - 1}print(d)\t# {'apple': '苹果', 'banana': '香蕉'} 14.3 集合推导式 格式为： { expression for item in Sequence }# 或{ expression for item in Sequence if conditional } 原理类似，推导出来的是一个集合。 14.4 元组推导式（生成器表达式） 元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 格式为： (expression for item in Sequence )# 或(expression for item in Sequence if conditional ) 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 [] ，另外元组推导式返回的结果是一个生成器对象。需要使用 tuple() 函数，可以直接将生成器对象转换成元组。 a = (x for x in range(1,10))print(a) # generator object genexpr at 0x000002B53CC81FF0print(type(a))\t# class 'generator'print(tuple(a))\t# (1, 2, 3, 4, 5, 6, 7, 8, 9)print(type(tuple(a)))\t# class 'tuple' 十五. 文件的读写 15.1 打开文件 Python的 open() 方法用于打开一个文件，并返回文件对象。注意打开文件使用完后记得关闭文件 close() 在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError 异常。 该函数的完整格式为： open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。 一般情况下，只需传入file参数和mode参数即可。 mode参数有： t ：文本模式 (默认)。 x ：写模式，新建一个文件，如果该文件已存在则会报错。 b ：二进制模式。 + ：打开一个文件进行更新(可读可写)。 r ：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb ：以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ ：打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ ：以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w ：打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb ：以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ ：打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ ：以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a ：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab ：以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ ：打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ ：以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 15.2 文件对象的方法 使用 open() 函数会创建一个file对象，file对象有以下常用函数： file.close() ：关闭文件。关闭后文件不能再进行读写操作。 file.flush() ：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 file.fileno() ：返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 file.isatty() ：如果文件连接到一个终端设备返回 True，否则返回 False。 file.read([size]) ：从文件读取指定的字节数，如果未给定或为负则读取所有。 file.readline([size]) ：读取整行，包括 “ ” 字符。 file.readlines([sizeint]) ：读取所有行并返回列表，若给定sizeint0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 file.seek(offset[, whence]) ：移动文件读取指针到指定位置 file.tell() ：返回文件当前位置，是从文件开头开始算起的字节数。 file.truncate([size]) ：从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 file.write(str) ：将字符串写入文件，返回的是写入的字符长度。 file.writelines(sequence) ：向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 方法众多，需要时再查阅资料再学习。 15.3 读取文件 file.read() 方法： 为了读取一个文件的内容，调用 file.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。 size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。 # test.txt中内容：# 111# 222f = open('test.txt', 'r')str = f.read()print(str)# 输出结果：# 111# 222f.close() file.readline() 方法： file.readline() 会从文件中读取单独的一行。换行符为 ‘ ’。 file.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。 # test.txt中内容：# 111# 222f = open('test.txt', 'r')str = f.readline()print(str)\t# 输出结果：111f.close() file.readlines() 方法： f.readlines() 将返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。 # test.txt中内容：# 111# 222f = open('test.txt', 'r')str = f.readlines()print(str)\t# 输出结果：['111 ', '222']f.close() 15.4 文件写入 file.write() 方法： f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。 # test.txt中为空f = open('test.txt', 'w')num = f.write('111 222')print(num)\t# 7# test.txt输出结果：# 111# 222f.close()","tags":["Python"],"categories":["笔记"]},{"title":"基于Qt的音频播放器程序设计记录","path":"/2023/fmusicplayer/","content":"使用Qt的工具完成一个音频播放器——FMusicPlayer 关键词：Qt、C++ 一、前言 利用Qt的工具开发一个音乐播放器，界面如下图： Qt版本5.12.12。该项目十分简单，适合用于练手。 二、模块构思 根据市场上现有的音乐播放器思考，一个基本的音乐播放器应该具有以下功能： 播放/暂停 停止 控制音频播放进度 管理音乐列表 音量控制 信息显示 …… 此软件仅实现了上述功能。 三、模块实现 此音乐播放器主要使用Qt现成的QMediaPlayer类和QMediaPlaylist类进行维护。 3.1 界面设计 整体界面设计如图： 9个按钮QPushButton，对应各种功能； 3个标签文字QLabel，用于说明； 2个文本框QLineEdit，用于显示信息； 1个列表QListWidget，用于存放播放列表； 2个滑条QSlider，一个用于控制和显示进度，一个用于控制和显示音量。 若干个弹簧用于调整布局。 完成后的程序界面： 3.1 初始化工程 此程序使用了Qt的multimedia部件，所以首先在Qt的.pro工程文件中包含multimedia。 ……QT += multimedia…… 接着项目中应该有以下文件： mainwindow.h mainwindow.cpp mainwindow.ui main.cpp mainwindow.h：主要存放主窗口的一些声明 mainwindow.cpp：记录主窗口的实现 mainwindow.ui：界面的设计文件 main.cpp：程序入口 首先在mainwindow.h中将我们实现的模块添加槽函数声明和成员变量的声明： QMediaPlayer *musicplayer; // 播放器QMediaPlaylist *musicplayList; // 播放列表QString durationTime;// 音频总长度QString positionTime;// 当前播放到位置// 槽函数声明略，见源代码 接着在主窗口构造函数中做一些初始化： // 创建实例musicplayer = new QMediaPlayer(this);musicplayList = new QMediaPlaylist(this);// 循环播放musicplayList-setPlaybackMode(QMediaPlaylist::Loop);musicplayer-setPlaylist(musicplayList);// 默认音量，同步音量显示ui-volume-setValue(50);\tchangedVolume(50); 3.3 播放/暂停模块 当点击播放键时播放音乐，为播放按钮play绑定单击事件，触发playMusic()函数： // 播放音乐connect(ui-play, SIGNAL(clicked()), this, SLOT(playMusic())); void MainWindow::playMusic()//播放{ // 维护播放列表，使其索引正常，正常播放 if(musicplayList-currentIndex()0) musicplayList-setCurrentIndex(0); musicplayer-play();} 当点击暂停键时暂停音乐，支持记录位置，从上次暂停的位置播放。为暂停按钮绑定单击事件，触发pauseMusic()函数： // 暂停音乐connect(ui-pause, SIGNAL(clicked()), this, SLOT(pauseMusic())); void MainWindow::pauseMusic()//暂停播放{ musicplayer-pause();} 3.4 停止模块 当点击停止键时，停止音乐，音乐播放位置归零。为停止按钮绑定单击事件，触发stopMusic()函数： // 停止音乐connect(ui-stop, SIGNAL(clicked()), this, SLOT(stopMusic())); void MainWindow::stopMusic()//停止播放{ musicplayer-stop();} 3.5 控制音频进度模块 播放时，音频进度条应当可以被拖动，并且更新播放的位置。为进度条绑定值修改事件，触发changedPosition()函数，函数参数为进度条传入的位置参数。 // 进度条控制connect(ui-timebar, SIGNAL(valueChanged(int)), this, SLOT(changedPosition(int))); void MainWindow::changedPosition(int pos) // 修改播放位置{ musicplayer-setPosition(pos);} 3.6 管理音乐列表模块 播放器应该可以输入多个文件，接着顺序播放，所以需要维护一个音乐列表。 首先可以向音乐列表添加音乐，为添加音乐按钮绑定单击事件，绑定addMusic()函数。 // 添加文件connect(ui-addMusic, SIGNAL(clicked()), this, SLOT(addMusictoList())); 读取文件时，wav文件是支持的，而mp3文件需要外置解码器的支持，处理mp3文件方法见文章最后。 void MainWindow::addMusictoList(){ QString curPath = QDir::currentPath(); QString title = \"选择音频文件\"; QString filter = \"音频文件(*.wav *.mp3)\"; QStringList fileList = QFileDialog::getOpenFileNames(this, title, curPath, filter);\t// 添加文件少于1个时退出函数 if(filter.count() 1) return;\t// 将读取的文件放入musicplayList里 for(int i = 0; i fileList.count(); ++ i) { QString aFile = fileList.at(i); musicplayList-addMedia(QUrl::fromLocalFile(aFile)); QFileInfo fileinfo(aFile); ui-playList-addItem(fileinfo.fileName()); }\t// 将音乐列表的第一首音频作为待播放音频 if(musicplayer-state() != QMediaPlayer::PlayingState) musicplayList-setCurrentIndex(0);} 同样还应支持移除音频文件： // 移除文件connect(ui-delMusic, SIGNAL(clicked()), this, SLOT(delMusic())); 移除文件时还应判断移除的是否为当前播放音乐，进行相应处理。 void MainWindow::delMusic(){ int pos = ui-playList-currentRow(); // 获取选中行 QListWidgetItem *item = ui-playList-takeItem(pos); delete item; if(musicplayList-currentIndex() == pos)// 删除是当前播放的音乐时 { int nextPos = 0; if(pos = 1) nextPos = pos - 1; musicplayList-removeMedia(pos); if(ui-playList-count() 0) { musicplayList-setCurrentIndex(nextPos); onPlayListChanged(nextPos); } else { musicplayer-stop(); ui-playmusic-setText(\"无文件\"); } } else musicplayList-removeMedia(pos);} 清空文件则是移除文件的简化版，直接将播放列表清空即可。 // 清空文件列表connect(ui-clearList, SIGNAL(clicked()), this, SLOT(clearList())); void MainWindow::clearList(){ musicplayList-clear();\t// 清空列表 ui-playList-clear();\t// 更新UI ui-playmusic-clear(); ui-time-clear(); ui-timebar-setValue(0); musicplayer-stop();\t// 停止播放} 最后还可以添加上一首和下一首的功能，只需简单绑定一下点击事件和调用musicplayList的函数即可。 musicplayList-previous();\t// 上一首musicplayList-next(); // 下一首 3.7 音量控制模块 一个播放器还应该支持音量的调节，而QMediaPlayer支持音量调节，所以绑定滑条值改变事件且调用函数即可，事件返回一个滑条的位置参数。 // 控制音量connect(ui-volume, SIGNAL(valueChanged(int)), this, SLOT(changedVolume(int))); void MainWindow::changedVolume(int value){ musicplayer-setVolume(value);} 3.8 信息显示与同步模块 根据UI的设计，显示的信息有：当前播放的音频名字、播放时间/完整时间。当播放音频进行切换时，需要更新音频名字、播放时间和音频完整时间等信息。 为播放列表musicplayList的当前索引变化事件绑定onPlayListChanged()函数，事件返回新的索引号，用此更新播放的音频名字。 // 播放音乐变化connect(musicplayList, SIGNAL(currentIndexChanged(int)), this, SLOT(onPlayListChanged(int))); void MainWindow::onPlayListChanged(int pos){ ui-playList-setCurrentRow(pos); // 使用QListWidgetItem类取出QListWidget的某一行 QListWidgetItem *item = ui-playList-currentItem(); if(item) { // 更新UI的音频名字 ui-playmusic-setText(item-text()); }} 切换音频时，其总时长也应该变化，需要为播放器musicplayer的播放位置变化durationChanged事件绑定onDurationChanged()函数。函数为计算音频总的时间。 // 时长变化connect(musicplayer, SIGNAL(durationChanged(qint64)), this, SLOT(onDurationChanged(qint64))); void MainWindow::onDurationChanged(qint64 dur){ ui-timebar-setMaximum(dur);\t// 设置进度条的最大值 int secs = int(dur / 1000); int mins = secs / 60; secs %= 60; durationTime = QString::asprintf(\" %d : %d \", mins, secs); // UI刷新时间 ui-time-setText(positionTime + \" / \" + durationTime);} 至于音频随着播放而位置和进度的刷新，则需要为播放器musicplayer的播放位置变化positionChanged事件绑定onPositionChanged()函数。函数为计算播放的时间。 // 播放位置变化connect(musicplayer, SIGNAL(positionChanged(qint64)), this, SLOT(onPositionChanged(qint64))); void MainWindow::onPositionChanged(qint64 pos){\t// 进度条滑动到尽头，退出函数 if(ui-timebar-isSliderDown()) return; ui-timebar-setSliderPosition(pos); // 计算分和秒 int secs = int (pos / 1000); int mins = secs / 60; secs %= 60; positionTime = QString::asprintf(\" %d : %d \", mins, secs); // UI刷新时间 ui-time-setText(positionTime + \" / \" + durationTime);} 四、总结 该程序源代码放在Gitee - https://gitee.com/fingsinz/fmusicplayer/ 该项目只是一个简单的播放器实现，希望能够帮助萌新认识Qt，提高自己的能力。 不支持直接加载mp3文件，需要先下载相关解码器。此处附上解码器链接： K-lite_codec_pack K-lite_codec_pack_basic（基础版） K-lite_codec_pack_standard（标准版）","tags":["CPP","Qt"],"categories":["笔记"]},{"title":"Qt的下载地址记录","path":"/2023/14/","content":"Qt（C++）和pyQt的安装记录 关键词：Qt Qt（C plus plus） 开源版离线官网下载 清华镜像下载 Qt（Python） 参考此篇文章 下载PyQt5 pip install PyQt5 网络不好的可选择豆瓣的镜像： pip install PyQt5 -i https://pypi.douban.com/simple 下载PyQt5-tools pip install PyQt5-tools 网络不好的可选择豆瓣的镜像： pip install PyQt5-tools -i https://pypi.douban.com/simple PyQt 5.15.x 之前，安装完成后在 %Python_path%\\Lib\\site-packages 目录中可以看到PyQt5、pyqt5-tools、PyQt5-sip 目录。 PyQt 5.15.x 之后，安装完成后在 %Python_path%\\Lib\\site-packages 目录中可以看到PyQt5、pyqt5-tools、PyQt5-sip 以及多了的 qt_applications 、qt5-tools 目录。 添加环境变量 在系统变量Path中添加 pyqt5-tools 目录的绝对路径。 验证 运行下面代码，出现窗口即为成功。 import sysfrom PyQt5.QtWidgets import QWidget, QApplicationapp = QApplication(sys.argv)widget = QWidget()widget.resize(640, 480)widget.setWindowTitle(\"Hello, PyQt5!\")widget.show()sys.exit(app.exec())","tags":["Qt"],"categories":["日常"]},{"title":"如何暂停Windows的系统升级","path":"/2023/13/","content":"关闭Windows的自动更新 关键词：Windows 1.修改注册表编辑器 按住 Win + R 输入 regedit 进入注册表编辑器。 找到 HKEY_LOCAL_MACHINE → SOFTWARE → Microsoft → WindowsUpdate → UX → Settings 点击右边空白处，选择新建DWORD（32位）值，重命名为 FlightSettingsMaxPauseDays ， 双击打开，选择十进制，输入想要暂停的最大天数，我这里输入 8888 。 2.打开系统设置 按住 Win + I 打开系统设置，搜索 Windows更新 ，进入Windows更新设置，在暂停更新处选择最大值即可。 Windows 10的暂停更新在 Windows 更新设置 → 高级选项 → 暂停更新 效果如图： 3.恢复更新 直接点击继续更新即可。","tags":["Windows"],"categories":["日常"]},{"title":"Python源代码打包成.exe文件记录","path":"/2023/12/","content":"使用auto-py-to-exe将.py打包成.exe 关键词：Python 安装auto-py-to-exe 打开cmd命令提示符，输入： pip install auto-py-to-exe 等待下载完成…… 使用auto-py-to-exe 下载安装完成后，选择文件夹作为输出文件夹，我的选择的路径为 F:\\，在此路径打开cmd命令提示符或者通过cmd命令进入到该路径。 输入： auto-py-to-exe 即可打开打包窗口。 脚本位置：选择需要打包的.py文件 单文件/单目录：选择打包的形式，选择将依赖整体打包成一个.exe还是依赖库分离+.exe文件 控制台窗口：自行选择 图标、附加文件、高级、设置：自行选择 我的打包结果：","tags":["Python"],"categories":["日常"]},{"title":"C语言入门学习教程","path":"/2023/c-language-learning/","content":"个人整理面向入门基础级别的C语言学习教程。 关键词：C语言 Ⅰ —— 基础知识介绍 此教程会用一些注记符号，表示某种格式。 1.1 C语言背景知识 C语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。 C语言标准有C89、C99、C11、C17、C2x ……等，后面的数字是标准发布的年份。如果想了解每个标准有什么差异，自行必应搜索。本教程的完整代码在GNU C17下成功运行。 1.2 用什么写C语言 编写C语言，就连基本的文本编辑器——记事本也可以完成。但我们并不会只想着使用那么奇奇怪怪的记事本，去编写十来行代码甚至上千行代码，至少是真的不习惯。 接触C语言，会有很多人推荐你用那个什么什么写啊，一点一动就行；但如果在大学学习，教师可能会让你使用Visual C++ 6.0（下简称VC 6.0）去写。 感受过VC 6.0软件界面的人都知道，很不舒服，甚至降低自己的效率。VC 6.0甚至比我的年龄还大，算是老古董了。但是目前教材用的是VC 6.0，实验室配置的是VC 6.0，乃至你的考试，甚至计算机二级，都是VC 6.0，所以用VC 6.0而不是别的软件，更加容易应付教学。 所以在此，我推荐使用的C语言编辑器是： 基础小白或图方便可使用Dev-C++ 非基础小白可使用Visual Studio或Visual Studio Code 此教程的代码使用Dev-C++，均在Dev-C++下成功运行。 按 Ctrl + N 可以新建文件，或者点击左上角文件新建文件。 在 工具 → 编译选项 → 代码生成/优化 → 代码生成 处可以找到语言标准。 1.3 从代码到执行程序 在上一节我提到了用什么写C语言，这是关于编辑器（Editor）的事情。字面意思，它只负责编辑，也就是敲上一个个的字母数字，就像写英语日记、写英语文章一样。 事实上，你在编辑器上写的内容，还不能完全算是程序，这个内容称为 源代码（Source Code） 。存放源代码的文件称为 源文件 。 我们还需要经过一些步骤，使得源代码变成 可执行文件（Executable file） ，也就是你计算机里面那些.exe文件。把这些步骤称之为 编译（Build） 和 链接（Link） 。 编译：编译需要 编译器 完成。编译器把一个源代码翻译成可执行文件的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。常见的编译器有：MinGW、MSVC等。 链接：链接需要 链接器 完成。链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。链接的意义在于我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。 这些只是一些知识补充，想详细了解可参阅编译原理。另外，如果你选择了Dev-C++或者Visual Studio这样的集成软件，编译器和链接器的配置会相对简单。 1.4 认识最基础的C语言代码 学习C语言的开始，从输出一个“Hello World！”开始，这似乎是所有编程语言一开始都经历的事情。 我在此直接给出完整代码，心急的可以复制到Dev-C++运行试试。 // Hello World.c #include stdio.hint main(){\tprintf(\"Hello World!\");\treturn 0;} 现在来逐行认识基本的C语言代码结构。 // 表示当前整行被编译器忽略，又称注释，供程序员理解语句。 #includestdio.h中的 #（井号）表示预处理命令，即在程序编译前进行提前处理的部分。若是头文件，可用 （单书名号）括起来，也可用 \" \"（引号）包含起来。 其中由 括起来的头文件表示在系统头文件的文件夹中查找，由 \"\" 括起来的头文件表示在源文件当前文件夹查找。 int main() 是一个函数的开头，再加以 {}（大括号）包含主函数内容。此处是主函数，主函数是一个程序最重要的函数，程序从此开始编译。 printf(\"Hello World!\"); 为程序工作语句，其作用是输出“Hello World！”。 C语言中以 ;（分号）作为一条语句的结束标志。 return 0;是函数的结构之一，在函数一节介绍。 一般情况下， 一个C语言程序包含预处理器指令、函数、变量、语句（表达式和注释）等 。函数是一个进行某种功能操作的模块，目前认识到的是主函数，还可以自定义函数。变量即程序运行时其值可以改变的量，变量的功能就是存储数据。 C语言代码按 顺序结构 ，由上到下顺序执行代码。 还有一件比较重要的事情，养成良好的代码风格，即令人舒适的缩进、空格位置等；千万不要所有代码都挤到一块或者全都左对齐。 1.5 头文件 在上一节提到了预处理命令包含的头文件，那么头文件是什么？ 头文件是扩展名为.h的文件，包含了C语言一些函数甚至几乎所有函数的提前 声明（Statement） 和 定义（Definition） ，没有这些声明和定义，编译器不会认识这些函数，故而不能运行。 有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用预处理指令 #include 来引用它，引用头文件相当于复制头文件的内容。如stdio.h头文件，它包含了printf()这一函数。 1.6 关键字 C语言的关键字是C语言的基本构成要素，共有32个，根据关键字的作用，可分其为数据类型关键字、控制语句关键字、存储类型关键字和其它关键字四类。 1 数据类型关键字（12个）： (1) char ：声明字符型变量或函数 (2) double ：声明双精度变量或函数 (3) enum ：声明枚举类型 (4) float ：声明浮点型变量或函数 (5) int ：声明整型变量或函数 (6) long ：声明长整型变量或函数 (7) short ：声明短整型变量或函数 (8) signed ：声明有符号类型变量或函数 (9) struct ：声明结构体变量或函数 (10) union ：声明共用体（联合）数据类型 (11) unsigned ：声明无符号类型变量或函数 (12) void ：声明函数无返回值或无参数，声明无类型指针 2 控制语句关键字（12个）： A循环语句 (1) for ：一种循环语句(可意会不可言传） (2) do ：循环语句的循环体 (3) while ：循环语句的循环条件 (4) break ：跳出当前循环 (5) continue ：结束当前循环，开始下一轮循环 B条件语句 (1) if : 条件语句 (2) else ：条件语句否定分支（与 if 连用） (3) goto ：无条件跳转语句 C开关语句 (1) switch :用于开关语句 (2) case：开关语句分支 (3) default：开关语句中的“其他”分支 D返回语句 return ：函数返回语句（可以带参数，也可不带参数） 3 存储类型关键字（4个） (1) auto ：声明自动变量 一般不使用 (2) extern ：声明变量是在其他文件正声明（也可以看做是引用变量） (3) register：声明积存器变量 (4) static ：声明静态变量 4 其它关键字（4个）： (1) const ：声明只读变量 (2) sizeof ：计算数据类型长度 (3) typedef ：用以给数据类型取别名 (4) volatile ：说明变量在程序执行中可被隐含地改变 你可能不明白这些关键字什么意思怎么用，但你只需要知道这些关键字不能随便用，它们被C语言内部定义占用了。 Ⅱ —— 函数 函数是用来完成特定任务的一组语句。在C语言中，每个程序至少有一个主函数 main() 。此外，C语言还提供了许多内置函数，可以在相应的头文件中找到。有时候，我们也可以称函数为方法。 当我们编写代码时，我们可以将其分割成不同的函数。划分代码到不同的函数中是我们自己决定的。但是从逻辑上来说，我们通常会根据每个函数执行特定的任务来进行划分。例如，如果我们正在编写一个计算器程序，我们可以使用四个函数分别处理加法、减法、乘法和除法。这样的划分可以让代码更有组织性，并且更易于理解和维护。 2.1 函数的基本结构 函数的结构应当如下，包括 函数返回类型return_type ， 函数名字function_name 、 参数arguments 和 函数主体Body 等。 return_type function_name(arguments){\t// body} 函数返回类型：一个函数可以返回一个值，return_type是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void 。 函数名字：这是函数的实际名称。函数名和参数列表一起构成了 函数签名（Function signature） 。 参数列表：当函数被调用时，可以向参数传递值。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。若有返回值的函数使用 return 返回。函数主体中遇到返回表示结束函数。 2.2 函数声明和定义 函数的产生有两个概念： 函数声明（Function Statement） 和 函数定义（Function Definition） 。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 使用函数之前必须先声明（也可以直接声明并定义）。 开玩笑地说，声明就是你骗机器有这么一个函数，但是当机器要找这个函数用的时候，你最好是有个定义。 // 函数声明int add(int a, int b);// 函数定义int add(int a, int b){\treturn a + b;} // 函数声明并定义int sub(int a, int b){\treturn a - b;} C语言从上到下运行，如果是先写了 main 函数，再写 sub 函数，而在 main 函数调用了 sub 函数的情况下，需要有一个声明在 main 函数的前面，告知编译器有这个函数，否则按从上到下的顺序，此时并未出现 sub 函数； 如果是先写了 sub 函数，再写 main 函数，而在 main 函数调用了 sub 函数的情况下，在 main 函数之前的 sub 函数就相当于函数声明并定义，main 函数调用 sub 函数也自然成功。 函数声明中的参数列表可以不具体写变量名，但函数定义中的参数列表必须写变量名。如上述代码的声明可以写成： int add(int, int); 2.3 调用函数 当我们写完我们的函数，使用时直接称呼 函数签名（函数名字+参数列表）即可。 // 声明并定义函数int add(int a, int b){\treturn a + b;}// 函数调用add(c, d); 2.4 函数参数传递 如果函数要使用参数，接受参数值的变量称为函数的 形式参数 。如上面 int add(int a, int b) 中的 a 和 b。 如果调用函数时，传递进入的参数称为 实际参数。如上面 add(1, 2)中的 c 和 d 。 参数传递有两种方式： 值传递 和 地址传递 。 值传递：把参数的数值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 地址（引用）传递：把参数的地址复制给函数的形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 对于地址传递，经过指针的学习可能更清晰。 Ⅲ —— 数据、运算符及语句 3.1 数据的表现形式 数据以常量、变量、常变量或标识符的形式出现。 变量、常变量的出现包括 声明 、 定义 、 初始化 三个步骤。 为变量分配地址和存储空间的称为定义，不分配地址的称为声明。 变量定义：用于为变量分配存储空间，还可为变量指定初始值，程序中，变量有且仅有一个定义。 变量声明：用于向程序表明变量的类型和名字。 定义也是声明：当定义变量时我们声明了它的类型和名字。 所有变量使用之前需要有声明或定义。 常量 ，其值不能改变的量。其分为 整型常量 （即整数，如1，2，1000，666）、 实型常量 、 字符常量 。 实型常量 ，包括十进制小数形式（由数字和小数点组成）和指数形式，指数形式以E或e代表以10为底的指数，如1e6，注意：e或E之前必须有数字，且e或E之后必须为整数； 字符常量之字符常量 ，由 ‘’ （单引号）包括的一个字符，如 ‘a’ 、 ‘A’ 等。普通字符，详见ASCII字符集；转义字符，特殊形式的字符，以 \\ 开头。 引号在此充当界限符，字符常量和字符串常量不包括引号。 转义字符 字符值 输出结果 \\' 一个单引号 ' \\\" 一个双引号 \" \\? 一个问号 ? \\\\ 一个反斜杠 \\ \\a 警告alert 产生声音或视觉信号 \\b 退格backspace 将光标后退一个字符 \\f 换页form feed 将光标移到下一页 换行 将光标移到下一行 \\r 回车carriage return 将光标移到本行开头 \\t 水平制表符 将光标移到下一个Tab位置 \\v 垂直制表符 将光标移到下一个垂直制表符 \\o 与该八进制码对应的ASCII字符 与该八进制码对应的ASCII字符 \\xh[h…] 与该十六进制码对应的ASCII字符 与该十六进制码对应的ASCII字符 字符常量之字符串常量 ，由 “ ” （双引号）包括的一个字符串，可以超过一个字符，如 “boy” 。 字符常量之符号常量 ，用 #define 指令指定一个符号名称代表一个常量。 #define Pi 3.14 //符号常量，之后所有语句中所有Pi用3.14替换 #define宏定义与常变量const的区别是，#define宏定义的值为实型常量，且#define为预处理命令，不分配内存，但常变量具有使程序稳定性提高的优点，使用方便。 变量 ，在运行期间可以改变的量。变量必须先定义后使用。 int a; //定义整型变量 aa = 3; //把3赋值给变量 a 常变量 ，在变量存在期间不可改变的量。也必须先定义后使用。用法是在定义变量前加上“const”。 const int a = 3; //定义一个整数常变量 a，后续不可修改。 标识符 ，简单来说就是一个对象的名字，遵守命名规则。 变量的命名规则： 变量名的开头必须是字母或下划线，不能是数字。实际编程中最常用的是以字母开头，而以下划线开头的变量名是系统专用的。 变量名中的字母是区分大小写的。比如 a 和 A 是不同的变量名，num 和 Num 也是不同的变量名。 变量名绝对不可以是C语言关键字。 变量名中不能有空格。这个可以这样理解：因为上面我们说过，变量名是字母、数字、下划线的组合，没有空格这一项。 3.2 数据的类型 3.2.1 整型数据 类型 存储大小 表示值范围（十进制） char 1字节 -128~127 unsigned char 1字节 0~255 signed char 1字节 -128~127 int 4字节 -2147483648（ −231-2^{31}−231 ）~2147483647（ 231−12^{31}-1231−1 ） unsigned int 4字节 0~4294967295（ 232−12^{32}-1232−1 ） short 2字节 -32768~32767 unsigned short 2字节 0~65535 long 4字节 -2147483648（ −231-2^{31}−231 ）~2147483648（ 231−12^{31}-1231−1 ） unsigned long 4字节 0~4294967295（ 232−12^{32}-1232−1 ） long int 4字节 -2147483648（ −231-2^{31}−231 ）~2147483648（ 231−12^{31}-1231−1 ） unsigned long int 4字节 0~4294967295（ 232−12^{32}-1232−1 ） long long int 8字节 −264-2^{64}−264~264−12^{64}-1264−1 unsigned long long int 8字节 0~ 264−12^{64}-1264−1 注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主，下同。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。 上述只讨论十进制，实际上C语言还可以表示八进制(int a = 010)和十六进制(int a = 0x10)。 特别指出，unsigned表示无符号数据，即非负数，但只有整型和字符型数据可以加unsigned修饰符。 由于ASCII码的存在， char 类型的数据范围恰好最小完整表达字符，所以 char 类型又称为字符类型。 3.2.2 浮点型数据 类型 存储大小 表示值范围 精度 float 4字节 1.2E-38~3.4E+38 6位有效数字 double 8字节 2.3E-308~1.7E+308 15位有效数字 long double 16字节 3.4E-4932~1.1E+4932 19位有效数字 需要注意，计算机对于浮点数的存储并不完全精准。 若我们声明定义的变量超过数据类型的数据范围时，编译会警告我们，我们可在数据末尾加专用字符进行类型转换。如在 float 类型数据后加“f”，指定为 float 类型，如在实型变量后加“L”，指定为 long double 型。 float a = 3.14159;//在某些系统中，会发出警告超出float类型，系统自动转化会影响精度float a = 3.14159f;//在数字后面加“f”，指定为float型，编译时不发出警告 3.2.3 Void类型 void 它通常用于以下三种情况下： 函数返回为空：C中有各种函数都不返回值，或者可以说它们返回空。不返回值的函数的返回类型为空。 函数参数为空：C中有各种函数不接受任何参数。不带参数的函数可以接受一个 void 。 指针指向 void ：类型为 void * 的指针代表对象的地址，而不是类型。返回指向 void 的指针，可以转换为任何数据类型。 3.2.4 类型转换 类型转换是将一个数据类型的值转换为另一种数据类型的值。 C 语言中有两种类型转换： 隐式类型转换：隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。 int i = 10;float f = 3.14;double d = i + f; // 隐式将int类型转换为double类型 显式类型转换：显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。 double d = 3.14159;int i = (int)d; // 显式将double类型转换为int类型 3.3 运算符 3.3.1 算术运算符 运算符 描述 实例 + 左操作数和右操作数相加 A + B - 左操作数减去右操作数 A - B * 左操作数和右操作数相乘 A * B / 左操作数除以右操作数 A / B % 左操作数除以右操作数后的余数 A % B ++ 操作数整数值自增1 A ++ -- 操作数整数值自减1 A -- % 运算符的操作数只可以是整数。 // test.c#includestdio.hint main(){\tint a, b, ans1;\tint c, d, ans2;\tans1 = a + b; //两个整型变量相加的结果仍为整型。\tans1 = a - b; //两个整型变量相减的结果仍为整型。\tans1 = a * b; //两个整型变量相乘的结果仍为整型。\tans1 = a / b; //两个整型变量相除的结果仍为整型，多数为除不尽向零取整。\t//如 5/3=1，-5/3=-1；\tans2 = c % d; // 取余运算要求运算对象均为整数，即整型。\treturn 0;} 应当注意， ++i 和 i++ ， --i 和 i-- 是两回事。 // test2.c//以下例子可能理解更加深刻#includestdio.hint main(){\tint i,j; i = 1;\ti++; //i使用后，使i的值加一,此时 i=1；\tj = i; // j=i=2; i = 1;\t++i; //i使用前，使i的值加一,此时 i=2；\tj = i; // j=i=2; i = 1;\ti--; //j使用后，使i的值减一，此时 i=1；\tj = i; //j=i=0; i = 1;\t--i; //j使用前，使i的值减一，此时 i=0；\tj = i; //j=i=0;\treturn 0; } 3.3.2 关系运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真 A == B != 检查两个操作数的值是否相等，如果不相等则条件为真 A != B 检查左操作数的值是否大于右操作数的值，如果是则条件为真 A B 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 A B = 检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。 A = B = 检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。 A = B 3.3.3 逻辑运算符 运算符 描述 实例 逻辑与运算符，如果两个操作数都非零，则条件为真。 A B \\|\\| 逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真 A \\|\\| B ! 逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !A 3.3.4 位运算符 位运算符是对数据转化为二进制，再逐位进行运算。如6010=00111100260_{10} = 00111100_{2}6010​=001111002​，再对每一位进行逻辑运算。 运算符 描述 实例 按位与运算符，对两个操作数的每一位执行逻辑与操作 A B \\| 按位或运算符，对两个操作数的每一位执行逻辑或操作 A \\| B ^ 按位异或运算符，对两个操作数的每一位执行逻辑异或操作 A ^ B ~ 按位取反运算符，对两个操作数的每一位执行逻辑取反操作 ~A 将操作数的所有位向左移动指定的位数。左移n位相当于乘以2的n次方 A n 将操作数的所有位向右移动指定的位数。右移n位相当于除以2的n次方 A n // bit.c#include stdio.h int main(){ unsigned int a = 60; /* 60 = 0011 1100 */ unsigned int b = 13; /* 13 = 0000 1101 */\tint c = 0; c = a b; /* 12 = 0000 1100 */ printf(\"c 的值是 %d \", c ); // 一个输出的函数 c = a | b; /* 61 = 0011 1101 */\tprintf(\"c 的值是 %d \", c ); c = a ^ b; /* 49 = 0011 0001 */\tprintf(\"c 的值是 %d \", c ); c = ~a; /*-61 = 1100 0011 */\tprintf(\"c 的值是 %d \", c ); c = a 2; /* 240 = 1111 0000 */\tprintf(\"c 的值是 %d \", c ); c = a 2; /* 15 = 0000 1111 */\tprintf(\"c 的值是 %d \", c );\treturn 0;} 3.3.5 赋值运算符 运算符 描述 实例 = 把右操作数的值赋给左操作数 C = A + B += 把右边操作数加上左边操作数的结果赋给左边操作数 C += A 相当于 C = C + A -= 把右边操作数减去左边操作数的结果赋给左边操作数 C -= A 相当于 C = C - A *= 把右边操作数乘以左边操作数的结果赋给左边操作数 C *= A 相当于 C = C * A /= 把右边操作数除以左边操作数的结果赋给左边操作数 C /= A 相当于 C = C / A %= 把右边操作数取余左边操作数的结果赋给左边操作数 C %= A 相当于 C = C % A = 左移且赋值运算符 C = A 相当于 C = C A = 右移且赋值运算符 C = A 相当于 C = C A = 按位与且赋值运算符 C = A 相当于 C = C A ^= 按位异或且赋值运算符 C ^= A 相当于 C = C ^ A \\|= 按位或且赋值运算符 C \\|= A 相当于 C = C \\| A 赋值运算符参与的表达式中，赋值表达式返回赋值符号右边的值。 3.3.6 其他运算符 条件运算符 （? : ） ：其形式为 (表达式1)? 表达式2 : 表达式3 ，先求解表达式1，若其值为真（非0）则将表达式2的值作为整个表达式的取值，否则（表达式1的值为0）将表达式3的值作为整个表达式的取值。 // test.c#includestdio.hint main(){\tint i = 9, o = 6, q;\ti o ? i : o;\t// i大于o吗，大于（真）则返回i的值，小于（假）则返回o的值。\treturn 0;} 逗号运算符 , ：其形式为 表达式1,表达式2 ，逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果，而左操作数只是当作副作用被计算，其值和类型不会被返回。 // test.c#includestdio.hint main(){\tint i = 9, o = 6, q;\tq = (i + o, i - o);\t// q = 3\treturn 0;} 指针运算符 和 * 。 * ：取值符，指向一个变量； ：取地址符，取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象。 成员运算符 . 和 - 。用于返回复杂数据类型的子成员。 下标运算符 [] 。用于访问下标，在数组中用到。 求字节运算符 sizeof() 。返回变量的大小，将需要求字节内存的变量或其他数据结构放于括号中。 强制类型转换运算符 (类型名)(表达式) 。 如 (float)(a + b) 。 3.3.7 运算符优先级 3.4 语句 控制语句 //条件语句if(条件) //如果小括号里面的条件为真，则运行大括号的语句。{ …… } //循环语句for(语句1;语句2;语句3) //语句2为条件，为真则运行大括号的语句，直至条件为假{ …… }//注意，小括号内必须得有两个分号，即使没有语句 //循环语句while(条件) //如果小括号的条件为真，则运行大括号的语句，直至条件为假{ …… }do{ …… }while(条件); //如果小括号的条件为真，则运行大括号的语句，直至条件为假// 注意，while(…){…}和do{…}while;的区别是，do-while至少循环一次，无视条件真或假。 continue;//用于循环语句//作用是结束该次循环，转至下一次循环，不改变总循环次数break;//用于循环语句或者switch语句//作用是结束整个循环，改变总循环次数 //条件语句switch (对象){ case 值1: 语句1 break; case 值2: 语句2 break; default: //default表示除以上case之外的情况 语句3 break;}//该语句每个case中的break不可省略。//若省略break则系统会一直往下读语句，直至结束或者break，可自行上机作死 return ……;//从函数中返回语句，一般情况下返回语句也是函数结束的地方 //转向语句goto a; number = 0;a: number = 1;//结果number为1; //声明一处标记为a，使用goto语句使程序转向a处； 函数调用语句：右一个函数调用加分号构成。 复合语句：用 {} 括起来的语句，也称语句块。 空语句：只有一个分号。 表达式语句：一个表达式加上一个分号构成。用C语言运算符将运算对象连接起来的式子称为表达式。 3.5 变量的作用范围 任何一种编程中， 作用域 是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。 C语言中有三个地方可以声明变量： 在函数或块（由花括号包括起来的称为代码块）内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义中 变量按作用范围可分为 局部变量 、 全局变量 、 形式参数 。 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。 // test.c#include stdio.hint main(){\t// 局部变量声明\tint a, b;\tint c; // 实际初始化 a = 10;\tb = 20;\tc = a + b; printf (\"value of a = %d, b = %d and c = %d \", a, b, c);\treturn 0;} 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。也就是说，全局变量在声明后整个程序中都是可用的。 #include stdio.h// 全局变量声明int g;int main (){\t// 局部变量声明\tint a, b; // 实际初始化\ta = 10;\tb = 20;\tg = a + b; printf (\"value of a = %d, b = %d and g = %d \", a, b, g);\treturn 0;} 形式参数 函数的参数就是形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用，同样如果局部变量与全局变量同名时优先使用当前区域的局部变量。 // test.c#include stdio.h// 全局变量声明int a = 20;int main(){\t// 在主函数中的局部变量声明\tint a = 10;\tint b = 20;\tint c = 0;\tint sum(int, int); printf (\"主函数中的 a = %d \", a);\tc = sum(a, b);\tprintf (\"主函数中的 c = %d \", c);\treturn 0;} // 添加两个整数的函数int sum(int a, int b){\tprintf (\"sum函数中的 a = %d \", a);\tprintf (\"sum函数中的 b = %d \", b);\treturn a + b;} 输出结果：主函数中的 a = 10sum函数中的 a = 10sum函数中的 b = 20主函数中的 c = 30 全局变量与局部变量在内存中的区别 全局变量保存在内存的全局存储区中，占用静态的存储单元； 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 局部变量和全局变量的初始化 当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示： 数据类型 初始化默认值 int 0 char \\0 float 0 double 0 pointer（指针） NULL Ⅳ —— 格式化输入输出 格式化的输入输出函数位于 stdio.h 头文件中。 4.1 格式化的输出 printf()函数进行格式化的输出，其函数定义如下： int printf(const char *fmt, ...);// fmt：为常量字符串,存储在内存的常量字段，fmt为该字符串首地址；// ...表示存在可变形参// 输出正确返回输出的字符总数，输出错误返回负值 也可以参考这样的格式： printf(格式控制,输出表列) // printf.c#includestdio.hint main(){\tint a = 1, b = 2, c = 3;\tprintf(\"%d %d %d \", a, b, c);\treturn 0;} 输出结果：1 2 3 格式控制，是使用双引号括起来的一个字符串，称为格式控制字符串，包括格式声明和普通字符。 格式声明，由 %（百分号）和格式字符组成，其作用是将输出的数据转换为指定的格式后输出。格式声明总是由 % 字符开始。 普通字符，即原样输出的字符，包括逗号、空格等。 应当注意的是： 当我们想在显示器输出一个 % 时，我们需要在格式控制字符串中连续使用两个 % 表示一个 % 。 当我们想在显示器输出一个 \\ 时，我们需要在格式控制字符串中连续使用两个 \\ 表示一个 \\ 。 对于格式字符，有如下： 格式字符 说明 d 或 i 以带符号的十进制输出整数（正数不带符号） ld 或 lld 数据类型为 long int 或 long long int 的输出 o 以无符号的八进制输出整数（不输出前导 0） x 或 X 以无符号的十六进制输出整数（不输出前导符 0x ） u 以无符号的十进制输出整数 c 以字符形式输出一个字符 s 输出一整个字符串，直至遇到 \\0 f 以小数形式输出单精度数，默认输出6位小数 lf 以小数形式输出双精度数，默认输出6位小数 e 或 E 以指数形式输出实数 g 或 G 选用 %f 或 %e 中宽度较短的格式，不输出无意义 0 PS：正常来说，一个数字的前面加 0 ，表示该数字为八进制。上述中不输出前导 0 ，但当格式为 %#o 时，输出前导 0 ；一个数字的前面加 0x ，表示该数字为十六进制。上述中不输出前导符，但当格式为 %#x 时，输出前导 0x 。 输入下面的代码可以直观感受输出的格式问题：会因为格式字符与输出的数据类型不匹配而导致输出乱码。 // test.c#includestdio.hint main(){\tint a = 1;\tfloat b = 3.1415926535; double c = 3.1415926535;\tlong int d = 1e9;\tlong long int e=1e18;\tprintf(\"%d\\t\\t%ld\\t\\t%lld\\t\\t%f\\t%lf \", a, a, a, a, a);\tprintf(\"%d\\t%ld\\t%lld\\t%.8f\\t%.8lf \", b, b, b, b, b);\tprintf(\"%d\\t%ld\\t%lld\\t%.8f\\t%.8lf \", c, c, c, c, c);\tprintf(\"%d\\t%ld\\t%lld\\t%f\\t%lf \", d, d, d, d, d);\tprintf(\"%d\\t%ld\\t%lld\\t%f\\t%lf \", e, e, e, e, e);\treturn 0;} 运行结果：1 1 4294967297 0.000000 0.0000001610612736 1074340347 4614256656748904448 3.14159274 3.141592741413551940 1074340347 4614256656551843652 3.14159265 3.141592651000000000 1000000000 4294967297000000000 3.141592 3.141593-1486618624 232830643 1000000000000000000 0.000000 0.000000 应该清晰格式字符，不乱用不混用。 输出表列的数量需与%d（或其他格式声明）的数量一致。 %f 默认保留6位小数，而 %m.nf 可以自定义小数位，m指输出宽度，n指保留小数位。如果想用 0 控制宽度，在宽度控制数字前加 0 可以这么使用 %06d 、%07.2f ，但只能补前导 0 。而单独的 %.nf 就可以控制输出的小数位。 当m前面添加 - ，则输出数据向左对齐，再补空格或 0 。当m前面无 - ，则输出数据向右对齐，再补空格或 0 ，此时称前导空格或前导 0 。 如 %7.2f ，表示输出数据占7列（小数点也占一列），保留2位小数。运行以下代码可深刻理解： // test.c#includestdio.hint main(){\tfloat a = 3.141592;\tprintf(\"|%07.2f| \", a);\tprintf(\"|%-07.2f| \", a);\treturn 0;} 运行结果：|0003.14||3.14 | 由 %f 拓展， %d 等格式声明都可在 % 和格式字符之间加一个数字（正或负），表示控制整个输出所占宽度，如 %7d 、 %4c 等。 如果事先并不知道保留多少小数位，而是后续输入的情况，可以使用占位符 %.*f 解决。 // test.c#includestdio.hint main(){\tfloat a = 3.1415926;\tint k;\tscanf(\"%d\", k); // 根据输入的k决定保留多少位小数\tprintf(\"%.*f\", k, a);\treturn 0;} 另外， printf() 函数在运行时的形参是 从右到左 处理，具体效果如下： // test.c#include stdio.h int main() { int a = 5, b = 2; printf(\"%d %d \", b = a + 1, a += 1); return 0;} 输出结果:7 6 由于是 从右到左 的顺序处理，所以先是 a += 1 ，a变成6，再接着 b = a + 1，b变成7。 putchar()：输出一个字符 函数原型： int putchar(int _Character) ，函数定义在 stdio.h 中。 puts()：输出一个字符串，并换行 函数原型： int puts(const char *s); ，函数定义在 stdio.h 中。 // test.c#includestdio.hint main(){\tchar a = 'a';\tputchar('!');\tputchar(a);\tputs(\"Hello World!\");\treturn 0;} 运行结果：!aHello World! 4.2 格式化的输入 用 scanf() 函数进行格式化的输入，其函数定义如下： int scanf(const char * restrict format,...);// 第一参数为输入格式字符串，省略号表示存在可变形参// 输入成功返回成功读入的数据项数，输入数据时遇到了结束则返回EOF（End Of File）。 也可以参考这样的格式： scanf(格式控制，地址表列)；。格式控制字符串同输入的规则。在使用 scanf() 的时候，我们应当注意， scanf() 函数的地址表列是需要输入的变量地址，而不是变量名，因此，我们要在变量名前加 取地址符。如： scanf(\"%d %d %d\", a, b, c); //此写法错误scanf(\"%d %d %d\", a, b, c); //此写法正确 当我们不加取地址符的时候，程序会因为储存内存溢出（输入的内容没有正确的地方存放）而终止程序。因此，当我们的程序莫名中断崩掉时，我们可以优先考虑是否在输入时加取地址符。 从另一个角度理解，对于函数而言，我们希望输入一个值，也就是修改变量里面的值，应当传入其地址，而不是直接传入值。 还需要注意的是， scanf() 的格式控制字符串应与我们输入的格式严格一致，即格式控制字符串中有逗号或空格等的时候，我们输入也需加上逗号或空格等。如： scanf(\"%d %d %d\", a, b, c);//此时应当输入 1 2 3scanf(\"%d,%d,%d\", a, b, c);//此时应当输入 1,2,3 如果没有留意到这个问题，那么当我们输入数据的时候，可能会出现数据吞没的情况，因为输入的跟字符串规定的不匹配，不读入。 该函数还有自动处理的地方，如 当我们的输入格式控制为 %d%d%d 时，系统会自动把空格或者换行（回车）作为分隔两个数据的标志。 当我们的输入格式控制为 %f%f%f 时，系统会自动把小数点、空格或者换行（回车）作为分隔两个数据的标志。 // test.c#includestdio.hint main(){\tfloat a, b;\tscanf(\"%f%f\", a, b);\tprintf(\"%f %f \", a, b);\treturn 0;} 运行窗口：3.142.77 //输入3.142000 0.770000 //输出 虽然系统会自动把空格作为分隔两个数据的标志而不读入空格，但是总有办法可以使得 scanf() 函数输入带空格，如下代码： // getstring.c#include stdio.hint main() {\tchar a[20]; // 存放字符串\tscanf(\"%[^ ]\", a); // 可输入带空格的字符串\tprintf(\"%s \", a);\treturn 0;} 实际上， scanf() 函数的注意点与其的键盘缓冲区和输入流有关。该函数会从输入流中选择数据放入键盘缓冲区中。在未输入满前忽略掉空白字符（空格、制表符和新行符），在输入满时把空白字符当作中断的标志。所以要注意反思输入流和键盘缓冲区里面的内容是什么，是否有键盘缓冲区遗留问题导致提前终止输入，是否有数据仍在输入流中没有进入键盘缓冲区而丢弃等。 getchar()：输入一个字符 函数原型： int getchar(void); ，返回值则是输入的字符的ASCII码，若读取失败返回EOF或-1，函数定义在 stdio.h 中。 // test.c#includestdio.hint main(){\tchar b;\tb = getchar();\tputchar(b);\treturn 0;} 运行窗口：h\t// 输入h\t// 输出 gets()：输入一个字符串，一般使用 scanf() 输入字符串的时候不能输入含空格的字符串，而使用 gets() 则可以输入含空格的字符串。 由于 gets() 函数的不安全性，在C99标准中，已经不再建议使用该函数，而在C11中更是直接抛弃了这个函数。 Ⅴ —— 条件结构 实际上，在很多情况下，需要根据某个条件是否满足来决定是否执行指定操作任务，或者从给定的两种或多种操作选择其一。这就是选择结构需要解决的问题。再举个详细的例子，当我们处于岔路时，做出方向的选择；比如数学上的分段函数，条件不同对应函数关系不同。 通过条件结构，可以完成一些简单的语法题，如交换两个数，输出两数最大值和最小值，由键盘输入三个数输出最大值，判断闰年…… 条件的真假如果对应到数字上，0为假，非0为真，即正负数都为真。 5.1 if构成的条件结构 if 语句的结构如下： if( condition is true ) { sentence1; sentence2; …………}//先简单地翻译一遍以上代码：如果（ 某个条件成立 ），则运行花括号中的内容。 需要注意， if 语句在没有花括号的情况下，只连带其后的一句语句。即 if(condition) 后只能跟一个语句，其可以是单个简单语句，也可以是由花括号包含起来的复合语句。 再加之 else （另外，否则），可以组成以下三种形式： // 情况一，无else子句部分，只有单个if语句if( condition ){\tsentence;} // 情况二，有else子句部分if( condition ){\tsentence1;} else{\tsentence2;} // 情况三，在else部分又嵌套多层if语句if( condition ){\tsentence1;} else if( condition1 ){\tsentence2;} else{\tsentence3;}// 情况三还可以写成下面的形式if( condition ){\tsentence1;} else {\tif( condition1 )\t{ sentence2;\t} else\t{ sentence3;\t}} if 语句无论写几行，都是一个整体，属于同一个语句，只是将其分成 if 部分和 else 部分。在 if 语句中要对给定的条件进行检查，判定所给定的条件是否成立。判断的结果是一个逻辑值“是”或“否”。 if 语句小括号中的 condition ，应该是由关系运算符与逻辑运算符构成的表达式，运算符号详见运算符。如表达x大于1时写成 x1 ，表达x在10到20之间时写成 x =10 x = 20 ，表达x不等于4时写成 x != 4 ，表达x等于4时写成 x == 4 。可以试着巧妙应用 ? : 三目运算符转化繁琐的if结构。 下面结合一个例子剖析 if-else 语句，在数学中有阶跃函数（分段函数），当x＞0时，y＝1；当x＝0时，y＝0；当x＜0时，y＝-1。 // test.c#include stdio.h //声明头文件int main() {\tint x, y; //定义x和y变量\tscanf(\"%d\", x); //输入x\tif(x 0) //第一个判断，做x＞0的判断\t{ y = 1;\t} else if( x == 0 ) //排除第一个判断后的另外一个判断，做x＝0的判断\t{ y = 0;\t} else if( x 0 ) //排除以上两种情况后的另一种情况，做x＜0的判断\t{ y = -1;\t} //其实这种情况下，排除以上两种情况，剩下唯一的可能，可以写成else部分\t//如：\t// else\t// {\t// y = -1;\t// } printf(\"%d\", y); //输出y\treturn 0;} if 语句可以多个嵌套， if 中又带有 if-else 等情况，请注意辨识。应当注意 if 与 else 的配对关系。 else 总是与它上面最近的未配对的 if 配对， else 一般不能单独出现，上面必须先有 if 部分。上面的例子用 if 语句嵌套可如下表示： // test.c#include stdio.h //声明头文件int main() {\tint x, y; //定义x和y变量\tscanf(\"%d\", x); //输入x\tif(x = 0) //将大于等于零归为一类\t{ if(x 0)//再判断大于0的情况 y = 1; else //在x大于等于零的情况下，再排除x大于零，即x等于零 y = ; }\telse //排除x大于等于零的情况下，即x小于零 y = -1; printf(\"%d\", y); //输出y\treturn 0;} 5.2 switch构成的条件结构 switch 语句的结构如下： switch (object) //对于某个变量或表达式进行switch{\tcase constant1: //对于常量1的情况，进行语句 //操作部分语句 break; //注意break必须存在\tcase constant2: //对于常量2的情况，进行语句 //操作部分语句 break; //注意break必须存在\tdefault: //对于默认情况，即排除上述情况，进行语句 //操作部分语句 break; //注意break不必存在，建议存在} 在此强调， switch 语句中 case 情况部分的 break 语句必须存在，此为语法规定。当去掉 break 语句时，系统将逐句往下运行。更具体地说，如果 switch 时 case 情况1的话，你想运行情况1部分的语句，但因为缺少 break 语句，系统还会运行下面 case 情况的语句，造成逻辑表达上的错误。可以对下面的代码中每个 break 试着取消注释，让其运行，观察系统运行语句输出区别。 // test.c#include stdio.h //声明头文件int main() {\tint object = 1, sum = 0;\tswitch(object) { case 0 : sum = 0; //break; case 1 : sum = 1; //brea; case 2 : sum = 2; //break; default : sum = -1; //break;\t}\tprintf(\"%d\", sum);\treturn 0;} switch 语句的对象应该是 整型和字符类型的变量或变量表达式 ，如 int 变量 number 、 char 变量 ch 、 number%10 、 ch+32 ……相对于的 case 情况应该是整型常量或者是字符常量。如整数1、2、3……和字符’A’、‘B’、‘c’…… 对于 switch 语句，还有以下规则说明。操作部分语句可以不止一个语句，其一直运行到 break 语句为止。可以没有 default 的情况，但此时如果没有与 switch 表达式相匹配的 case 常量时，不执行任何语句。 case 情况出现的次序不影响执行结果，每个 case 情况常量必须互不相同，不能存在一个值有多种执行情况。 这里有一个例子，对于输入分数，输出分数评级，可以辅助理解： // test.c#include stdio.h //声明头文件int main() {\tint score ; //输入分数score，此处人为规定输入值在0到100之间 char grade ; //输出分数评级，由'A'到'E' scanf(\"%d\" , score ) ; //输入分数 switch( score / 10 ) //对分数除以十，即判断十位的情况，如80分到90，除以十为8 { case 10: grade = 'A' ; break ; case 9: grade = 'A' ; break ; case 8: grade = 'B' ; break ; case 7: grade = 'C' ; break ; case 6: grade = 'D' ; break ; default: grade = 'E' ; break ; }\tprintf(\"Your grade is %c . \" , grade ) ;\treturn 0;} switch 语句也是可以嵌套的，但结构上比较繁琐。 Ⅵ —— 循环结构 有时候用条件结构还是不能简便解决问题，还需要使用循环结构，如处理求多个整数的和、处理多个判断。 再如在输入的时候，我希望输入50个数字，我们可以复制粘贴50句 scanf() 来实现这个要求。学了循环之后，至少，不再需要50句语句。 需要注意的是， 循环语句一定要设置终止条件，否则将进入死循环，无法得出结果！！！ 通过循环结构，可以完成一些简单的语法题，如判断一个数是否为素数，计算斐波那契数列，计算阶乘…… 6.1 while构成的循环结构 while 语句的一般形式如下： while( condition is true ) {\tsentences;\t……………………\t//花括号内的内容总称为循环体} 此处 condition 为表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。循环体可以是一条语句，也可以是一个语句块（用花括号包起来）。 while 循环的特点是先判断条件表达式，后执行循环体语句。 while 语句的运行顺序是：从上至下，先判断条件表达式是否为真，为真则执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。 这里给出一个例子，求1到100的和，希望通过例子更好理解 while 循环： 分析此问题，将100个数相加，要重复进行100次加法，显然是需要循环结构介入。有兴趣的可以尝试画画流程图（此处不做介绍）。 // add-100-number.c#include stdio.h //声明头文件 int main(){\tint i = 1; //初始化循环变量，从1开始 int sum = 0; //用来存求和的值 while(i = 100) { sum += i; //相当于sum=sum+i，求和 i ++; //i自增，实现从1到2到3到……100 }\tprintf(\"sum = %d \", sum); //输出求和的值 return 0;} while 括号里的 condition 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。 6.2 do-while构成的循环结构 do-while 语句。其一般形式如下： do {\tsentences;\t……………………\t//花括号内的内容总称为循环体} while(condition is true); //注意这有一个分号 此处 condition 为表达式，道理同上。 do-while 循环的特点是先无条件执行循环体，然后判断循环条件是否成立。即 do-while 循环至少进行一次循环，注意与 while 语句区分。 do-while 语句的运行顺序是：从上至下，先无条件执行一次循环体，再判断条件表达式是否为真，为真则回到循环体开始重新执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。 此处同样解决上面的问题，从1加到100求和。 // add-100-number.c#include stdio.h //声明头文件 int main(){\tint i = 1; //初始化循环变量，从1开始 int sum = 0; //用来存求和的值 do\t{ sum += i; //相当于sum=sum+i，求和 i ++; //i自增，实现从1到2到3到……100 } while(i = 100);\tprintf(\"sum = %d \", sum); //输出求和的值 return 0;} while 括号里的 condition 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。 6.3 for构成的循环结构 for 语句的一般形式如下： for( sentence1; condition; sentence2 ){\tsentences3\t…………………………\t//花括号内的内容总称为循环体} 此处 sentence1 和 sentence2 为普通表达式， sentence1 只执行一次，而 sentence2 在每次执行完循环体后都会运行一次。 condition 为条件控制表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。 for 语句的运行顺序是：先进行一次 sentence1 ，接着判断 condition 是否为真，为真则执行循环体。循环体运行完后执行 sentence2 。然后再次判断 condition ，一直循环直至条件为假。 所以延展出常用的 for 语句使用格式： for(循环变量赋值初始化; 循环条件; 循环变量变化){ 循环体} 做个补充，在老版本的C语言中， sentence1 不支持声明变量并同时初始化，如： for(int i = 1; i = 100; i ++) 。但是在C99版本后是允许的。 事实上， for 语句中的 sentence1 语句、 sentence2 语句和 condition 语句并非必要。即这三句语句可以省略，省略 condition 语句默认为真，写成 for( ; ; ) ，但是两个分号绝不可少。在省略掉这三句语句时，我们仍要思考如何终止循环。例如在 for 语句上面就把变量初始化，在循环体中设置判断 if 什么条件就终止循环，在循环体中处理条件变化…… 6.4 循环的终止与继续 使用 break 语句终止循环。 之前使用 break 语句，可能是条件结构中跳出 switch 语句。实际上， break 语句还可以用来跳出循环体，即终止循环。 以求1到100和的例子，假如我希望在和刚好大于等于2500的时候结束，并想知道此时是多少个数的和，那怎么实现呢？ // use-break.c#include stdio.h //声明头文件 int main() {\tint i, sum = 0;\tfor(i = 1; i = 100; i ++) { sum += i; if(sum = 2500) //当sum大于等于2500 break; //终止所在的一层for循环 }\tprintf(\"sum = %d, and now i is %d \", sum, i);\treturn 0;} 当然也可以这样解决： // use-for.c#include stdio.h //声明头文件 int main() {\tint i, sum = 0;\tfor(i = 1; sum 2500; i ++) { sum += i;\t}\tprintf(\"sum = %d, and now i is %d \", sum, i);\treturn 0;} 注释中我写到，终止 break 所在的一层 for 循环，因为当有多个循环嵌套时， break 不会终止所有的循环，而是一层循环。（可以自己做实验研究） 使用 continue 语句跳过本次循环。 有时候不希望终止整个循环，而是想结束这一次循环，还得执行下次循环。这时可以使用 continue 语句。 还是求1到100和的例子，但我希望求1到100中是偶数的和，那么奇数就没必要加进去，此时可以使用 continue 语句跳过本次循环。 // Find-the-sum-of-even-numbers-from-1-to-100.c#include stdio.h //声明头文件 int main() {\tint i, sum = 0;\tfor(i = 1; i = 100; i ++) { if(i % 2 == 1) //当i为奇数，即除于2余数为1 continue; //结束本次循环 sum += i; }\tprintf(\"sum = %d \", sum);\treturn 0;} 需要注意的是，结束本次循环并不是完全不进入循环，而是不执行 continue 下面的循环体部分。上面的代码，如果 sum += i 在 continue 的上面，结果还是会加上奇数的部分。 Ⅶ —— 枚举 枚举是C语言中的一种基本数据类型，用于定义一组具有离散值的常量。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。 定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从0开始递增。 枚举语法定义格式为： enum　枚举名　{枚举元素1,枚举元素2,……}; 举个例子，一周有7天，如果想将星期一映射为数字1，星期天映射为数字7，我们可以使用枚举。 enum Day{\tMON=1, TUE, WED, THU, FRI, SAT, SUN};// MON映射到1，后面的会自动递增// 效果跟#define MON 1 等一样 如果想让星期三之后特殊一些，星期三映射到8，星期天映射到12，只需在中间添加赋值即可。 enum Day{\tMON=1, TUE, WED=8, THU, FRI, SAT, SUN};// MON映射到1，TUE映射到2，WED映射到8，后面的会自动递增 使用时直接输出即可： printf(\"%d\", MON); 然而上面是对枚举类型的使用，下面介绍枚举变量的定义和使用。 枚举类型是一种数据类型，可以对标 int 理解；枚举变量是一个变量，可以对标 int number 中的 number 理解。 可以通过三种方式定义枚举变量： 先定义枚举类型，再定义枚举变量 enum DAY{\tMON=1, TUE, WED, THU, FRI, SAT, SUN};enum DAY day; 定义枚举类型的同时定义枚举变量 enum DAY{\tMON=1, TUE, WED, THU, FRI, SAT, SUN} day; 省略枚举名称，直接定义枚举变量 enum{\tMON=1, TUE, WED, THU, FRI, SAT, SUN} day; 给出使用枚举变量的情形： // test.c#include stdio.henum DAY{ MON=1, TUE, WED, THU, FRI, SAT, SUN}; int main(){ enum DAY day; day = WED; printf(\"%d\", day); return 0;} 在 枚举类型值连续 的情况下还可以进行循环： // test.c#include stdio.henum DAY{ MON=1, TUE, WED, THU, FRI, SAT, SUN} day;int main(){ // 遍历枚举元素 for (day = MON; day = SUN; day++) { printf(\"枚举元素：%d \", day); } return 0;} 如果将将整数转换为现有枚举值，只需强制类型转换： // test.c#include stdio.hint main(){ enum day { saturday, sunday, monday, tuesday, wednesday, thursday, friday } workday; int a = 1; enum day weekend; weekend = ( enum day ) a; //类型转换 //weekend = a; //错误 printf(\"%d\",weekend); return 0;} 输出结果： Ⅷ —— 数组 数组是一种可以存储固定大小的相同类型元素的顺序集合。简单来说，数组可以存放一串相同的数据类型。 8.1 数组结构 数组的结构如下图： 数组的每一个单体称作 元素 ，每个元素有它的 索引号 ，用于访问该元素。 索引号从0开始。 8.2 数组的定义和访问 数组的定义十分简单，其定义格式是： type arrayName [arraySize]; 如 int array[5]; 就定义了一个大小为5的整型数组，数组名为array，它可以存放5个整型数据，索引号从0到4。 访问数组时直接使用 arrayName[index] 的方式进行，如 array[0] 就是array数组的第一个元素的值。使用循环还可以将数组的内容输出： // test.c#include stdio.hint main(){\tint i;\tint array[5]; // 访问数组并赋值 for(i = 0; i 5; ++ i) array[i] = i + 1; // 访问数组并输出 for(i = 0; i 5; ++ i) printf(\"%d \", array[i]); return 0;} 补充个冷知识，我们比较经常使用 array[0] 访问元素，实际上还能以 0[array] 的方式访问元素。 8.3 数组的初始化 通过上面的例子，我们可以通过循环给数组中的每个元素赋值。但是还可以通过声明时的初始化语句进行相同的操作。 int array[5] = {1, 2, 3, 4, 5}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。即等价于： int array[] = {1, 2, 3, 4, 5}; 8.4 多维数组 C 语言支持多维数组。多维数组声明的一般形式如下： type name[size1][size2]...[sizeN]; 下面以二维数组作为示例。一个二维数组，在本质上，是一个元素为一维数组的数组。定义形式如下： type arrayName [x][y]; 如一个二维数组初始化如下： int array[3][4] = { {1, 2, 3, 4} , /* 初始化索引号为 0 的行 */ {5, 6, 7, 8} , /* 初始化索引号为 1 的行 */ {9, 10, 11, 12} /* 初始化索引号为 2 的行 */}; 二维数组中的元素是通过使用下标（即数组的行索引和列索引）访问。 // test.c#include stdio.h int main (){\t// 一个带有 5 行 2 列的数组\tint a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};\tint i, j; // 输出数组中每个元素的值\tfor (i = 0; i 5; i++)\t{ for (j = 0; j 2; j++) { printf(\"a[%d][%d] = %d \", i, j, a[i][j]); }\t}\treturn 0;} 8.5 数组的使用 求数组长度：使用 sizeof 关键字，将整个数组占的内存大小除以每个元素占的内存大小，得到的就是元素个数。 int numbers[] = {1, 2, 3, 4, 5};int length = sizeof(numbers) / sizeof(numbers[0]); 将数组作为函数参数传入 形式参数是一个已定义大小的数组 void fun(int param[10]){\t// ……} 形式参数是一个未定义大小的数组 void fun(int param[]){\t// ……} 为了函数的通用性，通常使用未定义大小的数组，再将数组大小作为第二参数传入。 double getAverage(int arr[], int size) // 求数组的平均值{\tint i;\tdouble avg;\tdouble sum;\tfor (i = 0; i size; ++ i)\t{ sum += arr[i];\t}\tavg = sum / size;\treturn avg;} 需要注意的是，我们传入的是数组，在函数内部中如若有对数组元素的修改，也会同步对外部的数组进行修改。因为此处形式参数是以地址传递的形式传入。 为什么传递数组名字会是以地址传递的形式传入呢？那是因为 数组名实际上是一个指针 ，它存放数组中首元素的地址。至于什么是指针，可查阅下一节。 Ⅸ —— 指针 指针是C语言很重要的一环。 数据都有一个内存空间，内存空间都有一个地址，我们形象地把这个地址称为指针。指针也就是内存地址，指针变量是用来存放内存地址的变量。 9.1 指针变量的定义 指针变量定义的一般形式为： type *var_name; type 是指针的基类型，它必须是一个有效的数据类型， var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的，但在此处的意义是标记改变量是指针变量，称为指针运算符。一个指针对应一个 * 。 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个 代表内存地址的长的十六进制数 。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 当我们需要取一个变量的地址时，我们需要加 （取地址符）；当我们需要取一个指针的数据时，我们需要加 * 。 int a = 1;int *pa = a; 之前使用 scanf() 函数时所加的 ，表明我们是把数据放到某变量名所处的地址，而不是塞到变量名里面。 如果想输出地址的话，可以使用 %p 或 %x 输出： int a = 1;printf(\"%p\", a); 指针使用前必须有初始化值，即定义时必须赋值，若无值则指向NULL。 int *p = NULL; 如果使用前没有初始化值时，该指针会变成 野指针 ，指针指向了一块随机的空间，不受程序控制。有可能是系统重要软件的地址，贸然使用可能使得系统崩溃。 9.2 指针的运算 指针之间不能进行 + 运算，无意义。 指针进行 运算时，表示实际内存高低位的比较； 指针进行 = 运算时，表示把右边的地址赋值给左边； 指针进行 - 运算时，表示在两指针之间相隔相同类型元素的个数。 指针进行 ++ 运算时，表示在指针递增，会指向下一个元素的存储单元。指针在递增时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。 指针进行 -- 运算时，表示在指针递减，会指向上一个元素的存储单元。指针在递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。 9.3 指针的使用 指针间接访问变量 通过指针输出： // test.c#includestdio.hint main(){\tint a = 100, b = 10;\tint *pointer1, *pointer2;\tpointer1 = a;\tpointer2 = b;\tprintf(\"a=%d,b=%d \", a, b); printf(\"pointer1=%d,pointer2=%d \", pointer1, pointer2); printf(\"pointer1=%d,pointer2=%d \", *pointer1, *pointer2);\treturn 0;} 输出结果：a=100,b=10pointer1=6422216,pointer2=6422220pointer1=100,pointer2=10 通过指针将两个变量存放的值交换，用地址传递实现存储空间上的交换。 // swap-ab.c#includestdio.hvoid swap(int *a,int *b){\tint tmp;\ttmp = *a;\t*a = *b;\t*b = tmp;}int main(){\tint x = 1, y = 2;\tprintf(\"x=%d,y=%d \", x, y);\tswap(x, y);\tprintf(\"x=%d,y=%d \", x, y);\treturn 0;} 输出结果：x=1,y=2x=2,y=1 指针引用一维数组 数组名即是该数组首元素（即序号为0的元素）的地址。所以我们可以直接用指针指向数组名，无需取地址符。 int a[10];int *p;p = a; 同时，我们可以对数组首元素进行取地址，即下代码等价： p = a; //p指向数组首元素的地址，即a[0]的地址；p = a[0]; //p指向a[0]的地址 当我们正确把指针指向一个数组的时候，可以对指针进行以下运算： p++ , ++p , p-- , --p , p = p + 1 , p = p - 1 等。 // test.c#includestdio.hint main(){\tint a[5] = {101,102,103,104,105};\tint *p;\tp = a;\tprintf(\"%d \", *p);\tprintf(\"%d \", *(p+1));\tprintf(\"%d\", *(p+2));\treturn 0; } 输出结果：101 102 103 因为数组名也有地址的属性，所以输出语句还可以改成： printf(\"%d \", *a);printf(\"%d \", *(a+1));printf(\"%d\", *(a+2)); 但数组名不能进行自增自减，如不能 a++ 或 a-- 等。 指针还可以引用字符串（字符数组），字符串的本质是一个字符数组。我们可以类似指针引用一维数组那样引用字符串。 // test.c#includestdio.hint main(){ char a[] = \"computer!\"; char *p; p = a; printf(\"%c \", *p); //%c，取*时，具体到某个元素，此处是首元素 printf(\"%c \", *(p + 2)); printf(\"%s \", p); //%s，不取*，从首元素输出所有字符 printf(\"%s \", p + 2); // 从a[2]开始输出所有字符 return 0;} 输出结果：输出结果：cmcomputer!mputer! //以上也可用字符指针变量表示，如下所示：char *p=\"computer!\";//此处可能会出现warning，但无关紧要//上句等价于char *p; p=\"computer!\";printf(\"%s\",p);//此处无需*p，注意对比 char *p=\"computer!\" 的意思是将字符指针变量 p 指到\"computer!\"的首地址即\"c\"的地址。 之前，我们用字符数组也能实现打印字符串，而使用字符指针的不同是： ①可以对字符指针变量赋值，但不能对数组名赋值，初始化不等于赋值，如不能： char a[10] = {\"computer!\"}; //此句合法char a[10]; a = \"computer!\"; //此句不合法 ②储存内容不同，字符数组把每一个元素的值都存放，而字符指针只存放第一个元素的地址。 指针指向二维数组 二维数组有两个下标，那么一个指针怎么指，我们将指针分为 行指针 和 列指针 。行指针，即指向某一行元素的指针；列指针，即指向某一列元素的指针。 下有二维数组 a[4][5] ： 动态数组 像 int a[5]; 这样的定义数组，我们称之为 静态数组 。在程序编译时，静态数组的内存空间就被分配好了，存储在栈上或者全局数据区。静态数组的大小在声明时确定且无法在运行时改变。静态数组的生命周期与其作用域相关。如果在函数内部声明静态数组，其生命周期为整个函数执行期间；如果在函数外部声明静态数组，其生命周期为整个程序的执行期间。 动态数组 是在运行时通过动态内存分配函数（如 malloc 和 calloc ）手动分配内存的数组。动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 malloc 、 calloc 等函数来申请内存，并使用 free 函数来释放内存。动态数组的大小在运行时可以根据需要进行调整。可以使用 realloc 函数来重新分配内存，并改变数组的大小。动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。 int size = 5;int *dynamicArray = (int *)malloc(size * sizeof(int)); // 动态数组内存分配// 使用动态数组free(dynamicArray); // 动态数组内存释放 数组指针 数组指针，其本质是指针，指向一个一维数组的指针。所以定义时，由运算符优先级，我们需要带上小括号 定义数组指针： 类型名 (*指针变量名)[长度]; // test.c#includestdio.hint main(){\tint a[4][5] = { 1,2,3,4,5, 6,7,8,9,10, 11,12,13,14,15, 16,17,18,19,20};\tint (*p)[5];\tp = a+1; // 指向第2行\tfor(int i=0;i5;i++) printf(\"%d \",(*p)[i]);\treturn 0;} 输出结果：6 7 8 9 10 指针数组 指针数组，其本质是数组，是一个元素均为指针类型的数组。 定义指针数组： 类型名 *数组名[长度]; 举例：（将数字转化为对应的英文月份） // test.c#includestdio.hint main(){\tchar *p[13];\tp[1]=\"Januray\"; p[2]=\"February\"; p[3]=\"March\"; p[4]=\"April\"; p[5]=\"May\"; p[6]=\"June\";\tp[7]=\"July\"; p[8]=\"August\"; p[9]=\"September\";\tp[10]=\"October\";p[11]=\"November\"; p[12]=\"December\";\t//可能会警告，但无关紧要\tint n;\tscanf(\"%d\",n);\tprintf(\"%s \",p[n]);\treturn 0;} 运行结果：3 // 输入March // 输出 指向函数的指针 函数名也代表函数的起始地址。 此内容直接看以下例子——比较两个数字的大小 // test.c#includestdio.hint max(int x,int y){\treturn (x y ? x : y);}int main(){\tint a = 50, b = 100;\tprintf(\"max=%d\", max(a, b));\treturn 0;} 上代码等价于： // test.c#includestdio.hint max(int x,int y){\treturn (x y ? x : y);}int main(){\tint a = 50, b = 100;\tint (*p)(int,int);\tp = max;\tprintf(\"max=%d\", (*p)(a,b));\treturn 0;} 注意 int (*p)(int,int)；定义指向函数的指针变量： 类型名 (* 指针变量名)(函数参数表列); 指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数，下附一个使用函数指针的例子； // test.c#includestdio.hvoid fun(int x, int y, int (*p)(int,int)){\tint ans;\tans = (*p)(x,y);\tprintf(\"%d\", ans);}int max(int x,int y){\tprintf(\"max=\");\treturn x y ? x : y;}int min(int x,int y){\tprintf(\"min=\");\treturn x y ? x : y;}int main(){\tint a = 34, b = -21, n;\tprintf(\"请输入你的选择(1-求最大值，2-求最小值)：\");\tscanf(\"%d\", n);\tif(n==1) fun(a, b, max);\tif(n==2) fun(a, b, min);\treturn 0;} 返回指针类型的函数 定义返回指针值得函数形式为： 类型名* 函数名(参数表列); 依然是使用一个例子：对若干学生成绩，找出不合格得课程得学生及其学生号，代码如下： // test.c#includestdio.hfloat* search(float (*pointer)[4])//定义函数{\tint i = 0;\tfloat *pt;\tpt = NULL;\t//切记初始化指针，无则指向NULL\tfor(; i 4; i ++)\t{ if(*(*pointer+i)60) pt = *pointer; //如有不及格，使pt指向score[i][0]\t}\treturn pt;}int main(){\tfloat score[][4] = {{60,70,80,90},{56,89,67,88},{34,78,90,66}};\t//定义数组，初始化成绩，有3名学生，每名学生有4门成绩\tfloat *p;\tint i, j;\tfor(i = 0; i 3; i ++)\t{ p = search(score + i); //调用search函数，如不及格则返回score[i][0]的地址 //否则返回NULL if(p == *(score+i)) //若返回的不是NULL，则输出学生成绩 { printf(\"No.%d score:\",i); for(j = 0; j 4; j ++) printf(\"%5.2f \", *(p+j)); printf(\" \"); }\t}\treturn 0;} 指向指针数据的指针变量 指向指针数据的指针，可以嵌套，如： // test.c#includestdio.hint main(){\tint a = 100;\tint *p;\tp = a;\tint **q;\tq = p;\tprintf(\"%d \", **q);\treturn 0;} 输出结果： Ⅹ —— 共用体与结构体 10.1 共用体 共用体（Union） 是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。 为了定义共用体，必须使用 union 语句。 union 语句定义了一个新的数据类型，带有多个成员。定义格式如下： union [union tag]{\t成员定义;\t成员定义;\t...\t成员定义;} 共用体变量; union tag 是可选的，每个 成员定义 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。 下面定义一个名为 Data 的共用体类型，有三个成员 i 、 f 和 str ： union Data{\tint i;\tfloat f;\tchar str[10];}; 也可以像枚举类型定义枚举类型的同时定义枚举变量一样，定义共用体类型的同时定义共用体变量。 union Data{\tint i;\tfloat f;\tchar str[10];} data; Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。 共用体占用的内存应足够存储共用体中最大的成员。 例如，在上面的实例中，Data 将占用10个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。 使用共用体时，我们需要先创建共用体类型变量，再根据变量访问成员。 union Data data; 为了访问共用体的成员，使用成员访问运算符 . ，如 data.i 、 data.f 、 data.str ，但是在同一时间只能使用一个成员。 10.2 结构体 结构体 与共用体类似，不同的是结构体的成员并列存在，可同时使用。 struct tag{\t成员定义;\t成员定义;\t...\t成员定义;} 结构体变量; tag 是结构体标签，每个 成员定义 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构体定义的末尾，最后一个分号之前，可以指定一个或多个结构体变量，这是可选的。 如： //此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//同时又声明了结构体变量s1//这个结构体并没有标明其标签struct {\tint a;\tchar b;\tdouble c;} s1;//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//结构体的标签被命名为SIMPLE,没有声明变量struct SIMPLE{\tint a;\tchar b;\tdouble c;};//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3struct SIMPLE t1, t2[20], *t3;//也可以用typedef创建新类型typedef struct{\tint a;\tchar b;\tdouble c; } Simple2;//现在可以用Simple2作为类型声明新的结构体变量Simple2 u1, u2[20], *u3; 第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=s1 ，则是非法的。 如果将结构体与基本数据类型做对比的话，举个例子： int a;struct Tag{\tdouble number;};struct Tag b；typedef struct{\tint number;} Tag2;Tag2 c; 那么 int 、 struct Tag 、 Tag2 是对等的，都是数据类型；而 a 、 b 和 c 是同级的，都是变量。 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针。如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示： struct B; //对结构体B进行不完整声明//结构体A中包含指向结构体B的指针struct A{ struct B *partner; //other members;};//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明struct B{ struct A *partner; //other members;}; 为了访问结构的成员，使用成员访问运算符 . 。对于结构体的初始化，可以使用 {} ： //book.c#include stdio.hstruct Books{\tchar title[50]; char author[50]; char subject[100]; int book_id;} book = {\"C 语言\", \"RUNOOB\", \"编程语言\", 123456};int main(){\tprintf(\"title : %s author: %s subject: %s book_id: %d \", book.title, book.author, book.subject, book.book_id);\treturn 0;} 结构体作为函数的参数传入时，传参方式与其他类型的变量或指针类似，如： void printBooks(struct Books b); ，之后在函数里访问成员即可。 可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如： struct Books *struct_pointer;struct_pointer = Book1;struct_pointer-title; // 指针访问成员时 需要注意的是，使用指向该结构的指针访问结构的成员时，必须使用 - 运算符。 使用 sizeof 运算符来计算结构体的大小，这在使用链表时有帮助。 Ⅺ —— 链表 11.1 链表及其构成 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。而这些储存单元需要及时开辟，此时需要使用动态储存分配函数。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的 数据域 ，另一个是存储下一个结点地址的 指针域 。如： struct test{ int num; // 数据域 char name[5]; // 数据域 struct test *next; // 指针域}; 链表还可分为动态链表和静态链表，此处不讨论静态链表，均为动态链表。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。 11.2 内存管理的函数 关于动态储存分配函数有 calloc() 、 malloc() 、 free() 、 realloc() 。他们都存在于 stdlib.h 头文件中。 有的编译系统要求用 malloc.h 头文件而不是 stdlib.h 头文件，实际上这两个头文件都包含以上的动态储存分配函数。 除 free() 函数，其他函数都会返回一定的地址，需要对地址进行强制类型转换，转换为我们所需的数据类型。 函数名 函数原型 功能 返回值 calloc() void *calloc(unsigned n, unsign size) 分配n个大小为size的内存连续空间 成功时返回分配内存的起始地址，不成功返回0 malloc() void *calloc(unsigned size) 分配1个大小为size的储存区 成功时返回分配内存起始地址，内存不足返回0 free() void free(void *p) 释放p所指的内存区 无 realloc() void *calloc(viod *p, unsigned isze) 将p所指的已分配内存区大小改为size，size可大于或小于原来大小 返回指向该内存的指针 11.3 单向链表 单向链表，指针指向单向，连接方向单向，优点是简单，缺点是效率略低。 单向链表是由结点构成，所讨论的单向链表结点如下： struct test{\tint num;\tstruct test *next;}; 链表的创建 //链表创建，返回一个表头headstruct test *creat() {\tstruct test *head;\tstruct test *p1, *p2;\tint n = 0;\tp1 = p2 = (struct test *)malloc(sizeof(struct test)); //开辟一个内存单元\tscanf(\"%d\", p1-num); //输入第一个信息\thead = NULL; //指针必须初始化，无地址则指向NULL\twhile(p1-num != 0) // 设计当输入0时停止创建链表\t{ n += 1; if(n == 1) head = p1; // 当链表为空，即创建的是第一个结点，则使头结点指向p1的地址 else p2-next = p1;\t// 当链表非空，用next指针连接 p2 = p1; // p2指向p1所指的地址，p2为当前链表末尾 p1 = (struct test *)malloc(sizeof(struct test)); //再开辟内存单元，并将起始地址赋值给p1 scanf(\"%d\", p1-num); //循环输入信息\t}\tfree(p1); // 释放最后一个结点，即释放输入为0的结点\tp2-next = NULL; // 链表的末尾指向NULL\treturn head;} 根据上述代码，演示过程如图： 链表的插入 链表的插入思路如图： // 在某链表中插入一个新的由指针引用的结构体struct test *add(struct test *head, struct test *insert){\tstruct test *p0, *p1, *p2;\tp0 = insert; //将新的由指针引用的结构体赋值给p0\tp1 = head;\tif(head == NULL)//判断是否为空链表\t{ head = p0; //是空链表则从头插入，头指针为p0 p0-next = NULL;//后面无新的数据\t}\telse //链表非空，按num排序，找到适合的位置或者到链表末端停下\t{ while((p0-num p1-num) (p1-next != NULL)) { p2=p1; p1=p1-next; } if(p0-num = p1-num) // 找到合适的位置 { if(head == p1) head = p0; else p2-next = p0; p0-next = p1; } else // 找不到合适位置，插入到链表末尾 { p1-next = p0; p0-next = NULL; } } return head; // 返回更新后的链表表头} 链表的删除 链表的删除思路如图： // 在某链表中查找num并删除该结构体，返回更新后的表头struct test *del(struct test *head, int num) {\tstruct test *p1, *p2;\tif(head == NULL) // 判断是否为空链表\t{ printf(\"这是一个空链表 \"); return head;\t} p1 = head;\t// 链表非空，将创建好的链表头指针head赋值给p1\t// 不能直接对表头进行操作，否则变动完之后找不到表头 // 当没匹配到元素或者已经到链表末端，停止循环\twhile(p1-num != num p1-next != NULL) { p2 = p1; // p2指向的是p1的前一个结点 p1 = p1-next; // p1指针遍历链表\t} // 此处寻找元素 if(p1-num == num) // 如果是找到了元素而停止循环的情况\t{ if(p1 == head) { head = p1-next;// 如果删除的是头指针，则将头指针指向下一个，修改表头 free(p1); } else { p2-next = p1-next; // 删除节点，即跳过某结构体直接连向下一个 free(p1); } }\telse printf(\"Not found!\"); // 到链表末端而停止循环的情况，也就是没找到\treturn head;\t// 返回修改后的表头} 链表的查找 思路简单，自行理解代码。 // 在链表中查找值为obj的结构体，找到返回该结构体的指针，找不到返回NULLstruct test *find(struct test *head, int obj){\tstruct test *p, *res = NULL; // res作为返回的结构体\tif(head == NULL)\treturn NULL; // 链表为空返回空 p = head; while(p != NULL) // 遍历链表\t{ if(p-num == obj) // 找到目标 { res = p; break; } p = p-next; // 往下顺延\t}\treturn res;} 链表的输出 思路简单，自行理解代码。 // while循环输出链表void print(struct test *head){\tstruct test *p;\tp = head;\twhile(p != NULL)\t{ printf(\"%d \", p-num); p = p-next;\t}} 11.4 双向链表 双向链表，指针指向双向，连接方向双向。 双向链表是由结点构成，所讨论的双向链表结点如下： struct test{\tint num;\tstruct test *next;\t// 指向后一个结构体\tstruct test *pre;\t// 指向前一个结构体}; 双向链表结构如下图： 至于双向链表的创建，插入，删除，查找，不详细介绍。多一个方向的指针使得该链表可以往前遍历，提高其方便性。 11.5 循环链表 循环链表的首位是相接的，构成一个环。所以还可以分成单向循环链表和双向循环链表。 循环单向链表 循环双向链表 Ⅻ —— 对文件的读写 12.1 打开文件 可以使用 fopen() 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型： FILE *fopen(const char *filename, const char *mode); 函数的第一参数是打开的文件名，常量字符指针类型，也能看成字符串类型；第二参数是打开文件的模式，有如下模式： 模式 描述 r 打开一个已有的文本文件，允许读取文件 r+ 打开一个已有的文本文件，允许读写文件 w 打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入 w+ 打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入 a 打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则在原有内容上追加写入 a+ 打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则在原有内容上追加写入 如果是处理二进制文件的情况，则在原来的基础上加上 b ，如： rb ， wb ， ab ， rb+ ， r+b ， wb+ ， w+b ， ab+ ， a+b 。 打开文件处理完成之后记得关闭文件，使用 fclose() 函数。 int fclose(FILE *fp); 如果成功关闭文件， fclose() 函数返回零，如果关闭文件时发生错误，函数返回 EOF 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。 EOF 是一个定义在头文件 stdio.h 中的常量，上述打开文件函数和关闭文件函数也都在 stdio.h 头文件中。 // test.c#include stdio.hint main(){\tFILE *fp;\t// 文件对象\tfp = fopen(\"test.txt\", \"a+\"); // 打开文件并把文件指针绑定到该文件\tfclose(fp); // 关闭文件} 12.2 写入文件 函数 fputc() ：把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF 。 int fputc(int c, FILE *fp); 函数 fputs() ：把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF 。 int fputs(const char *s, FILE *fp); 函数 fprintf ：把一个字符串写入到文件中。该函数形式与 printf 函数类似，参考 printf 函数使用。 int fprintf(FILE *fp,const char *format, ...) // 两函数比较printf(\"%d%d\", a, b);fprintf(fp, \"%d %d\", a, b); 12.3 读取文件 函数 fgetc() ：从 fp 所指向的输入文件中读取一个字符，返回值是读取的字符，发生错误时返回 EOF 。 int fgetc(FILE *fp); 函数 fgets() ：从 fp 所指向的输入文件中读取n-1个字符，并把字符串复制到 buf 中，最后追加 NULL 终止字符串。该函数如果在读取最后一个字符之前就遇到一个换行符 ‘ ’ 或文件的末尾 EOF ，则只会返回读取到的字符，包括换行符。 char *fgets(char *buf, int n, FILE *fp ); 函数 fscanf() ：从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。该函数形式与 scanf 函数类似，参考 scanf 函数使用，记得添加取地址符 。 int fscanf(FILE *fp, const char *format, ...) // 两函数比较scanf(\"%d%d\", a, b);fscanf(fp, \"%d%d\", a, b);","tags":["C"],"categories":["笔记"]},{"title":"给大一的你","path":"/2023/tofreshman/","content":"如今大二将完，给大一朋友的一些话。 关键词：经验 刚高考完就像是刚解放了一样，有的人安排得忙忙的：把好久没看的纪录片、电视剧、电影看个遍；有的人还不知道干什么，日复一日看手机无聊度过。 在我自己看来，大一的你可以是这样： 广泛阅读，看看文学，看看历史等等； 广泛交友，识得良师益友； 进入一两个社团组织，培养技能，提高能力； …… 大一其实还算处于一种很自由，很空闲的状态。这个时候拥有很多试错的机会，可以去长见识。 如果说你想拼搏努力地度过大一，那就去关注比赛等学术上的活动，同样也是获得经验的过程。如果说你想时而摆烂，不想逼得自己那么紧，那也完全可以，慢慢提升自己。你可以走得很慢，但绝不后退。 趁着大一，我觉得最好是提高广度。更重要的是，你是你，无需别人怎么样你也怎么样。有时候遇到的室友、同学摆烂或者很卷，你可以不受他们影响，自个过自个的。注意，这个观念很简单，做到其实很难。 其实还有一点，大一是视野逐渐开阔的过程，这个过程中也有很多骗子趁机而入，希望能够三思，能够谨慎，能够小心，谨防诈骗。 接着，我想说一些计算机专业相关的建议。其实很多同学大一之前对于计算机的知识是不全面的，更不用说丰富，你可以当作从零开始慢慢积累。 计算机并不是一门单纯地如何如何敲代码的学科，它其实更多是一门综合学科。你不用担心高中怎么偏科带来的影响，你可以先把高中带来的放到一边。 我个人觉得，计算机专业大一应该学习与实践结合，多用电脑，养成计算机的大局观： 学习方面 编程语言：C语言或C++或者Python等其他语言，这是你的基本能力之一，学会一门编程语言之后便可以用计算机语言去解决一些问题。本博客也有部分编程语言的教程，可参考学习。 计算机导论：关于计算机的部分术语和基本内容，开始慢慢了解计算机，便于养成计算机大局观。推荐两个课程，【计算机科学速成课】40集全/精校 - Crash Course Computer Science，【哈佛】计算机科学CS50-哈佛大学 计算机组成原理：关于计算机硬件方面的知识，慢慢知道从最小的逻辑门到整个CPU的组成原理，知道计算机的运作过程。 计算机网络：关于网络方面的知识，慢慢知道不同设备之间的连接通信的协议。 数据结构：关于编程基础的知识，用于进一步处理编程问题。 操作系统：关于计算机硬件和软件之间的内容，慢慢建立系统观念，了解如Windows系统和Linux系统。 上面的这些内容可能大一的时候还没开始学，但是个人大一学是很好的机会。通过对这些方面的了解，会更好地认识计算机这一专业甚至行业。如果跟着学习的话，知识量上、方向上会超过同龄人很多。 还有一些很平常，学校不会怎么教学但很重要的内容： 英语能力：尤其是阅读英语文章的能力，很多先进的理念知识都是由国外引进，直接阅读原文比别人翻译后喂到嘴里的感觉不一样的。很多国内的课程都可以找找国外大学有无网课，锻炼英语的同时也学到了技术。 学会使用Github和Gitee：Github（国外）和Gitee（国内）是较为出名的代码保管仓库，简单来说就是有很多大牛在上面发布他们的代码。 了解编程语言到程序的过程：比如知道C语言是怎么编程可执行文件，知道一些编译的事情。 了解编程工具的配置使用：编程工具的使用，比如Visual Studio，Visual Studio Code、Vim等工具。 养成良好的代码风格习惯：比如代码的格式，何时对齐，何时缩进。 程序项目和文件的管理：对于电脑上的文件敏感，懂得安排位置；对于项目知道大概的方向等等。 实践方面 光有理论还不行，在以上学习之余，也建议多去做一些小东西。哪怕是很简单的程序，哪怕就是一个黑窗口，都可以试着写一遍、运行一遍。有一些很简单的问题可以写程序解决，如一元二次方程求解、斐波那契数列求解等。 刷题：除了学校那一点的计算机作业，刷题是提高计算机代码能力的一个不错的途径，国内比较好的刷题网站有：牛客竞赛、洛谷、力扣Leetcode、Acwing，在刷题的过程中不断解决问题，学习到算法，渐渐找找算法比赛的兴趣。如果实在没有算法也可以保持每日刷个一两题。 比赛方面 算法比赛/程序设计比赛：实际上与算法息息相关，如果你是有兴趣、或者对数学比较热爱，建议全身投入到算法的学习上，参加几个比赛看看成效。 常见的算法比赛有蓝桥杯、ACM等，可以关注学校、学院发布的消息。 其实，大学里计算机的上课并不一定重要，要学会学习，不要盲目上课。如果你觉得老师授课模糊，理解不了，根本不能学习， 上课时就坐到后排，及时上网找网课补救 。学校里的课程考试，考前突击、弄懂作业，一般及格就行（如果你是希望走保研、拿奖学金的方向，那还是得花功夫把考试考好），真正重要的是你是否学习到了知识。 如若你在大一结束时真能了解计算机组成原理、计算机网络、数据结构和操作系统这四门课，恭喜你，这是计算机考研408的专业课，你也比其他人提前了许多，后面做项目的意识也会改变许多。如果自己很忙，大一学不了学不完也无所谓，这本来就是比别人提前的课程。 希望在大一里扩宽自己的认识面，找到自己的发展方向。 最后，如果想和我交流，或者是想要资料，欢迎QQ：1192697361","tags":["经验"],"categories":["经验之谈"]},{"title":"基于YOLOv5的电瓶车识别入门级项目记录","path":"/2023/yolov5/","content":"一次基于YOLOv5的深度学习项目，在GPU服务器完成模型训练，在Windows 10下进行图像识别推理（C++）。 关键词：深度学习、YOLOv5、C++推演、TensorRT、OpenCV 零 —— 前言 此篇博客是我亲手做的一次项目记录（2023.7.3~2023.7.14），在GPU服务器完成基于YOLOv5的模型训练，在Windows 10下将训练得到的权重文件作基本处理转化为.onnx文件和.engine文件分别进行C++下的推理，最后并做了简单界面，效果如下图。 本人学术不精，此篇博客可能会因为一些深度学习上的知识不熟悉而造成的表达错误，此博客只是记录此次项目过程，并尽力使其有参考性、使其可复刻。 项目代码放在码云Gitee仓库 壹 —— 环境准备 本项目需要的环境： Python环境：YOLOv5所需 CUDA环境：调用显卡进行显存加速 OpenCV环境：进行图像处理 我的环境是CUDA12.0，OpenCV4.5.2，训练所用Python3.8.10，本机Windows 10所用Python3.11.4。 下载安装CUDA可参考这篇博客 配置OpenCV和CUDA环境可参考这篇博客。 贰 —— 数据准备 2.1 数据集结构 本项目需要的数据集（不公开）： 校园内电瓶车463张：435张用于训练，28张用于验证 这个数量上和比例上并不良好，也没有设测试集，建议照片尽量多，并按8:1:1的比例分配在训练集、验证集和测试集。 训练集：用于YOLOv5模型调试神经网络；相当于学生的课本，学生根据课本里的内容来掌握知识。 验证集：验证集用来查看训练效果；相当于作业，通过作业可以知道不同学生学习情况、进步的速度快慢。 测试集：用来测试网络的实际学习能力；相当于考试，考的题是平常都没有见过，考察学生举一反三的能力。 数据集的文件结构应如下： dataset|---images| |---train| |---val| |---test|---labels| |---train| |---val| |---test 2.2 处理数据集 使用LabelImg进行对图片标记。或自行搜索使用安装教程。 打标签时，选择YOLO格式，生成的是.txt文件，用于模型训练。 打完标签后，在labels文件夹下的train文件夹、val文件夹和test文件夹会生成一个对应images各文件夹的.txt文件，还会生成一个classes.txt文件。故labels文件夹下的各个文件夹会多一个文件。 最后命名此数据集为eleb。 叁 —— 模型训练及分析 3.1 部署YOLOv5 训练模型需要在专业的GPU加速服务器上运行， 请勿尝试在自己的电脑上跑模型。 挑选GPU服务器可参考这篇博客。 3.1.1 使用社区镜像自动部署YOLOv5 我使用的是AutoDL算力云，其社区镜像默认安装了YOLOv5。在算力市场中寻找合适的地区，GPU型号尽量好，按量计费租用。我此次租用的是：芜湖区-RTX3090，1.58r/h，跑四百多张图片估计是四个小时左右。 租用实例后开机，我选择JupyterLab的方式连接服务器。为了方便，我把默认的yolov5文件夹转到（剪贴粘贴）数据盘。有文件如下： 3.1.2 手动部署YOLOv5 建议租用Ubuntu系统，在有Python、Git等环境下，服务器新建文件夹，使用git命令克隆YOLOv5仓库或者网页下载压缩包解压部署。如果有缺少的库可以pip install安装。 git clone https://github.com/ultralytics/yolov5.git 至此YOLOv5部署完毕。 3.2 上传数据 将我们准备好的数据集压缩成.zip压缩文件，上传到yolov5/data/eleb（数据集根目录，新建文件夹eleb），由于文件比较大，上传速度也比较慢，比较费时间，也可以在服务器上创建文件夹后多选文件上传。 在终端上进入yolov5/data运行下面的指令： unzip xx.zip 如果提示有包没下载就去下载。 解压后，复制data文件夹下的coco.yaml，并命名为数据集的名字。在上面我将数据集名字命名为eleb，故复制并命名为eleb.yaml。 将eleb.yaml编辑如下： # 训练集、验证集、测试集路径设置path: ./data/eleb # 数据集根目录train: images/train # 训练集目录val: images/val # 验证集目录test: # 测试集目录，此处没设立# 标签的类，此项目只有一个类names: 0: elebike# Download script/URL (optional) 不管，默认download: #https://ultralytics.com/assets/coco128-seg.zip 3.3 配置训练参数 3.3.1 修改train.py文件 回到yolov5/目录，找到train.py文件打开，找到parse_opt()函数，更改部分参数： # ……# model.yaml是模型配置文件，在文件夹yolov5/models中，此处我使用yolov5l.yamlparser.add_argument('--cfg', type=str, default='', help='yolov5l.yaml path') # 配置数据集的yaml文件，即eleb.yamlparser.add_argument('--data', type=str, default=ROOT / 'data/eleb.yaml', help='dataset.yaml path') # 配置训练轮数，默认300轮parser.add_argument('--epochs', type=int, default=300, help='total training epochs') # 配置训练时所有GPU的总批量大小，为-1则自动parser.add_argument('--batch-size', type=int, default=16, help='所有GPU的总批量大小, -1 for autobatch') # 配置训练输入的照片大小，默认为640 × 640parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')# 下面保持默认即可\t# …… 3.3.2 修改val.py文件 回到yolov5/目录，找到val.py文件打开，找到parse_opt()函数，更改部分参数： # ……# 配置数据集的yaml文件，即eleb.yamlparser.add_argument('--data', type=str, default=ROOT / 'data/eleb.yaml', help='dataset.yaml path')# …… 3.3.3 修改模型配置 （3）进入yolov5/models/目录，找到train.py设置的模型配置.yaml文件，我这里使用的是yolov5l模型，打开yolov5l.yaml，修改nc（分类数），此项目修改为1： # ……nc: 1 # number of classesdepth_multiple: 1.0 # model depth multiplewidth_multiple: 1.0 # layer channel multipleanchors: - [10,13, 16,30, 33,23] # P3/8 - [30,61, 62,45, 59,119] # P4/16 - [116,90, 156,198, 373,326] # P5/32# …… 至此训练参数配置完毕。 启动终端，进入yolov5文件夹，我这里是进入autodl-tmp/yolov5/，输入命令启动训练： python train.py 如下图即开始训练 3.4 训练可能出现的问题 如果出现训练过程长时间的R和P值为0或者val/box_loss和val/obj_loss为nan的情况，参考此篇博客。 如果仍不能解决，可以考虑重新手动部署YOLOv5，接着修改参数运行train.py启动训练，如果缺少库就pip install安装。 3.5 训练结果分析 等待训练结束，在 yolov5/runs/train 文件夹就存放在训练的数据，其中weights文件夹中还存放着此次训练的权重文件，用于后续推理。 3.5.1 保存训练结果 在训练结果文件夹（我的是runs/train/exp2）中新建.py文件，输入下面代码，接着使用终端进入runs/train/exp2，使用命令python save.py可以变成压缩包，下载压缩包即下载全部训练结果。 # save.pyimport osimport tarfiledef recursive_files(dir_name='.', ignore=None): for dir_name,subdirs,files in os.walk(dir_name): if ignore and os.path.basename(dir_name) in ignore: continue for file_name in files: if ignore and file_name in ignore: continue yield os.path.join(dir_name, file_name)def make_tar_file(dir_name='.', tar_file_name='tarfile.tar', ignore=None): tar = tarfile.open(tar_file_name, 'w') for file_name in recursive_files(dir_name, ignore): tar.add(file_name) tar.close()dir_name = '.'tar_file_name = 'train.tar'ignore = {'.ipynb_checkpoints', '__pycache__', tar_file_name}make_tar_file(dir_name, tar_file_name, ignore) 将训练结果下载到电脑上，解压有如下文件： 3.5.2 曲线类分析 P_curve：准确率Precision和置信度Confidence的关系图，当设置某置信度时对应某个类别的识别准确率。随着置信度设置越高，某个类别识别准确率越高。 R_curve：召回率Recall和置信度Confidence的关系图，当设置某置信度时对应某个类别的查找完全的概率。随着置信度设置越高，某个类别能被查找完全的概率越低。 PR_cruve：准确率Precision和召回率Recall的关系图，尽可能希望准确率高的同时召回率也高，即曲线与坐标轴围成的面积越大，模型越好。 F1_curve：精确率和召回率的调和平均数，某个分类对应F1的值，1为最好，0为最差。 3.5.3 混淆矩阵分析 confusion_matrix：矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例，可以方便地看出机器是否将两个不同的类混淆。 3.5.4 标签相关分析 左上角为训练集的数据量； 右上角是框的尺寸和数量； 左下角是打标签目标框中心点位置，由图可知中心点多为中心偏上。 右下角是打标签目标框的高和宽，由图可知多聚集在0.2×0.2 3.5.5 训练验证结果分析 前面加train为训练集的情况，加val表示验证集的情况。 定位损失box_loss：预测框与标定框之间的误差。 置信度损失obj_loss：计算网络的置信度。 分类损失cls_loss：计算锚框与对应标定分类是否正确。 precision：模型精度。 recall：真实为positive的准确率，即正样本有多少被找出来了。 mAP：Mean Average Precision，均值平均精度，mAP_0.5表示阈值大于0.5的平均mAP。 mAP_0.5:0.95：表示不同IoU阈值（从0.5到0.95，步长0.05）上的平均mAP。 3.5.6 其余分析 train_batch、 val_batch表示一批次读取的照片数。 results.csv存放着每轮训练的数据。 肆 —— 模型转化处理（基于.onnx文件推理） 4.1 转化为.onnx文件 将我们的.pt文件经过服务器上YOLOv5自带的export.py处理后即可得到.onnx文件。即下面的命令格式： python export.py --weights yolov5s.pt --include onnx 我输入的是（位于yolov5文件夹）： python export.py --weights runs/train/exp2/weights/best.pt --include onnx 4.2 通过C++利用.onnx文件进行推理识别 4.2.1 记录处理的数据结构 将置信度阈值confThreshold、NMS非极大值抑制阈值nmsThreshold、目标置信度阈值objThreshold和识别模型路径modelpath打包成结构体，用于识别时参数的配置。 // 自定义配置结构struct Configuration{public:\tfloat confThreshold; // Confidence threshold\tfloat nmsThreshold; // Non-maximum suppression threshold\tfloat objThreshold; // Object Confidence threshold\tstring modelpath;}; 创建YOLOv5类，其成员变量有置信度阈值confThreshold、NMS非极大值抑制阈值nmsThreshold、目标置信度阈值objThreshold，以及输入图片宽度inpWidth、输入图片高度inpHeight两个照片参数，识别种类数num_classes，类名classes； 主要函数为检测函数detect，辅助函数为预测画框函数drawPred和调整图片大小函数resize_image。 // 模型class YOLOv5{public:\t// 初始化\tYOLOv5(Configuration config, bool isCuda);\tvoid detect(Mat frame); // 检测函数private:\tfloat confThreshold;\tfloat nmsThreshold;\tfloat objThreshold;\tint inpWidth;\tint inpHeight;\tint num_classes;\tstring classes[1] = { \"eleb\" };\t//vectorstring class_names;\tconst bool keep_ratio = true;\tNet net; // dnn里的\tvoid drawPred(float conf, int left, int top, int right, int bottom, Mat frame, int classid);\tMat resize_image(Mat srcimg, int *newh, int *neww, int *top, int *left);}; 4.2.2 检测识别函数 进行预处理：对输入图像（帧）进行大小调整和归一化处理，以便为模型做准备。调整后的图像会被转换为Blob，一个具有NCHW 维度（图像数、通道数、高度、宽度）的 4D 矩阵。 Mat dstimg = this-resize_image(frame, newh, neww, padh, padw);Mat blob = blobFromImage(dstimg, 1 / 255.0, Size(this-inpWidth, this-inpHeight), Scalar(0, 0, 0), true, false);this-net.setInput(blob); 模型推理：在Blob上运行模型以获得输出，即边界框和类别概率列表。 vectorMat outs;this-net.forward(outs, this-net.getUnconnectedOutLayersNames()); 进行后处理：如果输出超过2维，则会对其进行重塑。对于每个边界框，它会检查对象的置信度是否高于阈值。计算最大类得分，同时检查其是否高于置信度阈值。如果超过了，就会保存边界框、置信度和类ID。 for (int i = 0; i num_proposal; ++i) { // ... if (obj_conf this-objThreshold) { // ... if (max_class_socre this-confThreshold) { // ... confidences.push_back((float) max_class_socre); boxes.push_back(Rect(left, top, (int) (w * ratiow), (int) (h * ratioh))); classIds.push_back(class_idx); } }} 非最大值抑制 (NMS)：NMS用于移除重叠的边界框。剩余的边界框在原始图像上绘制。 vectorint indices;dnn::NMSBoxes(boxes, confidences, this-confThreshold, this-nmsThreshold, indices);for (size_t i = 0; i indices.size(); ++i){ // ... this-drawPred(confidences[idx], box.x, box.y, box.x + box.width, box.y + box.height, frame, classIds[idx]);} 4.2.3 预测画框函数 预测画框函数用于将预测函数所得到的目标区域，经OpenCV的工具在图片上绘制出方框。首先传入的参数有置信度，图片的四个角落点，Mat类型图片和类id，接着借助OpenCV的rectangle函数和putText函数绘制。 // 绘制预测目标的边界框void YOLOv5::drawPred(float conf, int left, int top, int right, int bottom, Mat frame, int classid){\t// 绘制一个显示边界框的矩形\trectangle(frame, Point(left, top), Point(right, bottom), Scalar(0, 0, 255), 10);\t// 得到目标的类名和置信度\tstring label = cv::format(\"%.2f\", conf);\tlabel = this-classes[classid] + \":\" + label;\t// 绘制目标的类名和置信度文本\tint baseLine;\tSize labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, baseLine);\ttop = max(top, labelSize.height);\tputText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(0, 255, 0), 1);} 4.2.4 主函数 本程序通过main函数的参数进行传参。如C/C++语言语法， argc 是argument count的缩写，表示传入main函数中的参数个数，包括这个程序本身； argv 是 argument vector的缩写，表示传入 main 函数中的参数列表，其中 argv[0] 表示这个程序的名字。 //yolov5-onnx.cppint main(int argc, const char *argv[]){\tif (argc != 3)\t{ std::cout \"Run like this: \" argv[0] \" yolov5s.onnx input.jpg\" std::endl; return -1;\t} Configuration yolo_nets = { 0.3, 0.5, 0.3, argv[1] }; // 初始化数据\tYOLOv5 yolo_model(yolo_nets, false);\tMat srcimg = imread(argv[2]); // 读入图片\tyolo_model.detect(srcimg); // 进行推理\timwrite(\"result.jpg\", srcimg); // 输出图片\treturn 0;} 所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式： yolov5-onnx.exe best.onnx input.jpg 伍 —— 模型转化加速处理（基于.engine文件推理） 5.1 转化为.engine文件 5.1.1 通过YOLOv5自带的export.py转换 将我们的.pt文件经过服务器上YOLOv5自带的export.py处理后即可得到.engine文件（可能会自动下载TensorRT）。即下面的命令格式： python export.py --weights yolov5s.pt --include engine 我输入的是（位于yolov5文件夹）： python export.py --weights runs/train/exp2/weights/best.pt --include engine 5.1.2 通过自己下载安装的TensorRT转换 在安装TensorRT后，在TensorRT文件夹下有一个名为 bin 的文件夹，里面存在一个trtexec.exe文件。可以通过这个文件进行文件转换。在 bin 目录启动命令提示符，命令格式如下： trtexec --onnx=best.onnx --saveEngine=best.engine 5.2 通过C++利用.engine文件进行推理识别 5.2.1 记录识别结果的数据结构 一个记录识别结果的结构体，包括检测物体置信度 score，目标预测框 box 和类ID class_id 。 struct Result{\tfloat score;\tcv::Rect box;\tint class_id;}; 5.2.2 日志模块 在构建TensorRT Runtime时需要作为参数传入。日志模块必须继承自nvinfer1::ILogger类。 // TensorRT需要日志// 参考: https://github.com/cyrusbehr/tensorrt-cpp-apiusing Severity = nvinfer1::ILogger::Severity;class Logger : public nvinfer1::ILogger{\tvoid log(Severity severity, const char *msg) noexcept override;};void Logger::log(Severity severity, const char *msg) noexcept{\tif (severity = Severity::kWARNING)\t{ std::cout msg std::endl;\t}}Logger logger; 5.2.3 计算内存大小模块 一个计算内存大小的辅助函数。 size_t get_memory_size(const nvinfer1::Dims dims, const int32_t elem_size){\treturn std::accumulate(dims.d, dims.d + dims.nbDims, 1, std::multipliesint64_t()) * static_castsize_t(elem_size);} 5.2.4 检测识别模块 基于.engine文件的推理识别涉及到显卡的调用，故需用到CUDA的Context。 CUDA的Context是由CUDA驱动程序创建的数据结构，包含执行CUDA操作所需的所有信息，如设备代码、数据以及线程、内存和硬件设置等资源。每个线程都有一个当前Context，该线程上的所有CUDA操作都在该Context中执行。 初始化YOLOv5模型 首先从engine_file_path指定的文件中加载TensorRT引擎。 // 读取TensorRT引擎std::ifstream engine_file(engine_file_path, std::ios::binary);if (engine_file.fail()){\tstd::cout \"Failed to read model file.\" std::endl;}engine_file.seekg(0, std::ifstream::end);auto fsize = engine_file.tellg();engine_file.seekg(0, std::ifstream::beg);std::vectorchar engineData(fsize);engine_file.read(engineData.data(), fsize); 其次，推演运行时 nvinfer1::IRuntime 是一切资源的源头，是第一个需要被初始化的对象，注意运行时的初始化需要将辅助模块中定义好的 logger 作为传入参数。同时这段代码使用 unique_ptr 来跟踪初始化后的运行时对象。引擎 nvinfer1::ICudaEngine 存储了模型的权重参数，它的初始化分2步：首先将模型文件读入内存，然后使用运行时的 deserializeCudaEngine 方法初始化引擎对象。 // 初始化IRuntime和ICudaEnginestd::unique_ptrnvinfer1::IRuntime runtime{ nvinfer1::createInferRuntime(logger) };std::unique_ptrnvinfer1::ICudaEngine mEngine{ runtime-deserializeCudaEngine(engineData.data(), fsize) };if (mEngine.get() == nullptr){\tstd::cout \"Failed to deserialize CUDA engine.\" std::endl;} 最后创建CUDA的context，并为输入和输出绑定分配CUDA内存。引擎的本质是专为TensorRT优化后的模型。可使用createExecutionContext 方法来构建推演环境 nvinfer1::IExecutionContext 。 std::unique_ptrnvinfer1::IExecutionContext context{ mEngine-createExecutionContext() };if (context.get() == nullptr){\tstd::cout \"Failed to create CUDA context.\" std::endl;} 准备模型输入 了解模型结构，通过netron.app输入.onnx文件查看自己的神经网络结构。我这里输入名字为 images ，尺寸为3×640×640；输出名字为 output0 ，尺寸为1×25200×6。 TensorRT的模型推演在GPU上进行，需要在显存上为用于计算的数据申请空间。输入尺寸为3×640×640，使用内存大小计算函数得到显存中应当开辟的空间大小，然后使用 cudaMalloc 申请显存。其中 cuda_mem_input 为指向该显存区域的指针。为了方便后续推演，这里使用一个指针数组 bindings 记录下与推演有关的内存区域。 // 记录与推演相关的内存区域void *bindings[5];const char *input_name = \"images\";int32_t input_idx = mEngine-getBindingIndex(input_name);if (input_idx == -1){\tstd::cout \"ERROR: failed to get input by name: \" input_name std::endl;}// 计算显存大小并开辟int32_t channels = 3, height = 640, width = 640;nvinfer1::Dims4 input_dims { 1, channels, height, width };size_t input_mem_size = get_memory_size(input_dims, sizeof(float));void* cuda_mem_input { nullptr };if (cudaMalloc(cuda_mem_input, input_mem_size) != cudaSuccess) { std::cout \"ERROR: input cuda memory allocation failed, size = \" input_mem_size \" bytes\" std::endl;}bindings[0] = cuda_mem_input; 同时还需为输出区域计算并开辟内存。模型的输出包含一个或多个对象，必须为每个输出对象分配独立的显存区域。在循环体中，首先通过 getBindingDimensions 获得输出每个对象的维度，然后计算其占据的显存区域大小，并调用 cudaMalloc 函数分配显存，最后将指向该存储区域的指针存入之前创建好的 bindings 。 std::vectorstd::string output_node_names{ \"output0\" };std::vectorsize_t output_mem_sizes;bool output_mem_initialized = true;for (size_t i = 0; i output_node_names.size(); i++){\tint32_t output_idx = mEngine-getBindingIndex(output_node_names[i].c_str());\tif (output_idx == -1)\t{ std::cout \"ERROR: failed to get output by name: \" output_node_names[i] std::endl; output_mem_initialized = false; break;\t}\tauto output_dims = context-getBindingDimensions(output_idx);\tauto output_size = get_memory_size(output_dims, sizeof(float));\toutput_mem_sizes.push_back(output_size);\tvoid *cuda_mem_output{ nullptr };\tif (cudaMalloc(cuda_mem_output, output_size) != cudaSuccess)\t{ std::cout \"ERROR: output cuda memory allocation failed, size = \" output_size \" bytes\" std::endl; output_mem_initialized = false; break;\t}\telse\t{ bindings[1 + i] = cuda_mem_output;\t}} 显存空间初始化完成后，还需要初始化最后一个对象 cudaStream 。它用来在异步操作中同步结果。 cudaStream_t stream{ nullptr };if (cudaStreamCreate(stream) != cudaSuccess){\tstd::cout \"ERROR: cuda stream creation failed.\" std::endl;} 从image_file_path中读取图像，将其调整为所需尺寸，并复制到GPU内存中。输入图像在进入神经网络之前，首先会进行预处理操作。典型的预处理操作包括：缩放到指定尺寸、减去均值、归一化、除方差。另外如果模型对输入通道的顺序有要求，预处理也会调整通道顺序。YOLOv5的输入大小为640x640像素，通道顺序为RGB， 预处理也非常简单，像素值除以255即可。 cv::Mat img_bgr = cv::imread(image_file_path);// 预处理cv::resize(img_bgr, img_bgr, cv::Size(width, height));int32_t tmp = height * width * channels;float *input_buffer = new float[tmp]();for (int c = 0; c channels; c++){\tfor (int j = 0, HW = height * width; j HW; ++j)\t{ input_buffer[c * HW + j] = static_castfloat(img_bgr.data[j * channels + 2 - c]) / 255.0f; // 其中 img_bgr.data 为指向像素存储区域的指针，而括号内下表运算中的 +2 实现了BGR数据到RGB的转换。\t}} 数据预处理的操作是在HOST（CPU）侧完成，在推演之前还需要将预处理后的数据拷贝到GPU一侧。 if (cudaMemcpyAsync(cuda_mem_input, input_buffer, input_mem_size, cudaMemcpyHostToDevice, stream) != cudaSuccess){\tstd::cout \"ERROR: CUDA memory copy of input failed, size = \" input_mem_size \" bytes\" std::endl;} 运行推理 使用执行Context的 enqueueV2 方法异步运行模型。 enqueueV2 是真正触发模型推演的操作。参数中的 bindings 是之前记录的指向输入与输出显存的指针数组。 stream 是在初始化资源章节创建的 cudaStream 对象，用于同步数据。 bool status = context-enqueueV2(bindings, stream, nullptr);if (!status){\tstd::cout \"ERROR: TensorRT inference failed.\" std::endl;} 模型输出后处理 首先按照输出数据的规格申请输出内存空间。为输出结果 output0 申请了一份内存空间，并将指向这些内存区域的指针存储在 output_buffers 指针数组中。 std::vectorfloat * output_buffers;for (size_t i = 0; i output_mem_sizes.size(); i++){\tfloat *buf = new float[output_mem_sizes[i] / sizeof(float)];\toutput_buffers.push_back(buf);} 接着将输出从GPU内存复制到CPU内存。使用 cudaMemcpyAsync 函数。其中参数 output_buffers 为刚才申请好的内存空间， bindings 为GPU一侧的显存空间， output_mem_sizes 为输出结果所占据的内存大小， cudaMemcpyDeviceToHost 指定了拷贝操作的方向，由于这是一个异步操作，所以要使用 stream 作为同步数据的依据。 for (size_t i = 0; i output_mem_sizes.size(); i++){\tauto mem_to_host_result = cudaMemcpyAsync(output_buffers[i], bindings[1 + i], output_mem_sizes[i], cudaMemcpyDeviceToHost, stream);\tif (mem_to_host_result != cudaSuccess)\t{ std::cout \"ERROR: CUDA memory copy of output \" i \" failed, size = \" output_mem_sizes[i] \" bytes\" std::endl;\t}} 等待同步，已经调用了3个异步操作函数，因此这里需要使用同步操作来等待执行真正完成。同步之后，模型推演的结果才真正存储在了内存 output_buffers 中。 cudaStreamSynchronize(stream); 对输出进行后处理。首先定义三个向量分别存储检测获得的物体边界框 boxes 、分值 scores 与类别ID class_ids 。此次训练的YOLOv5模型有1个输出，即 output0 。 其本身是一个巨大的矩阵，其行数为25200，代表模型给出的物体检测结果。为此，可以定义一个指针 p 指向 output0 ，然后通过一个循环来轮询结果。 此次训练中， output0 每行具有6个元素：第0~3个元素为物体边界框中心x，物体边界框中心y，物体边界框宽度和物体边界框高度；第4个元素为预测框分值；第5个元素是物体类别ID的概率，可以按照最大值获取到分类结果。 std::vectorfloat scores;std::vectorcv::Rect boxes;std::vectorint class_ids;float *p = output_buffers[0]; // 指向output0的第一个元素int step = 6, proposal_count = 25200;float score_threshold = 0.5, nms_threshold = 0.45; // 分支阈值和NMS阈值float scale = 1.0;for (size_t i = 0; i proposal_count; i++){\t// 置信度低于分数阈值\tfloat obj_score = p[4]; // 第4个元素是预测框分值\tif (obj_score score_threshold)\t{ p += step; continue;\t}\t// 判断对象分类\tint c_id = -1;\tfloat c_score = 0;\tfor (size_t j = 1; j step; j++)\t{ if (p[j] c_score) { c_score = p[j]; c_id = j - 2; }\t} scores.push_back(c_score * obj_score);\tclass_ids.push_back(c_id);\tboxes.push_back(cv::Rect((p[0] - p[2] / 2) / scale, (p[1] - p[3] / 2) / scale, p[2] / scale, p[3] / scale));\tp += step; // 指向下一行} 使用了OpenCV提供的NMS方法 cv::dnn::NMSBoxes 。其中 boxes 为存储了 Rect 类的向量， scores 为存储了分值的向量， score_threshold 为检测分值阈值， nms_threshold 为NMS操作的阈值， indices 为一个空向量，用来存储NMS的结果。最后按照 indices 给出的物体序号提取最终结果。 // 执行非最大值抑制以消除具有较低置信度的冗余重叠框std::vectorint indices;cv::dnn::NMSBoxes(boxes, scores, score_threshold, nms_threshold, indices);// 收集检测结果std::vectorResult results;for (auto i : indices) { results.push_back(Result { scores[i], boxes[i], class_ids[i] });} 保存结果：它将包含绘制结果的图像保存下来。 for (auto r : results){\tcv::rectangle(img_bgr, r.box, cv::Scalar(0, 255, 255), 5);}cv::imwrite(\"result.jpg\", img_bgr); 5.2.5 主函数设计 此程序主函数与基于.onnx文件推理程序类似，通过main函数的参数进行传参。 //yolov5-engine.cppint main(int argc, char const *argv[]){\tif (argc != 3)\t{ std::cout \"Run like this: \" argv[0] \" yolov5s.engine input.jpg\" std::endl; return -1;\t} //...\trun(argv[1], argv[2]);\treturn 0;} 所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式： yolov5-engine.exe best.engine input.jpg 陆 —— 打包软件 6.1 基于.onnx文件图像推理程序打包 打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在output/文件夹也输出一张照片并做名字冲突处理。 //导出名冲突string getUniqueFileName(const std::string fileName, const std::string outputDirectory){\tstring baseName, extension;\tsize_t dotIndex = fileName.rfind('.');\tif (dotIndex != string::npos)\t{ baseName = fileName.substr(0, dotIndex); extension = fileName.substr(dotIndex);\t}\telse\t{ baseName = fileName;\t}\tstring newFileName = fileName;\tint counter = 1;\twhile (ifstream(outputDirectory + newFileName).good())\t{ newFileName = baseName + \"_\" + to_string(counter) + extension; counter++;\t}\treturn newFileName;} // 备份存储string dir = \"output/\"; //文件夹路径if (_access(dir.c_str(), 0) == -1)//判断该文件夹是否存在{\t_mkdir(dir.c_str());}imwrite(\"result.jpg\", srcimg);string newname = getUniqueFileName(\"result.jpg\", \"output/\");imwrite(\"output/\" + newname, srcimg); 由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考此博客进行打包即可。 打包之后即可移植到其他PC设备使用。 6.2 基于.engine文件图像推理程序打包 同理，打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在output/文件夹也输出一张照片并做名字冲突处理。 由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考此博客进行打包即可。 注意一点，由于.engine文件需要调用显卡驱动，故不能移植到别的电脑使用（暂时我是没成功）。 6.3 整体打包 此次项目整体打包采用Qt作为前端页面，将上面两个打包好的程序结合，使用时只需调用指定程序模块即可。具体Qt打包可参考此博客 具体代码不细展开，分享于码云仓库。 柒 —— 总结及后话 实际上，如5.1的步骤，将参数改为.trt，即可导出.trt文件。 trtexec --onnx=best.onnx --saveEngine=best.trt 至于如何根据.trt文件设计算法进一步进行推测识别，此次项目未能完成，有待补充，深度学习很多方面的知识也有待补充。故此次项目仅能作为一个带有启发性的入门级别的项目。 深度学习是机器学习领域中的一个新的研究方向，旨在让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。深度学习试图为数据的高层次摘要进行建模，通过使用多个处理层和对这些层的结果进行线性和非线性的转换，来实现对数据的识别和理解。深度学习在搜索技术、数据挖掘、机器翻译、自然语言处理、多媒体学习、语音、推荐和个性化技术等领域都取得了了很多成果。经过这次项目，我感受到了深度学习的有趣，写下这篇博客，用于记录与分享。","tags":["CPP","深度学习","YOLOv5","TensorRT","OpenCV"],"categories":["笔记"]},{"title":"Visual Studio2022的C++项目打包成软件记录","path":"/2023/11/","content":"介绍如何将VS的C++项目打包 关键词：C++ 1.编译出.exe文件 选择Release生成，我在此是Realease x64编译。 2.打包项目 将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到F:\\test\\HelloWorld1.0，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。 打开Visual Studio的安装目录，找到dumpbin.exe并复制其路径，可以按照下面的路径查找： E:\\Microsoft_Visual_Studio\\VS\\VC\\Tools\\MSVC\\14.36.32532\\bin\\Hostx64\\x64 回到软件工作目录，在地址栏输入cmd打开命令提示符，按格式输入： dumpbin.exe路径 /dependents 发布软件的路径 如： E:\\Microsoft_Visual_Studio\\VS\\VC\\Tools\\MSVC\\14.36.32532\\bin\\Hostx64\\x64\\dumpbin.exe /dependents HelloWorld.exe 接着将出现的.dll文件找出来，推荐使用Everything软件搜索，选择路径上对应的平台（x86或x64），复制到软件的工作目录即可。 如图： 这样即可直接点击.exe文件运行。","tags":["CPP"],"categories":["日常"]},{"title":"Qt5.14.2项目打包成软件记录","path":"/2023/10/","content":"介绍如何将Qt项目打包成软件发布 关键词：C++、Qt 1.编译出.exe文件 打开需要打包的项目，在左下角选择合适的构建部件和版本，版本要选择Release，至于64bit还是32bit看需求。 选择后点击锤子编译项目，此处我以MinGWx64,Release编译。 点击左侧的项目，查看构建目录（项目目录跟构建目录尽量别带中文）。 打开构建目录，发现出现一个.exe文件。 2.打包项目 将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到F:\\test\\HelloWorld1.0，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。 接着打开Qt的安装目录下的bin文件夹，找到windeployqt.exe，复制其路径，我的windeployqt.exe位于D:\\Qt\\5.14.2\\mingw73_64\\bin。 回到软件的工作目录（新建的文件夹），在地址栏输入cmd打开命令提示符，按格式输入： windeployqt文件路径 发布软件的路径 如： D:\\Qt\\5.14.2\\mingw73_64\\bin\\windeployqt.exe HelloWorld.exe 慢慢等待打包完成。 之后就可以直接打开软件工作目录下的exe执行。","tags":["CPP","Qt"],"categories":["日常"]},{"title":"OI Wiki，一个整合了编程竞赛的知识整合站点","path":"/2023/oiwiki/","content":"Github分享 关键词：算法、数据结构、竞赛 是什么 “OI Wiki 致力于成为一个免费开放且持续更新的知识整合站点，大家可以在这里获取关于 编程竞赛 (competitive programming) 有趣又实用的知识，我们为大家准备了竞赛中的基础知识、常见题型、解题思路以及常用工具等内容，帮助大家更快速深入地学习编程竞赛。” 内容链接 OI Wiki——网页使用 Github 仓库 Gitee 仓库 如何使用 在Github主页上有详细介绍。 可以直接点击上面的OI Wiki链接使用。 我在此用Windows 10做一个简单的 离线版 使用示例。 直接或git方式下载仓库压缩包。 解压压缩包 在Python下（没有Python的可以安装Python），使用命令建立静态网页：在解压后的目录下地址栏输入cmd，接着输入下面的命令启动网页。 # 如果是 python3python3 -m http.server# 如果是 python2python2 -m SimpleHTTPServer# 有些环境下找不到名叫 python3/python2 的可执行文件，不妨运行 python 试试 如上图则为启动网页服务成功。我在此输入的是python，可以试试python3或者python2能不能运行。 在浏览器地址栏中输入http://localhost:8000/或127.0.0.1:8000即可进入网页，其中8000为上图启动网页服务的端口，并不一定是8000。 页面如下图即可进行阅读学习","tags":["算法","数据结构","竞赛"],"categories":["分享"]},{"title":"Visual Studio2022的OpenCV4.5.2和CUDA12.0项目配置","path":"/2023/9/","content":"记录一次环境配置 关键词：深度学习、OpenCV、CUDA OpenCV的环境配置 OpenCV下载安装 前往官网选择适合的OpenCV版本下载，并安装到合适的位置。 官网下载OpenCV 我的OpenCV安装在：D:\\opencv4.5.2 添加OpenCV到系统Path变量 打开编辑系统环境变量，点击右下方的环境变量，在系统变量中找到PATH项，点击编辑添加OpenCV目录下的bin文件夹。 至于添加的是vc14还是vc15，参照下表 VS版本 VC VS2015 VC14 VS2017及以上 VC15 添加OpenCV环境到VS项目 右键项目，选择最下方属性，打开属性配置窗口，选择是Debug模式或Release模式配置。 VC++目录配置OpenCV 点击包含目录，在包含目录中把OpenCV目录下的include文件夹添加。 此处我的添加是： D:\\opencv4.5.2\\build\\include\\opencv2D:\\opencv4.5.2\\build\\include 点击库目录，在库目录中把OpenCV的lib文件添加，此处路径藏得比较深，参考我的添加。 此处我的添加是： D:\\opencv4.5.2\\build\\x64\\vc15\\lib 链接器配置OpenCV 点击输入，再点击附加依赖项，将OpenCV的lib文件添加，lib文件存放在上面库目录的文件夹中。 opencv_world452.libopencv_world452d.lib 注意，此处文件名带d的为Debug版本的依赖项，不带d的为Release版本的依赖项。 在配置Debug版本时把带d的文件放在不带d的文件之上， 在配置Release版本时把不带d的文件放在带d的文件之上。 如果显示找不到opencv_worldxxx.dll ，请把opencv_worldxxx.dll的路径添加到系统环境变量。 CUDA环境配置 CUDA下载安装 参考此条博客 我的CUDA目录在：G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0 添加CUDA环境到VS项目 配置为x64平台。 右键项目→生成依赖项→生成自定义→勾选“CUDA xxx”。 VC++目录配置CUDA 点击包含目录，在包含目录中把OpenCV目录下的include文件夹添加。 此处我的添加是： G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\include 点击库目录，在库目录中把OpenCV的lib文件夹添加。 此处我的添加是： G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\lib\\x64 链接器配置CUDA 点击常规，再点击附加库目录，添加下面的目录。似乎不配置这一条也可以 $(CUDA_PATH_V12_0)\\lib\\$(Platform) 或 G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\lib\\x64 点击输入，再点击附加依赖项，将CUDA的lib文件添加，输入下面的内容。 G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\lib\\x64\\*.lib 配置源码文件风格 右键源文件，可以添加新建项中选择“CUDA C/C++ File”。 右键“xxx.cu”源文件，点击属性，选择配置属性中的常规，从项类型中找到“CUDA C/C++”。 测试CUDA代码 #include \"cuda_runtime.h\"#include \"device_launch_parameters.h\"#include stdio.hcudaError_t addWithCuda(int *c, const int *a, const int *b, unsigned int size);__global__ void addKernel(int *c, const int *a, const int *b){ int i = threadIdx.x; c[i] = a[i] + b[i];}int main(){ const int arraySize = 5; const int a[arraySize] = { 1, 2, 3, 4, 5 }; const int b[arraySize] = { 10, 20, 30, 40, 50 }; int c[arraySize] = { 0 }; // Add vectors in parallel. cudaError_t cudaStatus = addWithCuda(c, a, b, arraySize); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"addWithCuda failed!\"); return 1; } printf(\"{1,2,3,4,5} + {10,20,30,40,50} = {%d,%d,%d,%d,%d} \", c[0], c[1], c[2], c[3], c[4]); // cudaDeviceReset must be called before exiting in order for profiling and // tracing tools such as Nsight and Visual Profiler to show complete traces. cudaStatus = cudaDeviceReset(); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaDeviceReset failed!\"); return 1; } return 0;}// Helper function for using CUDA to add vectors in parallel.cudaError_t addWithCuda(int *c, const int *a, const int *b, unsigned int size){ int *dev_a = 0; int *dev_b = 0; int *dev_c = 0; cudaError_t cudaStatus; // Choose which GPU to run on, change this on a multi-GPU system. cudaStatus = cudaSetDevice(0); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaSetDevice failed! Do you have a CUDA-capable GPU installed?\"); goto Error; } // Allocate GPU buffers for three vectors (two input, one output) . cudaStatus = cudaMalloc((void**)dev_c, size * sizeof(int)); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaMalloc failed!\"); goto Error; } cudaStatus = cudaMalloc((void**)dev_a, size * sizeof(int)); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaMalloc failed!\"); goto Error; } cudaStatus = cudaMalloc((void**)dev_b, size * sizeof(int)); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaMalloc failed!\"); goto Error; } // Copy input vectors from host memory to GPU buffers. cudaStatus = cudaMemcpy(dev_a, a, size * sizeof(int), cudaMemcpyHostToDevice); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaMemcpy failed!\"); goto Error; } cudaStatus = cudaMemcpy(dev_b, b, size * sizeof(int), cudaMemcpyHostToDevice); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaMemcpy failed!\"); goto Error; } // Launch a kernel on the GPU with one thread for each element. addKernel1, size(dev_c, dev_a, dev_b); // Check for any errors launching the kernel cudaStatus = cudaGetLastError(); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"addKernel launch failed: %s \", cudaGetErrorString(cudaStatus)); goto Error; } // cudaDeviceSynchronize waits for the kernel to finish, and returns // any errors encountered during the launch. cudaStatus = cudaDeviceSynchronize(); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaDeviceSynchronize returned error code %d after launching addKernel! \", cudaStatus); goto Error; } // Copy output vector from GPU buffer to host memory. cudaStatus = cudaMemcpy(c, dev_c, size * sizeof(int), cudaMemcpyDeviceToHost); if (cudaStatus != cudaSuccess) { fprintf(stderr, \"cudaMemcpy failed!\"); goto Error; }Error: cudaFree(dev_c); cudaFree(dev_a); cudaFree(dev_b); return cudaStatus;} 运行结果如下图： CUDA环境的一些碰壁 我的CUDA安装在一个可移动固态硬盘（G盘）中，可能导致了我的CUDA项目只能位于G盘使用，复制粘贴到电脑的盘会出现问题。 如果出现了大段指令无法运行，像下面的错误显示，可以复制命令（引号部分）到cmd运行，查看更详细的报错原因。 // VS报错如下严重性\t代码\t说明\t项目\t文件\t行\t禁止显示状态错误\tMSB3721\t命令“\"G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\bin vcc.exe\" -gencode=arch=compute_52,code=\\\"sm_52,compute_52\\\" --use-local-env -ccbin \"E:\\Microsoft_Visual_Studio\\VS\\VC\\Tools\\MSVC\\14.33.31629\\bin\\HostX64\\x64\" -x cu -IG:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\include -IG:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\include -G --keep-dir x64\\Debug -maxrregcount=0 --machine 64 --compile -cudart static -g -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler \"/EHsc /W3 /nologo /Od /FdG:\\Data\\Coding_Master\\yolov5-trt\\bin\\immediate\\x64\\Debug\\vc143.pdb /FS /Zi /RTC1 /MDd \" -o G:\\Data\\Coding_Master\\yolov5-trt\\bin\\x64\\File.cu.obj \"G:\\Data\\Coding_Master\\yolov5-trt\\File.cu\"”已退出，返回代码为 1。\tyolov5-trt\tE:\\Microsoft_Visual_Studio\\VS\\MSBuild\\Microsoft\\VC\\v170\\BuildCustomizations\\CUDA 12.0.targets\t794// 复制命令部分，即下面部分到cmd输入\"G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\bin vcc.exe\" -gencode=arch=compute_52,code=\\\"sm_52,compute_52\\\" --use-local-env -ccbin \"E:\\Microsoft_Visual_Studio\\VS\\VC\\Tools\\MSVC\\14.33.31629\\bin\\HostX64\\x64\" -x cu -IG:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\include -IG:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\include -G --keep-dir x64\\Debug -maxrregcount=0 --machine 64 --compile -cudart static -g -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler \"/EHsc /W3 /nologo /Od /FdG:\\Data\\Coding_Master\\yolov5-trt\\bin\\immediate\\x64\\Debug\\vc143.pdb /FS /Zi /RTC1 /MDd \" -o G:\\Data\\Coding_Master\\yolov5-trt\\bin\\x64\\File.cu.obj \"G:\\Data\\Coding_Master\\yolov5-trt\\File.cu\" 还遇到一些其他的坑可以自行必应。","tags":["深度学习","OpenCV","CUDA"],"categories":["日常"]},{"title":"Windows下Python3.11.4的安装记录","path":"/2023/8/","content":"记录一次安装Python 关键词：Python 下载Python安装包 官网选择尽量较新的Python版本下载。 安装Python 打开下载的Python安装包，选择Customize installation客制化安装，记得勾选下面的“Add python.exe to PATH”。 接着默认勾选： pip：包管理器，下载包时使用。建议勾选上 再接着更改安装路径，建议安装在非系统盘。 等待安装完成即可。 测试Python 按下Win+R输入cmd打开命令窗口，输入下面命令验证是否安装成功。 python -V 如果出现版本号，即为安装成功。 附：更改Python的pip安装路径 建议将pip安装的包放至非系统盘。进入Python的安装路径，如我的在D:\\Pyhton\\Lib，寻找文件site.py，使用记事本打开。使用ctrl+f查找关键字USER_SITE等字，将路径更改为自定义的路径。我更改情况如下图。 更改路径后，打开cmd，使用下面指令安装numpy包。 pip install numpy 安装成功后，再使用下面指令查看numpy包的安装位置。 pip show numpy 我成功更改pip的安装路径，新下载的numpy包位于D:\\Pyhton\\Lib\\site-packages。","tags":["Python"],"categories":["日常"]},{"title":"关于GPU服务器的选用","path":"/2023/gpuserver/","content":"介绍关于GPU服务器：租用、使用 关键词：深度学习、GPU服务器 GPU服务器服务商 AutoDL算力云 网站：AutoDL算力云 个人评价：本人具有使用经历，价格偏便宜，镜像有现成，适合新手入门尝试。 MistGPU 网站：MistGPU 个人评价：价格还行，备用选择。 阿里云 网站：阿里云 个人评价：阿里云，不多说，可靠也不便宜。 GPU服务器使用 选择适合的GPU型号、显存大小、浮点算力、存储盘大小。 选择合适的镜像进行环境配置。 一般无图形窗口，命令行使用，文件上传下载。 详细可参考各个服务商的帮助文档。","tags":["深度学习","GPU服务器"],"categories":["分享"]},{"title":"YOLOv5由pt文件转onnx文件报错解决","path":"/2023/7/","content":"ONNX: export failure ❌ 5.9s: Unsupported ONNX opset version: 17 关键词：深度学习、YOLOv5、onnx 报错窗口 报错原因 export.py文件中parse_opt()函数设置的opset版本错误。 解决方案 #找到parse_opt()函数中的此行，将default值改为12parser.add_argument('--opset', type=int, default=12, help='ONNX: opset version')","tags":["深度学习","YOLOv5","onnx"],"categories":["日常"]},{"title":"C++报错：表达式必须含有常量值","path":"/2023/6/","content":"关于在Visual Studio 2022使用C++ 20语法的表达式开辟数组空间报错 关键词：C++ 错误原因 c++中不允许使用变量作为数组的长度定义数组，必须为常量值，c++中所有的内存需求都是在程序执行前通过定义的常量来确定的。 声明为const或constexpr的表达式在编译时计算结果不是常数。 编译器必须能够在表达式被使用时确定表达式的值。 错误示例 //错误示范1#include iostreamusing namespace std;int main(){\tint a = 3, b = 4, c = 5;\tint d[a * b * c]; // error\treturn 0;} //错误示范2#include iostreamusing namespace std;int main(){\tint a = 3, b = 4, c = 5;\tconst int tmp = a * b * c;\tint d[tmp]; // error，如错误原因2\treturn 0;} //错误示范3struct test{ static const int array_size; // error int size_array[array_size];};const int test::array_size = 42; 解决方案 使用new进行动态内存分配，记得通过delete回收分配的内存，如上述代码改为： #include iostreamusing namespace std;int main(){\tint a = 3, b = 4, c = 5;\tint *d = new int[a * b * c];\tdelete[] d;\treturn 0;} 关于new分配内存的使用： 单变量分配 Type *p = new Type;delete p;Type *p = new Type(2); //动态分配内存并初始化delete p; 一维数组申请 Type *p = new Type[n];delete[] p;Type *p = new Type[n]();//动态分配内存并初始化全部为0delete[] p; 二维数组申请 Type **p = new Type *[m];for (int i = 0; i m; ++i){\tp[i] = new Type[n];}","tags":["CPP"],"categories":["日常"]},{"title":"Windows 10下安装CUDA、TensorRT记录","path":"/2023/5/","content":"GPU：NVIDIA GeFOrce GTX 1050 关键词：深度学习、YOLOv5、TensorRT、C++推演 一、下载CUDA 1.确定适配本机显卡驱动的CUDA版本 系统搜索打开NVIDIA控制面板，点击帮助，选择系统信息-组件，找到CUDA字样。此处我的CUDA适配版本为12.0。 2.下载对应版本的CUDA 下载地址 - NVIDIA官网 3.安装CUDA 点击下载的安装exe文件，可以更改文件安装位置，记住文件安装位置。此处我的安装位置是G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0。 二、下载cuDNN包 1.选择适配CUDA的版本下载对应的cuDNN包 下载地址 - NVIDIA官网 2.选择合适的位置解压cuDNN压缩包 3.复制文件 cuDNN属于是CUDA的一个补丁包，因此无需安装。需要将bin、include、lib文件夹中的相关文件拷贝到CUDA安装位置的bin、include、lib的x64文件夹中。 我的CUDA安装位置是：G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0。 4.验证是否成功 Win + R输入cmd打开cmd窗口。 直接输入盘符如F:跳转到F盘，cd进入到具体地址。 比如我的CUDA安装在G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0， 那么进入到G:\\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\extras\\demo_suite 接着在cmd窗口输入下面的指令分别运行两个exe文件，结果出现PASS（如图）则验证成功。 bandwidthTest.exe deviceQuery.exe 三、下载TensorRT包 1.选择适配CUDA版本的TensorRT包下载 进入官网，选择较新的大版本，再选择适合自己安装的CUDA版本下载。 我在此处下载Windows的支持CUDA12.0的版本。 2.选择合适的位置解压TensorRT压缩包 3.安装TensorRT 将TensorRT的include文件夹中文件复制到CUDA安装位置的include文件夹。 我的操作是：copy \\TensorRT-8.6.1.6\\include → NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\\include 将TensorRT的lib中所有lib文件复制到CUDA安装位置的lib\\x64文件夹 将TensorRT的lib中所有dll文件复制到CUDA安装位置的bin文件夹 4.验证TensoRT 检查系统环境变量中是否有包含了CUDA的bin文件夹，没有则添加。 使用Visual Studio打开sampleMNIST示例，即打开../TensorRT-8.6.1.6\\samples\\sampleOnnxMNIST文件夹中的sln文件，必要时对项目属性的常规、VC++目录、C/C++里面的环境进行配置，添加依赖。参考 右键项目，点击重新生成。可以点击不调试运行测试。 参考 TensorRT之安装与测试（Windows和Linux环境下安装TensorRT） Window下Python+CUDA+PyTorch安装","tags":["CPP","深度学习","YOLOv5","TensorRT"],"categories":["日常"]},{"title":"搭建一个自己的简单博客","path":"/2023/4/","content":"简单几步，基于Hexo搭建一个属于自己的简单博客 关键词：Hexo、博客 工具准备 1. Nodejs Nodejs简单来说就是运行在服务端的JavaScript，博客交互需要用到Nodejs。 选择合适的软件版本下载，下载地址：https://nodejs.cn/download/ 下载完成后按正常流程安装，可安装在非系统盘，记得选择“Add to PATH”配置PATH环境变量。我的Nodejs安装在E:\\Nodejs中。 注：为了软件安装简洁可控，还需要对Nodejs的内容（Cache和global）进行规划，具体可参考nodejs的安装及详细环境配置或修改项目默认node_modules路径或node安装后的设置(node_global和node_cache) - windows，或自行搜索。 2. Git Git是一个分布式版本控制系统，简单理解为它可以帮助我们管理文件各种版本，博客的更新之类的。 下载地址：https://git-scm.com/ 下载完成后按正常流程安装，可安装在非系统盘，其他选项可以保持默认。我的Git安装在E:\\Git中。 3. 验证Nodejs是否安装成功 在桌面鼠标右键，选择菜单中的Git Bash Here。 在弹出的窗口中输入以下指令 node -v npm -v 若出现了对应的版本号，则说明安装成功。若不出现版本号，则检查Nodejs的安装过程，或者必应搜索相关帮助。 4. cnpm 上面的npm -v查看了npm的版本，可以简单理解为npm是一种下载工具。而npm下载一般是通过国外网络下载，速度比较慢。因此需要先通过npm安装cnpm（国内下载），之后就是用cnpm代替npm。 npm install -g cnpm --registry=https://registry.npmmirror.com 可能出现镜像源过期的情况。 通过查询版本号验证是否安装成功。 cnpm -v 安装Hexo Hexo是一种博客框架，通过它可以将简单的Markdown语言转化为带装饰的网页。 通过下面命令安装Hexo。 cnpm install hexo-cli -g 也可以通过查询版本号确认Hexo是否安装成功。 hexo -V Hexo的常用命令：hexo -s本地查看博客，hexo g生成博客，hexo clean删除当前博客所有网页页面。 开始建造你的博客 1. 创建一个新的文件夹，尽量不再移动。 如我在F盘创建了一个文件夹叫15.Blog，就在15.Blog文件夹下右键选择Git Bash。 2. 初始化博客 在窗口中输入命令，等待完成。（如果运行至Install dependencies卡住，可以Ctrl + C结束命令） hexo init 3. 查看博客 在窗口中输入命令，查看博客的初始页面。 hexo s 4. 给博客下载主题——Next 点击此处寻找合适的主题，以Next为例，因为该主题基础、自定义程度高。 可以用git指令将Github的主题压缩包下载到博客的themes/文件夹中： git clone 复制的地址 themes/主题名字 上面指令意思是将指定地址的内容克隆到本地themes/文件夹并命名为指定名字。 也可以直接下载压缩包粘贴至themes/文件夹中。 5. 修改配置文件 在博客的根目录中有一个名为_config的文本文件，在主题目录也有一个名为_config的文本文件，此处做区分，前者为博客配置文件，后者为主题配置文件。 打开博客配置文件，可以根据官方配置介绍进行修改个性化博客。 将博客配置文件中themes一行填入刚下载的next主题，即可使用该主题。在博客目录打开Git Bash，输入hexo s可以查看博客。 注意：有些主题你更换之后是暂时无法预览的，因为有的主题还需要安装它需要的依赖。 编写你的第一条博客 在博客根目录打开Git Bash，输入下面的指令即可创建文章。 $ hexo new \"文章名字\" 每次生成的文章都固定在你的博客根目录下面的source/_posts下，并以Markdown文件形式编写保存。 部署你的博客到Github 首先需要有一个Github账号，并且新建仓库名为用户名+.github.io。 接着需要进行一系列的密钥绑定： 1. 在博客根目录打开Git Bash，输入下面的命令，接着会出现你的密钥。 ssh-keygen -t rsa -C “your_email@youremail.com“ cat ~/.ssh/id_rsa.pub 2. 在Github页面点击头像-Settings-SSH and GPG keys-New SSH key，接着把密钥复制上去。 3. 再在Git Bash中执行下面命令。 ssh -T git@github.com 接着提示Are you sure you want to continue connecting (yes/no/[fingerprint])? ，输入yes回车即可。 4. 点击项目仓库，在左上角的Clone or download中点击Use SSH，复制git开头的地址。 5. 打开博客配置文件，找到deploy一行，按照下面的指示修改。 deploy:\ttype: git\trepo: 复制到的地址\tbranch: master 6. 在博客根目录打开Git Bash，分别执行下列命令。 git config --global user.name \"yourname\"git config --global user.email \"youremail\" 7. 安装上传插件。 cnpm install hexo-deployer-git --save 8. 使用下面指令上传博客。 hexo d 9. 打开项目仓库，选择上方的Settings，找到Pages，在Source处选择Deploy from a branch。之后就会出现一个网站地址，便是博客地址。 注 如有纰漏，可同步参考此篇博客或自行搜索他人教程相互参考。","tags":["Hexo","博客"],"categories":["日常"]},{"title":"使用阿里云对象存储OSS实现图床","path":"/2023/3/","content":"注册登录阿里云👉开启对象存储👉配置Key👉放心上传 关键词：对象存储OSS 1.什么是图床 图床是一种概念，顾名思义用于网络上存放图片。当网站图片过多时，整个网站的存储大小会变得较大，负担也变得较大。为了减轻负担，可以选择把图片置于一种存储容器（图床）中，之后显示图片就只需引用网络链接即可。 2.开启对象存储服务 进入阿里云官网，点击右上角控制台，搜索对象存储OSS。 选择创建Bucket，设置建议如下： Bucket名称：自定义 地域：选择距离自己较近的 存储类型：默认不动 存储荣誉类型：默认不动 读写权限：公共读 创建成功后可在Bucket列表查看。 3.使用PicGo工具进行图片上传 下载地址 下载后选择合适的盘符安装，打开软件。 初始时可能不显示界面，需要去系统任务栏右键软件图标，选择打开主窗口。 接着选择图床设置，此处使用阿里云OSS。 回到阿里云OSS控制台，移动至右上角悬浮，点击AccessKey管理。创建一个新AccessKey，复制并粘贴到PicGo中。 配置参数建议如下： 设定KeyID：AccessKey中复制得来 设定KeySecret：AccessKey中复制得来 设定Bucket：你Bucket得名字 设定存储区域：OSS选择的地域 设定存储路径：图片上传至OSS的文件夹或路径 配置完成后即可上传图片，在PicGo的相册中可以获得图片的连接，可在HTML或者Markdown等文件中调用。","tags":["对象存储OSS"],"categories":["日常"]},{"title":"记录Keil_C51和Keil_MDK的安装","path":"/2023/2/","content":"介绍Keil_C51和Keil_MDK的安装 关键词：Keil 什么是Keil C51和Keil MDK Keil是一家公司名称，也是一款软件名称。Keil 有四大软件（IDE），包括 MDK、C51、C251、C166。 Keil C51和MDK是针对不同类型MCU的两款集成开发工具。 Keil C51 下载安装程序 Keil官网下载 安装过程 像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装，个人信息随便填，等待安装完成。 此次我安装路径设置为G:\\Keil_C51中。 启动软件 UV4可执行文件位于：G:\\Keil_C51\\UV4 Keil MDK 下载安装程序 Keil官网下载 安装过程 像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装本体和Pack文件，个人信息随便填，等待安装完成。 此次我将本体路径设置为G:\\Keil_MDK中，Pack路径设置为G:\\Keil_MDK\\。 启动软件 UV4可执行文件位于：G:\\Keil_MDK\\UV4 Keil Key Generator 参考此博客","tags":["Keil"],"categories":["日常"]},{"title":"HTML语言学习记录","path":"/2023/HTML/","content":"HTML：基础 关键词：HTML HTML前言 什么是HTML？ HTML，为HyperTest Markup Language的缩写，意为超文本标记语言。其是一种用于创建网页的标准标记语言。 HTML由一系列元素组成，可以用于描述网页的结构。 HTML使用各种元素使得浏览器展示内容，并使用元素标记内容片段。 作为HTML文件，必须以一个声明开始。 这个声明表示文档类型，帮助浏览器正确展示网页内容。其只需在每个文档开头出现一次，它也不注重大小写。一般的HTML5文件以!DOCTYPE html开始。 HTML文件应该以html开始并以/html结束。 HTML文件的可视部分应该在body和/body之间。 HTML整体是大小写不敏感，但为了格式与美观，一般有统一的标准。 HTML使用!-- --进行注释。 HTML5 HTML5 是最新的 HTML 标准。 HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件。 HTML5 拥有新的语义、图形以及多媒体元素。 HTML5 提供的新元素和新的 API 简化了 web 应用程序的搭建。 HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。 响应式Web设计 响应式Web设计，Responsive Web Design，能够以可变尺寸传递网页。 可以使用Bootstrap创建响应式设计。 HTML标准字符集 为了正确显示HTML页面，在meta标签中设置编码。如： meta charset=\"UTF-8\" / 字符集有很多，如ASCII码，UTF-8码，ISO-8859-1码，推荐用UTF-8码。 在使用某些字符时，存在歧义，使用实体代码或编号表示。 更多字符 HTML统一资源定位器与路径 统一资源定位器和路径不完全相同。 URL，Uniform Resource Locator，统一资源定位器，也被称为网址。 URL 只能使用 ASCII 字符集来通过因特网进行发送。URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 网址具有一定的语法规则：scheme://host.domain:port/path/filename scheme定义因特网服务类型，常见为http和https。 host定义域主机，http默认主机是www。 domain定义因特网域名。 :port定义主机上的端口号。 path定义服务器上的路径，省略默认根目录。 filename定义文档、资源的名称。 路径描述了网站文件夹结构中某个文件的位置，使用相对路径是个好习惯。 XHTML XHTML是指可扩展超文本标记语言，是更严格更纯净的HTML版本。 其与HTML4.01几乎相同。 HTML元素理念 定义 HTML 元素指的是从开始标签（xxx）到结束标签（/xxx）的所有代码。其包含开始标签，内容和结束标签。 语法 HTML元素以开始标签起始。 HTML元素以结束标签终止。 元素的内容是开始标签与结束标签之间的内容。 某些HTML元素具有空内容。 没有内容的 HTML 元素被称为空元素。空元素在开始标签中进行关闭（以开始标签的结束而结束，即无结束标签）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。在开始标签中添加斜杠，比如 br /，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。即使br在所有浏览器中都是有效的，但使用br /其实是更长远的保障。 大多数HTML元素可拥有属性。 元素实例 如html和/html元素（html与/html标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。），body和/body元素（body元素包含文档的所有内容），HTML标题，HTML段落，HTML链接，HTML图像等。 元素嵌套 大多数HTML元素可以嵌套（即包含其他HTML元素）如： htmlbody!-- 标签p表示段落元素 --pThis is a paragraph./p /body/html HTML属性理念 属性为 HTML 元素提供附加信息。 HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 属性总是在 HTML 元素的开始标签中规定。 属性总是以名称或值对的形式出现 HTML全局属性 HTML头部元素 head元素 定义关于文档的信息。 head标签放在文档的开始处，紧跟在html后面，并处于body标签或frameset标签之前。 head元素是所有头部元素的容器。head内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。以下标签都可以添加到 head 部分：title、base、link、meta、script以及style。 属性 profile，可以设置URL，一个由空格分隔的URL列表，这些URL包含有关页面的元数据信息。 文档的头部经常会包含一些meta标签，用来告诉浏览器关于文档的附加信息。在将来，创作者可能会利用预先定义好的标准文档的元数据配置文件（metadata profile），以便更好地描述它们的文档。profile属性提供了与当前文档相关联的配置文件的 URL。 title元素 定义文档标题，定义浏览器工具栏中的标题，定义页面被收藏时显示的标题，定义显示在搜索引擎结果中的页面标题。 title元素在所有 HTML/XHTML文档中都是必需的。 属性 dir，可以设置值，规定元素中内容的文本方向。 lang，可以设置代码，规定元素中内容的语言代码。 xml:lang，可以设置代码，规定XHTML文档中元素内容的语言代码。 base元素 定义页面上所有链接的默认地址或默认目标（target）。 其必须位于head元素内部。 属性 href，可以设置URL，规定页面中所有相对链接的基准URL。即设置默认地址。 target，可以设置值，规定在何处打开页面中的所有链接。值包括“_blank”，“_parent”，“_self”，“_top”，和框架名。 link元素 定义文档与外部资源之间的关系。 link标签最常用于连接样式表。 属性 charset，可以设置字符编码方式，在HTML5不支持。 href，可以设置URL，规定被链接文档的位置。 hreflang，可以设置语言代码，规定被链接文档中文本的语言。 media，可以设置媒体查询，规定被链接文档将被显示在什么设备上。 referrerpolicy，可以设置值，规定在获取资源时使用的引荐来源信息。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“unsafe-url”。 rel，可以设置值，规定当前文档与被链接文档之间的关系。值包括“alternate”，“author”，“help”，“icon”，“licence”，“next”，“pingback”，“prefetch”，“prev”，“search”，“sidebar”，“stylesheet”，“tag”。 rev，可以设置反向关系，在HTML5中不支持。 sizes，可以设置值，规定被链接资源的尺寸，仅适用rel=\"icon\"。值包括“heightxwidth”，“any”。 target，可以设置目标，在HTML5中不支持。 type，可以设置MIME类型，规定被链接文档的MIME类型。 style元素 定义文档的样式信息。如： htmlheadstyle type=\"text/css\"h1 {color:red}p {color:blue}/style/headbodyh1Header 1/h1pA paragraph./p/body/html 属性 type，只能设置text/css，规定样式表的MIME类型。 media，可以设置值，为样式表规定不同的媒介类型。值包括“screen”，“tty”，“tv”，“projection”，“handheld”，“print”，“braille”，“aural”，“all”。 meta元素 定义关于HTML文档的元数据。 meta标签位于文档的头部，不包含任何内容。meta标签的属性定义了与文档相关联的名称/值对。 meta无结束标签。 属性 charset，可以设置字符，规定HTML文档的字符编码。 content，可以设置文本，定义与http-equiv或name相关的元信息。 content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。content 属性始终要和name属性或http-equiv属性一起使用。 http-equiv，可以设置值，把content属性关联到HTTP头部。值包括“content-security-policy”，“content-type”，“default-style”，“refresh”。 name，可以设置值，把content属性关联到一个名称。值包括“application-name”，“author”，“description”，“generator”，“keywords”，“viewport”。 scheme，可以设置一些文本，定义用于解释content属性值的格式。scheme 属性用于指定要用来翻译属性值的方案。此方案应该在由 head标签的 profile 属性指定的概况文件中进行了定义。 script元素 定义客户端脚本。比如JavaScript。 属性 async，规定异步执行脚本（仅适用于外部脚本）。 charset，可以设置编码，规定在外部脚本文件中使用的字符编码。 crossorigin，可以设置值，将请求模式设置为HTTP CORS请求。值包括“anonymous”，“use-credentials”。 defer，规定是否对脚本执行进行延迟，直到页面加载为止。 language，规定脚本语言，不赞成使用，用type代替。 referrerpolicy，可以设置值，规定外部脚本文件的URL。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“same-origin”，“strict-origin”，“strict-origin-when-cross-origin”，“unsafe-url”。 src，可以设置URL，规定外部脚本文件的URL。 xml:space，规定是否保留代码中的空白。 type，可以设置MIME类型，指示脚本的MIME类型。 HTML基本元素 HTML标题 标题（Heading）是通过h1~h6等标签进行定义的。h1定义最大的标题。h6定义最小的标题。 具有“align”属性，其值有“left”、“center”、“right”和“justify”，规定了标题中文本的排列。 hr /标签在 HTML 页面中创建水平线。hr元素可用于分隔内容。 HTML段落 段落是通过p标签定义的。 具有“align”属性，其值有“left”、“center”、“right”和“justify”，规定了段落中文本的排列。 br /标签可以在段落中进行换行。 HTML格式化类标签 文本格式化标签 b和/b加粗字体 strong和/strong加重语气 big和/big加大字体 small和/small小字体 em和/em着重文字 i和/i 斜体字 sup和/sup上标 sub和/sub下标 del和/del删除字 ins和/ins下划线 “计算机输出”标签 code和/code计算机代码字体 kbd和/kbd键盘码字体 samp和/samp计算机代码样本字体 tt和/tt打字机代码字体 var和/var定义变量字体 pre和/pre预格式文本字体 引用和术语定义 abbr和/abbr定义缩写，鼠标悬浮显示内容 acronym和/acronym定义首字母缩写，鼠标悬浮显示内容。 address和/address定义地址 bdo和/bdo定义文字方向，具有dir属性，值为“rtl”(right-to-left)和“ltr”(left-to-right) blockquote和/blockquote定义长引用 q和/q定义短引用 cite和/cite定义引用、引证；dfn和/dfn定义项目。 HTML链接 链接或者超链接，可以是一个字、一个词、一幅画像，可以点击跳转到新的内容。 链接是通过a定义的。 开始标签和结束标签之间的文字被作为超级链接来显示。超级链接可以是文本、图片或者其他HTML元素。 a标签具有href属性和name属性，href属性用于创建指向另一个文档的链接，name属性用于创建文档内的书签。用法如下。 !DOCTYPE htmlhtml body a name = \"flag\"这是一句话/a br / a href=\"http://cn.bing.com/\" A link to Bing/a br / a href = \"#flag\"跳转到顶部句子/a /body/html a标签具有target属性，其用于定义被链接的文档在何处显示。如a href=\"http://cn.bing.com/\" target=\"_blank\"A Link/a中的target=\"_blank\"表示在新的窗口打开文档。 HTML图像 在 HTML 中，图像由img标签定义。img是空标签，意思是说，它只包含属性，并且没有闭合标签。 页面上显示图像需要使用源属性（src，source），源属性的值是图像的URL地址。如：img src=\"xxx/image.jpg\"，则image这个jpg文件需要在源属性的值的地址上。 替换文本属性（Alt），用来为图像定义一串预备的可替换的文本。替换文本属性的值是人为定义的。即当图片无法显示时，展示alt属性的值的文字。如：img src=\"xxx/a.jpg\" alt=\"test\"，当a.jpg无法显示时，显示test。 img标签中可以使用align属性进行图像与文本对齐。此处align的值可选“bottom”、“middle”和“top”，默认bottom对齐。 img标签中可以使用align属性进行文本和图像位置设定。此处align的值可选“left”、“right”，分别用于图像固定段落的左端和右端。 img标签中可以使用width和height属性进行更改图像的大小。如：img src=\"xxx/a.jpg\" width=\"200\" height=\"200\" 可以将a标签和img结合，制作能跳转链接的图片。如：a href=\"http://cn.bing.cn\"img src=\"xxx/a.jpg\"/a img标签中还有以下属性 属性 值 描述 border 像素值 定义图像周围的边框 hspace 像素值 定义图像左侧和右侧的空白 ismap URL 将图像定义为服务器端图像映射 loading eager/lazy 规定浏览器是立即加载图像还是推迟加载屏幕外图像 longdesc URL 指向包含长的图像描述文档的URL referrerpolicy no-referrer/no-referrer-when-downgrade/origin/origin-when-cross-origin/unsafe-url 规定获取图像时要使用的引荐来源信息 usemap URL 将图像定义为客户器端图像映射 vspace 像素值 定义图像顶部和底部的空白 在body标签中使用background属性可以使用图像作为背景。但如果图像小于页面，图像会进行重复。 使用map标签和area标签制作图像映射。 img src=\"xxx/a.jpg\" usemap=\"#amap\"!--map标签中有属性name和id，与img标签usemap对应--!--map标签中id属性时必须且唯一的，name属性时可选的--map name=\"amap\" id=\"amap\"!--area标签中有shape属性、coords属性等-- area shape=\"circle\" coords=\"180,139,14\" href=\"xxx\" alt=\"1\" area shape=\"circle\" coords=\"129,161,10\" href=\"xxx\" alt=\"2\" area shape=\"rect\" coords=\"0,0,110,260\" href=\"xxx\" alt=\"3\"/map area标签的其他属性如下： 属性 值 描述 coords 坐标值 定义可点击区域的坐标和大小 download 文件名 指定用户点击超链接时下载目标 href URL 此区域目标URL hreflang language_code 规定区域中URL的语言 media media query 规定目标URL优化的媒体、设备 referrerpolicy no-referrer/no-referrer-when-downgrade/origin/origin-when-cross-origin/same-origin/strict-origin-when-cross-origin/unsafe-url 规定用户单击超链接时发送引荐来源信息 rel alternate/author/bookmark/help/licence/next/nofollow/noreferrer/prefatch/prev/search/tag 规定区域中目标URL的语言 nohref nohref 从图像映射排除某个区域 shape default/rect/circ/poly 定义区域形状 target _blank/_parent/_self/_top 规定在何处打开href属性指定目标的URL type media_type 规定目标URL的Internet媒体类型 HTML表格元素 表格由table标签定义。每个表格均有若干行（由tr标签定义），每行被分割为若干单元格（由td标签定义）。 字母 tr 指一行（table row）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 表格的表头用th标签表示。 为了避免空单元边框（添加border属性）不显示，在空单元格中添加一个空格占位符（nbsp;），就可以将边框显示出来。 表格标签： 标签 描述 table 定义表格 caption 定义表格标题 th 定义表格的表头 tr 定义表格的行 td 定义表格单元 thead 定义表格的页眉 tbody 定义表格主体 tfoot 定义表格页脚 col 用于表格列的属性 colgroup 定义表格列的组 table标签 属性 align，可以设置值，规定表格相对周围元素的对齐方式。值包括“left”，“right”，“center”。不赞成使用，用样式代替。 bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。 border，可以设置像素值，规定表格边框的宽度。 cellpadding，可以通过设置百分比或像素值，规定单元边沿与其内容之间的空白。 cellspacing，可以通过设置百分比或像素值，规定单元格之间的空白。 frame，可以通过设置值，规定外侧边框的哪个部分时可见的。值包括“void”，“above”，“below”，“hsides”，“lhs”，“rhs”，“vsides”，“box”，“border”。 rules，可以通过设置值，规定内侧边框的哪个部分时可见的。值包括“none”，“groups”，“rows”，“cols”，“all”。 summary，可以通过设置文本，规定表格的摘要。 width，可以通过设置百分比或像素值，规定表格的宽度。 caption标签 caption 元素定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 属性 其属性有align，可以设置值，规定标题的对齐方式。值包括“left”，“right”，“top”，“bottom”。不赞成使用，用样式代替。 th标签与td标签 定义表格内的表头单元格。 HTML 表单中有两种类型的单元格： 表头单元格 - 包含表头信息（由 th 元素创建） 标准单元格 - 包含数据（由 td 元素创建） th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。如果需要将内容横跨多个行或列，请使用 colspan 和 rowspan 属性。 属性 abbr，可以通过设置文本，规定单元格中内容的缩写版本。 align，可以通过设置值，规定单元格内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。 axis，可以设置分类名字，对单元格进行分类。 bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。 char，可以设置字符，规定根据哪个字符进行内容的对齐。 charoff，可以设置数字，规定对齐字符的偏移量。 colspan，可以设置数字，规定单元格可跨越的列数。 headers，可以设置属性类型，由空格分隔的表头单元格ID列标，为数据单元格提供表头信息。 nowrap，可以设置值，规定单元格中是否折行。不推荐使用，用样式代替。 rowspan，可以设置数字，规定单元格可横跨的行数。 scope，可以设置值，定义将表头数据与单元数据相关联的方法。值包括“col”，“clogroup”，“row”，“rowgroup”。 valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。 width，可以设置百分比或像素值，规定表格单元格的宽度。不推荐使用，用样式代替。 height，可以设置百分比或像素值，规定表格单元格的高度。不推荐使用，用样式代替。 tr标签 属性 align，可以通过设置值，规定表格行内容对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。 bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。 char，可以设置字符，规定根据哪个字符进行内容的对齐。 charoff，可以设置数字，规定对齐字符的偏移量。 valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。 thead标签、tbody标签和tfoot标签 thead标签定义表格的表头。thead 元素应该与 tbody 和 tfoot 元素结合起来使用。 tbody 元素用于对 HTML 表格中的主体内容进行分组，而 tfoot 元素用于对 HTML 表格中的表注（页脚）内容进行分组。 如果使用 thead、tfoot 以及 tbody 元素，就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody。必须在 table 元素内部使用这些标签。 属性 align，可以通过设置值，规定元素中内容对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。 char，可以设置字符，规定根据哪个字符进行内容的对齐。 charoff，可以设置数字，规定对齐字符的偏移量。 valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。 col标签 col标签为表格中一个或多个列定义属性值。 如需对全部列应用样式，col标签很有用，这样就不需要对各个单元和各行重复应用样式了。 只能在 table 或 colgroup 元素中使用col标签。 无结束标签。 为col标签添加 class 属性。这样就可以使用 CSS 来负责对齐方式、宽度和颜色等等。 属性 align，可以通过设置值，规定与col元素相关的内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。 char，可以设置字符，规定根据哪个字符进行内容的对齐。 charoff，可以设置数字，规定对齐字符的偏移量。 span，可以设置数字，规定col元素应该跨越的列数。 valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。 width，可以设置百分比或像素值或相关长度，规定col元素的宽度。 colgroup标签 colgroup标签用于对表格中的列进行组合，以便对其进行格式化。 如需对全部列应用样式，colgroup标签很有用，这样就不需要对各个单元和各行重复应用样式了。 colgroup标签只能在 table 元素中使用。 属性 align，可以通过设置值，定义在列组合中内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。 char，可以设置字符，规定根据哪个字符进行内容的对齐。 charoff，可以设置数字，规定对齐字符的偏移量。 span，可以设置数字，规定列组应该跨越的列数。 valign，可以设置值，定义在列组合中内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。 width，可以设置百分比或像素值或相关长度，规定列组合的宽度。 HTML列表元素 无序列表 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。 无序列表始于ul标签（unordered_list）。每个列表项始于li标签（list）。 ul lia/li lib/li/ul 列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 有序列表 有序列表始于ol标签（ordered_list）。每个列表项始于li标签（list）。 ol lia/li lib/li/ol 列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 定义列表 自定义列表不仅仅是一列项目，而是项目及其注释的组合。 自定义列表以dl标签开始。每个自定义列表项以dt开始。每个自定义列表项的定义以dd开始。 dl dtCoffee/dt ddBlack hot drink/dd dtMilk/dt ddWhite cold drink/dd/dl 列表标签 ol标签 定义有序列表。 属性 compact，不赞成使用。 reversed，设置列表顺序为降序。 start，可以设置数字，规定有序列表的起始值。 type，可以设置值，规定在列表中使用的标记类型。值包括“1”，“A”，“a”，“I”，“i”。 ul标签 定义无序列表。 属性 compact，不赞成使用。 type，可以设置值，规定在列表中使用的标记类型。值包括“disc”，“square”，“circle”。 li标签 定义列表项目。 用于ol标签或ul标签中。 属性 type，不赞成使用，值如上5+3，共8种。 value，不赞成使用，规定项目的数字。 dl标签、dt标签和dd标签 dl标签定义定义列表。 dt标签定义定义项目。 dd标签定义定义描述。 htmlbodyh2一个定义列表：/h2dl dt计算机/dt dd用来计算的仪器 ... .../dd dt显示器/dt dd以视觉方式显示信息的装置 ... .../dd/dl/body/html dir标签和menu标签 已废弃，使用ul标签代替。 HTML块 大多数 HTML 元素被定义为块级元素（block level element）或内联元素（inline element）。 块级元素在浏览器显示时，通常会以新行来开始（和结束）而内联元素在显示时通常不会以新行开始。 div元素 div用于定义文档中的分区或节（division/section）。 HTMLdiv元素是块级元素，它是可用于组合其他 HTML 元素的容器。浏览器通常会在 div 元素前后放置一个换行符。 div元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，div元素可用于对大的内容块设置样式属性。 div元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用div元素来组合块级元素，这样就可以使用样式对它们进行格式化。如： !--使用div分块，并用class标识和更改颜色为蓝色-- div class=\"xxx\" style=\"color:blue\" h2xxxxxx/h2 pxxxxxx/p /div align属性，可以设置值，规定div元素中的内容的对齐方式。不赞成使用，用样式取代。 值包括“left”、“right”、“center”、“justify”。 span元素 span用于组合文档中的行内元素。 HTMLspan元素是内联元素，可用作文本的容器。 span元素也没有特定的含义。当与 CSS 一同使用时，span元素可用于为部分文本设置样式属性。如： !--在html中标识class，并使用span组合--p class=\"tip\"span强调：/span... ... .../p /*在CSS文件中统一设置span的格式*/p.tip span { font-weight:bold; color:#ff9955; } 使用span来组合行内元素，以便通过样式来格式化它们。 HTML类标签 使用class标识分类，进行内容格式化。如： !DOCTYPE htmlhtml head !--CSS样式-- style .cities { background-color:black; color:white; margin:20px; padding:20px; } span.place { background-color:blue; color:white; margin:20px; padding:20px; } /style /head body !--使用class名整体格式化-- div class=\"cities\" h2London/h2 p London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. /p /div h1A span class=\"place\"place/spanin London/h1 /body/html HTML内联框架 iframe可以在网页内显示网页。 语法：iframe src=\"URL\"iframe 属性 align，可以设置值，规定如何根据周围的元素对齐此框架。不赞成使用，值包括“left”，“right”，“top”，“middle”，“bottom”。 frameborder，可以设置0或1，规定是否显示框架周围的边框。 height，可以设置百分比或像素值，规定iframe的高度。 width，可以设置百分比或像素值，规定iframe的宽度。 longdesc，可以设置URL，规定一个页面，该页面包含了有关iframe的描述。 marginheight，可以设置像素值，定义iframe的顶部和底部的边距。 marginwidth，可以设置像素值，定义iframe的左边和右边的边距。 name，可以设置文本，规定iframe的名称。 referrerpolicy，可以设置值，规定iframe的引荐信息。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“same-origin”，“strict-origin-when-cross-origin”，“unsafe-url”。 sandbox，可以设置值，启用一系列对iframe中内容的额外限制。值包括“”，“allow-forms”，“allow-same-origin”，“allow-scripts”，“allow-top-navigation”。 scrolling，可以设置值，规定是否在iframe中显示滚动条。值包括“yes”，“no”，“auto”。 seamless，规定iframe看上去像是包含文档的一部分。 src，可以设置URL，规定iframe中显示的文档的URL。 srcdoc，可以设置HTML代码，规定在iframe中显示的页面的HTML内容。 HTML布局类标签 HTML5语义元素 header 定义文档或节的页眉。应该被用作介绍性内容的容器。 main 规定文档的主内容。 mark 定义重要或强调的文本。 time 定义日期/时间。 nav 定义导航链接的容器。 section 定义文档中的节。 article 定义独立的自包含文章。应用场景：论坛、博客、新闻…… aside 定义内容之外的内容，如侧栏。aside内容应该与周围内容相关。 footer 定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。 details 定义额外的细节。 figure 规定自包含内容，比如图示、图表、照片、代码清单等。通过 HTML5，图片和标题能够被组合在figure元素中。 figcaption 定义figure元素的标题。 summary 定义details元素的标题。 框架 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。 但使用框架开发人员必须同时跟踪更多的HTML文档，并且很难打印整张页面。 标签 frameset，定义如何将窗口分割为框架。每个 frameset 定义了一系列行或列，rows/columns 的值规定了每行或每列占据屏幕的面积。 frame，定义了放置在每个框架中的 HTML 文档。 为不支持框架的浏览器添加noframes标签。 假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在frame标签中加入：noresize=“noresize”。为不支持框架的浏览器添加noframes标签。不能将body/body标签与frameset/frameset标签同时使用！不过，假如你添加包含一段文本的noframes标签，就必须将这段文字嵌套于body/body标签内。如 htmlframeset cols=\"25%,50%,25%\" frame src=\"/xxx/frame_a.html\" frame src=\"/xxx/frame_b.html\" frame src=\"/xxx/frame_c.html\"noframesbody您的浏览器无法处理框架！/body/noframes/frameset/html HTML表单 HTML表单用于搜集不同类型的用户输入。 form元素定义HTML表单。 表单元素是指不同类型的input元素、复选框、单选按钮、提交按钮等等。 form元素属性 action属性 action 属性定义提交表单时要执行的操作。通常，当用户单击“提交”按钮时，表单数据将发送到服务器上的文件中。 值为URL。 如果省略 action 属性，则将 action 设置为当前页面。 target属性 target 属性规定提交表单后在何处显示响应。 值包括“_blank”（新窗口），“_self”（当前窗口），“_parent”（父框架），“_top”（窗口的body中），框架名。默认为“_self”。 method属性 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）。 表单数据可以作为 URL 变量（使用 method=“get”）或作为 HTTP post 事务（使用 method=“post”）发送。提交表单数据时，默认的 HTTP 方法是 GET。 如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。当您使用 GET 时，表单数据在页面地址栏中是可见的。GET 最适合少量数据的提交。浏览器会设定容量限制。 如果表单正在更新数据，或者包含敏感信息（例如密码）。POST 的安全性更好，因为在页面地址栏中被提交的数据是不可见的。 注意事项 GET 以名称/值对的形式将表单数据追加到 URL。 永远不要使用 GET 发送敏感数据！（提交的表单数据在 URL 中可见！）。 URL 的长度受到限制（2048 个字符）。 对于用户希望将结果添加为书签的表单提交很有用。 GET 适用于非安全数据，例如 Google 中的查询字符串。 POST 将表单数据附加在 HTTP 请求的正文中（不在 URL 中显示提交的表单数据）。 POST 没有大小限制，可用于发送大量数据。 带有 POST 的表单提交无法添加书签。 如果表单数据包含敏感信息或个人信息，请务必使用 POST！ autocomplete属性 autocomplete 属性规定表单是否应打开自动完成功能。 启用自动完成功能后，浏览器会根据用户之前输入的值自动填写值。 值为on或off。 novalidate属性 novalidate 属性是一个布尔属性。它规定提交时不应验证表单数据。 值为自身。 accept-charset属性 accept-charset 属性规定服务器用哪种字符集处理表单数据。 常用值有：UTF-8 - Unicode 字符编码，ISO-8859-1 - 拉丁字母表的字符编码，gb2312 - 简体中文字符集。 enctype属性 enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。 表单数据会默认编码为 “application/x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。 值包括“application/x-www-form-urlencoded”（编码所有），“multipart/form-data”（不对字符编码），“text/plain”（部分编码）。 name属性 name属性规定表单名称，提供了一种在脚本中引用表单的方法。 如果要正确地被提交，每个输入字段必须设置一个 name 属性。 值为自定义名称。 rel属性 rel 属性规定当前文档和被链接文档之间的关系。 值包括“external”（规定引用的文档不是当前站点的一部分），“help”（链接到帮助文档），“license”（链接到文档的版权信息），“next”（集合中的下一个文档），“nofollow” （链接到未经认可的文档，例如付费链接）（Google 使用 “nofollow” 来指定 Google 搜索蜘蛛不应跟踪该链接），“noopener”， “noreferrer”（规定如果用户点击该超链接，则浏览器不应发送 HTTP 推荐标头），“opener”， “prev”（集合中的上一个文档），“search”（链接到文档的搜索工具）。 input元素输入类型 文本输入 input type=\"text\"定义用于文本输入的单行输入字段。 表单本身并不可见。还要注意文本字段的默认宽度是 20 个字符。 密码输入 input type=\"password\"定义密码字段。 password 字段中的字符会被做掩码处理（显示为星号或实心圆）。 单选按钮输入 input type=\"radio\"定义单选按钮。 通常单选应该有选项，如下是一个单选： forminput type=\"radio\" name=\"sex\" value=\"male\" checked/男br /input type=\"radio\" name=\"sex\" value=\"female\" checked/女/form 复选框输入 input type=\"checkbox\"定义复选框。 复选框允许用户在有限数量的选项中选择零个或多个选项。 按钮输入 input type=\"button定义按钮。 提交按钮 input type=\"submit\"定义用于向表单处理程序提交表单的按钮。 表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。有关处理表单输入的知识，参考ASP或PHP语言。 表单处理程序在表单的 action 属性中指定： !--将表单数据提交到xxx.asp页面--form action=\"../xxx/xxx.asp\"Name:br /input type=\"text\" name=\"Name\"input type=\"submit\" value=\"提交\"/form 提交按钮中的value属性值是显示在按钮上的内容。 HTML5新增输入类型 color input type=\"color\"用于应该包含颜色的输入字段。根据浏览器支持，颜色选择器会出现输入字段中。 date input type=\"date\"用于应该包含日期的输入字段。根据浏览器支持，日期选择器会出现输入字段中。 datetime input type=\"datetime\"允许用户选择日期和时间（有时区）。根据浏览器支持，日期选择器会出现输入字段中。 datetime-local input type=\"datetime-local\"允许用户选择日期和时间（无时区）。根据浏览器支持，日期选择器会出现输入字段中。 email input type=\"email\"用于应该包含电子邮件地址的输入字段。根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。某些智能手机会识别 email 类型，并在键盘增加 “.com” 以匹配电子邮件输入。 month input type=\"month\"允许用户选择月份和年份。根据浏览器支持，日期选择器会出现输入字段中。 number input type=\"number\"用于应该包含数字值的输入字段。能够对数字做出限制。 range input type=\"range\"用于应该包含一定范围内的值的输入字段。根据浏览器支持，输入字段能够显示为滑块控件。 search input type=\"search\"用于搜索字段（搜索字段的表现类似常规文本字段）。 tel input type=\"tel\"用于应该包含电话号码的输入字段。目前只有 Safari 8 支持 tel 类型。 time input type=\"time\"允许用户选择时间（无时区）。根据浏览器支持，时间选择器会出现输入字段中。 url input type=\"url\"用于应该包含 URL 地址的输入字段。根据浏览器支持，在提交时能够自动验证 url 字段。某些智能手机识别 url 类型，并向键盘添加 “.com” 以匹配 url 输入。 week input type=\"week\"允许用户选择周和年。根据浏览器支持，日期选择器会出现输入字段中。 image input type=\"image\"获取点击图像时的x和y坐标。 input元素属性 value，值为自定义字段，规定输入字段的初始值。 readonly，不需要值，规定输入字段只读不可修改。 disabled，不需要值，规定输入字段禁用，不可用不可点击不会被提交。 size，值为字符数，规定输入字段框的尺寸。 maxlength，值为数字，规定输入字段允许的最大长度。 如设置 maxlength 属性，则输入控件不会接受超过所允许数的字符。 该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码。 输入限制并非万无一失。JavaScript 提供了很多方法来增加非法输入。如需安全地限制输入，则接受者（服务器）必须同时对限制进行检查。 autocomplete，值为on或off，规定表单或输入字段是否应该自动完成。当自动完成开启，浏览器会基于用户之前的输入值自动填写值。 可以把表单的 autocomplete 设置为 on，同时把特定的输入字段设置为 off，反之亦然。 autocomplete 属性适用于form以及如下input类型：text、search、url、tel、email、password、datepickers、range 以及 color。 autofocus，布尔属性，如果设置，则规定当页面加载时，input元素应该自动获得焦点。 form，规定input元素所属的一个或多个表单。如需引用一个以上的表单，请使用空格分隔的表单 id 列表。 即表单外使用input标签。 form action=\"xxx.php\" id=\"form1\" First name: input type=\"text\" name=\"fname\"br input type=\"submit\" value=\"Submit\"/form Last name: input type=\"text\" name=\"lname\" form=\"form1\" formaction，规定当提交表单时处理该输入控件文件的URL。 formaction 属性覆盖form元素的 action 属性。 formaction 属性适用于type=\"submit\"以及type=\"image\"。 formenctype，规定表单数据提交服务器时编码规则。 formenctype 属性覆盖form元素的 enctype 属性。 formenctype 属性适用于type=\"submit\"以及type=\"image\"。 formmethod，定义用以向action URL发送表单数据的HTTP方法。 formmethod 属性覆盖form元素的 method 属性。 formmethod 属性适用于type=\"submit\"以及type=\"image\"。 formnovalidate，布尔属性，设置时，规定提交表单时不对input元素进行验证。 formnovalidate 属性覆盖form元素的 novalidate 属性。 formnovalidate 属性可用于type=\"submit\"。 formtarget，规定名称或关键词指示提交表单后何处显示接收到的响应。 formtarget 属性会覆盖form元素的 target 属性。 formtarget 属性可与type=\"submit\"和type=\"image\"使用。 height和width，规定input元素的高度和宽度。 height 和 width 属性仅用于input type=\"image\"。 list，引用的datalist元素中包含了input元素的预定义选项。 min和max，规定input元素的最小值和最大值。 min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。 multiple，布尔属性，设置时，规定允许用户在input元素中输入一个以上的值。 multiple 属性适用于以下输入类型：email 和 file。 pattern，规定用于检查input元素值的正则表达式。 pattern 属性适用于以下输入类型：text、search、url、tel、email、password。 placeholder，规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。 该提示会在用户输入值之前显示在输入字段中。 placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password。 required，布尔属性，设置时，规定在提交表单之前必须填写输入字段。 required 属性适用于以下输入类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio、file。 step，规定input元素的合法数字间隔。 step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。 step 属性适用于以下输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。 select元素 定义下拉列表 option元素定义待选择的选项。列表通常会把首个选项显示为被选选项。通过添加 selected 属性来定义预定义选项。 select name=\"cars\"option value=\"volvo\"Volvo/optionoption value=\"saab\"Saab/optionoption value=\"fiat\"Fiat/optionoption value=\"audi\"Audi/option/select textarea元素 定义多行输入字段（文本域）。 button元素 定义可点击的按钮。 HTML媒体 Web 上的多媒体指的是音效、音乐、视频和动画。 插件（Plug-in）是扩展浏览器标准功能的计算机程序。 HTML对象 object元素 object元素定义 HTML 文档中的嵌入式对象。 它旨在将插件（例如 Java applet、PDF 阅读器和 Flash 播放器）嵌入网页中，但也可以用于将 HTML 包含在 HTML 中。 embed元素 embed元素也可定义了 HTML 文档中的嵌入式对象，也可用于在 HTML 中包含 HTML。 Web 浏览器长期以来一直支持embed元素。但是，它不属于 HTML5 之前的 HTML 规范的一部分。 embed元素没有结束标记。它无法包含替代文本。 HTML音频 使用embed元素嵌入MP3文件。 embed标签在 HTML 4 中是无效的。页面无法通过 HTML 4 验证。 不同的浏览器对音频格式的支持也不同。 如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。 如果用户的计算机未安装插件，无法播放音频。 如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。 使用object元素嵌入MP3文件。 不同的浏览器对音频格式的支持也不同。 如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。 如果用户的计算机未安装插件，无法播放音频。 如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。 使用HTML5audio元素播放音频。 audio标签在 HTML 4 中是无效的。您的页面无法通过 HTML 4 验证。 必须把音频文件转换为不同的格式。 audio元素在老式浏览器中不起作用。 audio controls=\"controls\" source src=\"song.mp3\" type=\"audio/mp3\" / source src=\"song.ogg\" type=\"audio/ogg\" /Your browser does not support this audio format./audio 最好的HTML解决方法是audio标签与embed标签混用。 使用JS和播放器播放音频。 audio标签属性 autoplay，设置该属性时，音频就绪后马上播放。 controls，设置该属性时，显示控件。 loop，出现该属性时，音频循环播放。 muted，出现该属性时，规定音频静音。 preload，出现该属性时，在页面加载时加载音频，预备播放。 src，值为URL，播放音频的URL。 HTML视频 使用embed标签。 HTML4 无法识别embed标签。您的页面无法通过验证。 如果浏览器不支持 Flash，那么视频将无法播放 iPad 和 iPhone 不能显示 Flash 视频。 如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。 使用object标签。 如果浏览器不支持 Flash，将无法播放视频。 iPad 和 iPhone 不能显示 Flash 视频。 如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。 使用video标签。 video ，是 HTML 5 中的新标签，作用是在 HTML 页面中嵌入视频元素。 您必须把视频转换为很多不同的格式。 video元素在老式浏览器中无效。 video元素无法通过 HTML 4 和 XHTML 验证 最好的HTML解决方法：HTML5+object+embed。 video标签属性 autoplay，设置该属性时，视频就绪后马上播放。 controls，设置该属性时，显示控件。 height，值为像素值，设置播放器高度。 width，值为像素值，设置播放器宽度。 loop，出现该属性时，视频循环播放。 muted，出现该属性时，规定视频静音。 poster，值为URL，规定视频下载时现实的图像，或播放按钮前显示的图像。 preload，出现该属性时，在页面加载时加载视频，预备播放。 src，值为URL，播放音频的URL。 HTML5新增元素 datalist datalist元素为input元素规定预定义选项列表。用户会在他们输入数据时看到预定义选项的下拉列表。input元素的 list 属性必须引用datalist元素的 id 属性 keygen output fieldset元素 fieldset元素组合表单中的相关数据。 legend元素为fieldset元素定义标题。 form fieldset legendPersonal information:/legend First name:br input type=\"text\" name=\"firstname\" br Last name:br input type=\"text\" name=\"lastname\" brbr input type=\"submit\" value=\"Submit\"/fieldset/form HTML id属性 HTML id 属性用于HTML 元素指定唯一的id。一个 HTML文档中不能存在多个有相同 id 的元素。 id 的语法是：写一个井号 (#)，后跟一个 id 名称。然后，在花括号 {} 中定义 CSS 属性。如： !DOCTYPE htmlhtml head style #London { background-color: lightblue; color: black; padding: 40px; text-align: center; } /style /head body h1 id=\"London\"My City/h1 /body/html id对大小写敏感，且至少包含一个字符，不能为空白字符（空格、制表符等）。 id还可以用于实现书签。 !--先用id创建书签--h2 id=\"C4\"第四章/h2!--接着使用链接元素跳转--a href=\"#C4\"跳转到第四章/a!--或者跳转到另一页的书签--a href=\"test.html#C4\"跳转到第四章/a CSS和JS可以使用id属性选取元素或设置样式。 Class 与 ID 的差异 同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用。","tags":["HTML"],"categories":["笔记"]},{"title":"一个小巧的Markdown编辑工具","path":"/2023/tools1/","content":"介绍一个小巧方便的编写Markdown语言工具——MarkText。 关键词：Markdown工具 什么是Markdown Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown可用于编写记录笔记、博客、电子书等电子文档。 MarkText MarkText是一款开源的Markdown工具，可用于编辑输出Markdown文件。本人推荐的是英文语言软件，如何汉化自行研究。 软件地址：建议安装到非系统盘（非C盘） MarkText下载 - 官网 MarkText下载 - 个人网盘（Windows64位） MarkText具有多个明暗主题选择，软件菜单内容明确，主打轻便，是一款很不错的小工具。 使用方法 输入@选择插入的模块，包括段落、分割线、标题、表格、数学公式、引用块、列表等。如果本身对于Markdown语言有一定基础的话，也可直接建立该模块。 在编写完内容后，可以直接保存为Markdown文件（.md后缀），也可以导出为PDF文件和HTML文件。 进阶使用 有时候对于PDF文件，会有显示目录大纲的需求，但是该软件直接导出并不能设置，此时需要借助另一个工具：wkhtmltopdf。 wkhtmltopdf 一款将HTML文件转化为PDF文件的小工具，但是其并没有软件UI界面，对小白不友好，但是万能的网络能搜到使用方法，此处针对如何导出带目录的PDF进行介绍。 下载软件 下载地址：可能提示有风险，建议安装到非系统盘（非C盘） wkhtmltopdf下载 - 官网 wkhtmltopdf下载 - 个人网盘（Windows64位） 安装并配置 安装后，需要记住安装的具体位置，比如我是安装在D盘，位置就是D:\\wkhtmltopdf，接着进行系统环境变量的配置。在电脑设置中搜索环境变量，打开编辑页面。 具体步骤：编辑→新建→输入安装的位置里面的bin文件夹即D:\\wkhtmltopdf\\bin→确定所有系统设置窗口。 （添加错误的环境变量并不会对电脑造成严重伤害，但不要胡乱删除环境变量） 再接着确认环境变量是否配置成功：按快捷键win+r，输入cmd，打开黑窗口，在窗口内输入wkhtmltopdf -V（查询wkhtmltopdf的版本），如果出现类似于版本号的数字，则说明添加环境变量成功。 软件使用 在cmd黑窗口切换到想要HTML文件转换为PDF文件的位置，直接输入F:切换到不同的盘，输入cd xx可以进入不同文件夹。如果不知道自己是什么路径，可以先进入所在盘，再打开文件所在文件夹，在地址栏点击获得路径，然后复制粘贴到黑窗口进入。 接着回到MarkText软件，将文件导出为HTML文件，保存在特定文件夹，该文件夹应该跟cmd黑窗口进入的文件夹一样。举例时，我将该文件保存为test.html文件在F:\\14.Books文件夹。 再回到黑窗口，使用命令wkhtmltopdf 目的文件名字 新文件名字转换，我这里应该是wkhtmltopdf test.html test.pdf。等待转换成功。 此时回到文件夹，就可以看到转换完成的带目录的PDF文件。","tags":["Markdown工具"],"categories":["分享"]},{"title":"两个用过的导航页","path":"/2023/导航页/","content":"介绍两个我常用的导航页——果汁导航页和青柠起始页。导航页就是一个网站的目录，其包含了很多常用其他网站的快捷方式。 关键词：导航页 果汁导航 果汁导航页包括互联网搜索功能，还有各种生活学习用到的网页快捷方式。每层目录下还收纳了很多相关网站，包括影视、知识、新闻、等网站，丰富度很高，也很容易因为内容太多眼花缭乱忘记了有这么样的功能。更多功能可以自己探索发现收藏。可登录使用也可不登录使用。 地址：果汁导航 - guozhivip.com 青柠起始页 一个简约的起始页，具有搜索功能，当搜索框聚焦时，背景具有毛玻璃效果。点击时钟可以到达另一页，此页可以添加一些常用的网站快捷方式（需登录），自定义程度高。丰富度不高，简约型网站。 地址：青柠起始页 - limestart.cn 附：设置为浏览器起始页 以Edge浏览器为例，打开设置页面，选择开始、主页和新建标签页，将启动时页面改为想要的导航页，更方便自己浏览器使用。","tags":["导航页"],"categories":["分享"]},{"title":"第一个博客","path":"/2023/1/","content":"博客建成：Hello World 前言 之前常常看博客学习内容，想着自己也可以做一个博客，记录自己的学习内容。所以此博客随之诞生。取名Fingsinz’s space。 用途 我想着，这个博客分为几个栏目，可以记录我的学习笔记，可以分享我平常使用体验较好的软件网站，甚至可以分享我毫无营养的日常……看看侧栏，于是分成了主页、日常、比较、好物分享、归档、关于几个模块。我还增加了搜索功能，便于搜索关键词。 更多 我并不是主攻前端方向，学习到的知识也较为浅薄，所以该博客还有很大改进空间。","categories":["日常"]},{"title":"关于我","path":"/about/me.html","content":"你好，这里是风信梓，Fingsinz，25届智能科学与技术毕业生，目前是助理研究工程师，很高兴遇见你。 以下是我的联系方式，如果你有想法、反馈、建议，欢迎与我联系，幸会。 📧电子邮箱：fingsinz@foxmail.com（推荐）"},{"title":"关于博客","path":"/about/site.html","content":"2025年7月13日，更换主题为 Stellar，同时考虑重构博客内容。 2024年3月17日，增加“趣事💡”板块。 2024年2月19日，更新为 A4 主题，使用 vercel 进行部署。 2023年8月23日，解决了页内目录问题，点击右侧目录进行跳转。 2023年8月13日，博客部署到Gitee，备用链接fingsinz.gitee.io 2023年8月3日，更新为redefine主题。 2023年6月24日，使用阿里云OSS（部分为腾讯云OSS）对象存储作为图床；更换背景。 2023年6月上旬，部署到Github，调整配置，但是本博客目录存在故障，锚点问题，无法正常跳转，使用文章顶部目录+回到顶部的方式阅读。 2023年5月28日，萌生了搭建博客的想法，参考了众多教程，建立了文件夹。"},{"title":"趣事","path":"/explore/index.html","content":"记录下我所收集到的趣事，施工中🏗🏗🏗 趣事记录格式 ul h3日期MM-DD/h3\tli事件概括/li\ta href=\"\"原文链接/a\tpi注/i/p\tp align=\"right\"打上的标签/p/ul 趣事💡 2024 03-17 一份现代C++编程指导，近1500页PPT。 Github：Modern-CPP-Programming 网络不好也可前往 Gitee 查找 C++ 一个 C++11 的跨平台 HTTP/HTTPS 库。 Github：cpp-httplib C++，Http 03-18 关于 C++ 的设计模式，很详细，但是英文。 Github：design-patterns-cpp C++，设计模式 03-20 folly：Facebook 开源的 C++ 工具库。里面有许多高性能的组件，可以学习代码规范以及如何写函数 Github：folly C++ TinyWebServer：一个 Linux 下 C++ 的轻量级 Web 服务器项目，使用线程池 + 非阻塞 socket + epoll + 事件处理的并发模型 Github：TinyWebServer 适合初学者快速实践网络编程，搭建属于自己的服务器。 C++，Linux，网络编程 写一个操作系统！一本详细的书籍 Gitbook：how-to-create-an-operating-system OS 搜狗：一个设计轻盈优雅的企业级程序引擎，支撑搜狗几乎所有后端C++在线服务，还附带教程 Github：workflow C++，Http 30天写一个 C++ 服务器？ Github：30dayMakeCppServer Github：续作（原作者好像断更了） 面向 Linux C/C++ C++，网络编程 03-22 用 Rust 重写 Pandas！快来试试性能超群的 Polars 吧！ Github：polars Rust 03-24 C++11：一个简单的线程池实现。挖到宝了，是10多年前的代码。 Github：ThreadPool C++ 各种算法的 C++ 实现，包括计算机科学、数学、机器学习等领域。 Github：C-Plus-Plus C++ 03-31 Java：互联网公司常用框架源码赏析 文档链接 Github仓库 Gitee仓库 Java，Spring，MyBatis，Tomcat React：面试题 Github：reactjs-interview-questions React 计算机八股， 包括计算机网络，操作系统，MySQL，linux，设计模式 学习链接 CS Base 04-23 计算机经典书籍分享，很多，真的很多 Github仓库 CS 05-29 Linux 内核实验中文教程，是布加勒斯特理工大学的 Linux 内核教学课程。该课程通过动手实践设备驱动编写，使学习者深入理解 Linux 内核，适合所有对 Linux 内核原理感兴趣的人阅读。 Github仓库 中文网站 Linux 大语言模型，这是一本为想入门大模型技术的程序员/学生准备的开源书籍，内容不仅涵盖了大模型的基础原理和关键技术，还提供了配套的代码工具库和大模型，帮助读者快速入门并实践。 Github仓库 PDF书籍 大模型 C++关于光线追踪的编程，有图形学知识，可惜还没翻译。 Github仓库 C++，图形学 05-30 汇总互联网公司技术岗考察Leetcode题目的热度 Github仓库 网站 Leetcode labuladong 的算法小抄 Github仓库 算法 07-02 极快的 Python 包管理工具：uv Github仓库 Python"},{"title":"分类 Categories","path":"/categories/index.html","content":""},{"title":"Fingsinz","path":"/index/index.html","content":"欢迎来到我的主页 Welcome to my homepage 导航栏介绍： 文章📄：\t显示所有的文章 笔记✏️：\t显示博客下我的学习笔记 趣事💡：\t显示我所收集到的趣事 关于🧑：\t显示关于我和这个博客"},{"title":"list","path":"/list/index.html","content":""},{"title":"标签 Tags","path":"/tags/index.html","content":""},{"title":"wiki","path":"/wiki/index.html","content":""},{"title":"AdaBoost","path":"/notebooks/ml/adaboost.html","content":"基本流程 自适应提升（Adaptive Boosting，AdaBoost）算法，可作为一种从一系列弱分类器中产生一个强分类器的通用方法。 弱分类器的分类效果比强分类器差。 假设有一个集合 {(x1,y1),(x2,y2),…,(xN,yN)}\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),\\ldots,(\\mathbf{x}_N,y_N)\\}{(x1​,y1​),(x2​,y2​),…,(xN​,yN​)}，xi\\mathbf{x}_ixi​ 表示特征矢量；yiy_iyi​ 表示对应分类为 {−1,1}\\{-1,1\\}{−1,1} 的标签。 AdaBoost 算法通过 MMM 次迭代得到若干个弱分类器 {k1,k2,…,kM}\\{k_1,k_2,\\ldots,k_M\\}{k1​,k2​,…,kM​}，对于每个样本，弱分类器都会给出分类结果 km(xi)∈{−1,1}k_m(\\mathbf{x}_i)\\in\\{-1,1\\}km​(xi​)∈{−1,1}。 将 MMM 个弱分类器进行某种线性组合，得到一个强分类器 CmC_mCm​。 进行第 m−1m-1m−1 次迭代后，线性组合得到的强分类器为： Cm−1(xi)=α1k1(xi)+α2k2(xi)+⋯+αm−1km−1(xi)(1)C_{m-1}(\\mathbf{x}_i)=\\alpha_1k_1(\\mathbf{x}_i)+\\alpha_2k_2(\\mathbf{x}_i)+\\cdots+\\alpha_{m-1}k_{m-1}(\\mathbf{x}_i)\\tag{1} Cm−1​(xi​)=α1​k1​(xi​)+α2​k2​(xi​)+⋯+αm−1​km−1​(xi​)(1) αi\\alpha_iαi​ 为权值，m1m1m1。 进行第 mmm 次迭代时，AdaBoost通过增加一个弱分类器的方式扩展成一个强分类器： Cmxi=Cm−1(xi)+αmkm(xi)(2)C_m{\\mathbf{x}_i}=C_{m-1}(\\mathbf{x}_i)+\\alpha_mk_m(\\mathbf{x}_i)\\tag{2} Cm​xi​=Cm−1​(xi​)+αm​km​(xi​)(2) 定义误差 EEE，判断 CmC_mCm​ 和 Cm−1C_{m-1}Cm−1​ 的性能，当 CmC_mCm​ 比 Cm−1C_{m-1}Cm−1​ 的效果强才有意义。误差用所有样本 xi\\mathbf{x}_ixi​ 的指数损失的总和定义： E=∑i=1Ne−yiCm(xi)=∑i=1Ne−yi(Cm−1(xi)+αmkm(xi))(3)\\mathbf{E}=\\sum_{i=1}^Ne^{-y_iC_m(\\mathbf{x}_i)}=\\sum_{i=1}^Ne^{-y_i(C_{m-1}(\\mathbf{x}_i)+\\alpha_mk_m(\\mathbf{x}_i))}\\tag{3} E=i=1∑N​e−yi​Cm​(xi​)=i=1∑N​e−yi​(Cm−1​(xi​)+αm​km​(xi​))(3) 令 wi(m)w_i^{(m)}wi(m)​ 表示在第 m−1m-1m−1 次迭代后，对训练样本 xi\\mathbf{x}_ixi​ 所分配的权重。 wi(1)=1w_i^{(1)}=1wi(1)​=1，wi(m)=e−yiCm−1(xi)w_i^{(m)}=e^{-y_iC_{m-1}(\\mathbf{x}_i)}wi(m)​=e−yi​Cm−1​(xi​) E=∑i=1Nwi(m)e−yiαmkm(xi)(4)\\mathbf{E}=\\sum_{i=1}^Nw_i^{(m)}e^{-y_i\\alpha_mk_m(\\mathbf{x}_i)}\\tag{4} E=i=1∑N​wi(m)​e−yi​αm​km​(xi​)(4) 将上式拆成： E=∑yi=km(xi)wi(m)e−αm+∑yi≠km(xi)wi(m)eαm(5)\\mathbf{E}=\\sum_{y_i=k_m(\\mathbf{x}_i)}w_i^{(m)}e^{-\\alpha_m}+\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}e^{\\alpha_m}\\tag{5} E=yi​=km​(xi​)∑​wi(m)​e−αm​+yi​​=km​(xi​)∑​wi(m)​eαm​(5) 若 yi=km(xi)y_i=k_m(\\mathbf{x}_i)yi​=km​(xi​)，则分类结果与实际相符，无论都为 −1-1−1 还是 111，乘积为 111。 若 yi≠km(xi)y_i eq k_m(\\mathbf{x}_i)yi​​=km​(xi​)，则分类结果与实际不符，乘积为 −1-1−1。 根据对所有 yi=km(xi)y_i=k_m(\\mathbf{x}_i)yi​=km​(xi​) 的数据项 xi\\mathbf{x}_ixi​ 的误差求和，对所有 yi≠km(xi)y_i eq k_m(\\mathbf{x}_i)yi​​=km​(xi​) 的数据项 xi\\mathbf{x}_ixi​ 的误差求和，再改写成： E=∑yi=km(xi)wi(m)e−αm+∑yi≠km(xi)wi(m)eαm=∑i=1Nwi(m)e−αm+∑yi≠km(xi)wi(m)(eαm−e−αm)(6)\\mathbf{E}=\\sum_{y_i=k_m(\\mathbf{x}_i)}w_i^{(m)}e^{-\\alpha_m}+\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}e^{\\alpha_m}=\\sum_{i=1}^Nw_i^{(m)}e^{-\\alpha_m}+\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}(e^{\\alpha_m}-e^{-\\alpha_m})\\tag{6} E=yi​=km​(xi​)∑​wi(m)​e−αm​+yi​​=km​(xi​)∑​wi(m)​eαm​=i=1∑N​wi(m)​e−αm​+yi​​=km​(xi​)∑​wi(m)​(eαm​−e−αm​)(6) 可以看出，如果 αm\\alpha_mαm​ 一定，强分类器 CmC_mCm​ 的误差大小完全取决于第二项中 ∑yi≠km(xi)wi(m)\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}∑yi​​=km​(xi​)​wi(m)​ 的大小，即取决于这次迭代中被错分类的权值 wi(m)w_i^{(m)}wi(m)​ 的大小。 对式5进行求导： dEdαm=∑yi≠km(xi)wi(m)eαm−∑yi=km(xi)wi(m)e−αm(7)\\frac{d\\mathbf{E}}{d\\alpha_m}=\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}e^{\\alpha_m}-\\sum_{y_i=k_m(\\mathbf{x}_i)}w_i^{(m)}e^{-\\alpha_m}\\tag{7} dαm​dE​=yi​​=km​(xi​)∑​wi(m)​eαm​−yi​=km​(xi​)∑​wi(m)​e−αm​(7) 令导数为0，得到权值 αm\\alpha_mαm​： αm=12ln⁡(∑yi=km(xi)wi(m)∑yi≠km(xi)wi(m))(8)\\alpha_m=\\frac{1}{2}\\ln\\left(\\frac{\\sum_{y_i=k_m(\\mathbf{x}_i)}w_i^{(m)}}{\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}}\\right)\\tag{8} αm​=21​ln(∑yi​​=km​(xi​)​wi(m)​∑yi​=km​(xi​)​wi(m)​​)(8) 令 ϵm\\epsilon_mϵm​ 表示误差率： ϵm=∑yi≠km(xi)wi(m)∑i=1Nwi(m)(9)\\epsilon_m=\\frac{\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}}{\\sum_{i=1}^Nw_i^{(m)}}\\tag{9} ϵm​=∑i=1N​wi(m)​∑yi​​=km​(xi​)​wi(m)​​(9) 则 αm\\alpha_mαm​ 写成： αm=12ln⁡(1−ϵϵm)(10)\\alpha_m=\\frac{1}{2}\\ln\\left(\\frac{1-\\epsilon}{\\epsilon_m}\\right)\\tag{10} αm​=21​ln(ϵm​1−ϵ​)(10) 得到 AdaBoost 算法：每次迭代中，选择使 ∑yi≠km(xi)wi(m)\\sum_{y_i eq k_m(\\mathbf{x}_i)}w_i^{(m)}∑yi​​=km​(xi​)​wi(m)​ 最小的分类器 kmk_mkm​，得到误差率 ϵm\\epsilon_mϵm​，从而计算权值 αm\\alpha_mαm​，则最终强分类器由 Cm−1C_{m-1}Cm−1​ 逐渐提升为 Cm=Cm−1+αmkmC_m=C_{m-1}+\\alpha_mk_mCm​=Cm−1​+αm​km​。 每次迭代后，得到每个训练样本数据权值 wi(m+1)w_i^{(m+1)}wi(m+1)​ 为： wi(m+1)=wi(m)e−yiαmkm(xi)=wi(m)×{e−αm,分类正确eαm,分类错误(11)w_i^{(m+1)}=w_i^{(m)}e^{-y_i\\alpha_mk_m(\\mathbf{x}_i)}=w_i^{(m)}\\times\\begin{cases}e^{-\\alpha_m},分类正确\\\\e^{\\alpha_m},分类错误\\end{cases}\\tag{11} wi(m+1)​=wi(m)​e−yi​αm​km​(xi​)=wi(m)​×{e−αm​,eαm​,​分类正确分类错误​(11) AdaBoost的计算步骤： 设有 nnn 个样本 x1,…,xn\\mathbf{x}_1,\\ldots,\\mathbf{x}_nx1​,…,xn​，分类为 y1,…,yn,yi∈{−1,1}y_1,\\ldots,y_n,y_i\\in\\{-1,1\\}y1​,…,yn​,yi​∈{−1,1}。 初始化每个样本的权值 w1(1),…,wn(1)w_1^{(1)},\\ldots,w_n^{(1)}w1(1)​,…,wn(1)​，都为 1n\\frac{1}{n}n1​。 进行迭代：m=1,…,Mm=1,\\ldots,Mm=1,…,M。 找到使得错误率 ϵm\\epsilon_mϵm​ 最小的弱分类器 km(x)k_m(\\mathbf{x})km​(x)，并得到 ϵm\\epsilon_mϵm​（见式9）。 计算 km(x)k_m(\\mathbf{x})km​(x) 的权值 αm\\alpha_mαm​（见式10）。 得到新的强分类器 Cm(x)C_m(\\mathbf{x})Cm​(x)（见式2）。 更新每个样本的权值 wi(m+1)w_i^{(m+1)}wi(m+1)​（见式11）。 对权值 wi(m+1)w_i^{(m+1)}wi(m+1)​ 进行归一化，使 ∑iwi(m+1)=1\\sum_iw_i^{(m+1)}=1∑i​wi(m+1)​=1。 得到最终的强分类器： C(x)=sign(CM(x))=sign(∑i=1Mαmkm(x))(12)C(\\mathbf{x})=\\mathbf{sign}(C_M(\\mathbf{x}))=\\mathbf{sign}(\\sum_{i=1}^M\\alpha_mk_m(\\mathbf{x}))\\tag{12} C(x)=sign(CM​(x))=sign(i=1∑M​αm​km​(x))(12) AdaBoost 算法可分为 Discrete AdaBoost、Real AdaBoost、LogitBoost 和 Gentle AdaBoost。 Discrete AdaBoost 的弱分类输出结果是 1 或 -1，组成强分类器时是离散的形式。 Real AdaBoost的弱分类器输出结果是该样本属于某一类的概率。 上述讨论即为 Discrete AdaBoost 的迭代过程。 Real AdaBoost 的迭代过程： 基于每个样本的权值 wi(m)w_i^{(m)}wi(m)​，拟合一个分类概率估计 pm(x)=P(y=1∣x)∈[0,1]p_m(\\mathbf{x})=P(y=1|x)\\in[0,1]pm​(x)=P(y=1∣x)∈[0,1]，表示样本属于分类结果为1的概率。 得到这次迭代的弱分类器：km(x)=12ln⁡(pm(x)1−pm(x))k_m(\\mathbf{x})=\\frac{1}{2}\\ln\\left(\\frac{p_m(\\mathbf{x})}{1-p_m(\\mathbf{x})}\\right)km​(x)=21​ln(1−pm​(x)pm​(x)​)。 更新权值：wi(m+1)=wi(m)e−yikm(x)w_i^{(m+1)}=w_i^{(m)}e^{-y_ik_m(\\mathbf{x})}wi(m+1)​=wi(m)​e−yi​km​(x)。 归一化权值。 最终强分类器 CCC 为： C(x)=sign(∑i=1Mkm(x))(13)C(\\mathbf{x})=\\mathbf{sign}(\\sum_{i=1}^Mk_m(\\mathbf{x}))\\tag{13} C(x)=sign(i=1∑M​km​(x))(13) LogitBoost 是逻辑回归技术在 AdaBoost 的应用。弱分类器的选取基于加权最小二乘法。 设迭代前强分类器 C0(x)=0C_0(\\mathbf{x})=0C0​(x)=0，每个训练样本数据的概率估计 p0(xi)=0.5p_0(\\mathbf{x}_i)=0.5p0​(xi​)=0.5，迭代过程如下： 计算工作响应 zi(m)z_i^{(m)}zi(m)​： zi(m)=yi∗−pm−1(xi)pm−1(xi)[1−pm−1(xi)](14)z_i^{(m)}=\\frac{y_i^*-p_{m-1}(x_i)}{p_{m-1}(x_i)[1-p_{m-1}(x_i)]}\\tag{14} zi(m)​=pm−1​(xi​)[1−pm−1​(xi​)]yi∗​−pm−1​(xi​)​(14) yi∗=yi−12(15)y_i^*=\\frac{y_i-1}{2}\\tag{15} yi∗​=2yi​−1​(15) 计算权值： wi(m)=pm−1(xi)[1−pm−1(xi)](16)w_i^{(m)}=p_{m-1}(\\mathbf{x}_i)[1-p_{m-1}(\\mathbf{x}_i)]\\tag{16} wi(m)​=pm−1​(xi​)[1−pm−1​(xi​)](16) 应用权值 wi(m)w_i^{(m)}wi(m)​，基于 zi(m)z_i^{(m)}zi(m)​ 到 xi\\mathbf{x}_ixi​ 的加权最小二乘回归法，拟合弱分类器 km(xi)k_m(\\mathbf{x}_i)km​(xi​)。 更新 pm(xi)p_m(\\mathbf{x}_i)pm​(xi​) pm(xi)=eCm−1(xi)eCm−1(xi)+e−Cm−1(xi)=11+e−2Cm−1(xi)(17)p_m(x_i)=\\frac{e^{C_{m-1}(\\mathbf{x}_i)}}{e^{C_{m-1}(\\mathbf{x}_i)}+e^{-C_{m-1}(\\mathbf{x}_i)}}=\\frac{1}{1+e^{-2C_{m-1}(\\mathbf{x}_i)}}\\tag{17} pm​(xi​)=eCm−1​(xi​)+e−Cm−1​(xi​)eCm−1​(xi​)​=1+e−2Cm−1​(xi​)1​(17) 更新强分类器。 Cm(xi)=Cm−1(xi)+12km(xi)(18)C_m(\\mathbf{x}_i)=C_{m-1}(\\mathbf{x}_i)+\\frac{1}{2}k_m(\\mathbf{x}_i)\\tag{18} Cm​(xi​)=Cm−1​(xi​)+21​km​(xi​)(18) 最终强分类器为式13。 Gentle AdaBoost 算法与 LogitBoost 算法相似，但参数选择更简单。弱分类器 km(x)k_m(\\mathbf{x})km​(x) 由基于权值 wi(m)w_i^{(m)}wi(m)​ 的从 yiy_iyi​ 到 xi\\mathbf{x}_ixi​ 的加权最小二乘法回归拟合得到。 每次迭代得到的强分类器 Cm(x)C_m(\\mathbf{x})Cm​(x) 和 权值： Cm(xi)=Cm−1(xi)+km(xi)(19)C_m(\\mathbf{x}_i)=C_{m-1}(\\mathbf{x}_i)+k_m(\\mathbf{x}_i)\\tag{19} Cm​(xi​)=Cm−1​(xi​)+km​(xi​)(19) wi(m+1)=wi(m)e−yikm(xi)(20)w_i^{(m+1)}=w_i^{(m)}e^{-y_ik_m(\\mathbf{x}_i)}\\tag{20} wi(m+1)​=wi(m)​e−yi​km​(xi​)(20) OpenCV提供的AdaBoost OpenCV 实现了上述4种 AdaBoost，且弱分类器都采用 CART 决策树的方法。 使用决策树时： αm=ln⁡(1−ϵϵm)(21)\\alpha_m=\\ln\\left(\\frac{1-\\epsilon}{\\epsilon_m}\\right)\\tag{21} αm​=ln(ϵm​1−ϵ​)(21) wi(m+1)=wi(m)×{1,分类正确eαm,分类错误(22)w_i^{(m+1)}=w_i^{(m)}\\times\\begin{cases}1,分类正确\\\\e^{\\alpha_m},分类错误\\end{cases}\\tag{22} wi(m+1)​=wi(m)​×{1,eαm​,​分类正确分类错误​(22) OpenCV 的 ml 中提供了Boost 类，继承自 DTree 类。 类中有部分参数： BoostType：Boosting 算法的类型。 enum Types { DISCRETE=0, // Discrete AdaBoost. REAL=1, // Real AdaBoost. LOGIT=2, // LogitBoost. GENTLE=3 // Gentle AdaBoost. };// 访问函数：int getBoostType(); // 默认是 REALvoid setBoostType(int val); WeakCount：弱分类器的数量，也是迭代次数。访问函数： int getWeakCount(); // 默认是 100void setWeakCount(int val); WeightTrimRate：裁剪率，0～1，在迭代过程中，那些归一化后的样本权值 wi(m) 小于该裁剪率的样本将不进入下次迭代。访问函数： double getWeightTrimRate(); // 默认是 0.95void setWeightTrimRate(double val); 例子-用户贷款违约预测 数据集地址：https://aistudio.baidu.com/datasetdetail/112664 数据集的属性如下： income：用户收入，较大数 age：用户年龄 experience_years：用户从业年限 is_1：是否单身 city：居住城市，抽象代号 region：居住地区，抽象代号 current_job_years：现任职位工作年数 current_house_years：现居房屋居住年数 house_ownership：房屋所有权，租用（1）、自有（2）、未有（0） car_ownership：是否拥有汽车 profession：职业，抽象代号 label：是否存在违约，即响应值 AdaBoost 分类效果如下： Train Data imported: 168000Test Data imported: 84000AdaBoost算法(基于OpenCV实现)：计算花费时长：31247ms准确率：0.890024 代码地址：Gitee - AdaBoost","tags":[null,null]},{"title":"EM基础","path":"/notebooks/ml/basic_em.html","content":"EM 介绍 期望极大值（Expectation Maximization，EM）算法是一种能够得到极大似然参数估计的迭代方法。 可适用于包含隐变量的统计模型 隐变量：属性值未知的变量。 令 XXX 表示已观测变量集，ZZZ 表示隐变量集，θ\\thetaθ 表示模型参数，如果想对 θ\\thetaθ 作极大似然估计，则最大化对数似然应为： LL(θ∣X,Z)=ln⁡P(X,Z∣θ)LL(\\theta|X,Z)=\\ln P(X,Z|\\theta) LL(θ∣X,Z)=lnP(X,Z∣θ) 由于 ZZZ 是隐变量，故无法直接求解。可以通过对 ZZZ 计算期望，来最大化已观测数据的对数“边际似然”： LL(θ∣X)=ln⁡P(X∣θ)=ln⁡∑ZP(X,Z∣θ)(1)LL(\\theta|X)=\\ln P(X|\\theta)=\\ln\\sum_ZP(X,Z|\\theta)\\tag{1} LL(θ∣X)=lnP(X∣θ)=lnZ∑​P(X,Z∣θ)(1) EM 算法的基本思想： E-step：若参数 θ\\thetaθ 已知，则根据训练数据推断除最优隐变量 ZZZ 的值。 M-step：若隐变量 ZZZ 的值已知，则对参数 θ\\thetaθ 作极大似然估。 若计算 ZZZ 的期望，以 θ0\\theta^0θ0 为起点，对式1迭代以下步骤直至收敛： E-step：基于 θt\\theta^tθt 推断隐变量 ZZZ 的期望，记作 ZtZ^tZt； M-step：基于已观测变量 XXX 和 ZtZ^tZt 对参数 θ\\thetaθ 作极大似然估计，记作 θt+1\\theta^{t+1}θt+1。 若基于 θt\\theta^tθt 计算隐变量 ZZZ 的概率分布 P(Z∣X,θt)P(Z|X,\\theta^t)P(Z∣X,θt)，则 EM 的步骤变成： E-step：基于 θt\\theta^tθt 推断隐变量分布 P(Z∣X,θt)P(Z|X,\\theta^t)P(Z∣X,θt)，并计算对数似然 LL(θ∣X,z)LL(\\theta|X,z)LL(θ∣X,z) 关于 ZZZ 的期望： Q(θ∣θt)=EZ∣X,θtLL(θ∣X,Z)Q(\\theta|\\theta^t)=E_{Z|X,\\theta^t}LL(\\theta|X,Z) Q(θ∣θt)=EZ∣X,θt​LL(θ∣X,Z) M-step：寻找参数最大化期望似然： θi+1=arg⁡max⁡θQ(θ∣θt)\\theta^{i+1}=\\arg\\max_\\theta Q(\\theta|\\theta^t) θi+1=argθmax​Q(θ∣θt) 基于OpenCV实现EM EM 是一种无监督的机器学习方法，它还可以用于聚类处理上。 OpenCV 提供了 EM 类，可用于实现 EM 算法对高斯混合模型的参数估计： 高斯混合模型可以看作是由 K 个单高斯模型组合而成的模型，这 K 个子模型是混合模型的隐变量。 // 创建 EMcv::Ptrcv::ml::EM model=cv::ml::EM::create();// 设置聚类数model-setClustersNumber(classes);// 训练函数，结果反映在 labels参数bool trainEM(InputArray samples,OutputArray logLikelihoods=noArray(),OutputArray labels=noArray(),OutputArray probs=noArray()) ; 使用 EM 算法进行像素聚类进而实现图像分割。 将 RGB 属性作为样本，进行聚类。即每一个像素都是一个样本。 效果如下： 代码地址：EM 算法 - Gitee","tags":[null,null]},{"title":"贝叶斯分类器","path":"/notebooks/ml/bayesian_classifier.html","content":"假设有 NNN 个类别，B={B1,B2,...,BN}B=\\{B_1,B_2,...,B_N\\}B={B1​,B2​,...,BN​}，现有样本 AAA，通过贝叶斯公式： P(Bi∣A)=P(Bi)P(A∣Bi)∑j=1nP(Bj)P(A∣Bj)P(B_i\\vert A)=\\frac{P(B_i)P(A\\vert B_i)}{\\sum_{j=1}^nP(B_j)P(A\\vert B_j)} P(Bi​∣A)=∑j=1n​P(Bj​)P(A∣Bj​)P(Bi​)P(A∣Bi​)​ P(Bi)P(B_i)P(Bi​)：类别 BiB_iBi​ 发生的概率。 称作先验概率，表达了样本空间中各类样本所占的概率。 根据大数定律，当训练集包含充足的独立同分布样本时，P(Bi)P(B_i)P(Bi​) 可通过各类样本出现的频率来进行估计 P(A∣Bi)P(A\\vert B_i)P(A∣Bi​)：确定是 BiB_iBi​ 类下，样本 AAA 出现的概率。称作类条件概率。 P(Bi∣A)P(B_i\\vert A)P(Bi​∣A)：在样本 AAA 出现下，属于类别 BiB_iBi​ 的概率。称作后验概率。 类条件概率通过数据集进行训练，估计参数 θb\\theta_bθb​。 令 DiD_iDi​ 表示训练集 DDD 中第 iii 类样本组成的集合，假设样本是独立同分布，则参数 θb\\theta_bθb​ 对于数据集的似然是： P(Di∣θb)=∏x∈DiP(x∣θb)P(D_i\\vert\\theta_b)=\\prod_{x\\in D_i}P(x\\vert\\theta_b) P(Di​∣θb​)=x∈Di​∏​P(x∣θb​) 对 θb\\theta_bθb​ 进行极大似然估计，寻找最大化似然 P(Di∣θb)P(D_i\\vert\\theta_b)P(Di​∣θb​) 的参数值 θb′\\theta_b'θb′​。 从 θb\\theta_bθb​ 的所有可能取值中，找到一个能使数据出现可能性最大的值。 连乘容易出现下溢，可以使用对数计算： LL(θb)=log⁡P(Di∣θb)=∑x∈Dilog⁡P(x∣θb)LL(\\theta_b)=\\log P(D_i\\vert\\theta_b)=\\sum_{x\\in D_i}\\log P(x\\vert\\theta_b) LL(θb​)=logP(Di​∣θb​)=x∈Di​∑​logP(x∣θb​) θb′=arg⁡max⁡θbLL(θb)\\theta_b'=\\arg\\max_{\\theta_b}LL(\\theta_b) θb′​=argθb​max​LL(θb​) 朴素贝叶斯分类器 一种基于贝叶斯理论的简单概率分类器。 朴素：输入变量的特征属性间具有独立性 由属性条件独立性： P(Bi∣A)=P(Bi)P(A∣Bi)∑j=1nP(Bj)P(A∣Bj)=P(Bi)P(A)∏i=1dP(A(i)∣Bi)P(B_i\\vert A)=\\frac{P(B_i)P(A\\vert B_i)}{\\sum_{j=1}^nP(B_j)P(A\\vert B_j)}=\\frac{P(B_i)}{P(A)}\\prod_{i=1}^dP(A^{(i)}\\vert B_i) P(Bi​∣A)=∑j=1n​P(Bj​)P(A∣Bj​)P(Bi​)P(A∣Bi​)​=P(A)P(Bi​)​i=1∏d​P(A(i)∣Bi​) ddd：样本的属性个数。 BiB_iBi​：第 iii 个类别。 A(i)A^{(i)}A(i)：样本 AAA 的第 iii 个属性值。 对于所有类别， P(A)P(A)P(A) 都相等。 所以朴素贝叶斯表达式写成： f(A)=arg⁡max⁡Bi∈BP(Bi)∏j=1dP(A(j)∣Bi)f(A)=\\arg\\max_{B_i\\in B}P(B_i)\\prod_{j=1}^dP(A^{(j)}\\vert B_i) f(A)=argBi​∈Bmax​P(Bi​)j=1∏d​P(A(j)∣Bi​) 朴素贝叶斯的训练过程就是基于训练集 DDD 来估计类先验概率 P(Bi)P(B_i)P(Bi​)，并为每个属性估计条件概率 P(A(j)∣Bi)P(A^{(j)}\\vert B_i)P(A(j)∣Bi​)。 先验概率： P(Bi)=∣Di∣∣D∣P(B_i)=\\frac{\\vert D_i\\vert}{\\vert D\\vert}{} P(Bi​)=∣D∣∣Di​∣​ 离散属性下，设 DBi,A(j)D_{B_i,A^{(j)}}DBi​,A(j)​ 为第 BiB_iBi​ 类，第 jjj 个属性值为 A(j)A^{(j)}A(j) 构成的集合，则条件概率可估计为： P(A(j)∣Bi)=∣DBi,A(j)∣∣DBi∣P(A^{(j)}\\vert B_i)=\\frac{\\vert D_{B_i,A^{(j)}}\\vert}{\\vert D_{B_i}\\vert}{} P(A(j)∣Bi​)=∣DBi​​∣∣DBi​,A(j)​∣​ 连续属性则考虑概率密度函数。 如果某个属性值在训练集中没有与某个类同时出现过，可能会出现概率值为零，此时需要做一些平滑。 常用拉普拉斯修正： P^(Bi)=∣Di∣+1∣D∣+N\\hat{P}(B_i)=\\frac{\\vert D_i\\vert+1}{\\vert D\\vert+N} P^(Bi​)=∣D∣+N∣Di​∣+1​ P^(A(j)∣Bi)=∣DBi,A(j)∣+1∣DBi∣+Nj\\hat{P}(A^{(j)}\\vert B_i)=\\frac{\\vert D_{B_i,A^{(j)}}\\vert+1}{\\vert D_{B_i}\\vert+N_j} P^(A(j)∣Bi​)=∣DBi​​∣+Nj​∣DBi​,A(j)​∣+1​ NNN：训练集中可能的类别数； NjN_jNj​：第 jjj 个属性可能的取值数。 拉普拉斯修正避免了因训练集样本不充分而导致概率估值为零的问题，并且在训练集变大时，修正过程所引入的先验的影响也会逐渐变得可忽略，使得估值渐趋向于实际概率值。 正态贝叶斯分类器 正态贝叶斯分类器认为每一个分类的所有特征属性（即特征向量）服从多变量正态高斯分布，即： P(x∣Ck)=1(2π)n∣∑k∣exp⁡(−12(x−μk)T∑k−1(x−μk))P(x\\vert C_k)=\\frac{1}{\\sqrt{(2\\pi)^n\\vert\\sum_k\\vert}}\\exp\\left(-\\frac{1}{2}(x-\\mu_k)^T\\sum_k^{-1}(x-\\mu_k)\\right) P(x∣Ck​)=(2π)n∣∑k​∣​1​exp(−21​(x−μk​)Tk∑−1​(x−μk​)) μk\\mu_kμk​ 表示第 kkk 个分类对应的 nnn 维均值向量； ∣∑k∣|\\sum_k|∣∑k​∣ 表示第 kkk 个分类对应的 n×nn×nn×n 的协方差矩阵 ∑k\\sum_k∑k​ 的行列式的值。 正态贝叶斯分类器只能处理特征属性是连续数值的分类问题。但它认为特征属性直接不必独立，比朴素贝叶斯的使用条件宽。 同样，计算最大似然： y^=arg⁡max⁡k∈{1,...,k}P(x1,...,xn∣Ck)\\hat{y}=\\arg\\max_{k\\in\\{1,...,k\\}}P(x1,...,x_n\\vert C_k) y^​=argk∈{1,...,k}max​P(x1,...,xn​∣Ck​) 化为对数似然函数： ln(L)=−12[ln⁡(∣∑k∣)+(x−μk)T∑k−1(x−μk)+nln⁡(2π)](1)ln(L)=-\\frac{1}{2}\\left[\\ln(\\vert\\sum_k\\vert)+(x-\\mu_k)^T\\sum_k^{-1}(x-\\mu_k)+n\\ln(2\\pi)\\right]\\tag{1} ln(L)=−21​[ln(∣k∑​∣)+(x−μk​)Tk∑−1​(x−μk​)+nln(2π)](1) 求式上极大值问题可以转换为求式中方括号内的极小值问题。 均值向量 μk\\mu_kμk​ 的第 iii 个特征属性 μki\\mu_{ki}μki​ 的极大似然估计为： μ^ki=∑j=1Nkxki(j)Nk\\hat{\\mu}_{ki}=\\frac{\\sum_{j=1}^{N_k}x_{ki}^{(j)}}{N_k} μ^​ki​=Nk​∑j=1Nk​​xki(j)​​ xki(j)x_{ki}^{(j)}xki(j)​：训练样本中属于分类 kkk 的第 jjj 个样本的第 iii 个特征属性的值。 NkN_kNk​：训练样本中属于分类 kkk 的样本数。 μk^=(μ^k1,...,μ^kn)T(2)\\hat{\\mu_k}=(\\hat{\\mu}_{k1}, ..., \\hat{\\mu}_{kn})^T\\tag{2} μk​^​=(μ^​k1​,...,μ^​kn​)T(2) n×nn×nn×n 的协方差矩阵 ∑k\\sum_k∑k​ 的无偏估计形式为： ∑^k=1Nk−1[covk(1,1)covk(1,2)...covk(1,n)covk(2,1)covk(2,2)...covk(2,n)⋮⋮⋱⋮covk(n,1)covk(n,2)...covk(n,n)](3)\\hat{\\sum}_k=\\frac{1}{N_k-1}\\left[\\begin{matrix} cov_k^{(1,1)} cov_k^{(1,2)} ... cov_k^{(1,n)} \\\\ cov_k^{(2,1)} cov_k^{(2,2)} ... cov_k^{(2,n)} \\\\ \\vdots \\vdots \\ddots \\vdots \\\\ cov_k^{(n,1)} cov_k^{(n,2)} ... cov_k^{(n,n)} \\end{matrix}\\right] \\tag{3} ∑^​k​=Nk​−11​⎣⎢⎢⎢⎢⎢⎡​covk(1,1)​covk(2,1)​⋮covk(n,1)​​covk(1,2)​covk(2,2)​⋮covk(n,2)​​......⋱...​covk(1,n)​covk(2,n)​⋮covk(n,n)​​⎦⎥⎥⎥⎥⎥⎤​(3) 其中 covk(p,q)cov_k^{(p,q)}covk(p,q)​ 表示训练样本中第 kkk 个分类所组成的数据集合中，第 ppp 个特征属性与第 qqq 个特征属性的协方差，如果 p=qp=qp=q，那么为方差。 covk(p,q)=∑j=1Nk[(xkp(j)−μ^kp)(xkq(j)−μ^kq)]=∑j=1Nk(xkp(j)xkq(j))−μ^kq∑j=1Nkxkp(j)−μ^kp∑j=1Nkxkq(j)+Nkμ^kpμ^kq\\begin{matrix} cov_{k}^{(p,q)}=\\sum_{j=1}^{N_k}[(x_{kp}^{(j)}-\\hat{\\mu}_{kp})(x_{kq}^{(j)}-\\hat{\\mu}_{kq})]\\\\ =\\sum_{j=1}^{N_k}(x_{kp}^{(j)}x_{kq}^{(j)})-\\hat{\\mu}_{kq}\\sum_{j=1}^{N_k}x_{kp}^{(j)}-\\hat{\\mu}_{kp}\\sum_{j=1}^{N_k}x_{kq}^{(j)}+N_k\\hat{\\mu}_{kp}\\hat{\\mu}_{kq} \\end{matrix} covk(p,q)​​==​∑j=1Nk​​[(xkp(j)​−μ^​kp​)(xkq(j)​−μ^​kq​)]∑j=1Nk​​(xkp(j)​xkq(j)​)−μ^​kq​∑j=1Nk​​xkp(j)​−μ^​kp​∑j=1Nk​​xkq(j)​+Nk​μ^​kp​μ^​kq​​ 正态贝叶斯分类器的执行步骤： 由训练样本数据估计每个分类的协方差矩阵（式3）和均值向量（式2）； 把协方差矩阵和均值向量代入到对数似然函数（式1）； 得到每个分类完整的对数似然函数； 预测样本时，将样本的特征属性分别代入全部分类的对数似然函数中，最大对数似然函数对应的分类就是该样本的分类结果。 基于OpenCV实现正态贝叶斯分类器 OpenCV 自带实现了 正态贝叶斯分类器 的类： NormalBayesClassifier。 相关代码 // 创建贝叶斯分类器cv::Ptrcv::ml::NormalBayesClassifier model=cv::ml::NormalBayesClassifier::create(); // 设置训练数据cv::Ptrcv::ml::TrainData tData =cv::ml::TrainData::create(datas, ROW_SAMPLE, labels);//训练分类器model-train(tData); //预测int label = model-predict(samples)//保存模型model-save(filename) 例子-糖尿病预测数据集 数据集地址：https://aistudio.baidu.com/datasetdetail/33810 该数据集包含数据集中共包含768个样本，取后100个数据组成测试集。 数据集中每个样本有8种特征。Outcome 是样本的标签（即类别），0表示没有糖尿病，1表示患有糖尿病。 Pregnancies: 怀孕次数 Glucose：血浆葡萄糖浓度 BloodPressure：舒张压 SkinThickness：肱三头肌皮肤褶皱厚度 Insulin：两小时胰岛素含量 BMI：身体质量指数，即体重除以身高的平方 DiabetesPedigreeFunction：糖尿病血统指数，即家族遗传指数 Age：年龄 使用手搓的朴素贝叶斯分类器和 OpenCV 实现的正态贝叶斯分类器进行训练测试，结果如下： Train Data imported: 668正态贝叶斯分类器：计算花费时长：0msTest Data imported: 100正确率：0.76Train Data imported: 668朴素贝叶斯分类器：计算花费时长：1msTest Data imported: 100正确率：0.59 代码及数据集地址：Gitee - bayesClassifier 例子-鸢尾花数据集 数据集地址： 训练集：http://download.tensorflow.org/data/iris_training.csv 测试集：http://download.tensorflow.org/data/iris_test.csv 部分数据如下： 花萼长度 花萼宽度 花瓣长度 花瓣宽度 类别 6.4 2.8 5.6 2.2 2 5.0 2.3 3.3 1.0 1 4.9 2.5 4.5 1.7 2 4.9 3.1 1.5 0.1 0 使用手搓的朴素贝叶斯分类器和 OpenCV 实现的正态贝叶斯分类器进行训练测试，结果如下： Train Data imported: 120正态贝叶斯分类器：计算花费时长：0msTest Data imported: 30正确率：0.966667Train Data imported: 120朴素贝叶斯分类器：计算花费时长：0msTest Data imported: 30正确率：0.8 代码及数据集地址：Gitee - bayesClassifier","tags":[null,null]},{"title":"机器学习基础概念","path":"/notebooks/ml/concepts.html","content":"机器学习是研究如何在计算机上 从数据产生模型 的学问。 模型：泛指从数据中学得的结果。 基本术语 数据：用于学习的输入内容，通常是一组或多组记录。 数据集：记录的集合。 学习、训练：从数据集中学习模型的过程，通过执行某个学习算法完成。 训练集：用于训练的数据集合。 测试集：用于通过模型预测结果的数据集合，评估模型优劣。 验证集：用于纠正和强化模型的数据集合 类别 验证集 测试集 是否参与训练 否 否 作用 多次使用，不断调整 仅仅在最终模型评估时使用 西瓜书（周志华的机器学习）中提到 一批关于西瓜的数据，如(色泽=青绿;根蒂=蜷缩;敲声=浊响)、(色泽=乌黑;根蒂=稍蜷;敲声=沉闷)…… 其中每对括号内时一条记录，记录的集合为数据集。 每条记录是关于一个对象的描述，称为一个样品。 反映对象在某方面的表现或性质的事项，称为属性或特征。 如色泽、根蒂、敲声 属性的取值为属性值 如青绿、乌黑、浊响 属性所组成的空间称为属性空间、样本空间或输入空间。 可以根据色泽、根蒂、敲声的取值确定一个对象，由这三者可组成向量，称为特征向量。 通常，令 D={x1,x2,...,xm}D=\\{x_1,x_2,...,x_m\\}D={x1​,x2​,...,xm​} 表示包含 mmm 个样本的数据集，每个样本又由 ddd 个属性描述，xi=(xi1,xi2,...,xid)x_i=(x_{i1},x_{i2},...,x_{id})xi​=(xi1​,xi2​,...,xid​)。ddd 通常称为样本的维数，表示样本的属性个数。 通过学习得到模型，即可在没剖开一个西瓜之前，预测未知的西瓜。建立关系： ((色泽=青绿;根蒂=蜷缩;敲声=浊响),好瓜)((色泽=青绿;根蒂=蜷缩;敲声=浊响),好瓜) ((色泽=青绿;根蒂=蜷缩;敲声=浊响),好瓜) 逗号前面是前面提过的特征向量。 逗号后面是结果，称为标签（标记）。 即 (xi,yi)(x_i,y_i)(xi​,yi​) 由全部的标签组成的集合称为标记空间或输出空间。 只预测是“好瓜”或者“坏瓜”的任务称为分类任务。 只涉及两个类别称为二分类，通常为正类和反类。 涉及多个类别称为多分类。 预测连续的值，如西瓜的成熟度，称为回归任务。 当事先不知道某些概念，通过学习发现将西瓜分成若干组（如“外地瓜”“本地瓜”），称为聚类任务。 又根据训练数据是否拥有标记信息，学习任务可以分为监督学习和无监督学习。 分类和回归是监督学习的代表 聚类是无监督学习的代表 泛化：模型适用于新样本的能力。 经验误差与过拟合 分类错误的样本数占样本总数的比例称为错误率。 错误率=am,在m个样本中有a个样本分类错误精度=1−错误率=(1−am)×100%错误率=\\frac{a}{m},在m个样本中有a个样本分类错误\\\\ 精度=1-错误率=(1-\\frac{a}{m})\\times 100\\% 错误率=ma​,在m个样本中有a个样本分类错误精度=1−错误率=(1−ma​)×100% 误差：模型的实际预测输出与样本的真实输出之间的差异。 训练集上的误差称为训练误差或经验误差 新样本上的误差称为泛化误差 过拟合：模型对训练集的某些特殊特点过于重视，泛化性能下降。 比如对西瓜数据集训练识别西瓜，西瓜大小被过于重视，认为小西瓜（或远处的西瓜）不是西瓜。 欠拟合：模型对训练样本的一般性质拟合不足。 比如对西瓜数据集训练识别西瓜，认为绿色的都是西瓜。","tags":[null]},{"title":"K邻近算法","path":"/notebooks/ml/knn.html","content":"K 近邻算法（K-Nearest Neighbors，KNN）既可以处理分类问题，也可以处理回归问题。 KNN 是一种懒惰学习算法。 懒惰学习算法：指直到出现新的测试样本，该算法才开始依据训练样本进行样本的预测处理工作。 也就是说，该算法事先不会对训练样本进行任何处理，只会懒散地等待测试样本的到来，然后才开始工作。 懒惰学习算法构建的目标函数能够更近似测试样本数据本身，但同时它需要更大的存储空间用于存储训练样本数据。 懒惰学习算法非常适用于 具有较少特征属性 的 大型数据库 的问题。 KNN 算法原理 在训练集中，每个样本假设都是一个具有 nnn 个特征属性的向量，即 x=(x1,x2,x3,...,xn)x=(x_1, x_2, x_3, ..., x_n)x=(x1​,x2​,x3​,...,xn​) ，可看作每个样本在 nnn 维特征空间内分布。每个样本还有一个标签 yyy。 目的是找到一个函数，使得 y=f(x)y=f(x)y=f(x)，以确定新样本 uuu 的标签。 样本在 nnn 维特征空间内分布，可以找到样本间的一种“距离”，用于评估样本间的相似程度。 欧氏距离：（适用于特征属性是连续变量） DEu(x,u)=∑i=1n(xi−ui)2D_{Eu}(x, u)=\\sqrt{\\sum_{i=1}^n(x_i-u_i)^2} DEu​(x,u)=i=1∑n​(xi​−ui​)2​ 曼哈顿距离：（适用于特征属性是连续变量） DMan(x,u)=∑i=1n∣xi−ui∣D_{Man}(x, u)=\\sum_{i=1}^n|x_i-u_i| DMan​(x,u)=i=1∑n​∣xi​−ui​∣ 闵可夫斯基距离：（适用于特征属性是连续变量） DMin=∑i=1n∣xi−ui∣qqD_{Min}=\\sqrt[q]{\\sum_{i=1}^n|x_i-u_i|^q} DMin​=qi=1∑n​∣xi​−ui​∣q​ 汉明距离：（适用于特征属性是离散变量） DHam(x,u)=∑i=1n∣xi−ui∣,{当xi=ui时，DHam(x,u)=0当xi≠ui时，DHam(x,u)=1D_{Ham}(x, u)=\\sum_{i=1}^n|x_i-u_i|,\\begin{cases}当x_i=u_i时，D_{Ham}(x, u)=0\\\\当x_i eq u_i时，D_{Ham}(x, u)=1\\end{cases} DHam​(x,u)=i=1∑n​∣xi​−ui​∣,{当xi​=ui​时，DHam​(x,u)=0当xi​​=ui​时，DHam​(x,u)=1​ KNN 的任务是在训练集中，依据距离找到与新样本（测试样本） uuu 最相似的那 KKK 个训练样本。 若做分类问题，则多数表决，在 KKK 个训练样本中，哪个分类的样本数多，哪个分类就是 uuu 的预测分类。 若做回归问题，uuu 的预测值 vvv 为： v=∑i=1KyiKv=\\frac{\\sum_{i=1}^Ky_i}{K} v=K∑i=1K​yi​​ 在考虑训练集与测试样本之间距离大小的影响下，使得距离更小的样本具有更大的权值，KKK 个最邻近样本中第 iii 个样本 xix^ixi 与测试样本 uuu 的权值定义为： w(xi,u)=exp⁡(−D(xi,u))∑i=1nexp⁡(−D(xi,u))w(x^i, u)=\\frac{\\exp{(-D(x^i, u))}}{\\sum_{i=1}^n\\exp{(-D(x^i, u))}} w(xi,u)=∑i=1n​exp(−D(xi,u))exp(−D(xi,u))​ 对于回归问题，预测结果 vvv 变成： v=∑i=1Kw(xi,u)yiv=\\sum_{i=1}^Kw(x^i, u)y_i v=i=1∑K​w(xi,u)yi​ 对于分类问题，最终分类结果为权值最大的类。 KNN 的 KKK 需要预先确定： 若值过大，会使特征空间内明确分类边界变得模糊； 若值过小，则引入误差。 常用 交叉验证法 选择 KKK 值。 把训练数据 DDD 分为 KKK 份，用其中的 (K−1)(K-1)(K−1) 份训练模型，把剩余的1份数据用于评估模型的质量。 基于OpenCV实现KNN OpenCV 并没有采用交叉验证和距离权值的方法。 相关函数： // 创建模型cv::Ptrcv::ml::KNearest model=cv::ml::KNearest::create();// 设置默认 K 值model-setDefaultK(k);// 是否分类model-setIsClassifier(true);// 设置算法类型model-setAlgorithmType(cv::ml::KNearest::BRUTE_FORCE);// 训练，实际上是初始化训练样本数据model-train(trainDataPtr);// 找到最近邻model-findNearest(testMat, k, result); 例子-小麦品种籽粒数据集 数据集地址：https://archive.ics.uci.edu/dataset/236/seeds 三种不同小麦品种籽粒几何特性的测定。数据集具有7个属性： 一个区域 周边P 紧性 C=4×π×A/P2C=4\\times\\pi\\times A / P^2C=4×π×A/P2 核的长度 核的宽度 不对称系数 核槽长度 部分数据如下： area perimeter compactness length of kernel width of kernel asymmetry coefficient length of kernel groove class 15.26 14.84 0.871 5.763 3.312 2.221 5.22 1 14.88 14.57 0.8811 5.554 3.333 1.018 4.956 1 14.29 14.09 0.905 5.291 3.337 2.699 4.825 1 13.84 13.94 0.8955 5.324 3.379 2.259 4.805 1 16.14 14.99 0.9034 5.658 3.562 1.355 5.175 1 14.38 14.21 0.8951 5.386 3.312 2.462 4.956 1 12.74 13.67 0.8564 5.395 2.956 2.504 4.869 1 使用自实现 KNN 和 OpenCV 提供的 KNN 类进行训练计算，结果如下： Train Data imported: 150Test Data imported: 60K近邻算法：正确率：0.933333计算花费时长：1msTrain Data imported: 150Test Data imported: 60K近邻算法(基于OpenCV实现)：正确率：0.95计算花费时长：50ms 代码及数据集地址：KNN - Gitee","tags":[null,null]},{"title":"决策树","path":"/notebooks/ml/dt.html","content":"基本流程 决策树是一种非参数的监督学习方法，可用于分类和回归。 构造一种模型，从样本数据的特征属性中，通过决策规则，从而预测目标变量的值。 一颗决策树包含一个根结点、若干个内部结点和若干个叶结点。 叶结点：对应于决策结果。 其他每个结点对应一个属性测试。 根结点的范围为样本全集。 从根节点到每个叶结点的路径对应了一个判定测试序列。 决策树往往是自上而下，每迭代循环一次，就会选择一个特征进行分叉，直至不能再分。 使用“非纯度”的概念，尽量选择最佳的属性进行分叉。 如果一个数据集只有一种分类结果，则该集合很“纯”。 常用有熵、基尼指数和分类误差等指标定量度量： 熵Entropy=E(D)=−∑j=1Jpjlog⁡2(pj)熵\\mathbf{Entropy}=\\mathbf{E}(D)=-\\sum_{j=1}^Jp_j\\log_2(p_j) 熵Entropy=E(D)=−j=1∑J​pj​log2​(pj​) 基尼指数Gini=Gini(D)=∑j=1Jpj(1−pj)=1−∑j=1Jpj2=1−∑j=1JNj2N2基尼指数\\mathbf{Gini}=\\mathbf{Gini}(D)=\\sum_{j=1}^Jp_j(1-p_j)=1-\\sum_{j=1}^Jp_j^2=1-\\frac{\\sum_{j=1}^JN_j^2}{N^2} 基尼指数Gini=Gini(D)=j=1∑J​pj​(1−pj​)=1−j=1∑J​pj2​=1−N2∑j=1J​Nj2​​ 分类误差Error=1−max⁡(pj)分类误差\\mathbf{Error}=1-\\max{(p_j)} 分类误差Error=1−max(pj​) 上三式都是值越大，表示越不纯。 DDD 表示样本数据的分类集合。 设集合有 JJJ 种分类，pjp_jpj​ 表示第 jjj 种分类的样本率：pj=NjNp_j=\\frac{N_j}{N}pj​=NNj​​ NNN 表示集合 DDD 中样本数据总数，NjN_jNj​ 表示第 jjj 种分类的样本数。 常用的决策树算法包括第三代迭代二叉树（ID3）、C4.5、分类和回归树（CART）。 前两种算法是基于熵的方法。 CART：是基于基尼指数的方法。 ID3 易知小型决策树优于大型决策树，希望分类以后降低熵的大小。使用信息增益衡量分类后熵变小的判断： G(D,A)=E(D)−∑i=1nNiNE(Di)\\mathbf{G}(D,A)=\\mathbf{E}(D)-\\sum_{i=1}^n\\frac{N_i}{N}\\mathbf{E}(D_i) G(D,A)=E(D)−i=1∑n​NNi​​E(Di​) nnn 表示对特征 AAA，样本集合被划分为 nnn 个不同的部分。（即 AAA 中包含 nnn 个不同的值） NiN_iNi​ 表示第 iii 个部分的样本数量 E(Di)\\mathbf{E}(D_i)E(Di​) 表示特征 AAA 下第 iii 个部分的分类集合的熵。 信息增益越大，分类后熵的值下降得越快，分类效果越好。 选择信息增益最大的特征属性进行分类。 C4.5 使用信息增益率进行衡量非纯度： GR(D,A)=G(D,A)SI(D,A)\\mathbf{GR}(D,A)=\\frac{\\mathbf{G}(D,A)}{\\mathbf{SI}(D,A)} GR(D,A)=SI(D,A)G(D,A)​ 其中： SI(D,A)=−∑i=1nNiNlog⁡2NiN\\mathbf{SI}(D,A)=-\\sum_{i=1}^n\\frac{N_i}{N}\\log_2\\frac{N_i}{N} SI(D,A)=−i=1∑n​NNi​​log2​NNi​​ 选择信息增益率最大的特征属性作为分类属性。 CART 分类树 针对特征属性 AAA，分类后的基尼指数为： Ginisp(D,A)=∑i=1nNiNGini(Di)\\mathbf{Gini}_{sp}(D,A)=\\sum_{i=1}^n\\frac{N_i}{N}\\mathbf{Gini}(D_i) Ginisp​(D,A)=i=1∑n​NNi​​Gini(Di​) 选择分类基尼指数最小的特征属性作为分类属性。 当特征属性 AAA 的取值大于2时（此处讨论二叉树），需要一个阈值 β\\betaβ，把 DDD 分成 D1D_1D1​ 和 D2D_2D2​。设 D1D_1D1​ 的样本数为 LLL，D2D_2D2​ 的样本数为 RRR， L+R=NL+R=NL+R=N。 Ginisp(D,A(β))=LNGini(D1)+RNGini(D2)\\mathbf{Gini}_{sp}(D,A^{(\\beta)})=\\frac{L}{N}\\mathbf{Gini}(D_1)+\\frac{R}{N}\\mathbf{Gini}(D_2) Ginisp​(D,A(β))=NL​Gini(D1​)+NR​Gini(D2​) Ginisp(D,A(β))=LN(1−∑j=1JLj2L2)+RN(1−∑j=1JRj2R2)=1N(L−∑j=1JLj2L+R−∑j=1JRj2R)=1−1N(∑j=1JLj2L+∑j=1JRj2R)\\mathbf{Gini}_{sp}(D,A^{(\\beta)})=\\frac{L}{N}\\left(1-\\frac{\\sum_{j=1}^JL_j^2}{L^2}\\right)+\\frac{R}{N}\\left(1-\\frac{\\sum_{j=1}^JR_j^2}{R^2}\\right)\\\\ =\\frac{1}{N}\\left(L-\\frac{\\sum_{j=1}^JL_j^2}{L}+R-\\frac{\\sum_{j=1}^JR_j^2}{R}\\right)\\\\ =1-\\frac{1}{N}\\left(\\frac{\\sum_{j=1}^JL_j^2}{L}+\\frac{\\sum_{j=1}^JR_j^2}{R}\\right) Ginisp​(D,A(β))=NL​(1−L2∑j=1J​Lj2​​)+NR​(1−R2∑j=1J​Rj2​​)=N1​(L−L∑j=1J​Lj2​​+R−R∑j=1J​Rj2​​)=1−N1​(L∑j=1J​Lj2​​+R∑j=1J​Rj2​​) ∑Lj=L\\sum L_j=L∑Lj​=L，∑Rj=R\\sum R_j=R∑Rj​=R 求 Ginisp\\mathbf{Gini}_{sp}Ginisp​ 最小值变成求下式的最大值： SG(D,A(β))∑j=1JLj2L+∑j=1JRj2R\\mathbf{SG}(D,A^{(\\beta)})\\frac{\\sum_{j=1}^JL_j^2}{L}+\\frac{\\sum_{j=1}^JR_j^2}{R} SG(D,A(β))L∑j=1J​Lj2​​+R∑j=1J​Rj2​​ 特征为类的分类树： 采集 20 个样本来构建是否踢球分类树，设出去踢球的响应值为 1，不踢球的响应值为 0，针对风力这个特征属性，响应值为 1 的样本有 14 个，无风有 6 个样本，小风有 5 个，中风 2 个，大风 1 个，则排序的结果为：大风中风小风无风。然后依据这个顺序依次按照二叉树的分叉方式把样本分为左分支和右分支，并代入式求使该式为最大值的那个分叉方式，即先把是大风的样本放入左分支，其余的放入右分支，代入式，得到 A，再把大风和中风放入左分支，其余的放入右分支，代入式，得到 B，然后把大风、中风和小风放入左分支，无风的放入右分支，计算得到 C。比较 A、B、C，如果最大值为 C，则按照 C 的分叉方式划分左右分支，其中阈值 β 可以设为 3。 特征为数值的分类树： 如一共有 14 个样本，按照由小至大的顺序为abcdefghijklmn，第一次分叉为a|bcdefghijklmn，竖线“|”的左侧被划分到左分支，右侧被划分到右分支，代入式计算其值，然后第二次分叉为 ab|cdefghijklmn，同理代入式计算其值。依次类推，得到这 13 次分叉的最大值，该种分叉方式为最佳的分叉方式，其中阈值 β 为分叉的次数。 回归树 用均方误差代替熵计算： LS(D)=1N∑i=1N(yi−ri)2\\mathbf{LS}(D)=\\frac{1}{N}\\sum_{i=1}^N(y_i-r_i)^2 LS(D)=N1​i=1∑N​(yi​−ri​)2 NNN 表示 DDD 样本数量。 yiy_iyi​ 表示第 iii 个样本的输出值。 rir_iri​ 表示第 iii 个样本的预测值。 用样本输出值的平均值代替样本的预测值： LS(D)=1N∑i=1N(yi−∑i=1NyiN)2=1N∑i=1N[yi2−2yi∑i=1NyiN+(∑i=1Nyi)2N2]2=1N[∑i=1Nyi2−2(∑i=1Nyi)2N+(∑i=1Nyi)2N2]=1N[∑i=1Nyi2−(∑i=1Nyi)2N]\\begin{aligned} \\mathbf{LS} (D) = \\frac {1} {N} \\sum_{i=1}^N \\left( y_i - \\frac {\\sum_{i=1}^Ny_i} {N} \\right) ^2 \\\\ = \\frac {1} {N} \\sum_{i=1}^N \\left[ y_i^2 - \\frac {2y_i\\sum_{i=1}^Ny_i} {N} + \\frac {(\\sum_{i=1}^Ny_i)^2} {N^2} \\right] ^2 \\\\ = \\frac {1} {N} \\left[ \\sum_{i=1}^Ny_i^2 - \\frac {2(\\sum_{i=1}^Ny_i)^2} {N} + \\frac {(\\sum_{i=1}^Ny_i)^2} {N^2} \\right] \\\\ = \\frac {1} {N} \\left[ \\sum_{i=1}^Ny_i^2 - \\frac {(\\sum_{i=1}^Ny_i)^2} {N} \\right] \\end{aligned} LS(D)​=N1​i=1∑N​(yi​−N∑i=1N​yi​​)2=N1​i=1∑N​[yi2​−N2yi​∑i=1N​yi​​+N2(∑i=1N​yi​)2​]2=N1​[i=1∑N​yi2​−N2(∑i=1N​yi​)2​+N2(∑i=1N​yi​)2​]=N1​[i=1∑N​yi2​−N(∑i=1N​yi​)2​]​ 上式是集合 DDD 的最小均方误差。如果针对某特征 AAA，则把集合 DDD 划分为 sss 个部分，划分后的均方误差： LS(D,A)=∑i=1sNiNLS(Di)\\mathbf{LS}(D,A)=\\sum_{i=1}^s\\frac{N_i}{N}\\mathbf{LS}(D_i) LS(D,A)=i=1∑s​NNi​​LS(Di​) NiN_iNi​ 表示被划分的第 iii 个集合 DiD_iDi​ 的样本数量。 集合 DDD 的最小均方误差和划分后的均方误差的差值是划分为 sss 个部分后的误差减小量： ΔLS(D,A)=LS(D)−∑i=1sNiNLS(Di)\\Delta\\mathbf{LS}(D,A)=\\mathbf{LS}(D)-\\sum_{i=1}^s\\frac{N_i}{N}\\mathbf{LS}(D_i) ΔLS(D,A)=LS(D)−i=1∑s​NNi​​LS(Di​) 此时需要寻求最大化的误差减小量，就得到最佳的 sss 个部分划分。 考虑二叉树，s=2s=2s=2。把 DDD 分成 D1D_1D1​ 和 D2D_2D2​。设 D1D_1D1​ 的样本数为 LLL，D2D_2D2​ 的样本数为 RRR，L+R=NL+R=NL+R=N。 ΔLS(D,A(β))=LS(D)−LNLS(D1)−RNLS(D2)\\Delta\\mathbf{LS}(D,A^{(\\beta)})=\\mathbf{LS}(D)-\\frac{L}{N}\\mathbf{LS}(D_1)-\\frac{R}{N}\\mathbf{LS}(D_2) ΔLS(D,A(β))=LS(D)−NL​LS(D1​)−NR​LS(D2​) ΔLS(D,A(β))=1N[∑i=1Nyi2−(∑i=1Nyi)2N]−LN{1L[∑i=1Lli2−(∑i=1Lli)2L]}−RN{1R[∑i=1Rri2−(∑i=1Rri)2R]}=1N[∑i=1Nyi2−(∑i=1Nyi)2N−∑i=1Lli2+(∑i=1Lli)2L−∑i=1Rri2+(∑i=1Rri)2R]=−(∑i=1Nyi)2N2+1N[(∑i=1Lli)2L+(∑i=1Rri)2R]\\begin{aligned} \\Delta\\mathbf{LS}(D,A^{(\\beta)}) =\\frac{1}{N}\\left[\\sum_{i=1}^Ny_i^2-\\frac{(\\sum_{i=1}^Ny_i)^2}{N}\\right]-\\frac{L}{N}\\left\\{\\frac{1}{L}\\left[\\sum_{i=1}^Ll_i^2-\\frac{(\\sum_{i=1}^Ll_i)^2}{L}\\right]\\right\\}-\\frac{R}{N}\\left\\{\\frac{1}{R}\\left[\\sum_{i=1}^Rr_i^2-\\frac{(\\sum_{i=1}^Rr_i)^2}{R}\\right]\\right\\}\\\\ =\\frac{1}{N}\\left[\\sum_{i=1}^Ny_i^2-\\frac{(\\sum_{i=1}^Ny_i)^2}{N}-\\sum_{i=1}^Ll_i^2+\\frac{(\\sum_{i=1}^Ll_i)^2}{L}-\\sum_{i=1}^Rr_i^2+\\frac{(\\sum_{i=1}^Rr_i)^2}{R}\\right]\\\\ =-\\frac{(\\sum_{i=1}^Ny_i)^2}{N^2}+\\frac{1}{N}\\left[\\frac{(\\sum_{i=1}^Ll_i)^2}{L}+\\frac{(\\sum_{i=1}^Rr_i)^2}{R}\\right] \\end{aligned} ΔLS(D,A(β))​=N1​[i=1∑N​yi2​−N(∑i=1N​yi​)2​]−NL​{L1​[i=1∑L​li2​−L(∑i=1L​li​)2​]}−NR​{R1​[i=1∑R​ri2​−R(∑i=1R​ri​)2​]}=N1​[i=1∑N​yi2​−N(∑i=1N​yi​)2​−i=1∑L​li2​+L(∑i=1L​li​)2​−i=1∑R​ri2​+R(∑i=1R​ri​)2​]=−N2(∑i=1N​yi​)2​+N1​[L(∑i=1L​li​)2​+R(∑i=1R​ri​)2​]​ yiy_iyi​ 为集合 DDD 的样本响应值。 lil_ili​ 为集合 D1D_1D1​ 的样本响应值。 rir_iri​ 为集合 D2D_2D2​ 的样本响应值。 上式除开定值，求上式最大值问题变成求下式最大值问题： ΔLLS(D,A(β))=(∑i=1Lli)2L+(∑i=1Rri)2R\\Delta\\mathbf{LLS}(D,A^{(\\beta)})=\\frac{(\\sum_{i=1}^Ll_i)^2}{L}+\\frac{(\\sum_{i=1}^Rr_i)^2}{R} ΔLLS(D,A(β))=L(∑i=1L​li​)2​+R(∑i=1R​ri​)2​ 特征为类的回归树： 计算每个特征属性各个种类的平均样本响应值，按大小进行排序，依次代入计算，得到最大值。 与特征为数值的分类树类似，按照数值大小顺序依次代入，得到最大值。 决策树缺失 分类树缺失响应值 如果想检测罕见的异常现象，而训练中包含的是大量正常现象，那么很可能分类结果就认为每种情况都是正常的。 可以通过设置先验概率，将异常情况的发生概率人为增加。 设 QjQ_jQj​ 为设置的第 jjj 个分类的先验概率，NjN_jNj​ 为该分类的样本数，考虑样本率并进行归一化处理的先验概率 qjq_jqj​ 为： qj=Qj/Nj∑j=1J(Qj/Nj)q_j=\\frac{Q_j/N_j}{\\sum_{j=1}^J(Q_j/N_j)} qj​=∑j=1J​(Qj​/Nj​)Qj​/Nj​​ 代入分类树的式子，得到： SG(D,A(β),q)=∑j=1J(qjLj)2∑j=1J(qjLj)+∑j=1J(qjRj)∑j=1J(qjRj)\\mathbf{SG}(D,A^{(\\beta)},q)=\\frac{\\sum_{j=1}^J(q_jL_j)^2}{\\sum_{j=1}^J(q_jL_j)}+\\frac{\\sum_{j=1}^J(q_jR_j)}{\\sum_{j=1}^J(q_jR_j)} SG(D,A(β),q)=∑j=1J​(qj​Lj​)∑j=1J​(qj​Lj​)2​+∑j=1J​(qj​Rj​)∑j=1J​(qj​Rj​)​ 缺失特征属性 如果某些样本缺失了某个最佳分叉属性，如何解决： 把该样本删除； 使用各种算法估计缺失属性值； 用另一个特征属性代替最佳分叉属性。 CART 采用的就是计算替代分叉属性，防止最佳分叉属性缺失。 决策树剪枝 剪枝：去掉一些结点，包括叶结点和中间结点，简化树。 预剪枝：构建树过程中，提前终止决策树的生长； 后剪枝：构建树后去掉一些结点。 悲观错误剪枝（PEP） 最小错误剪枝（MEP） 代价复杂度剪枝（CCP） 基于错误剪枝（EBP） CCP 算法会产生一系列树的序列 {T0,T1,⋯ ,Tm}\\{T_0,T_1,\\cdots,T_m\\}{T0​,T1​,⋯,Tm​}，T0T_0T0​ 是由训练得到的最初的完整决策树，TmT_mTm​ 只含有一个根节点，序列中的树是嵌套的，即 Ti+1T_{i+1}Ti+1​ 由 TiT_iTi​ 剪枝得到的。 用 Ti+1T_{i+1}Ti+1​ 中的一个叶结点替代 TiT_iTi​ 中以该节点为根的子树。 替代的原则就是使误差的增加率 α\\alphaα 最小： α=R(n)−R(nt)∣nt∣−1\\alpha=\\frac{\\mathbf{R}(n)-\\mathbf{R}(n_t)}{\\vert n_t\\vert-1} α=∣nt​∣−1R(n)−R(nt​)​ R(n)\\mathbf{R}(n)R(n) 表示 TiT_iTi​ 中结点 nnn 的预测误差； R(nt)\\mathbf{R}(n_t)R(nt​) 表示 TiT_iTi​ 中以结点 nnn 为根结点的子树的所有叶结点的预测误差之和； ∣nt∣\\vert n_t\\vert∣nt​∣ 表示该子树叶结点的数量，ntn_tnt​ 也被称为复杂度。 α\\alphaα 的含义是用一个结点 nnn 来替代以 nnn 为根节点的所有 ∣nt∣\\vert n_t\\vert∣nt​∣ 个结点的误差增加的规范化程度。 在 TiT_iTi​ 中，选择最小的 α\\alphaα 值的结点进行替代，得到 Ti+1T_{i+1}Ti+1​。每需要得到一棵决策树，都需要计算其前一棵决策树的 α\\alphaα 值，根据 α\\alphaα 值进行剪枝，最终直至 TmT_mTm​。 分类树的情况，如果使用分类误差来表示结点 nnn 的预测误差，则： R(n)=∑j=1mNj−max⁡{Nj}∑j=1mNj=N−max⁡{Nj}N\\mathbf{R}(n)=\\frac{\\sum_{j=1}^mN_j-\\max{\\{N_j\\}}}{\\sum_{j=1}^mN_j}=\\frac{N-\\max{\\{N_j\\}}}{N} R(n)=∑j=1m​Nj​∑j=1m​Nj​−max{Nj​}​=NN−max{Nj​}​ NjN_jNj​ 表示结点 nnn 下第 jjj 个分类的样本数； NNN 表示该结点的所有样本数； max⁡{Nj}\\max{\\{N_j\\}}max{Nj​} 表示在 mmm 个分类中，拥有样本数最多的那个分类的样本数量。 回归树的情况，可以使用集合 DDD 的最小均方误差表示结点 nnn 的预测误差： R(n)=∑i=1N(yi2)−(∑i=1Nyi)2NN\\mathbf{R}(n)=\\frac{\\sum_{i=1}^N(y_i^2)-\\frac{(\\sum_{i=1}^Ny_i)^2}{N}}{N} R(n)=N∑i=1N​(yi2​)−N(∑i=1N​yi​)2​​ yiy_iyi​ 表示第 iii 个样本的响应值； NNN 为该结点的样本数量。 用全部样本得到的决策树序列为 {T0,T1,⋯ ,Tm}\\{T_0,T_1,\\cdots,T_m\\}{T0​,T1​,⋯,Tm​}，其对应值 α0α1⋯αm\\alpha_0\\alpha_1\\cdots\\alpha_mα0​α1​⋯αm​。下一步是从这个序列最优选择一颗决策树 TiT_iTi​，常用交叉验证法。 OpenCV提供的DTree DTrees 类表示一个决策树或一组决策树。类的当前公共接口允许用户只训练单个决策树，但是类能够存储多个决策树并使用它们进行预测(通过求和响应或使用投票方案)，以及从DTree类派生的类（如RTree和Boost）使用此功能来实现决策树集成。 该类中有部分参数解释： MaxCategories：表示特征属性为类的形式的最大类数量。如果训练过程中，类的数量大于该值，采用聚类方法更高效。该参数只应用于非两类的分类树问题。通过以下函数访问： int getMaxCategories();void setMaxCategories(int val); MaxDepth：决策树的最大可能深度。通过以下函数访问： int getMaxDepth();void setMaxDepth(int val); MinSampleCount：如果某个结点的样本数小于该值，则该结点不再被分叉。通过以下函数访问： int getMinSampleCount();void setMinSampleCount(int val); CVFolds：表示交叉验证的子集数量。如果值大于1，则应该交叉验证进行剪枝。通过以下函数访问： int getCVFolds();void setCVFolds(int val); UseSurrogates：如果设为真，则需要产生代替分叉节点。默认为假。通过以下函数访问： bool getUseSurrogates();void setUseSurrogates(bool val); Use1SERule：如果设为真，表示剪枝过程使用 1SE 规则，使决策树更加的，且对训练集的噪声更有抵抗力，但精度会下降。默认为真。通过以下函数访问： bool getUse1SERule();void setUse1SERule(bool val); TruncatePrunedTree：如果设为真，则要被剪掉的结点将从树上移除，否则仍保留。默认为真。通过以下函数访问： bool getTruncatePrunedTree();void setTruncatePrunedTree(bool val); RegressionAccuracy：构建回归树的条件，表示回归树的响应值的精度如果达到该值则无需再分叉。通过以下函数访问： float getRegressionAccuracy();void setRegressionAccuracy(float val); Priors：表示分类树的类别标签先验概率，按类别标签值排序。通过以下函数访问： cv::Mat getPriors()void setPriors(const cv::Mat val); 例子-单词难度预测 数据集地址：https://aistudio.baidu.com/datasetdetail/107161 数据集属性有： Word：单词 Length：长度 Freq_HAL：频率_HAL Log_Freq_HAL：对数频率HAL I_Mean_RT I_Zscore：确定单词的难度。对于一个单词，此值在0和1之间波动，其中0为简单，1为困难 I_SD Obs I_Mean_Accuracy：准确性，为响应值 部分数据如下： Length Freq_HAL Log_Freq_HAL I_Mean_RT I_Zscore I_SD Obs I_Mean_Accuracy 1.00 10610626.00 16.18 798.92 -0.01 333.85 24.00 0.73 3.00 222.00 5.40 816.43 0.21 186.03 21.00 0.62 5.00 10806.00 9.29 736.06 -0.11 289.01 32.00 0.97 5.00 387.00 5.96 796.27 0.11 171.61 15.00 0.45 6.00 513.00 6.24 964.40 0.65 489.00 15.00 0.47 效果如下： Train Data imported: 30457Test Data imported: 9992决策树算法(基于OpenCV实现)：计算花费时长：159ms平均误差：0.0239817 代码地址：Gitee - Decision Tree","tags":[null,null]},{"title":"基础线性模型","path":"/notebooks/ml/linear.html","content":"基本形式 对于一个样本 x=(x1,x2,...,xd)\\pmb{x}=(x_1,x_2,...,x_d)xx=(x1​,x2​,...,xd​)，其中 xix_ixi​ 为第 iii 个属性上的取值。 线性模型试图通过一个属性值与权值的线性组合进行预测： f(x)=ω1x1+ω2x2+...+ωdxd+bf(x)=\\omega_1x_1+\\omega_2x_2+...+\\omega_dx_d+b f(x)=ω1​x1​+ω2​x2​+...+ωd​xd​+b 向量模式写成： f(x)=ωTx+bω=(ω1,ω2,...,ωd)f(\\pmb{x})=\\pmb{\\omega}^T\\pmb{x}+b\\\\ \\pmb{\\omega}=(\\omega_1,\\omega_2,...,\\omega_d) f(xx)=ωωTxx+bωω=(ω1​,ω2​,...,ωd​) 线性回归 一元线性回归 线性回归对于样本 (xi,yi)(x_i,y_i)(xi​,yi​) ，试图使： f(xi)=ωxi+b近似于yif(x_i)=\\omega x_i+b近似于y_i f(xi​)=ωxi​+b近似于yi​ 通过均方误差评估 f(xi)f(x_i)f(xi​) 与 yiy_iyi​ 之间的差别，试图让均方误差取最小值： (w∗,b∗)=arg⁡min⁡(w,b)∑i=1m(f(xi)−yi)2=arg⁡min⁡(w,b)∑i=1m(yi−f(xi))2(w∗,b∗)=arg⁡min⁡(w,b)∑i=1m(yi−wxi−b)2(w^*,b^*)=\\arg\\min_{(w,b)} \\sum_{i=1}^m(f(x_i)-y_i)^2=\\arg\\min_{(w,b)} \\sum_{i=1}^m(y_i-f(x_i))^2\\\\ (w^*,b^*)=\\arg\\min_{(w,b)} \\sum_{i=1}^m(y_i-wx_i-b)^2 (w∗,b∗)=arg(w,b)min​i=1∑m​(f(xi​)−yi​)2=arg(w,b)min​i=1∑m​(yi​−f(xi​))2(w∗,b∗)=arg(w,b)min​i=1∑m​(yi​−wxi​−b)2 (ω∗,b∗)(\\omega^*,b^*)(ω∗,b∗) 为 ω\\omegaω 和 bbb 的解，此处 mmm 为样本数。 arg⁡min⁡\\arg\\minargmin 表示右式取最小值时 ω\\omegaω 和 bbb 的值。 求均方误差也对应了求欧氏距离。 基于均方误差最小值来进行模型求解，称为最小二乘法。 线性回归中，最小二乘法就是试图找到一条直线，使得样本到直线上的欧式距离之和最小。 令： E(w,b)=∑i=1m(yi−wxi−b)2E_{(w,b)}=\\sum_{i=1}^m(y_i-wx_i-b)^2 E(w,b)​=i=1∑m​(yi​−wxi​−b)2 上式分别对 ω\\omegaω 和 bbb 求导： ∂E(ω,b)∂ω=2(ω∑i=1mxi2−∑i=1m(yi−b)xi),∂E(ω,b)∂b=2(mb−∑i=1m(yi−wxi))\\frac{\\partial E_{(\\omega,b)}}{\\partial\\omega}=2(\\omega\\sum_{i=1}^mx_i^2-\\sum_{i=1}^m(y_i-b)x_i),\\\\ \\frac{\\partial E_{(\\omega,b)}}{\\partial b}=2(mb-\\sum_{i=1}^m(y_i-wx_i)) ∂ω∂E(ω,b)​​=2(ωi=1∑m​xi2​−i=1∑m​(yi​−b)xi​),∂b∂E(ω,b)​​=2(mb−i=1∑m​(yi​−wxi​)) 使导数为0，得到： ω=∑i=1myi(xi−x‾)∑i=1mxi2−1m(∑i=1mxi)2b=1m∑i=1m(yi−ωxi)\\omega=\\frac{\\sum_{i=1}^my_i(x_i-\\overline{x})}{\\sum_{i=1}^mx_i^2-\\frac{1}{m}(\\sum_{i=1}^mx_i)^2}\\\\ \\ \\\\ b=\\frac{1}{m}\\sum_{i=1}^m(y_i-\\omega x_i) ω=∑i=1m​xi2​−m1​(∑i=1m​xi​)2∑i=1m​yi​(xi​−x)​b=m1​i=1∑m​(yi​−ωxi​) x‾\\overline{x}x 为 xxx 的均值。 例子-一元线性回归 对于一个一元线性回归数据集进行回归计算，效果如下： 该例子相关的数据集以及代码已置于仓库：Gitee 多元线性回归 用梯度下降求解多元线性回归。 梯度下降法的基本思想可以类⽐为⼀个下⼭的过程。 最快的下山方式就是找到当前位置最陡峭的⽅向，然后沿着此方向向下⾛，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的⽅向，就能让函数值下降的最快。 反复求取梯度，最后就能到达局部的最⼩值。 在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率； 在多变量函数中，梯度是⼀个向量（向量有方向），梯度的方向就指出了函数在给定点的上升最快的方向。 梯度下降公式为： xi+1=xi−α∂∂xif(xi)x^{i+1}=x^i-\\alpha\\frac{\\partial}{\\partial x_i}f(x^i) xi+1=xi−α∂xi​∂​f(xi) α\\alphaα 称作学习率或者步长，意味着每一步走的距离。距离太大容易错过最低点，距离太小迟迟未到最低点。 如： 单变量函数梯度下降： f(x)=x2f(x)=x^2f(x)=x2 微分为：f′(x)=2xf'(x)=2xf′(x)=2x 初始化起点为： x0=1x^0=1x0=1，学习率取0.4 梯度下降迭代： x1=x0−0.4×2x0=1−0.4×2=0.2x^1=x^0-0.4\\times 2x^0=1-0.4\\times 2=0.2x1=x0−0.4×2x0=1−0.4×2=0.2 x2=x1−0.4×2x1=0.2−0.4×0.4=0.04x^2=x^1-0.4\\times 2x^1=0.2-0.4\\times 0.4=0.04x2=x1−0.4×2x1=0.2−0.4×0.4=0.04 x3=x2−0.4×2x2=0.04−0.4×0.08=0.008x^3=x^2-0.4\\times 2x^2=0.04-0.4\\times 0.08=0.008x3=x2−0.4×2x2=0.04−0.4×0.08=0.008 x4=x3−0.4×2x3=0.008−0.4×0.016=0.0016x^4=x^3-0.4\\times 2x^3=0.008-0.4\\times 0.016=0.0016x4=x3−0.4×2x3=0.008−0.4×0.016=0.0016 多变量函数的梯度下降： f(x)=x12+x22f(x)=x_1^2+x_2^2f(x)=x12​+x22​ 微分为：f′(x)=2x1+2x2f'(x)=2x_1+2x_2f′(x)=2x1​+2x2​ 初始化起点为： x0=(1,3)x^0=(1,3)x0=(1,3)，学习率取0.1 梯度下降迭代： x1=x0−0.1×f′(x0)=(1,3)−0.1×(2,6)=(0.8,2.4)x^1=x^0-0.1\\times f'(x^0)=(1,3)-0.1\\times (2,6)=(0.8,2.4)x1=x0−0.1×f′(x0)=(1,3)−0.1×(2,6)=(0.8,2.4) x2=x1−0.1×f′(x1)=(0.8,2.4)−0.1×(1.6,4.8)=(0.64,1.92)x^2=x^1-0.1\\times f'(x^1)=(0.8,2.4)-0.1\\times (1.6,4.8)=(0.64,1.92)x2=x1−0.1×f′(x1)=(0.8,2.4)−0.1×(1.6,4.8)=(0.64,1.92) x3=x2−0.1×f′(x2)=(0.64,1.92)−0.1×(1.28,3.84)=(0.512,1.536)x^3=x^2-0.1\\times f'(x^2)=(0.64,1.92)-0.1\\times (1.28,3.84)=(0.512,1.536)x3=x2−0.1×f′(x2)=(0.64,1.92)−0.1×(1.28,3.84)=(0.512,1.536) …… x100=(1.6296e−10,4.8889e−10)x^{100}=(1.6296e^{-10},4.8889e^{-10})x100=(1.6296e−10,4.8889e−10) 引入损失函数，度量拟合的程度。损失函数极小化，意味着拟合程度最好，对应的模型参数即为最优参数。线性回归中假设模型函数为： f(x1,...,xn)=w0+w1x1+w2x2+...+wnxnf(x_1,...,x_n)=w_0+w_1x_1+w_2x_2+...+w_nx_nf(x1​,...,xn​)=w0​+w1​x1​+w2​x2​+...+wn​xn​ wiw_iwi​ 为模型参数，bbb 为偏置。 简化：增加特征 x0=1x_0=1x0​=1，可以简化为：f(x0,...,xn)=∑i=0nwixif(x_0,...,x_n)=\\sum_{i=0}^nw_ix_if(x0​,...,xn​)=∑i=0n​wi​xi​ 在线性回归中，损失函数通常为样本输出和假设函数的差取平方（或者带系数）。比如对于 mmm 个样本 (xi,yi)(i=1,2,...m)(\\pmb{x_i},y_i)(i = 1, 2, ...m)(xi​​xi​,yi​)(i=1,2,...m)，采⽤线性回归，假设损失函数为： Loss(w0,w1,...,wn)=12m∑j=0m(f(x0(j),x1(j),...,xn(j))−yj)2Loss(w_0,w_1,...,w_n)=\\frac{1}{2m}\\sum_{j=0}^m(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)^2 Loss(w0​,w1​,...,wn​)=2m1​j=0∑m​(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)2 xi(j)x_i^{(j)}xi(j)​：上标 jjj 表示第 jjj 个样本，下标 iii 表示第 iii 个特征。 系数 12\\frac {1}{2}21​ 是方便微分化简。 x0(j)x_0^{(j)}x0(j)​ 都为1。 对于上述损失函数的梯度为： ∂∂wiLoss(w0,w1,...,wn)=1m∑j=0m(f(x0(j),x1(j),...,xn(j))−yj)xi(j)\\frac{\\partial}{\\partial w_i}Loss(w_0,w_1,...,w_n)=\\frac{1}{m}\\sum_{j=0}^m(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)x_i^{(j)} ∂wi​∂​Loss(w0​,w1​,...,wn​)=m1​j=0∑m​(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)xi(j)​ 接着变化： wi=wi−α1m∑j=0m(f(x0(j),x1(j),...,xn(j))−yj)xi(j)w_i=w_i-α\\frac{1}{m}\\sum_{j=0}^m(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)x_i^{(j)} wi​=wi​−αm1​j=0∑m​(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)xi(j)​ 梯度算法变种 全梯度下降算法（Full Gradient Descent） 更新参数时使⽤所有的样本来进⾏更新。 wi=wi−α∑j=0m(f(x0(j),x1(j),...,xn(j))−yj)xi(j)w_i=w_i-α\\sum_{j=0}^m(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)x_i^{(j)} wi​=wi​−αj=0∑m​(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)xi(j)​ 随机梯度下降算法（Stochastic Gradient Descent） 每次只代⼊计算⼀个样本⽬标函数的梯度来更新权重，再取下⼀个样本重复此过程，直到损失函数值停⽌下降或损失函数值⼩于某个可以容忍的阈值。 wi=wi−α(f(x0(j),x1(j),...,xn(j))−yj)xi(j)w_i=w_i-α(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)x_i^{(j)} wi​=wi​−α(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)xi(j)​ 小批量梯度下降算法（Mini-batch Gradient Descent） 每次从训练样本集上随机抽取⼀个⼩样本集，在抽出来的⼩样本集上采⽤FG迭代更新权重。 wi=wi−α∑j=tt+x−1(f(x0(j),x1(j),...,xn(j))−yj)xi(j)w_i=w_i-α\\sum_{j=t}^{t+x-1}(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)x_i^{(j)} wi​=wi​−αj=t∑t+x−1​(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)xi(j)​ 随机平均梯度下降算法（Stochastic Average Gradient Descent） 在内存中为每⼀个样本都维护⼀个旧的梯度，随机选择第i个样本来更新此样本的梯度，其他样本的梯度保持不变，然后求得所有梯度的平均值，进⽽更新了参数。 m 个样本 wi=wi−αm(f(x0(j),x1(j),...,xn(j))−yj)xi(j)w_i=w_i-\\frac{α}{m}(f(x_0^{(j)},x_1^{(j)},...,x_n^{(j)})-y_j)x_i^{(j)} wi​=wi​−mα​(f(x0(j)​,x1(j)​,...,xn(j)​)−yj​)xi(j)​ 例子-波士顿房价 数据集地址：https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data 直接复制到本地即可，保存为 .txt 文件。 数据集具有14列： CRIM：城镇人均犯罪率。 ZN：占地面积超过25,000平方英尺的住宅用地比例。 INDUS：每个城镇非零售业务的比例。 CHAS：Charles River虚拟变量（如果是河道，则为1;否则为0）。 NOX：一氧化氮浓度（每千万份）。 RM：每间住宅的平均房间数。 AGE：1940年以前建造的自住单位比例。 DIS：波士顿的五个就业中心加权距离。 RAD：径向高速公路的可达性指数。 TAX：每10,000美元的全额物业税率。 PTRATIO：城镇的学生与教师比例。 B：1000(Bk−0.63)21000(Bk - 0.63)^21000(Bk−0.63)2 其中Bk是城镇黑人的比例。 LSTAT：人口状况下降%。 MEDV：自有住房的中位数报价, 单位1000美元。 前13列为属性值（即 xix_ixi​），第14列为房价（即 yyy）。 使用 SAG 算法进行线性回归计算。 测试结果： Data imported: 506平均误差：4.57072迭代时长：46.329s 该例子相关的数据集以及代码已置于仓库：Gitee","tags":[null,null]},{"title":"神经网络","path":"/notebooks/ml/nn.html","content":"神经网络是一种模仿生物神经系统的机器学习算法。 神经元 人工神经网络由若干个神经元构成。神经元结构如下： x1、x2、...、xnx_1、x_2、...、x_nx1​、x2​、...、xn​ 是神经元的输入。 yyy 是神经元的输出。 w1、w2、...、wnw_1、w_2、...、w_nw1​、w2​、...、wn​ 是神经元的权重。 bbb 为偏移量。 神经元内部包括两个部分： 输入的加权求和； u=∑i=1n(wixi)+b=∑i=0n(wixi),x0恒为1u=\\sum_{i=1}^n(w_ix_i)+b=\\sum_{i=0}^n(w_ix_i),x_0恒为1 u=i=1∑n​(wi​xi​)+b=i=0∑n​(wi​xi​),x0​恒为1 对求和结果的“激活”。激活指的是对输出值进行某种关系映射，使得神经元兴奋或抑制。 y=f(u)y=f(u) y=f(u) 激活函数有多种： 线性函数： f(x)=xf(x)=x f(x)=x 阈值函数： f(x)={1,x≥θ0,xθf(x)=\\begin{cases}1,x\\geq\\theta\\\\0,x\\theta\\end{cases} f(x)={1,0,​x≥θxθ​ Sigmoid 函数： f(x)=11+e−xf(x)=\\frac{1}{1+e^{-x}} f(x)=1+e−x1​ 对称 Sigmoid 函数： f(x)=β1−e−αx1+e−αxf(x)=\\beta\\frac{1-e^{-\\alpha x}}{1+e^{-\\alpha x}} f(x)=β1+e−αx1−e−αx​ 双曲正切函数： f(x)=ex−e−xex+e−xf(x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}} f(x)=ex+e−xex−e−x​ 高斯函数： f(x)=βe−α2x2f(x)=\\beta e^{-\\alpha^2x^2} f(x)=βe−α2x2 RELU 函数： f(x)=max⁡(0,x)f(x)=\\max(0,x) f(x)=max(0,x) 感知器 感知器由两层神经元组成： 输入层：输入数据 输出层：处理并输出结果 感知器的学习规则很简单，对于训练样本 (x,y)(\\mathbf{x},y)(x,y)，若当前感知机输出为 y^\\hat{y}y^​，则权重调整为： wi=wi+Δwi=wiη(y−y^)xiw_i=w_i+\\Delta w_i=w_i\\eta(y-\\hat{y})x_i wi​=wi​+Δwi​=wi​η(y−y^​)xi​ η∈(0,1)\\eta\\in(0,1)η∈(0,1) 称为学习率。 感知器只有输出层神经元进行激活函数处理，也就是只有一层功能神经元，处理线性可分问题。 存在一个线性超平面将样本分开，则感知器的学习过程会收敛。 多层感知器 MLP 解决非线性可分问题，需要考虑多层（功能）神经元。 前馈神经网络是神经网络的一种，包括一个输入层、一个输出层和若干个隐含层。 某一层的神经元只能通过一个方向连接到下一层的神经元。 像上图这种拓扑结构的神经网络又称为多层感知器（MLP，Multi-Layer Perceptron）。 MLP 可以用 Backprop（backward propagation of errors，误差反向传播，BP）算法实现建模。 BP 算法输入层的神经元数量一般为样本的特征属性数量，输出层的神经元的数量一般为样本的所有可能目标值的数量。 对于分类问题，输出层的神经元数量为分类数量。 BP 算法的核心思想是：通过前向通路得到误差，再把误差反向传播，实现权值的修正。 MPL 的误差可以用平方误差函数表示。 设某个样本 x=(x1,x2,...,xn)\\mathbf{x}=(x_1,x_2,...,x_n)x=(x1​,x2​,...,xn​) 对应的目标值为 ttt，有 JJJ 种可能值，t={t1,t2,...,tj}t=\\{t_1,t_2,...,t_j\\}t={t1​,t2​,...,tj​}。 则 MLP 输入层一共有 nnn 个神经元，输出层（第 LLL 层）有 JJJ 个神经元。 设样本 x\\mathbf{x}x 经过前向通路得到的最终输出为 y={y1L,y2L,...,yjL}y=\\{y_1^L,y_2^L,...,y_j^L\\}y={y1L​,y2L​,...,yjL​}。 下标表示神经元的索引，上标表示所在的层 则该样本的平方误差为： E=12∑j=1J(tj−yjL)2E=\\frac{1}{2}\\sum_{j=1}^J(t_j-y_j^L)^2 E=21​j=1∑J​(tj​−yjL​)2 12\\frac{1}{2}21​ 为方便求导系数，不影响误差的变化趋势。 MLP 的目标是使得 EEE 最小。通过改变权值 www，从而使得 EEE 最小。 Backprop算法是一种迭代的方法，渐进地减小 EEE。 梯度下降法 误差 EEE 对权值 www 的导数为 www 的变化率： Δw=−ηdEdw\\Delta w=-\\eta\\frac{dE}{dw} Δw=−ηdwdE​ η∈(0,1)\\eta\\in(0,1)η∈(0,1) 表示学习效率，控制收敛速度和准确性。 η\\etaη 过大，导致震荡，很难收敛； η\\etaη 过小，导致长时间不能收敛。 引入“动量” μ\\muμ，改变因 η\\etaη 的选取不好而带来的问题，上式改写为： Δw(t)=−ηdEdw(t)+μΔw(t−1)\\Delta w(t)=-\\eta\\frac{dE}{dw}(t)+\\mu\\Delta w(t-1) Δw(t)=−ηdwdE​(t)+μΔw(t−1) ttt 表示当前，t−1t-1t−1 表示上一次，t+1t+1t+1 表示下一次。 说明本次的 www 变化率不仅与 EEE 的导数相关，还与上一次 www 的变化率相关。 μ\\muμ 提供了一些惯性，使之平滑权值的随机波动。 由 Δw\\Delta wΔw 更新当前权值 www： w(t+1)=w(t)+Δw(t)w(t+1)=w(t)+\\Delta w(t) w(t+1)=w(t)+Δw(t) 上式表示了更新权值的过程是从输出层到隐含层，向输入层逐层推进的过程，即误差的反向传播。 当所有权值更新完后，再由前向通路计算得到新的误差 EEE，完成一次迭代。 具体计算过程 设 wkhlw_{kh}^lwkhl​ 表示第 lll 层的第 kkk 个神经元与第 l−1l-1l−1 层的第 hhh 和神经元之间连接的权值。第 lll 层的第 kkk 个神经元的输出 ykly_k^lykl​ 为： ykl=f(ukl)=f(∑h=1H(wkhlyhl−1)+bkl)y_k^l=f(u_k^l)=f\\left(\\sum_{h=1}^H(w_{kh}^ly_h^{l-1})+b_k^l\\right) ykl​=f(ukl​)=f(h=1∑H​(wkhl​yhl−1​)+bkl​) uklu_k^lukl​ 表示第 lll 层第 kkk 个神经元的加权和； bklb_k^lbkl​ 表示第 lll 层第 kkk 个神经元的偏置。 若第 lll 层共有 KKK 个神经元，第 l−1l-1l−1 层共有 HHH 个神经元，则第 lll 层的 KKK 个神经元的加权和 ulu^lul 可以用矩阵表示： ul=(u1lu2l⋮uKl)=(w11lw12l⋯w1Hlw21lw22l⋯w2Hl⋮⋮⋱⋮wK1lwK2l⋯wKHl)(y1l−1y2l−1⋮yHl−1)+(b1lb2l⋮bKl)u^l=\\left(\\begin{matrix}u_1^l\\\\u_2^l\\\\\\vdots\\\\u_K^l\\end{matrix}\\right)=\\left(\\begin{matrix}w_{11}^lw_{12}^l\\cdotsw_{1H}^l\\\\w_{21}^lw_{22}^l\\cdotsw_{2H}^l\\\\\\vdots\\vdots\\ddots\\vdots\\\\w_{K1}^lw_{K2}^l\\cdotsw_{KH}^l\\end{matrix}\\right)\\left(\\begin{matrix}y_1^{l-1}\\\\y_2^{l-1}\\\\\\vdots\\\\y_H^{l-1}\\end{matrix}\\right)+\\left(\\begin{matrix}b_1^l\\\\b_2^l\\\\\\vdots\\\\b_K^l\\end{matrix}\\right) ul=⎝⎜⎜⎜⎜⎛​u1l​u2l​⋮uKl​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​w11l​w21l​⋮wK1l​​w12l​w22l​⋮wK2l​​⋯⋯⋱⋯​w1Hl​w2Hl​⋮wKHl​​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎛​y1l−1​y2l−1​⋮yHl−1​​⎠⎟⎟⎟⎟⎞​+⎝⎜⎜⎜⎜⎛​b1l​b2l​⋮bKl​​⎠⎟⎟⎟⎟⎞​ 第 lll 层的所有 KKK 个神经元输出 yly^lyl 为： yl=(y1ly2l⋮yKl)=(f(u1l)f(u2l)⋮f(uKl))=f(ul)y^l=\\left(\\begin{matrix}y_1^l\\\\y_2^l\\\\\\vdots\\\\y_K^l\\end{matrix}\\right)=\\left(\\begin{matrix}f(u_1^l)\\\\f(u_2^l)\\\\\\vdots\\\\f(u_K^l)\\end{matrix}\\right)=f(u^l) yl=⎝⎜⎜⎜⎜⎛​y1l​y2l​⋮yKl​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​f(u1l​)f(u2l​)⋮f(uKl​)​⎠⎟⎟⎟⎟⎞​=f(ul) 把每层的输出 yly^lyl 级联在一起，就构成了 MLP 的前向通路。 当一个样本添加到输入层时，通过层层计算得到最终输出 yLy^LyL，再代入误差计算中得到误差。 前向通路过程为，样本进行权值计算，通过激活输出，最后得到误差： wkhl→ukl→ykl→Ew_{kh}^l\\rightarrow u_k^l\\rightarrow y_k^l\\rightarrow E wkhl​→ukl​→ykl​→E 计算权值变化率，即对误差求导，由链式法则可知，样本 x\\mathbf{x}x 的误差 EEE 对权值 wkhlw_{kh}^lwkhl​ 的偏导数为： ∂E∂wkhl=∂E∂ykl∂ykl∂ukl∂ukl∂wkhl\\frac{\\partial E}{\\partial w_{kh}^l}=\\frac{\\partial E}{\\partial y_k^l}\\frac{\\partial y_k^l}{\\partial u_k^l}\\frac{\\partial u_k^l}{\\partial w_{kh}^l} ∂wkhl​∂E​=∂ykl​∂E​∂ukl​∂ykl​​∂wkhl​∂ukl​​ 定义 δkl\\delta_k^lδkl​ 为上式等号右侧的前两项偏导，δkl=∂E∂ykl∂ykl∂ukl=∂E∂ukl\\delta_k^l=\\frac{\\partial E}{\\partial y_k^l}\\frac{\\partial y_k^l}{\\partial u_k^l}=\\frac{\\partial E}{\\partial u_k^l}δkl​=∂ykl​∂E​∂ukl​∂ykl​​=∂ukl​∂E​ 计算上式等号右侧第三个偏导，有： ∂ukl∂wkhl=∂∂wkhl[∑h=1H(wkhlyhl−1)+bkl]∂ukl∂wkhl=∂∂wkhl(wk1ly1l−1+⋯+wkhlyhl−1+⋯+wkHlyHl−1+bkl)∂ukl∂wkhl=yhl−1\\frac{\\partial u_k^l}{\\partial w_{kh}^l}=\\frac{\\partial}{\\partial w_{kh}^l}\\left[\\sum_{h=1}^H(w_{kh}^ly_h^{l-1})+b_k^l\\right]\\\\ \\frac{\\partial u_k^l}{\\partial w_{kh}^l}=\\frac{\\partial}{\\partial w_{kh}^l}\\left(w_{k1}^ly_1^{l-1}+\\cdots+w_{kh}^ly_h^{l-1}+\\cdots+w_{kH}^ly_H^{l-1}+b_k^l\\right)\\\\ \\frac{\\partial u_k^l}{\\partial w_{kh}^l}=y_h^{l-1} ∂wkhl​∂ukl​​=∂wkhl​∂​[h=1∑H​(wkhl​yhl−1​)+bkl​]∂wkhl​∂ukl​​=∂wkhl​∂​(wk1l​y1l−1​+⋯+wkhl​yhl−1​+⋯+wkHl​yHl−1​+bkl​)∂wkhl​∂ukl​​=yhl−1​ 求导的结果为第 l−1l-1l−1 层的第 hhh 个神经元的输出。如果第 l−1l-1l−1 为输入层，则 yhl−1y_h^{l-1}yhl−1​ 为样本的第 hhh 个属性。 计算上式等号右侧第二个偏导，有： ∂ykl∂ukl=∂f(ukl)∂ukl=f′(ukl)\\frac{\\partial y_k^l}{\\partial u_k^l}=\\frac{\\partial f(u_k^l)}{\\partial u_k^l}=f'(u_k^l) ∂ukl​∂ykl​​=∂ukl​∂f(ukl​)​=f′(ukl​) f(⋅)f(\\cdot)f(⋅) 表示激活函数。 线性函数求导为：df(x)dx=ddxx=1\\frac{df(x)}{dx}=\\frac{d}{dx}x=1dxdf(x)​=dxd​x=1。 Sigmoid 函数求导为：df(x)dx=ddx(11+e−x)=11+e−x(1−11+e−x)=f(x)(1−f(x))\\frac{df(x)}{dx}=\\frac{d}{dx}\\left(\\frac{1}{1+e^{-x}}\\right)=\\frac{1}{1+e^{-x}}\\left(1-\\frac{1}{1+e^{-x}}\\right)=f(x)(1-f(x))dxdf(x)​=dxd​(1+e−x1​)=1+e−x1​(1−1+e−x1​)=f(x)(1−f(x)) 对称 Sigmoid 函数求导为： df(x)dx=ddx(β1−e−αx1+e−αx)=2αβe−αx(1+e−αx)2\\frac{df(x)}{dx}=\\frac{d}{dx}\\left(\\beta\\frac{1-e^{-\\alpha x}}{1+e^{-\\alpha x}}\\right)=2\\alpha\\beta\\frac{e^{-\\alpha x}}{(1+e^{-\\alpha x})^2}dxdf(x)​=dxd​(β1+e−αx1−e−αx​)=2αβ(1+e−αx)2e−αx​ 双曲正切函数求导为：df(x)dx=ddx(ex−e−xex+e−x)=1−f2(x)\\frac{df(x)}{dx}=\\frac{d}{dx}\\left(\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\right)=1-f^2(x)dxdf(x)​=dxd​(ex+e−xex−e−x​)=1−f2(x) 高斯函数求导为： df(x)dx=ddx(βe−α2x2)=−2α2βxe−α2x2\\frac{df(x)}{dx}=\\frac{d}{dx}\\left(\\beta e^{-\\alpha^2x^2}\\right)=-2\\alpha^2\\beta xe^{-\\alpha^2x^2}dxdf(x)​=dxd​(βe−α2x2)=−2α2βxe−α2x2 计算上式等号右侧第一个偏导，当 ykly_k^lykl​ 为输出层的输出时，即 yjLy_j^LyjL​，有： ∂E∂yjL=∂∂yjL[12∑j=1J(tj−yjL)2]∂E∂yjL=∂∂yjL[12(t1−y1L)2+⋯+12(tj−yjL)2+⋯+12(tJ−yJL)2]∂E∂yjL=yjL−tj\\frac{\\partial E}{\\partial y_j^L}=\\frac{\\partial}{\\partial y_j^L}\\left[\\frac{1}{2}\\sum_{j=1}^J(t_j-y_j^L)^2\\right]\\\\ \\frac{\\partial E}{\\partial y_j^L}=\\frac{\\partial}{\\partial y_j^L}\\left[\\frac{1}{2}(t_1-y_1^L)^2+\\cdots+\\frac{1}{2}(t_j-y_j^L)^2+\\cdots+\\frac{1}{2}(t_J-y_J^L)^2\\right]\\\\ \\frac{\\partial E}{\\partial y_j^L}=y_j^L-t_j ∂yjL​∂E​=∂yjL​∂​[21​j=1∑J​(tj​−yjL​)2]∂yjL​∂E​=∂yjL​∂​[21​(t1​−y1L​)2+⋯+21​(tj​−yjL​)2+⋯+21​(tJ​−yJL​)2]∂yjL​∂E​=yjL​−tj​ 所以，基于输出层的权值 yjhLy_{jh}^LyjhL​ 误差导数为： ∂E∂wjhL=(yjL−tj)f′(ujL)yhL−1\\frac{\\partial E}{\\partial w_{jh}^L}=(y_j^L-t_j)f'(u_j^L)y_h^{L-1} ∂wjhL​∂E​=(yjL​−tj​)f′(ujL​)yhL−1​ δjL=(yjL−tj)f′(ujL)\\delta_j^L=(y_j^L-t_j)f'(u_j^L)δjL​=(yjL​−tj​)f′(ujL​) 不知道内部神经元的输出误差，只知道输出层的误差，所以需要把内部神经元误差传递到输出层。 又因为神经元都直接或间接地相互连接，所以内部所有神经元的误差最终都会传递到输出层的所有神经元上。 设 yhly_h^lyhl​ 为中间第 lll 层的第 hhh 个神经元的输出，则： ∂E∂yhl=∂∂yhl[E(u1l+1),⋯ ,E(uKl+1)]\\frac{\\partial E}{\\partial y_h^l}=\\frac{\\partial}{\\partial y_h^l}\\left[E(u_1^{l+1}),\\cdots,E(u_K^{l+1})\\right] ∂yhl​∂E​=∂yhl​∂​[E(u1l+1​),⋯,E(uKl+1​)] E(ukl+1)E(u_k^{l+1})E(ukl+1​) 表示误差 EEE 是关于 ukl+1u_k^{l+1}ukl+1​ 的函数。 上式表明，第 lll 层的第 hhh 个神经元的输出误差传递到第 l+1l+1l+1 层内的所有 KKK 个神经元内，则： ∂E∂yhl=∑k=1K(∂E∂ukl+1∂ukl+1∂yhl)\\frac{\\partial E}{\\partial y_h^l}=\\sum_{k=1}^K\\left(\\frac{\\partial E}{\\partial u_k^{l+1}}\\frac{\\partial u_k^{l+1}}{\\partial y_h^l}\\right) ∂yhl​∂E​=k=1∑K​(∂ukl+1​∂E​∂yhl​∂ukl+1​​) 计算右侧第二个偏导： ∂ukl+1∂yhl=∂∂yhl[∑h=1H(wkhl+1yhl)+bkl+1]∂ukl+1∂yhl=∂∂yhl(wk1l+1y1l+⋯+wkhl+1yhl+⋯+wkHl+1yHl+bkl+1)∂ukl+1∂yhl=wkhl+1\\frac{\\partial u_k^{l+1}}{\\partial y_h^l}=\\frac{\\partial}{\\partial y_h^l}\\left[\\sum_{h=1}^H(w_{kh}^{l+1}y_h^l)+b_k^{l+1}\\right]\\\\ \\frac{\\partial u_k^{l+1}}{\\partial y_h^l}=\\frac{\\partial}{\\partial y_h^l}(w_{k1}^{l+1}y_1^l+\\cdots+w_{kh}^{l+1}y_h^l+\\cdots+w_{kH}^{l+1}y_H^l+b_k^{l+1})\\\\ \\frac{\\partial u_k^{l+1}}{\\partial y_h^l}=w_{kh}^{l+1} ∂yhl​∂ukl+1​​=∂yhl​∂​[h=1∑H​(wkhl+1​yhl​)+bkl+1​]∂yhl​∂ukl+1​​=∂yhl​∂​(wk1l+1​y1l​+⋯+wkhl+1​yhl​+⋯+wkHl+1​yHl​+bkl+1​)∂yhl​∂ukl+1​​=wkhl+1​ 计算右侧第一个偏导： ∂E∂ukl+1=δkl+1\\frac{\\partial E}{\\partial u_k^{l+1}}=\\delta_k^{l+1} ∂ukl+1​∂E​=δkl+1​ 所以，基于中间层的权值 wkhlw_{kh}^lwkhl​ 的误差导数为： ∂Ep∂wkhl=[∑k=1K(wkhl+1δkl+1)]f′(ukl)yhl−1\\frac{\\partial E_p}{\\partial w_{kh}^l}=\\left[\\sum_{k=1}^K(w_{kh}^{l+1}\\delta_k^{l+1})\\right]f'(u_k^l)y_h^{l-1} ∂wkhl​∂Ep​​=[k=1∑K​(wkhl+1​δkl+1​)]f′(ukl​)yhl−1​ 先得到输出层的结果，再计算倒数第二层，以此类推，完整的误差导数： ∂E∂wkhl=δklyhl−1,其中δkl={(ykl−tk)f′(ukl),l为输出层[∑k=1K(wkhl+1δkl+1)]f′(ukl),l为中间层\\frac{\\partial E}{\\partial w_{kh}^l}=\\delta_k^ly_h^{l-1},其中\\delta_k^l=\\begin{cases}(y_k^l-t_k)f'(u_k^l),l为输出层\\\\\\left[\\sum_{k=1}^K(w_{kh}^{l+1}\\delta_k^{l+1})\\right]f'(u_k^l),l为中间层\\end{cases} ∂wkhl​∂E​=δkl​yhl−1​,其中δkl​={(ykl​−tk​)f′(ukl​),[∑k=1K​(wkhl+1​δkl+1​)]f′(ukl​),​l为输出层l为中间层​ 把上式的结果代入计算得到 权值的变化率。再由 w(t+1)=w(t)+Δw(t)w(t+1)=w(t)+\\Delta w(t)w(t+1)=w(t)+Δw(t) 得到更新后的权值。经过新权值计算下一样本，反复进行。 计算的方法： 在线方法：样本一个一个地进入 MLP，每完成一个样本的计算，就更新一次权值。 为了增加鲁棒性，每次迭代之前，可以把全体样本打乱顺序，这样在每次迭代的过程中，提取样本的顺序就会不相同。 批量方法：把所有样本的误差累加在一起，用该累加误差计算误差的导数，进而得到权值的变化率。 初始化权值 一般会随机选择很小的值作为初始权值。 但收敛较慢。 采用 Nguyen-Widrow 算法初始化权值： 每个神经元都有属于自己的一个区间范围，通过初始化权值就可以限制它的区间位置。当改变权值时，也在自己的区间范围内变化。 Nguyen-Widrow 算法初始化 MLP 权值的方法为： 对于所有连接输出层的权值和偏移量，初始值为在 −1-1−1 到 111 之间的随机数； 对于中间层的权值，初始化为（νh u_hνh​ 为 −1-1−1 到 111 之间的随机数，HHH 为第 l−1l-1l−1 层神经元的数量）： wkhl=νh∑h=1H∣νh∣w_{kh}^l=\\frac{ u_h}{\\sum_{h=1}^H\\vert u_h\\vert} wkhl​=∑h=1H​∣νh​∣νh​​ 对于中间层的偏移量，初始化为（νk u_kνk​ 为 −1-1−1 到 111 之间的随机数，KKK 为第 lll 层神经元的数量）： bkl=(2kK−1)νkGb_k^l=\\left(\\frac{2k}{K}-1\\right) u_kG bkl​=(K2k​−1)νk​G G=0.7H1K−1G=0.7H^{\\frac{1}{K-1}} G=0.7HK−11​ RPROP 上述 BP 算法的权值变化基于误差梯度的变化率。 而 RPROP 算法的权值变化基于它的符号： Δw(t)={−Δ(t),∂E∂w(t)0+Δ(t),∂E∂w(t)00,其他\\Delta w(t)=\\begin{cases}-\\Delta(t),\\frac{\\partial E}{\\partial w}(t)0\\\\+\\Delta(t),\\frac{\\partial E}{\\partial w}(t)0\\\\0,其他\\end{cases} Δw(t)=⎩⎪⎪⎨⎪⎪⎧​−Δ(t),+Δ(t),0,​∂w∂E​(t)0∂w∂E​(t)0其他​ 其中， Δ(t)={η+Δ(t−1),∂E∂w(t−1)∂E∂w(t)0η−Δ(t−1),∂E∂w(t−1)∂E∂w(t)0Δ(t−1),其他\\Delta(t)=\\begin{cases}\\eta^+\\Delta(t-1),\\frac{\\partial E}{\\partial w}(t-1)\\frac{\\partial E}{\\partial w}(t)0\\\\\\eta^-\\Delta(t-1),\\frac{\\partial E}{\\partial w}(t-1)\\frac{\\partial E}{\\partial w}(t)0\\\\\\Delta(t-1),其他\\end{cases} Δ(t)=⎩⎪⎪⎨⎪⎪⎧​η+Δ(t−1),η−Δ(t−1),Δ(t−1),​∂w∂E​(t−1)∂w∂E​(t)0∂w∂E​(t−1)∂w∂E​(t)0其他​ 常数 η+\\eta^+η+ 必须大于1； 常数 η−\\eta^-η− 必须在0~1之间。 ∂E/∂w\\partial E/\\partial w∂E/∂w 由下式得到： ∂E∂wkhl=δklyhl−1,其中δkl={(ykl−tk)f′(ukl),l为输出层[∑k=1K(wkhl+1δkl+1)]f′(ukl),l为中间层\\frac{\\partial E}{\\partial w_{kh}^l}=\\delta_k^ly_h^{l-1},其中\\delta_k^l=\\begin{cases}(y_k^l-t_k)f'(u_k^l),l为输出层\\\\\\left[\\sum_{k=1}^K(w_{kh}^{l+1}\\delta_k^{l+1})\\right]f'(u_k^l),l为中间层\\end{cases} ∂wkhl​∂E​=δkl​yhl−1​,其中δkl​={(ykl​−tk​)f′(ukl​),[∑k=1K​(wkhl+1​δkl+1​)]f′(ukl​),​l为输出层l为中间层​ Δ(0)=0.1\\Delta(0)=0.1Δ(0)=0.1 比较好； Δmax(t)=50,Δmin(t)=10−6\\Delta_{max}(t)=50,\\Delta_{min}(t)=10^{-6}Δmax​(t)=50,Δmin​(t)=10−6 可以防止溢出。 OpenCV 提供的 ANN OpenCV 提供的神经网络算法有： enum TrainingMethods{ BACKPROP=0, // BP 算法 RPROP = 1, // RPROP 算法 ANNEAL = 2 // 模拟退火算法}; 通过函数设置： // param1：// - 对于RPROP算法，传递给setRpropDW0；// - 对于BP算法，传递给setBackpropWeightScale；// - 对于模拟退火算法，传递给initialT。// param2：// - 对于RPROP算法，传递给setRpropDWMin；// - 对于BP算法，传递给setBackpropMomentumScale；// - 对于模拟退火算法，传递给finalT。void setTrainMethod(int method, double param1 = 0, double param2 = 0);int getTrainMethod(); OpenCV 提供的激活函数（目前，默认和唯一完全支持的激活函数是对称 Sigmoid）： enum ActivationFunctions{ // 线性函数 IDENTITY = 0, // 对称 Sigmoid 函数 SIGMOID_SYM = 1, // 高斯函数 GAUSSIAN = 2, // ReLU 函数：f(x)=max(0,x) RELU = 3, // Leaky ReLU 函数：当 x0，f(x)=x；当 x=0，f(x)=αx LEAKYRELU= 4}; 通过函数设置： // param1：激活函数的第一个参数，α// param2：激活函数的第二个参数，βvoid setActivationFunction(int type, double param1 = 0, double param2 = 0); 部分参数如下： LayerSizes：指定每层神经元的数量，包括输入和输出层。参数为向量，第一个元素指定了输入层中元素的数量。最后一个元素为输出层中元素的数量。默认值为空。 void setLayerSizes(InputArray _layer_sizes);cv::Mat getLayerSizes() const = 0; BackpropWeightScale：权重梯度项的强度， 推荐值为0.1左右，默认值为0.1。 double getBackpropWeightScale();void setBackpropWeightScale(double val); BackpropMomentumScale：动量项的强度，该参数提供了一些惯量来平滑权重的随机波动。默认值为0.1。 double getBackpropMomentumScale();void setBackpropMomentumScale(double val); propDW0：RPROP 中的 Δ0\\Delta_0Δ0​，默认值为0.1。 double getRpropDW0();void setRpropDW0(double val); RpropDWPlus：RPROP 中的增加因子 η+\\eta^+η+，默认值为1.2。 double getRpropDWPlus();void setRpropDWPlus(double val); RpropDWMinus：RPROP 中的减少因子 η−\\eta^-η−，默认值为0.5。 double getRpropDWMinus();void setRpropDWMinus(double val); RpropDWMin 和 RpropDWMax：RPROP 中的 Δmin(t)\\Delta_{min}(t)Δmin​(t) 和 Δmax(t)\\Delta_{max}(t)Δmax​(t) // Default value is FLT_EPSILON.double getRpropDWMin();void setRpropDWMin(double val);// Default value is 50.double getRpropDWMax();void setRpropDWMax(double val); 模拟退火相关： // 更新初始温度，默认值为 10double getAnnealInitialT(); void setAnnealInitialT(double val);// 更新最终温度，默认值为 0.1double getAnnealFinalT();void setAnnealFinalT(double val);// 更新冷却比，默认值为 0.95double getAnnealCoolingRatio();void setAnnealCoolingRatio(double val);// 每一步更新迭代，默认值为 10int getAnnealItePerStep();void setAnnealItePerStep(int val);// 设置/初始化退火RNGvoid setAnnealEnergyRNG(const RNG rng); TermCriteria：迭代条件。 例子-糖尿病预测（MLP） 数据集在贝叶斯分类器学习记录中使用过，详见贝叶斯分类器。 数据集属性如下： Pregnancies: 怀孕次数 Glucose：血浆葡萄糖浓度 BloodPressure：舒张压 SkinThickness：肱三头肌皮肤褶皱厚度 Insulin：两小时胰岛素含量 BMI：身体质量指数，即体重除以身高的平方 DiabetesPedigreeFunction：糖尿病血统指数，即家族遗传指数 Age：年龄 使用 MLP 进行预测结果与贝叶斯分类器比较如下： Train Data imported: 668Test Data imported: 100正态贝叶斯分类器：计算花费时长：0ms正确率：0.76Train Data imported: 668Test Data imported: 100神经网络（BP）算法(基于OpenCV实现)：计算花费时长：230ms正确率：0.82 代码地址：Gitee - ANN_MLP","tags":[null,null]},{"title":"随机森林","path":"/notebooks/ml/rf.html","content":"森林由若干棵树组成。 随机森林由若干棵决策树组成，每棵决策树之间互不相关。 随机体现在： 通过 随机 抽取得到不同的样本，来构建每棵决策树。 决策树每个节点的最佳分叉属性从由 随机 得到的特征属性集合中选取。 预测时，预测样本作用于所有决策树。 对于分类问题，利用投票方式得到分类。 对于回归问题，取所有决策树结果的平均值。 随机过程 Bootstrap 过程 Bootstrap过程：生成每棵决策树时，使用的参数相同，但使用的训练集不同。 随机得到的子集称为 bootstrap 集合。 在 Bootstrap 集合的基础上聚集得到学习模型的过程称为 Bagging（Bootstrap aggregating）。 不在 Bootstrap 集合中的样本称为 OOB（Out Of Bag）。 Bootstrap 过程：从全部 NNN 个样本中，有放回的随机抽取 SSS 次（OpenCV中，S=NS=NS=N），其中存在 OOB。计算 OOB 样本所占比率： 每个样本被抽取的概率为 1/N1/N1/N，未被抽取的概率为 1−1/N1-1/N1−1/N，SSS 次仍未被抽到的概率为 (1−1/n)S(1-1/n)^S(1−1/n)S，lim⁡N=S→∞(1−1N)S=e−1\\lim_{N=S\\rightarrow \\infty}(1-\\frac{1}{N})^S=e^{-1}limN=S→∞​(1−N1​)S=e−1。 随机森林中每棵决策树的 bootstrap 集合是不完全相同的，每棵决策树的 OOB 集合也不完全相同。 即每棵生成决策树之前，进行 Bootstrap 过程。 保证 bootstrap 集合不同，保证了每棵决策树不相关以及不相同。 随机特征属性过程 随机森林的决策树的最佳分叉属性是在一个特征属性随机子集内计算得到。 全部的 ppp 个特征属性中，随机选择 qqq 个特征属性。 对于分类问题，qqq 可以为 ppp 的平方根。 对于回归问题，qqq 可以为 ppp 的三分之一。 随机子集内特征属性的数量 qqq 是固定的，但不同决策树之间这 qqq 个特征属性不同。 由于 qqq 远小于 ppp，构建决策树时无需剪枝。 OOB误差 评估机器学习算法的预测误差的常用方法时交叉验证法，但 Bagging 方法不需要交叉验证。 OOB 误差可以代替 bootstrap 集合误差，结果近似于交叉验证。 OOB 误差是利用那 e−1e^{-1}e−1 的 OOB 样本来评估预测误差。 OOB 误差计算是在训练过程同步得到。每得到一棵决策树，就可以根据该决策树来调整前面决策树得到的 OOB 误差。 对于分类问题， OOB 误差计算： 构建生成决策树 Tk,k=1,2,...,KT_k,k=1,2,...,KTk​,k=1,2,...,K。 用 TkT_kTk​ 预测 TkT_kTk​ 的 OOB 样本的分类结果。 更新所有训练样本的 OOB 预测分类结果次数（如果样本 x\\mathbf{x}x 是 T1T_1T1​ 的 OOB 样本，则它有一个预测结果，而它是 T2T_2T2​ 的 bootstrap 集合内的样本，则此时它没有预测结果）。 对所有样本，把每个样本的预测次数最多的分类作为该样本在 TkT_kTk​ 时的预测结果。 统计所有训练样本中预测错误的数量。 该数量除以 TkT_kTk​ 的 OOB 样本的数量作为 TkT_kTk​ 的 OOB 误差。 对于回归问题， OOB 误差计算： 构建生成决策树 Tk,k=1,2,...,KT_k,k=1,2,...,KTk​,k=1,2,...,K。 用 TkT_kTk​ 预测 TkT_kTk​ 的 OOB 样本的回归值。 累加所有训练样本中的 OOB 样本的预测值。 对所有样本，计算 TkT_kTk​ 时每个样本的平均预测值（预测累加值除以被预测的次数）。 累加每个训练样本平均预测值与真实响应值之差的平方。 该平方累加和除以 TkT_kTk​ 的 OOB 样本的数量作为 TkT_kTk​ 的 OOB 误差。 OOB 误差会逐渐缩小，设置精度 ε\\varepsilonε，当误差小于 ε\\varepsilonε 时，提前终止迭代。 计算特征属性的重要性 特征属性的重要性：样本哪个特征属性对预测起决定作用。 Gini 法和置换法常用于计算特征属性的重要性。 Gini 法依据不纯度减小的原则。 置换法依据原则为：样本某个特征属性越重要，那么改变该特征属性值，则样本预测值就越容易出错。 通过置换两个样本的相同特征属性的值来改变特征属性。 具体方法： 在决策树 TkT_kTk​ 的 OOB 集合中随机选择两个样本 xi=(xi,1,xi,2,…,xi,p)\\mathbf{x}_i=(x_{i,1},x_{i,2},\\ldots,x_{i,p})xi​=(xi,1​,xi,2​,…,xi,p​) 和 xj=(xj,1,xj,2,…,xj,p)\\mathbf{x}_j=(x_{j,1},x_{j,2},\\ldots,x_{j,p})xj​=(xj,1​,xj,2​,…,xj,p​)，这两个样本响应值分别为 yiy_iyi​ 和 yjy_jyj​，用 TkT_kTk​ 的预测值分别为 y^i(k)\\hat{y}_i^{(k)}y^​i(k)​ 和 y^j(k)\\hat{y}_j^{(k)}y^​j(k)​。 设该 OOB 集合有 mkm_kmk​ 个样本。衡量第 qqq 个特征属性的重要性，置换 xi\\mathbf{x}_ixi​ 和 xj\\mathbf{x}_jxj​ 中的 xi,qx_{i,q}xi,q​ 和 xj,qx_{j,q}xj,q​，置换后为：xi,jq=(xi,1,…,xj,q,…,xi,p)\\mathbf{x}_{i,jq}=(x_{i,1},\\ldots,x_{j,q},\\ldots,x_{i,p})xi,jq​=(xi,1​,…,xj,q​,…,xi,p​) 和 xj,iq=(xj,1,…,xi,q,…,xj,p)\\mathbf{x}_{j,iq}=(x_{j,1},\\ldots,x_{i,q},\\ldots,x_{j,p})xj,iq​=(xj,1​,…,xi,q​,…,xj,p​) 根据这个方法，对 OOB 集合共置换 mkm_kmk​ 次，最终置换结果为：xi,mq=(xi,1,…,xmi,q,…,xi,p)\\mathbf{x}_{i,mq}=(x_{i,1},\\ldots,x_{mi,q},\\ldots,x_{i,p})xi,mq​=(xi,1​,…,xmi,q​,…,xi,p​)。 使用 TkT_kTk​ 对 xi,mq\\mathbf{x}_{i,mq}xi,mq​ 的预测值为 y^i,mq(k)\\hat{y}_{i,mq}^{(k)}y^​i,mq(k)​。 对于分类问题： 如果 y^i,mq(k)=yi\\hat{y}_{i,mq}^{(k)}=y_iy^​i,mq(k)​=yi​，说明改变第 qqq 个特征属性的值，并不改变最终的响应值。 如果 y^i,mq(k)≠yi\\hat{y}_{i,mq}^{(k)} eq y_iy^​i,mq(k)​​=yi​，说明第 qqq 个特征属性很重要。 重要程度量化为： VIq(k)=∑i∈mkI(yi=y^i(k))−∑i∈mkI(yi=y^i,mq(k))mk\\mathbf{VI}_q^{(k)}=\\frac{\\sum_{i\\in m_k}I(y_i=\\hat{y}_i^{(k)})-\\sum_{i\\in m_k}I(y_i=\\hat{y}_{i,mq}^{(k)})}{m_k} VIq(k)​=mk​∑i∈mk​​I(yi​=y^​i(k)​)−∑i∈mk​​I(yi​=y^​i,mq(k)​)​ 分子第一项表示对 OOB 中，预测正确的样本数量。 分子第二项表示置换后正确的样本数量。 对于回归问题，重要程度量化为： VIq(k)=∑i∈mke−(yi−y^i(k)A)2−∑i∈mke−(yi−y^i,mq(k)A)2mk\\mathbf{VI}_q^{(k)}=\\frac{\\sum_{i\\in m_k}e^{-\\left(\\frac{y_i-\\hat{y}_i^{(k)}}{A}\\right)^2}-\\sum_{i\\in m_k}e^{-\\left(\\frac{y_i-\\hat{y}_{i,mq}^{(k)}}{A}\\right)^2}}{m_k} VIq(k)​=mk​∑i∈mk​​e−(Ayi​−y^​i(k)​​)2−∑i∈mk​​e−(Ayi​−y^​i,mq(k)​​)2​ 其中， A=max⁡i∈N∣yi∣A=\\max_{i\\in N}\\vert y_i\\vert A=i∈Nmax​∣yi​∣ 如果第 qqq 个特征属性不属于 TkT_kTk​，则 VIq(k)=0\\mathbf{VI}_q^{(k)}=0VIq(k)​=0。 对随机森林的所有决策树都计算第 qqq 个特征属性的重要性，取平均得到整个随机森林对第 qqq 个特征属性的重要程度量化为： VIq=∑i=1KVIq(i)K\\mathbf{VI}_q=\\frac{\\sum_{i=1}^K\\mathbf{VI}_q^{(i)}}{K} VIq​=K∑i=1K​VIq(i)​​ 归一化处理： VIq(1)=VIq∑i=1pVIi\\mathbf{VI}_{q^{(1)}}=\\frac{\\mathbf{VI}_q}{\\sum_{i=1}^p\\mathbf{VI}_i} VIq(1)​=∑i=1p​VIi​VIq​​ OpenCV 提供的随机森林 OpenCV 提供了一个 继承自 DTree 的 RTree 类，可用于设计随机森林。 DTree 指决策树。 部分参数如下： CalculateVarImportance：表示是否计算特征属性的重要程度。函数接口： bool getCalculateVarImportance();void setCalculateVarImportance(bool val); // 默认值为false// 可以通过RTrees::getVarImportance检索。 ActiveVarCount：在每棵树结点处随机选择的特征子集的大小，以及所使用的找到最佳分割点。如果将其设置为0，则大小将设置为特征总数的平方根。函数接口： int getActiveVarCount() ;void setActiveVarCount(int val); // 默认值为0 TermCriteria：迭代终止条件。 还有些参数通过 DTree 的函数设置。 例子-单词难度预测(RTrees) 该数据集在决策树中也使用过，故不多介绍。 数据集属性有： Word：单词 Length：长度 Freq_HAL：频率_HAL Log_Freq_HAL：对数频率HAL I_Mean_RT I_Zscore：确定单词的难度。对于一个单词，此值在0和1之间波动，其中0为简单，1为困难 I_SD Obs I_Mean_Accuracy：准确性，为响应值 使用决策树和随机森林的效果如下： Train Data imported: 30457Test Data imported: 9992决策树算法(基于OpenCV实现)：计算花费时长：186ms平均误差：0.0239817Train Data imported: 30457Test Data imported: 9992随机森林算法(基于OpenCV实现)：计算花费时长：17378ms平均误差：0.0212776 代码地址：Gitee - Random Trees","tags":[null,null]},{"title":"支持向量机","path":"/notebooks/ml/svm.html","content":"SVM（Support Vector Machine）：支持向量机 SVC（Support Vector Classifier）：支持向量分类器 SVR（Support Vector Regression）：支持向量回归器 支持向量机基本型 给定大小为 mmm 的训练集 D={(x1,y1),(x2,y2),…,(xm,ym)},yi∈{−1,1}D=\\{(\\mathbf{x}_1, y_1), (\\mathbf{x}_2, y_2), \\ldots, (\\mathbf{x}_m, y_m)\\},y_i\\in\\{-1, 1\\}D={(x1​,y1​),(x2​,y2​),…,(xm​,ym​)},yi​∈{−1,1}。基于训练集 DDD 在样本空间中找到一个超平面，将不同类别的样本分开，如下图： 明显红色的划分超平面更合适。划分超平面可通过线性方程描述： wTx+b=0w^T\\mathbf{x}+b=0 wTx+b=0 w=(w1,w2,…,wn)w=(w_1, w_2, \\ldots, w_n)w=(w1​,w2​,…,wn​)：为法向量，决定了超平面的方向； bbb：位移项。 x=(x1,x2,…,xn)\\mathbf{x}=(\\mathbf{x}_1, \\mathbf{x}_2, \\ldots,\\mathbf{x}_n)x=(x1​,x2​,…,xn​) 样本空间中任意点到超平面 (w,b)(w,b)(w,b) 的距离为： r=∣wTx+b∣∣∣w∣∣r=\\frac{\\vert w^T\\mathbf{x}+b\\vert}{\\vert\\vert w\\vert\\vert} r=∣∣w∣∣∣wTx+b∣​ 在做分类时，应有 (xi,yi)∈D(\\mathbf{x}_i, y_i)\\in D(xi​,yi​)∈D，当 yi=+1y_i=+1yi​=+1 时，wTxi+b0w^T\\mathbf{x}_i+b0wTxi​+b0；当 yi=−1y_i=-1yi​=−1 时，wTxi+b0w^T\\mathbf{x}_i+b0wTxi​+b0。令： {wTxi+b≥+1,yi=+1wTxi+b≤−1,yi=−1\\begin{cases} w^T\\mathbf{x}_i+b\\geq+1, y_i=+1\\\\ w^T\\mathbf{x}_i+b\\leq-1, y_i=-1 \\end{cases} {wTxi​+b≥+1,yi​=+1wTxi​+b≤−1,yi​=−1​ 距离超平面最近的几个训练样本点满足上式，如下图 H1H_1H1​、H2H_2H2​ 上的样本被称为支持向量（support vector）。 两个异类的支持向量到超平面的距离之和（也称为间隔）为： γ=∣(b+1)−(b−1)∣∣∣w∣∣=2∣∣w∣∣\\gamma=\\frac{\\vert(b+1)-(b-1)\\vert}{\\vert\\vert w\\vert\\vert}=\\frac{2}{\\vert\\vert w\\vert\\vert} γ=∣∣w∣∣∣(b+1)−(b−1)∣​=∣∣w∣∣2​ 为了找到具有最大间隔的划分超平面，需要满足下式中约束参数 www 和b，使得 γ\\gammaγ 最大： max⁡w,b2∣∣w∣∣同时保证yi(wTxi+b)≥1,i=1,2,…,m.\\max_{w,b}\\frac{2}{\\vert\\vert w\\vert\\vert}\\\\ 同时保证\\ y_i(w^T\\mathbf{x}_i+b)\\geq 1,i=1,2,\\ldots,m. w,bmax​∣∣w∣∣2​同时保证yi​(wTxi​+b)≥1,i=1,2,…,m. 为了最大化间隔，需要最大化 ∣∣w∣∣−1\\vert\\vert w\\vert\\vert^{-1}∣∣w∣∣−1，等价于最小化 ∣∣w∣∣2\\vert\\vert w\\vert\\vert^2∣∣w∣∣2 min⁡w,b12∣∣w∣∣2同时保证yi(wTxi+b)≥1,i=1,2,…,m.\\min_{w,b}\\frac{1}{2}\\vert\\vert w\\vert\\vert^2\\\\ 同时保证\\ y_i(w^T\\mathbf{x}_i+b)\\geq 1,i=1,2,\\ldots,m. w,bmin​21​∣∣w∣∣2同时保证yi​(wTxi​+b)≥1,i=1,2,…,m. 对上式使用拉格朗日乘子法可得到它的对偶问题。 拉格朗日乘⼦法是⼀种寻找多元函数在⼀组约束下的极值的方法。 通过引⼊拉格朗日乘子，可将有 ddd 个变量与 kkk 个约束条件的最优化问题转化为具有 d+kd+kd+k 个变量的⽆约束优化问题求解。 对上式每条约束添加拉格朗日乘子 αi≥0\\alpha_i\\geq 0αi​≥0 对偶问题是原始问题的一种变换形式，它在数学上与原始问题密切相关，但可能具有不同的结构和性质。 L(w,b,α)=12∣∣w∣∣2+∑i=1mαi(1−yi(wTxi+b))L(w,b,\\mathcal{\\alpha})=\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+\\sum_{i=1}^m\\alpha_i(1-y_i(w^T\\mathbf{x}_i+b)) L(w,b,α)=21​∣∣w∣∣2+i=1∑m​αi​(1−yi​(wTxi​+b)) 其中 α=(α1,α2,…,αm)\\mathcal{\\alpha}=(\\alpha_1, \\alpha_2, \\ldots, \\alpha_m)α=(α1​,α2​,…,αm​) 令 L(w,b,α)L(w,b,\\mathcal{\\alpha})L(w,b,α) 对 www 和 bbb 的偏导为零，可得 ∂L(w,b,α)∂w=w−∑i=1mαiyixi=0⇒w=∑i=1mαiyixi\\frac{\\partial L(w,b,\\mathcal{\\alpha})}{\\partial w}=w-\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i=0\\Rightarrow w=\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i ∂w∂L(w,b,α)​=w−i=1∑m​αi​yi​xi​=0⇒w=i=1∑m​αi​yi​xi​ ∂L(w,b,α)∂b=−∑i=1mαiyi=0⇒0=∑i=1mαiyi\\frac{\\partial L(w,b,\\mathcal{\\alpha})}{\\partial b}=-\\sum_{i=1}^m\\alpha_iy_i=0\\Rightarrow 0=\\sum_{i=1}^m\\alpha_iy_i ∂b∂L(w,b,α)​=−i=1∑m​αi​yi​=0⇒0=i=1∑m​αi​yi​ 将 w=∑i=1mαiyixiw=\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_iw=∑i=1m​αi​yi​xi​ 代入 L(w,b,α)L(w,b,\\mathcal{\\alpha})L(w,b,α)，将 www 和 bbb 消去，再结合 0=∑i=1mαiyi0=\\sum_{i=1}^m\\alpha_iy_i0=∑i=1m​αi​yi​，得到 min⁡w,b12∣∣w∣∣2\\min_{w,b}\\frac{1}{2}\\vert\\vert w\\vert\\vert^2minw,b​21​∣∣w∣∣2 的对偶问题： max⁡α∑i=1mαi−12∑i=1m∑j=1mαiαjyiyjxiTxj(1)\\max_{\\mathcal{\\alpha}}\\sum_{i=1}^m\\alpha_i-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_j\\mathbf{x}_i^T\\mathbf{x}_j\\tag{1} αmax​i=1∑m​αi​−21​i=1∑m​j=1∑m​αi​αj​yi​yj​xiT​xj​(1) 同时保证∑i=1mαiyi=0,αi≥0,i=1,2,…,m.同时保证\\ \\sum_{i=1}^m\\alpha_iy_i=0,\\\\ \\alpha_i\\geq0,i=1,2,\\ldots,m. 同时保证i=1∑m​αi​yi​=0,αi​≥0,i=1,2,…,m. 求解出 α\\mathcal{\\alpha}α 后： f(x)=wTx+b=∑i=1mαiyixiTx+b(2)f(\\mathbf{x})=w^T\\mathbf{x}+b=\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i^T\\mathbf{x}+b\\tag{2} f(x)=wTx+b=i=1∑m​αi​yi​xiT​x+b(2) 上述过程需满足 KKT 条件，即： {αi≥0yif(x)−1≥0αi(yif(x)−1)=0\\begin{cases} \\alpha_i\\geq 0\\\\ y_if(\\mathbf{x})-1\\geq 0\\\\ \\alpha_i(y_if(\\mathbf{x})-1)=0 \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​αi​≥0yi​f(x)−1≥0αi​(yi​f(x)−1)=0​ 对任意训练样本 (xi,yi)(\\mathbf{x}_i,y_i)(xi​,yi​)，总有 αi=0\\alpha_i=0αi​=0 或 yif(xi)=1y_if(\\mathbf{x}_i)=1yi​f(xi​)=1。 若 αi=0\\alpha_i=0αi​=0，该样本不会出现在式 1 的求和中，也不会对 f(xi)f(\\mathbf{x}_i)f(xi​) 产生影响。 若 αi0\\alpha_i0αi​0，则必有 yif(xi)=1y_if(\\mathbf{x}_i)=1yi​f(xi​)=1，对应的样本点位于最大间隔边界上，即支持向量。 训练完后，大部分训练样本也不需要保留，最终模型仅与支持向量有关。 SMO 对于式 1 的求解，可以使用二次规划算法求解，也可以通过 SMO（Sequential Minimal Optimization） 算法求解。 SMO 的基本思路： 固定 αi\\alpha_iαi​ 之外的所有参数，求 αi\\alpha_iαi​ 上的极值。 每次选择两个变量 αi\\alpha_iαi​ 和 αj\\alpha_jαj​，同时固定其他参数，在参数初始化后，不断执行以下步骤直至收敛： 选取一对需更新的变量 αi\\alpha_iαi​ 和 αj\\alpha_jαj​； 固定 αi\\alpha_iαi​ 和 αj\\alpha_jαj​ 以外的参数，求解式 1 获得更新后的 αi\\alpha_iαi​ 和 αj\\alpha_jαj​ 。 SMO 使选取的两变量所对应样本之间的间隔最大。 使得两个变量有很大区别，给目标函数值更大的变化。 核函数 上述讨论训练样本是线性可分的（即存在划分超平面能正确分类），如果原始样本空间内不能存在这样的划分超平面，那么需要 将样本从原始空间映射到更高维的空间，使其在这个特征空间内线性可分。 令 ϕ(x)\\phi(\\mathbf{x})ϕ(x) 表示将 x\\mathbf{x}x 映射后的特征向量，则在特征空间中划分超平面所对应的模型表示为： f(x)=wTϕ(x)+bf(\\mathbf{x})=w^T\\phi(\\mathbf{x})+b f(x)=wTϕ(x)+b 其中 www 和 bbb 为模型参数，有： min⁡w,b12∣∣w∣∣2同时保证yi(wTϕ(xi)+b)≥1,i=1,2,…,m\\min_{w,b}\\frac{1}{2}\\vert\\vert w\\vert\\vert^2\\\\ 同时保证\\ y_i(w^T\\phi(\\mathbf{x}_i)+b)\\geq 1,\\ i=1,2,\\ldots,m w,bmin​21​∣∣w∣∣2同时保证yi​(wTϕ(xi​)+b)≥1,i=1,2,…,m 其对偶问题是： max⁡α∑i=1mαi−12∑i=1m∑j=1mαiαjyiyjϕ(xi)Tϕ(xj)同时保证∑i=1mαiyi=0,αi≥0,i=1,2,…,m\\max_\\alpha\\sum_{i=1}^m\\alpha_i-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_j\\phi(\\mathbf{x}_i)^T\\phi(\\mathbf{x}_j)\\\\ 同时保证\\ \\sum_{i=1}^m\\alpha_iy_i=0,\\alpha_i\\geq 0,i=1,2,\\ldots,m αmax​i=1∑m​αi​−21​i=1∑m​j=1∑m​αi​αj​yi​yj​ϕ(xi​)Tϕ(xj​)同时保证i=1∑m​αi​yi​=0,αi​≥0,i=1,2,…,m 设计核函数： κ(xi,xj)=ϕ(xi),ϕ(xj)=ϕ(xi)Tϕ(xj)\\kappa(\\mathbf{x}_i, \\mathbf{x}_j)=\\phi(\\mathbf{x}_i),\\phi(\\mathbf{x}_j)=\\phi(\\mathbf{x}_i)^T\\phi(\\mathbf{x}_j) κ(xi​,xj​)=ϕ(xi​),ϕ(xj​)=ϕ(xi​)Tϕ(xj​) 即 xi\\mathbf{x}_ixi​ 与 xj\\mathbf{x}_jxj​ 在特征空间的内积等于它们在原始样本空间通过函数 κ(⋅,⋅)\\kappa(\\cdot,\\cdot)κ(⋅,⋅) 计算的结果。 所以之前的式子改写为： max⁡α∑i=1mαi−12∑i=1m∑j=1mαiαjyiyjκ(xi,xj)同时保证∑i=1mαiyi=0,αi≥0,i=1,2,…,m\\max_\\alpha\\sum_{i=1}^m\\alpha_i-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_j\\kappa(\\mathbf{x}_i,\\mathbf{x}_j)\\\\ 同时保证\\ \\sum_{i=1}^m\\alpha_iy_i=0,\\alpha_i\\geq 0,i=1,2,\\ldots,m αmax​i=1∑m​αi​−21​i=1∑m​j=1∑m​αi​αj​yi​yj​κ(xi​,xj​)同时保证i=1∑m​αi​yi​=0,αi​≥0,i=1,2,…,m 求解后可得到： f(x)=wTϕ(x)+b=∑i=1mαiyiϕ(xi)Tϕ(x)+b=∑i=1mαiyiκ(xi,x)+bf(\\mathbf{x})=w^T\\phi(\\mathbf{x})+b\\\\ =\\sum_{i=1}^m\\alpha_iy_i\\phi(\\mathbf{x}_i)^T\\phi(\\mathbf{x})+b\\\\ =\\sum_{i=1}^m\\alpha_iy_i\\kappa(\\mathbf{x}_i,\\mathbf{x})+b f(x)=wTϕ(x)+b=i=1∑m​αi​yi​ϕ(xi​)Tϕ(x)+b=i=1∑m​αi​yi​κ(xi​,x)+b 上式说明模型最优解可通过训练样本的核函数展开，展式称为支持向量展式。 定理：令 χ\\chiχ 为输入空间，κ(⋅,⋅)\\kappa(\\cdot,\\cdot)κ(⋅,⋅) 式定义在 χ×χ\\chi\\times\\chiχ×χ 上的对称函数，则 κ\\kappaκ 式核函数 当且仅当 对于任意数据 D={x1,x2,…,xm}D=\\{\\mathbf{x}_1,\\mathbf{x}_2,\\ldots,\\mathbf{x}_m\\}D={x1​,x2​,…,xm​}，核矩阵 KKK 总是半正定的： K=[κ(x1,x1)⋯κ(x1,xj)⋯κ(x1,xm)⋮⋱⋮⋱⋮κ(xi,x1)⋯κ(xi,xj)⋯κ(xi,xm)⋮⋱⋮⋱⋮κ(xm,x1)⋯κ(xm,xj)⋯κ(xm,xm)]K=\\left[\\begin{matrix} \\kappa(\\mathbf{x}_1,\\mathbf{x}_1) \\cdots \\kappa(\\mathbf{x}_1,\\mathbf{x}_j) \\cdots \\kappa(\\mathbf{x}_1,\\mathbf{x}_m)\\\\ \\vdots \\ddots \\vdots \\ddots \\vdots\\\\ \\kappa(\\mathbf{x}_i,\\mathbf{x}_1) \\cdots \\kappa(\\mathbf{x}_i,\\mathbf{x}_j) \\cdots \\kappa(\\mathbf{x}_i,\\mathbf{x}_m)\\\\ \\vdots \\ddots \\vdots \\ddots \\vdots\\\\ \\kappa(\\mathbf{x}_m,\\mathbf{x}_1) \\cdots \\kappa(\\mathbf{x}_m,\\mathbf{x}_j) \\cdots \\kappa(\\mathbf{x}_m,\\mathbf{x}_m) \\end{matrix}\\right] K=⎣⎢⎢⎢⎢⎢⎢⎢⎡​κ(x1​,x1​)⋮κ(xi​,x1​)⋮κ(xm​,x1​)​⋯⋱⋯⋱⋯​κ(x1​,xj​)⋮κ(xi​,xj​)⋮κ(xm​,xj​)​⋯⋱⋯⋱⋯​κ(x1​,xm​)⋮κ(xi​,xm​)⋮κ(xm​,xm​)​⎦⎥⎥⎥⎥⎥⎥⎥⎤​ 对于一个半正定和矩阵，总能找到一个与之对应的映射 ϕ\\phiϕ。任何一个核函数都隐式定义了一个称为“再生核希尔伯特空间”（简称RKHS）的特征空间。 常用核函数如下： 线性核：κ(xi,xj)=xiTxj\\kappa(\\mathbf{x}_i,\\mathbf{x}_j)=\\mathbf{x}_i^T\\mathbf{x}_jκ(xi​,xj​)=xiT​xj​； 多项式核：κ(xi,xj)=(xiTxj)d\\kappa(\\mathbf{x}_i,\\mathbf{x}_j)=(\\mathbf{x}_i^T\\mathbf{x}_j)^dκ(xi​,xj​)=(xiT​xj​)d，d≥1d\\geq 1d≥1 为多项式的次数； 高斯核：κ(xi,xj)=exp⁡(−∣∣xi−xj∣∣22σ2)\\kappa(\\mathbf{x}_i,\\mathbf{x}_j)=\\exp(-\\frac{\\vert\\vert\\mathbf{x}_i-\\mathbf{x}_j\\vert\\vert^2}{2\\sigma^2})κ(xi​,xj​)=exp(−2σ2∣∣xi​−xj​∣∣2​)，σ0\\sigma0σ0 为高斯核的带宽； 拉普拉斯核：κ(xi,xj)=exp⁡(−∣∣xi−xj∣∣2σ2)\\kappa(\\mathbf{x}_i,\\mathbf{x}_j)=\\exp(-\\frac{\\vert\\vert\\mathbf{x}_i-\\mathbf{x}_j\\vert\\vert^2}{\\sigma^2})κ(xi​,xj​)=exp(−σ2∣∣xi​−xj​∣∣2​)，σ0\\sigma0σ0； Sigmoid核：κ(xi,xj)=tanh⁡(βxiTxj+θ)\\kappa(\\mathbf{x}_i,\\mathbf{x}_j)=\\tanh(\\beta\\mathbf{x}_i^T\\mathbf{x}_j+\\theta)κ(xi​,xj​)=tanh(βxiT​xj​+θ)，tanh⁡\\tanhtanh 为双曲正切函数，β0,θ0\\beta0,\\theta0β0,θ0。 此外，核函数还可通过组合得到： 若 κ1\\kappa_1κ1​ 和 κ2\\kappa_2κ2​ 为核函数，则对于任意正数 γ1、γ2\\gamma_1、\\gamma_2γ1​、γ2​，其线性组合 γ1κ1+γ2κ2\\gamma_1\\kappa_1+\\gamma_2\\kappa_2γ1​κ1​+γ2​κ2​ 也是核函数。 若 κ1\\kappa_1κ1​ 和 κ2\\kappa_2κ2​ 为核函数，则核函数的直积 κ1⊗κ2(xi,z)=κ1(xi,z)κ2(xi,z)\\kappa_1\\otimes\\kappa_2(\\mathbf{x}_i,\\mathbf{z})=\\kappa_1(\\mathbf{x}_i,\\mathbf{z})\\kappa_2(\\mathbf{x}_i,\\mathbf{z})κ1​⊗κ2​(xi​,z)=κ1​(xi​,z)κ2​(xi​,z) 也是核函数。 若 κ1\\kappa_1κ1​ 为核函数，则对于任意函数 g(x)g(x)g(x)，κ(x,z)=g(x)κ1(x,z)g(z)\\kappa(\\mathbf{x},\\mathbf{z})=g(\\mathbf{x})\\kappa_1(\\mathbf{x},\\mathbf{z})g(\\mathbf{z})κ(x,z)=g(x)κ1​(x,z)g(z) 也是核函数。 C-SVC算法 C-SVC算法：受参数 CCC 的制约。 参数 CCC 是最小的训练误差和最大的分类间隔的折中。 常用交叉验证法选取 CCC。 给定大小为 mmm 的训练集 DDD，其中每个样本具有 nnn 个属性，对应一个标签 yi∈{+1,−1}y_i\\in\\{+1,-1\\}yi​∈{+1,−1} 表示其分类。 +1+1+1 表示正例 −1-1−1 表示负例 超平面方程表示为： wTx+b=0w^T\\mathbf{x}+b=0 wTx+b=0 对每一个样本 xi\\mathbf{x}_ixi​，引入一个松弛变量 ξ≥0\\xi\\geq 0ξ≥0，作为错误分类误差的度量，可以被认为是在分类错误的情况下样本与属于它的间隔边界超平面的距离。 如果分类正确，该变量为0。 ξi={0,如果yi(wTxi+b)≥+11−yi(wTxi+b),如果yi(wTxi+b)≤+1\\xi_i=\\begin{cases}0,如果\\ y_i(w^T\\mathbf{x}_i+b)\\geq +1\\\\ 1-y_i(w^T\\mathbf{x}_i+b),如果\\ y_i(w^T\\mathbf{x}_i+b)\\leq +1 \\end{cases} ξi​={0,1−yi​(wTxi​+b),​如果yi​(wTxi​+b)≥+1如果yi​(wTxi​+b)≤+1​ 由上式得到原公式下实现软间隔最大化的约束条件： yi(wTxi+b)≥1−ξi,ξi≥0,i=1,2,…,my_i(w^T\\mathbf{x}_i+b)\\geq 1-\\xi_i,\\ \\xi_i\\geq 0,\\ i=1,2,\\ldots,m yi​(wTxi​+b)≥1−ξi​,ξi​≥0,i=1,2,…,m 如下图 H1H_1H1​ 和 H2H_2H2​ 之间的间隔称为软间隔： 在软间隔最大化中，被软间隔分隔错误的样本应该受到惩罚，且随着 ξi\\xi_iξi​ 增大而增加。还要尽可能减少错误分隔的样本数。软间隔最大化原公式如下： min⁡12∣∣w∣∣2+C∑i=1mξi同时保证yi(wTxi+b)≥1−ξi,ξi≥0,i=1,2,…,m\\min\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+C\\sum_{i=1}^m\\xi_i\\\\ 同时保证\\ y_i(w^T\\mathbf{x}_i+b)\\geq 1-\\xi_i,\\ \\xi_i\\geq 0,i=1,2,\\ldots,m min21​∣∣w∣∣2+Ci=1∑m​ξi​同时保证yi​(wTxi​+b)≥1−ξi​,ξi​≥0,i=1,2,…,m CCC 为非负的惩罚参数，用于对分类错误样本的一定程度上的惩罚。 CCC 大，相当于错误惩罚力度大。达到一定程度从而没有错误分类的样本，软间隔最大化等价于硬间隔最大化。 CCC 小，相当于错误惩罚力度小。可能有更多样本被软间隔分类错误。 ∑i=1mξi\\sum_{i=1}^m\\xi_i∑i=1m​ξi​ 为分类错误的总量。 对其进行构造拉格朗日方程： L(w,b,α,ξ,μ)=12∣∣w∣∣2+∑i=1mαi(1−yi(wTxi+b))+∑i=1m(C−αi−μi)ξiL(w,b,\\mathcal{\\alpha},\\xi,\\mu)=\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+\\sum_{i=1}^m\\alpha_i(1-y_i(w^T\\mathbf{x}_i+b))+\\sum_{i=1}^m(C-\\alpha_i-\\mu_i)\\xi_i L(w,b,α,ξ,μ)=21​∣∣w∣∣2+i=1∑m​αi​(1−yi​(wTxi​+b))+i=1∑m​(C−αi​−μi​)ξi​ 也求偏导得到 ∂L(w,b,α,ξ,μ)∂w=w−∑i=1mαiyixi=0⇒w=∑i=1mαiyixi\\frac{\\partial L(w,b,\\mathcal{\\alpha},\\xi,\\mu)}{\\partial w}=w-\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i=0\\Rightarrow w=\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i ∂w∂L(w,b,α,ξ,μ)​=w−i=1∑m​αi​yi​xi​=0⇒w=i=1∑m​αi​yi​xi​ ∂L(w,b,α,ξ,μ)∂b=−∑i=1mαiyi=0⇒0=∑i=1mαiyi\\frac{\\partial L(w,b,\\mathcal{\\alpha},\\xi,\\mu)}{\\partial b}=-\\sum_{i=1}^m\\alpha_iy_i=0\\Rightarrow 0=\\sum_{i=1}^m\\alpha_iy_i ∂b∂L(w,b,α,ξ,μ)​=−i=1∑m​αi​yi​=0⇒0=i=1∑m​αi​yi​ ∂L(w,b,α,ξ,μ)∂ξi=C−αi−μi=0\\frac{\\partial L(w,b,\\mathcal{\\alpha},\\xi,\\mu)}{\\partial \\xi_i}=C-\\alpha_i-\\mu_i=0 ∂ξi​∂L(w,b,α,ξ,μ)​=C−αi​−μi​=0 最后通过偏导式、拉格朗日方程、原公式得到软间隔对偶优化问题： max⁡α−12∑i=1m∑j=1mαiαjyiyjxiTxj+∑i=1mαi同时保证∑i=1mαiyi=0和0≤αi≤C,i=1,2,…,m\\max_\\alpha-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_j\\mathbf{x}_i^T\\mathbf{x}_j+\\sum_{i=1}^m\\alpha_i\\\\ 同时保证\\ \\sum_{i=1}^m\\alpha_iy_i=0和0\\leq\\alpha_i\\leq C,\\ i=1,2,\\ldots,m αmax​−21​i=1∑m​j=1∑m​αi​αj​yi​yj​xiT​xj​+i=1∑m​αi​同时保证i=1∑m​αi​yi​=0和0≤αi​≤C,i=1,2,…,m KTT 条件： αi(yi(wTxi+b)−1+ξi)=0,(C−αi)ξi=0,i=1,2,…,m\\alpha_i(y_i(w^T\\mathbf{x}_i+b)-1+\\xi_i)=0,\\ (C-\\alpha_i)\\xi_i=0,\\ i=1,2,\\ldots,m αi​(yi​(wTxi​+b)−1+ξi​)=0,(C−αi​)ξi​=0,i=1,2,…,m ξi=0,αi=0\\xi_i=0,\\ \\alpha_i=0ξi​=0,αi​=0：样本被正确分类，并且这些样本不是支持向量，不影响最终解。 ξi=0,0αiC\\xi_i=0,\\ 0\\alpha_iCξi​=0,0αi​C：样本在间隔超平面上，即这些向量是支持向量。 0ξi≤1,αi=C0\\xi_i\\leq1,\\ \\alpha_i=C0ξi​≤1,αi​=C：表示样本被分割超平面正确分类，但落在软间隔内。 ξi1,αi=C\\xi_i1,\\ \\alpha_i=Cξi​1,αi​=C：样本被错误分类。 设 α∗=(α1∗,α2∗,…,αm∗)\\alpha^*=(\\alpha_1^*,\\alpha_2^*,\\ldots,\\alpha_m^*)α∗=(α1∗​,α2∗​,…,αm∗​) 为解，得到分隔超平面的法向量 w∗w^*w∗ 为： w∗=∑i=1mαi∗yixiw^*=\\sum_{i=1}^m\\alpha_i^*y_i\\mathbf{x}_i w∗=i=1∑m​αi∗​yi​xi​ 然后通过 αi(yi(wTxi+b)−1+ξi)=0,(C−αi)ξi=0,i=1,2,…,m\\alpha_i(y_i(w^T\\mathbf{x}_i+b)-1+\\xi_i)=0,\\ (C-\\alpha_i)\\xi_i=0,\\ i=1,2,\\ldots,mαi​(yi​(wTxi​+b)−1+ξi​)=0,(C−αi​)ξi​=0,i=1,2,…,m 计算 bbb，并把它的平均值作为分隔超平面的偏移量 b∗b^*b∗，则最终的决策函数为： f(x)=sgn(∑i=1mαi∗yiK(xi⋅x)+b∗)f(\\mathbf{x})=\\mathbf{sgn}\\left(\\sum_{i=1}^m\\alpha_i^*y_iK(\\mathbf{x}_i\\cdot\\mathbf{x})+b^*\\right) f(x)=sgn(i=1∑m​αi∗​yi​K(xi​⋅x)+b∗) ν-SVC 算法 使用参数 ν uν 代替参数 CCC。 表示支持向量占全部训练样本的比例下限； 也表示错误分类样本占全部训练样本的比例上限。 如 ν=0.05 u=0.05ν=0.05，则保证最多有5%的训练样本被错分类，且至少有5%的支持向量。 用常系数 ν uν 代替参数 CCC，同时还引入一个需要被优化的变量 ρ\\rhoρ，ν-SVC 的原公式： min⁡12∣∣w∣∣2−νρ+1m∑i=1mξi同时保证yi(wTxi+b)≥ρ−ξi和ξi≥0,ρ≥0,i=1,2,…,m\\min\\frac{1}{2}\\vert\\vert w\\vert\\vert^2- u\\rho+\\frac{1}{m}\\sum_{i=1}^m\\xi_i\\\\ 同时保证\\ y_i(w^T\\mathbf{x}_i+b)\\geq\\rho-\\xi_i和\\xi_i\\geq 0,\\rho\\geq 0,i=1,2,\\ldots,m min21​∣∣w∣∣2−νρ+m1​i=1∑m​ξi​同时保证yi​(wTxi​+b)≥ρ−ξi​和ξi​≥0,ρ≥0,i=1,2,…,m ν-SVC 的软间隔宽度为：2ρ/∣∣w∣∣2\\rho/\\vert\\vert w\\vert\\vert2ρ/∣∣w∣∣。 拉格朗日方程： L(w,b,α,ξ,μ,ρ,δ)=12∣∣w∣∣2−νρ+1m∑i=1mξi−∑i=1mα[yi(wTxi+b)−ρ+ξi]−∑i=1mμξi−δρL(w,b,\\mathcal{\\alpha},\\xi,\\mu,\\rho,\\delta)=\\frac{1}{2}\\vert\\vert w\\vert\\vert^2- u\\rho+\\frac{1}{m}\\sum_{i=1}^m\\xi_i-\\sum_{i=1}^m\\alpha[y_i(w^T\\mathbf{x}_i+b)-\\rho+\\xi_i]-\\sum_{i=1}^m\\mu\\xi_i-\\delta\\rho L(w,b,α,ξ,μ,ρ,δ)=21​∣∣w∣∣2−νρ+m1​i=1∑m​ξi​−i=1∑m​α[yi​(wTxi​+b)−ρ+ξi​]−i=1∑m​μξi​−δρ 再次求偏导，使导数为0，得到： w=∑i=1mαiyixiw=\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i w=i=1∑m​αi​yi​xi​ αi+μi=1m\\alpha_i+\\mu_i=\\frac{1}{m} αi​+μi​=m1​ ∑i=1mαiyi=0\\sum_{i=1}^m\\alpha_iy_i=0 i=1∑m​αi​yi​=0 ∑i=1mαi−δ=0\\sum_{i=1}^m\\alpha_i-\\delta=0 i=1∑m​αi​−δ=0 结合，最终得到二次优化问题： max⁡α−12∑i=1m∑j=1mαiαjyiyjK(xi,xj)同时保证∑i=1mαiyi=0,0≤αi≤1m和∑i=1mαi≥ν,i=1,2,…,m\\max_\\alpha-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jy_iy_jK(x_i,x_j)\\\\ 同时保证\\ \\sum_{i=1}^m\\alpha_iy_i=0,0\\leq\\alpha_i\\leq\\frac{1}{m}和\\sum_{i=1}^m\\alpha_i\\geq u,\\ i=1,2,\\ldots,m αmax​−21​i=1∑m​j=1∑m​αi​αj​yi​yj​K(xi​,xj​)同时保证i=1∑m​αi​yi​=0,0≤αi​≤m1​和i=1∑m​αi​≥ν,i=1,2,…,m 常系数 ν uν 仍需满足： ν≤2min⁡(Nums(yi=+1),Nums(yi=−1))m u\\leq\\frac{2\\min(\\mathbf{Nums}(y_i=+1),\\mathbf{Nums}(y_i=-1))}{m} ν≤m2min(Nums(yi​=+1),Nums(yi​=−1))​ Nums(yi=+1)\\mathbf{Nums}(y_i=+1)Nums(yi​=+1) 表示样本中正例数量。 Nums(yi=−1)\\mathbf{Nums}(y_i=-1)Nums(yi​=−1) 表示样本中负例数量。 决策函数为： f(x)=sgn(∑i=1mαi∗yiK(xi,x)+b∗)f(\\mathbf{x})=\\mathbf{sgn}\\left(\\sum_{i=1}^m\\alpha_i^*y_iK(\\mathbf{x}_i,\\mathbf{x})+b^*\\right) f(x)=sgn(i=1∑m​αi∗​yi​K(xi​,x)+b∗) w=∑i=1mαiyixiw=\\sum_{i=1}^m\\alpha_iy_i\\mathbf{x}_i w=i=1∑m​αi​yi​xi​ 设两个集合 S+S_+S+​ 和 S−S_-S−​，集合内分别为正例和负例的支持向量（ξi=0\\xi_i=0ξi​=0），元素数量都为 sss。约束变成 yif(xi)=ρy_if(\\mathbf{x}_i)=\\rhoyi​f(xi​)=ρ。得到 b∗b^*b∗ 和 ρ∗\\rho^*ρ∗： b∗=−12s∑x∈S+∪S−∑i=1mαi∗yiK(x,xi)b^*=-\\frac{1}{2s}\\sum_{x\\in S_+\\cup S_-}\\sum_{i=1}^m\\alpha_i^*y_iK(\\mathbf{x},\\mathbf{x}_i) b∗=−2s1​x∈S+​∪S−​∑​i=1∑m​αi∗​yi​K(x,xi​) ρ∗=12s(∑x∈S+∑i=1mαi∗yiK(x,xi)−∑x∈S−∑i=1mαi∗yiK(x,xi))\\rho^*=\\frac{1}{2s}\\left(\\sum_{x\\in S_+}\\sum_{i=1}^m\\alpha_i^*y_iK(\\mathbf{x},\\mathbf{x}_i)-\\sum_{x\\in S_-}\\sum_{i=1}^m\\alpha_i^*y_iK(\\mathbf{x},\\mathbf{x}_i)\\right) ρ∗=2s1​⎝⎜⎛​x∈S+​∑​i=1∑m​αi∗​yi​K(x,xi​)−x∈S−​∑​i=1∑m​αi∗​yi​K(x,xi​)⎠⎟⎞​ 多类问题的 SVC 处理多类问题时，把多个类转化为若干个问题处理。 一对其余：用一类与其余类进行比较。 如将类1作为正例，其他组合一起作为负例，得到决策函数 f1(x)f_1(\\mathbf{x})f1​(x)；然后将类2作为正例，其余组合一起作为负例，得到决策函数 f2(x)f_2(\\mathbf{x})f2​(x)。以此类推得到 kkk 个决策函数。 当对新样本 x\\mathbf{x}x，带入下式得到分类： arg⁡max⁡ifi(x)\\arg\\max_{i}f_i(\\mathbf{x}) argimax​fi​(x) 一对一：一共得到 k(k−1)/2k(k-1)/2k(k−1)/2 个决策函数 fi,j(x),0≤ij≤kf_{i,j}(\\mathbf{x}),0\\leq ij\\leq kfi,j​(x),0≤ij≤k，表示第 iii 类和第 jjj 类比较得到的决策函数。 当对新样本 x\\mathbf{x}x，需要代入所有的 fi,j(x)f_{i,j}(\\mathbf{x})fi,j​(x)，统计所有类别的胜出次数，得票最多的类即为结果。 单类 SVM 单类问题并不是进行分类，而是判断新样本是否属于该类。 如判断银行业务中是否为欺诈交易时，无法提供足够多的欺诈例子用于训练，但有大量正常交易用于建模。 解决方法：Tax Duin 法和 Schölkopf 法。 Tax Duin 法：在输入空间或特征空间内找到一个体积最小的超球体，能够包含全部训练样本。 当然也为每个样本 xi\\mathbf{x}_ixi​ 分配一个松弛变量 ξi\\xi_iξi​ 带有 ξi\\xi_iξi​、球心为 a\\mathbf{a}a、半径为 R\\mathbf{R}R 的超球体表达式为： F(R,a,ξi)=R2+C∑i=1mξiF(\\mathbf{R},\\mathbf{a},\\xi_i)=\\mathbf{R}^2+C\\sum_{i=1}^m\\xi_i F(R,a,ξi​)=R2+Ci=1∑m​ξi​ CCC 是常数，用于平衡超球体的体积大小和超球体外样本的数量。 使得上式最小化，还需满足约束： ∣∣ϕ(xi)−a∣∣2≤R2+ξi,ξi≥0,i=1,2,…,m\\vert\\vert\\phi(\\mathbf{x}_i)-\\mathbf{a}\\vert\\vert^2\\leq\\mathbf{R}^2+\\xi_i,\\xi_i\\geq 0, i=1,2,\\ldots,m ∣∣ϕ(xi​)−a∣∣2≤R2+ξi​,ξi​≥0,i=1,2,…,m ϕ(xi)\\phi(\\mathbf{x}_i)ϕ(xi​) 表示样本 xi\\mathbf{x}_ixi​ 从输入空间到特征空间的映射。 拉格朗日乘子法得到： L(R,a,α,ξ,μ)=R2+C∑i=1mξi−∑i=1mαi[R2+ξi−∣∣ϕ(xi)−a∣∣2]−∑i=1mμiξiL(\\mathbf{R},\\mathbf{a},\\alpha,\\xi,\\mu)=\\mathbf{R}^2+C\\sum_{i=1}^m\\xi_i-\\sum_{i=1}^m\\alpha_i\\left[\\mathbf{R}^2+\\xi_i-\\vert\\vert\\phi(\\mathbf{x}_i)-\\mathbf{a}\\vert\\vert^2\\right]-\\sum_{i=1}^m\\mu_i\\xi_i L(R,a,α,ξ,μ)=R2+Ci=1∑m​ξi​−i=1∑m​αi​[R2+ξi​−∣∣ϕ(xi​)−a∣∣2]−i=1∑m​μi​ξi​ αi\\alpha_iαi​ 和 μi\\mu_iμi​ 都不小于0。 基于变量 R\\mathbf{R}R、a\\mathbf{a}a、ξi\\xi_iξi​ 的偏导数分别为： ∑i=1mαi=1\\sum_{i=1}^m\\alpha_i=1 i=1∑m​αi​=1 a=∑i=1mαiϕ(xi)\\mathbf{a}=\\sum_{i=1}^m\\alpha_i\\phi(\\mathbf{x}_i) a=i=1∑m​αi​ϕ(xi​) C−αi−μi=0C-\\alpha_i-\\mu_i=0 C−αi​−μi​=0 通过代入得到对偶公式： L(R,a,α,ξ,μ)=∑i=1mαiϕ(xi)⋅ϕ(xi)−∑i=1m∑j=1mαiαjϕ(xi)⋅ϕ(xj)L(\\mathbf{R},\\mathbf{a},\\alpha,\\xi,\\mu)=\\sum_{i=1}^m\\alpha_i\\phi(\\mathbf{x}_i)\\cdot\\phi(\\mathbf{x}_i)-\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_j\\phi(\\mathbf{x}_i)\\cdot\\phi(\\mathbf{x}_j) L(R,a,α,ξ,μ)=i=1∑m​αi​ϕ(xi​)⋅ϕ(xi​)−i=1∑m​j=1∑m​αi​αj​ϕ(xi​)⋅ϕ(xj​) 使用核函数代替点乘，得到二次优化问题： max⁡α∑i=1mαiK(xi,xi)−∑i=1m∑j=1mαiαjK(xi,xj)受限于∑i=1mαi=1,0≤αi≤C,i=1,2,…,m\\max_\\alpha\\sum_{i=1}^m\\alpha_iK(\\mathbf{x}_i,\\mathbf{x}_i)-\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_jK(\\mathbf{x}_i,\\mathbf{x}_j)\\\\ 受限于\\sum_{i=1}^m\\alpha_i=1,\\ 0\\leq\\alpha_i\\leq C, i=1,2,\\ldots,m αmax​i=1∑m​αi​K(xi​,xi​)−i=1∑m​j=1∑m​αi​αj​K(xi​,xj​)受限于i=1∑m​αi​=1,0≤αi​≤C,i=1,2,…,m 在超球体表面的样本为支持向量。 超球体的半径 R\\mathbf{R}R 可通过计算球心 a\\mathbf{a}a 到任意一个支持向量的距离得到。 设解为 α∗=(α1∗,α2∗,⋯+αm∗)\\alpha^*=(\\alpha_1^*,\\alpha_2^*,\\cdots+\\alpha_m^*)α∗=(α1∗​,α2∗​,⋯+αm∗​)，支持向量为 xs\\mathbf{x}_sxs​ ： R2=∣∣ϕ(xj)−a∣∣∣2=∣∣ϕ(xs)−∑i=1mαi∗ϕ(xi)2∣∣=K(xs,xs)−2∑i=1mαi∗K(xs,xs)+∑i=1m∑j=1mαi∗αj∗K(xi,xj)\\mathbf{R}^2=\\vert\\vert\\phi(\\mathbf{x}_j)-\\mathbf{a}\\vert\\vert\\vert^2\\\\ =\\vert\\vert\\phi(\\mathbf{x}_s)-\\sum_{i=1}^m\\alpha_i^*\\phi(\\mathbf{x}_i)^2\\vert\\vert\\\\ =K(\\mathbf{x}_s,\\mathbf{x}_s)-2\\sum_{i=1}^m\\alpha_i^*K(\\mathbf{x}_s,\\mathbf{x}_s)+\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i^*\\alpha_j^*K(\\mathbf{x}_i,\\mathbf{x}_j) R2=∣∣ϕ(xj​)−a∣∣∣2=∣∣ϕ(xs​)−i=1∑m​αi∗​ϕ(xi​)2∣∣=K(xs​,xs​)−2i=1∑m​αi∗​K(xs​,xs​)+i=1∑m​j=1∑m​αi∗​αj∗​K(xi​,xj​) 当判断样本是否属于该类时，需要计算样本 x\\mathbf{x}x 与球心的距离 aaa，并与半径 R\\mathbf{R}R 比较，如果小于半径，则是该类，否则不属于该类。 决策函数： f(x)=sgn(d(x))f(x)=\\mathbf{sgn}(d(\\mathbf{x})) f(x)=sgn(d(x)) f(x)=sgn(R2−K(x,x)+2∑i=1mαi∗K(xi,x)−∑i=1m∑j=1mαi∗αj∗K(xi,xj))=sgn(K(xs,xs)−K(x,x)−2∑i=1mαi∗[K(xi,xs)−K(xi,x)])\\begin{aligned} f(x)=\\mathbf{sgn}\\left(\\mathbf{R}^2-K(\\mathbf{x},\\mathbf{x})+2\\sum_{i=1}^m\\alpha_i^*K(\\mathbf{x}_i,\\mathbf{x})-\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i^*\\alpha_j^*K(\\mathbf{x}_i,\\mathbf{x}_j)\\right)\\\\ =\\mathbf{sgn}\\left(K(\\mathbf{x}_s,\\mathbf{x}_s)-K(\\mathbf{x},\\mathbf{x})-2\\sum_{i=1}^m\\alpha_i^*[K(\\mathbf{x}_i,\\mathbf{x}_s)-K(\\mathbf{x}_i,\\mathbf{x})]\\right) \\end{aligned} f(x)​=sgn(R2−K(x,x)+2i=1∑m​αi∗​K(xi​,x)−i=1∑m​j=1∑m​αi∗​αj∗​K(xi​,xj​))=sgn(K(xs​,xs​)−K(x,x)−2i=1∑m​αi∗​[K(xi​,xs​)−K(xi​,x)])​ xs\\mathbf{x}_sxs​ 表示任意一个支持向量； 当 f(x)=1f(\\mathbf{x})=1f(x)=1，表示 x\\mathbf{x}x 属于该类。 Schölkopf 法：在特征空间找到一个超平面，该超平面能够分隔全部样本和坐标原点，并且要使该超平面到远点的距离最远。 求解： min⁡12∣∣w∣∣2+1νm∑i=1mξi−ρ受限于(w⋅ϕ(xi))≥ρ−ξi,ξi≥0,i=1,2,…,m\\min\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+\\frac{1}{ u m}\\sum_{i=1}^m\\xi_i-\\rho\\\\ 受限于\\ (w\\cdot\\phi(\\mathbf{x}_i))\\geq\\rho-\\xi_i,\\xi_i\\geq 0,i=1,2,\\ldots,m min21​∣∣w∣∣2+νm1​i=1∑m​ξi​−ρ受限于(w⋅ϕ(xi​))≥ρ−ξi​,ξi​≥0,i=1,2,…,m ν uν 表示支持向量占全部训练样本的比例下限，也表示错误分类样本占全部训练样本的比例上限。 做拉格朗日方程： L(w,ξ,ρ,α,μ)=12∣∣w∣∣2+1νm∑i=1mξi−ρ−∑i=1mαi(w⋅ϕ(xi)−ρ+ξi)−∑i=1mμiξiL(w,\\xi,\\rho,\\alpha,\\mu)=\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+\\frac{1}{ u m}\\sum_{i=1}^m\\xi_i-\\rho-\\sum_{i=1}^m\\alpha_i(w\\cdot\\phi(\\mathbf{x}_i)-\\rho+\\xi_i)-\\sum_{i=1}^m\\mu_i\\xi_i L(w,ξ,ρ,α,μ)=21​∣∣w∣∣2+νm1​i=1∑m​ξi​−ρ−i=1∑m​αi​(w⋅ϕ(xi​)−ρ+ξi​)−i=1∑m​μi​ξi​ 对 w、ξ、ρw、\\xi、\\rhow、ξ、ρ 求偏导，使其为0，有： w=∑i=1mαiϕ(xi)w=\\sum_{i=1}^m\\alpha_i\\phi(\\mathbf{x}_i) w=i=1∑m​αi​ϕ(xi​) αi=1νm−μi⇒αi≤1νm\\alpha_i=\\frac{1}{ u m}-\\mu_i\\Rightarrow\\alpha_i\\leq\\frac{1}{ u m} αi​=νm1​−μi​⇒αi​≤νm1​ ∑i=1mαi=1\\sum_{i=1}^m\\alpha_i=1 i=1∑m​αi​=1 则对偶问题为： max⁡α−12∑i=1m∑j=1mαiαiK(xi,xj)受限于∑i=1mαi=1,0≤αi≤1νm,i=1,2,…,m\\max_{\\alpha}-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m\\alpha_i\\alpha_iK(\\mathbf{x}_i,\\mathbf{x}_j)\\\\ 受限于\\ \\sum_{i=1}^m\\alpha_i=1,0\\leq\\alpha_i\\leq\\frac{1}{ u m},i=1,2,\\ldots,m αmax​−21​i=1∑m​j=1∑m​αi​αi​K(xi​,xj​)受限于i=1∑m​αi​=1,0≤αi​≤νm1​,i=1,2,…,m 设解为 α∗=(α1∗,α2∗,⋯ ,αm∗)\\alpha^*=(\\alpha_1^*,\\alpha_2^*,\\cdots,\\alpha_m^*)α∗=(α1∗​,α2∗​,⋯,αm∗​)，若 αi\\alpha_iαi​ 和 μi\\mu_iμi​ 都不为0，则 ξi\\xi_iξi​ 必为0： ρ=(w⋅ϕ(xs))\\rho=(w\\cdot\\phi(\\mathbf{x}_s)) ρ=(w⋅ϕ(xs​)) xs\\mathbf{x}_sxs​ 为任意一个支持向量。 由 αj\\alpha_jαj​ 不为0，代入 w=∑i=1mαiϕ(xi)w=\\sum_{i=1}^m\\alpha_i\\phi(\\mathbf{x}_i)w=∑i=1m​αi​ϕ(xi​)，则： ρ=(w⋅ϕ(xs))=∑i=1mαiK(xi,xs)\\rho=(w\\cdot\\phi(\\mathbf{x}_s))=\\sum_{i=1}^m\\alpha_iK(\\mathbf{x}_i,\\mathbf{x}_s) ρ=(w⋅ϕ(xs​))=i=1∑m​αi​K(xi​,xs​) 决策函数： f(x)=sgn(d(x))=sgn((w⋅ϕ(x))−ρ)f(\\mathbf{x})=\\mathbf{sgn}(d(\\mathbf{x}))=\\mathbf{sgn}((w\\cdot\\phi(\\mathbf{x}))-\\rho) f(x)=sgn(d(x))=sgn((w⋅ϕ(x))−ρ) f(x)=sgn(∑i=1mαi∗K(xi,x)−∑i=1mαi∗K(xi,xs))f(\\mathbf{x})=\\mathbf{sgn}\\left(\\sum_{i=1}^m\\alpha_i^*K(\\mathbf{x}_i,\\mathbf{x})-\\sum_{i=1}^m\\alpha_i^*K(\\mathbf{x}_i,\\mathbf{x}_s)\\right) f(x)=sgn(i=1∑m​αi∗​K(xi​,x)−i=1∑m​αi∗​K(xi​,xs​)) xs\\mathbf{x}_sxs​ 为任意一个支持向量。 x\\mathbf{x}x 为待预测样本。 当 f(x)=1f(\\mathbf{x})=1f(x)=1，表示 x\\mathbf{x}x 属于该类。 ε-SVR 算法 Vapnik 通过 ε\\varepsilonε 不敏感损失函数，把 SVM 扩展到回归问题中。 设 yiy_iyi​ 为样本 x\\mathbf{x}x 对应的响应值，回归问题则是找到一个函数 f(x)f(\\mathbf{x})f(x)，使得 f(xi)=yif(\\mathbf{x}_i)=y_if(xi​)=yi​。 估计的质量好坏由不敏感损失函数衡量。 Lossε={0,如果∣y−f(x)≤ε∣y−f(x)∣−ε,其他\\mathbf{Loss}_\\varepsilon=\\begin{cases}0, 如果\\vert y-f(\\mathbf{x})\\leq\\varepsilon\\\\\\vert y-f(\\mathbf{x})\\vert-\\varepsilon, 其他\\end{cases} Lossε​={0,∣y−f(x)∣−ε,​如果∣y−f(x)≤ε其他​ ε0\\varepsilon0ε0，表示控制误差限度的常量，即如果误差在 [−ε,ε][-\\varepsilon,\\varepsilon][−ε,ε] 之间，就认为忽略误差。 线性关系时，函数表示为： f(x)=w⋅x+bf(\\mathbf{x})=w\\cdot\\mathbf{x}+b f(x)=w⋅x+b www 为权重，bbb 为偏置。 由于误差允许，所以在 f(x)f(\\mathbf{x})f(x) 周围形成一个包围，称之为 ε\\varepsilonε 管。 ε\\varepsilonε-SVR 中，得到 f(x)f(\\mathbf{x})f(x) 还需要满足： 使 f(x)f(\\mathbf{x})f(x) 与测量值 yiy_iyi​ 的偏差值不大于 ε\\varepsilonε，让所有样本都在 ε\\varepsilonε 管中。 使 f(x)f(\\mathbf{x})f(x) 尽可能平坦，简化模型，能够避免过拟合。平直指的是样本中各个特征属性对样本贡献大小应该均衡，即 www 要小。 ε\\varepsilonε-SVR 问题表示为： min⁡12∣∣w∣∣2受限于{yi−w⋅xi−b≤εw⋅xi+b−yi≤ε,i=1,2,…,m\\min\\frac{1}{2}\\vert\\vert w\\vert\\vert^2\\\\ 受限于\\begin{cases}y_i-w\\cdot \\mathbf{x}_i-b\\leq\\varepsilon\\\\ w\\cdot\\mathbf{x}_i+b-y_i\\leq\\varepsilon\\end{cases},i=1,2,\\ldots,m min21​∣∣w∣∣2受限于{yi​−w⋅xi​−b≤εw⋅xi​+b−yi​≤ε​,i=1,2,…,m 也使用软间隔，引入两个松弛变量 ξ+\\xi^+ξ+ 和 ξ−\\xi^-ξ−，上式改写为： ξi+\\xi_i^+ξi+​ 表示那些被高估的样本响应值的误差； ξi−\\xi_i^-ξi−​ 表示那些被低估的样本响应值的误差 min⁡12∣∣w∣∣2+C∑i=1m(ξi++ξi−)受限于{yi−w⋅xi−b≤ε+ξi−w⋅xi+b−yi≤ε+ξi+,{ξi−≥0ξi+≥0,i=1,2,…,m\\min\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+C\\sum_{i=1}^m(\\xi_i^++\\xi_i^-)\\\\ 受限于\\begin{cases}y_i-w\\cdot \\mathbf{x}_i-b\\leq\\varepsilon+\\xi_i^-\\\\ w\\cdot\\mathbf{x}_i+b-y_i\\leq\\varepsilon+\\xi_i^+\\end{cases},\\ \\begin{cases}\\xi_i^-\\geq 0\\\\\\xi_i^+\\geq 0\\end{cases},\\ i=1,2,\\ldots,m min21​∣∣w∣∣2+Ci=1∑m​(ξi+​+ξi−​)受限于{yi​−w⋅xi​−b≤ε+ξi−​w⋅xi​+b−yi​≤ε+ξi+​​,{ξi−​≥0ξi+​≥0​,i=1,2,…,m C0C0C0：为常数，均衡 f(x)f(\\mathbf{x})f(x) 的平坦程度与偏差大于 ε\\varepsilonε 的样本数量。 ∣ξ∣ε={0,如果∣ξ∣≤ε∣ξ∣−ε,其他\\vert\\xi\\vert_\\varepsilon=\\begin{cases}0, 如果\\vert\\xi\\vert\\leq\\varepsilon\\\\\\vert\\xi\\vert-\\varepsilon, 其他\\end{cases} ∣ξ∣ε​={0,∣ξ∣−ε,​如果∣ξ∣≤ε其他​ 表示改写后的拉格朗日乘子法方程为： L(w,b,ξ,α,μ)=12∣∣w∣∣2+C∑i=1m(ξi++ξi−)−∑i=1m(μi+ξi++μi−ξi−)−∑i=1mαi+(ε+ξi++yi−w⋅xi−b)−∑i=1mαi−(ε+ξi−−yi+w⋅xi+b)L(w,b,\\xi,\\alpha,\\mu)=\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+C\\sum_{i=1}^m(\\xi_i^++\\xi_i^-)-\\sum_{i=1}^m(\\mu_i^+\\xi_i^++\\mu_i^-\\xi_i^-)\\\\ -\\sum_{i=1}^m\\alpha_i^+(\\varepsilon+\\xi_i^++y_i-w\\cdot\\mathbf{x}_i-b)-\\sum_{i=1}^m\\alpha_i^-(\\varepsilon+\\xi_i^--y_i+w\\cdot\\mathbf{x}_i+b) L(w,b,ξ,α,μ)=21​∣∣w∣∣2+Ci=1∑m​(ξi+​+ξi−​)−i=1∑m​(μi+​ξi+​+μi−​ξi−​)−i=1∑m​αi+​(ε+ξi+​+yi​−w⋅xi​−b)−i=1∑m​αi−​(ε+ξi−​−yi​+w⋅xi​+b) αi+、αi−、μi+、μi−\\alpha_i^+、\\alpha_i^-、\\mu_i^+、\\mu_i^-αi+​、αi−​、μi+​、μi−​ 都为非负值。 对原变量 w、b、ξw、b、\\xiw、b、ξ 进行求偏导并使其为0： ∂L∂w=w−∑i=1m(αi−−αi+)xi=0⇒w=∑i=1m(αi−−αi+)xi\\frac{\\partial L}{\\partial w}=w-\\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)\\mathbf{x}_i=0\\Rightarrow w=\\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)\\mathbf{x}_i ∂w∂L​=w−i=1∑m​(αi−​−αi+​)xi​=0⇒w=i=1∑m​(αi−​−αi+​)xi​ ∂L∂b=∑i=1m(αi+−αi−)=0\\frac{\\partial L}{\\partial b}=\\sum_{i=1}^m(\\alpha_i^+-\\alpha_i^-)=0 ∂b∂L​=i=1∑m​(αi+​−αi−​)=0 ∂L∂ξ+=C−μi+−αi+=0\\frac{\\partial L}{\\partial \\xi^+}=C-\\mu_i^+-\\alpha_i^+=0 ∂ξ+∂L​=C−μi+​−αi+​=0 ∂L∂ξ−=C−μi−−αi−=0\\frac{\\partial L}{\\partial \\xi^-}=C-\\mu_i^--\\alpha_i^-=0 ∂ξ−∂L​=C−μi−​−αi−​=0 进入代入，得到对偶优化问题： max⁡α−,α+−12∑i=1m∑j=1m(αi−−αi+)(αj−−αj+)K(xi,xj)−ε∑i=1m(αi−+αi+)+∑i=1myi(αi−−αi+)受限于∑i=1m(αi−−αi+)=0,αi−,αj+∈[0,C]\\max_{\\alpha^-,\\alpha^+}-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m(\\alpha_i^--\\alpha_i^+)(\\alpha_j^--\\alpha_j^+)K(\\mathbf{x}_i,\\mathbf{x}_j)-\\varepsilon\\sum_{i=1}^m(\\alpha_i^-+\\alpha_i^+)+\\sum_{i=1}^my_i(\\alpha_i^--\\alpha_i^+)\\\\ 受限于\\ \\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)=0,\\ \\alpha_i^-,\\alpha_j^+\\in[0,C] α−,α+max​−21​i=1∑m​j=1∑m​(αi−​−αi+​)(αj−​−αj+​)K(xi​,xj​)−εi=1∑m​(αi−​+αi+​)+i=1∑m​yi​(αi−​−αi+​)受限于i=1∑m​(αi−​−αi+​)=0,αi−​,αj+​∈[0,C] K(xi,xj)K(\\mathbf{x}_i,\\mathbf{x}_j)K(xi​,xj​)：为核函数，同前映射关系。 设解为 α∗=(α1−∗,α1+∗,⋯ ,αm−∗,αm+∗)\\alpha^*=(\\alpha_1^{-*},\\alpha_1^{+*},\\cdots,\\alpha_m^{-*},\\alpha_m^{+*})α∗=(α1−∗​,α1+∗​,⋯,αm−∗​,αm+∗​)，则： w=∑i=1m(αi−∗−αi+∗)ϕ(xi)w=\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})\\phi(\\mathbf{x}_i) w=i=1∑m​(αi−∗​−αi+∗​)ϕ(xi​) 最后回归计算公式： f(x)=∑i=1m(αi−∗−αi+∗)K(xi,x)+b∗f(\\mathbf{x})=\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})K(\\mathbf{x}_i,\\mathbf{x})+b^* f(x)=i=1∑m​(αi−∗​−αi+∗​)K(xi​,x)+b∗ 由 KKT 条件计算： b∗=yj−∑i=1m(αi−∗−αi+∗)K(xi,xj)+εb^*=y_j-\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})K(\\mathbf{x}_i,\\mathbf{x}_j)+\\varepsilon b∗=yj​−i=1∑m​(αi−∗​−αi+∗​)K(xi​,xj​)+ε 或 b∗=yk−∑i=1m(αi−∗−αi+∗)K(xi,xk)−εb^*=y_k-\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})K(\\mathbf{x}_i,\\mathbf{x}_k)-\\varepsilon b∗=yk​−i=1∑m​(αi−∗​−αi+∗​)K(xi​,xk​)−ε (xj,yj)(\\mathbf{x}_j,y_j)(xj​,yj​) 为任意一个样本对应的 αj+∗∈(0,C)\\alpha_j^{+*}\\in(0,C)αj+∗​∈(0,C)； (xk,yk)(\\mathbf{x}_k,y_k)(xk​,yk​) 为任意一个样本对应的 αk−∗∈(0,C)\\alpha_k^{-*}\\in(0,C)αk−∗​∈(0,C)。 由 KKT 条件，还可以知道 αi−∗\\alpha_i^{-*}αi−∗​ 或 αi+∗\\alpha_i^{+*}αi+∗​ 等于 CCC 的样本在 ε\\varepsilonε 管外，而且 αi−∗\\alpha_i^{-*}αi−∗​ 或 αi+∗\\alpha_i^{+*}αi+∗​ 不可能同时为0。 这意味着一个样本不能拥有两个方向的松弛变量 ξ\\xiξ，只能向一个方向偏离。 ν-SVR 算法 Schölkopf 从 ν-SVC 算法上扩展得到 ν-SVR 算法。 ν-SVR 原公式： min⁡12∣∣w∣∣2+C(νε+1m∑i=1m(ξi++ξi−))受限于{yi−w⋅ϕ(xi)−b≤ε+ξi−w⋅ϕ(xi)+b−yi≤ε+ξi+,{ξi−≥0ξi+≥0,i=1,2,…,m\\min\\frac{1}{2}\\vert\\vert w\\vert\\vert^2+C\\left( u\\varepsilon+\\frac{1}{m}\\sum_{i=1}^m(\\xi_i^++\\xi_i^-)\\right)\\\\ 受限于\\ \\begin{cases}y_i-w\\cdot\\phi(\\mathbf{x}_i)-b\\leq\\varepsilon+\\xi_i^-\\\\ w\\cdot\\phi(\\mathbf{x}_i)+b-y_i\\leq\\varepsilon+\\xi_i^+\\end{cases},\\ \\begin{cases}\\xi_i^-\\geq 0\\\\\\xi_i^+\\geq 0\\end{cases},\\ i=1,2,\\ldots,m min21​∣∣w∣∣2+C(νε+m1​i=1∑m​(ξi+​+ξi−​))受限于{yi​−w⋅ϕ(xi​)−b≤ε+ξi−​w⋅ϕ(xi​)+b−yi​≤ε+ξi+​​,{ξi−​≥0ξi+​≥0​,i=1,2,…,m ε\\varepsilonε-SVR 中，参数 ε\\varepsilonε 通过经验选取，而在 ν uν-SVR 中把 ε\\varepsilonε 作为目标函数的一个变量。同时 CCC 和 ν uν 为常数， CCC 为正值； ν∈[0,1] u\\in[0,1]ν∈[0,1] 同样表示支持向量占全部训练样本的比例下限，也表示错误估计样本占全部训练样本的比例上限。 取拉格朗日方程为： L(w,b,β,ε,ξ,α,μ)=12+Cνε+Cm∑i=1m(ξi++ξi−)−βε−∑i=1m(μi+ξi++μi−ξi−)−∑i=1mαi+(ε+ξi++yi−w⋅ϕ(xi)−b)−∑i=1mαi−(ε+ξi−−yi+w⋅ϕ(xi)+b)L(w,b,\\beta,\\varepsilon,\\xi,\\alpha,\\mu)=\\frac{1}{2}+C u\\varepsilon+\\frac{C}{m}\\sum_{i=1}^m(\\xi_i^++\\xi_i^-)-\\beta\\varepsilon-\\sum_{i=1}^m(\\mu_i^+\\xi_i^++\\mu_i^-\\xi_i^-)\\\\ -\\sum_{i=1}^m\\alpha_i^+(\\varepsilon+\\xi_i^++y_i-w\\cdot\\phi(\\mathbf{x}_i)-b)-\\sum_{i=1}^m\\alpha_i^-(\\varepsilon+\\xi_i^--y_i+w\\cdot\\phi(\\mathbf{x}_i)+b) L(w,b,β,ε,ξ,α,μ)=21​+Cνε+mC​i=1∑m​(ξi+​+ξi−​)−βε−i=1∑m​(μi+​ξi+​+μi−​ξi−​)−i=1∑m​αi+​(ε+ξi+​+yi​−w⋅ϕ(xi​)−b)−i=1∑m​αi−​(ε+ξi−​−yi​+w⋅ϕ(xi​)+b) 对原变量 w、ε、b、ξw、\\varepsilon、b、\\xiw、ε、b、ξ 求偏导并使之为0： ∂L∂w=w−∑i=1m(αi−−αi+)ϕ(xi)=0⇒w=∑i=1m(αi−−αi+)ϕ(xi)\\frac{\\partial L}{\\partial w}=w-\\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)\\phi(\\mathbf{x}_i)=0\\Rightarrow w=\\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)\\phi(\\mathbf{x}_i) ∂w∂L​=w−i=1∑m​(αi−​−αi+​)ϕ(xi​)=0⇒w=i=1∑m​(αi−​−αi+​)ϕ(xi​) ∂L∂ε=Cν−∑i=1m(αi++αi−)−β=0\\frac{\\partial L}{\\partial \\varepsilon}=C u-\\sum_{i=1}^m(\\alpha_i^++\\alpha_i^-)-\\beta=0 ∂ε∂L​=Cν−i=1∑m​(αi+​+αi−​)−β=0 ∂L∂b=∑i=1m(αi+−αi−)=0\\frac{\\partial L}{\\partial b}=\\sum_{i=1}^m(\\alpha_i^+-\\alpha_i^-)=0 ∂b∂L​=i=1∑m​(αi+​−αi−​)=0 ∂L∂ξ+=Cm−μi+−αi+=0\\frac{\\partial L}{\\partial \\xi^+}=\\frac{C}{m}-\\mu_i^+-\\alpha_i^+=0 ∂ξ+∂L​=mC​−μi+​−αi+​=0 ∂L∂ξ−=Cm−μi−−αi−=−β\\frac{\\partial L}{\\partial \\xi^-}=\\frac{C}{m}-\\mu_i^--\\alpha_i^-=-\\beta ∂ξ−∂L​=mC​−μi−​−αi−​=−β 进入代入，得到对偶优化问题： max⁡α−,α+−12∑i=1m∑j=1m(αi−−αi+)(αj−−αj+)K(xi,xj)+∑i=1myi(αi−−αi+)受限于∑i=1m(αi−−αi+)=0,αi−,αj+∈[0,Cm],∑i=1m(αi++αi−)≤Cν\\max_{\\alpha^-,\\alpha^+}-\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m(\\alpha_i^--\\alpha_i^+)(\\alpha_j^--\\alpha_j^+)K(\\mathbf{x}_i,\\mathbf{x}_j)+\\sum_{i=1}^my_i(\\alpha_i^--\\alpha_i^+)\\\\ 受限于\\ \\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)=0,\\ \\alpha_i^-,\\alpha_j^+\\in[0,\\frac{C}{m}],\\ \\sum_{i=1}^m(\\alpha_i^++\\alpha_i^-)\\leq C u α−,α+max​−21​i=1∑m​j=1∑m​(αi−​−αi+​)(αj−​−αj+​)K(xi​,xj​)+i=1∑m​yi​(αi−​−αi+​)受限于i=1∑m​(αi−​−αi+​)=0,αi−​,αj+​∈[0,mC​],i=1∑m​(αi+​+αi−​)≤Cν 设解为 α∗=(α1−∗,α1+∗,⋯ ,αm−∗,αm+∗)\\alpha^*=(\\alpha_1^{-*},\\alpha_1^{+*},\\cdots,\\alpha_m^{-*},\\alpha_m^{+*})α∗=(α1−∗​,α1+∗​,⋯,αm−∗​,αm+∗​)，则最后回归计算公式： f(x)=∑i=1m(αi−∗−αi+∗)K(xi,x)+b∗f(\\mathbf{x})=\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})K(\\mathbf{x}_i,\\mathbf{x})+b^* f(x)=i=1∑m​(αi−∗​−αi+∗​)K(xi​,x)+b∗ 由 KKT 条件得到： b∗=12[yi+yk−∑i=1m(αi−∗−αi+∗)K(xi,xj)−∑i=1m(αi−∗−αi+∗)K(xi,xk)]b^*=\\frac{1}{2}\\left[y_i+y_k-\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})K(\\mathbf{x}_i,\\mathbf{x}_j)-\\sum_{i=1}^m(\\alpha_i^{-*}-\\alpha_i^{+*})K(\\mathbf{x}_i,\\mathbf{x}_k)\\right] b∗=21​[yi​+yk​−i=1∑m​(αi−∗​−αi+∗​)K(xi​,xj​)−i=1∑m​(αi−∗​−αi+∗​)K(xi​,xk​)] (xj,yj)(\\mathbf{x}_j,y_j)(xj​,yj​) 为任意一个样本对应的 αj+∗∈(0,C/N)\\alpha_j^{+*}\\in(0,C/N)αj+∗​∈(0,C/N)； (xk,yk)(\\mathbf{x}_k,y_k)(xk​,yk​) 为任意一个样本对应的 αk−∗∈(0,C/N)\\alpha_k^{-*}\\in(0,C/N)αk−∗​∈(0,C/N) 解 ε∗\\varepsilon^*ε∗ 为： ε∗=∑i=1m(αi−−αi+)K(xi,xj)−yj+b∗\\varepsilon^*=\\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)K(\\mathbf{x}_i,\\mathbf{x}_j)-y_j+b^* ε∗=i=1∑m​(αi−​−αi+​)K(xi​,xj​)−yj​+b∗ 或 ε∗=yk−∑i=1m(αi−−αi+)K(xi,xj)−b∗\\varepsilon^*=y_k-\\sum_{i=1}^m(\\alpha_i^--\\alpha_i^+)K(\\mathbf{x}_i,\\mathbf{x}_j)-b^* ε∗=yk​−i=1∑m​(αi−​−αi+​)K(xi​,xj​)−b∗ (xj,yj)(\\mathbf{x}_j,y_j)(xj​,yj​) 为任意一个样本对应的 αj+∗∈(0,C/N)\\alpha_j^{+*}\\in(0,C/N)αj+∗​∈(0,C/N)； (xk,yk)(\\mathbf{x}_k,y_k)(xk​,yk​) 为任意一个样本对应的 αk−∗∈(0,C/N)\\alpha_k^{-*}\\in(0,C/N)αk−∗​∈(0,C/N) OpenCV所支持的 SVM OpenCV 提供了五种支持向量机的类型，分别为： enum Types { // C-SVC，n类分类（n≥2） C_SVC=100, // ν-SVC NU_SVC=101, // 单类SVM ONE_CLASS=102, // ε-SVR EPS_SVR=103, // ν-SVR NU_SVR=104}; 通过 SVM::setType(int val) 设置 SVM 类型，默认为 C_SVC。通过 SVM::getType() 获取 SVM 类型。 各个类型的 SVM 的超参可以通过以下函数访问： CCC：通过 SVM::setC(double val) 和 SVM::getC() 访问。 ν uν：通过 SVM::setNu(double val) 和 SVM::getNu() 访问。 ε\\varepsilonε：通过 SVM::setP(double val) 和 SVM::getP() 访问。 同时支持的核函数有： enum KernelTypes { // 当自定义内核已设置时，由SVM::getKernelType返回 CUSTOM=-1, // 线性核 LINEAR=0, // 多项式核 POLY=1, // 径向基函数（RBF），在大多数情况下是一个很好的选择。 RBF=2, // Sigmoid 核函数 SIGMOID=3, // 指数CHI2核，类似于RBF核 CHI2=4, // 直方图相交核，比较快. INTER=5}; 使用 SVM::setKernelType(int kernelType) 设置核函数类型。 多项式核为：K(xi,xj)=(γxiTxj+coef0)degree,γ0K(x_i, x_j) = (\\gamma x_i^T x_j + \\mathbf{coef0})^{\\mathbf{degree}},\\ \\gamma 0K(xi​,xj​)=(γxiT​xj​+coef0)degree,γ0 径向基函数 RBF：K(xi,xj)=e−γ∣∣xi−xj∣∣2,γ0K(x_i, x_j) = e^{-\\gamma ||x_i - x_j||^2},\\ \\gamma 0K(xi​,xj​)=e−γ∣∣xi​−xj​∣∣2,γ0 Sigmoid 函数：K(xi,xj)=tanh⁡(γxiTxj+coef0)K(x_i, x_j) = \\tanh(\\gamma x_i^T x_j + \\mathbf{coef0})K(xi​,xj​)=tanh(γxiT​xj​+coef0) 指数 CHI2 核：K(xi,xj)=e−γχ2(xi,xj),χ2(xi,xj)=(xi−xj)2/(xi+xj),γ0K(x_i, x_j) = e^{-\\gamma \\chi^2(x_i,x_j)},\\ \\chi^2(x_i,x_j) = (x_i-x_j)^2/(x_i+x_j),\\ \\gamma 0K(xi​,xj​)=e−γχ2(xi​,xj​),χ2(xi​,xj​)=(xi​−xj​)2/(xi​+xj​),γ0 直方图相交核：K(xi,xj)=min(xi,xj)K(x_i, x_j) = min(x_i,x_j)K(xi​,xj​)=min(xi​,xj​) 上述的超参： γ\\gammaγ：通过 SVM::setGamma(double val) 和 SVM::getGamma() 访问。 coef0\\mathbf{coef0}coef0：通过 SVM::setCoef0(double val) 和 SVM::getCoef0() 访问。 degree\\mathbf{degree}degree：通过 SVM::setDegree(int val) 和 SVM::getDegree() 访问。 关于迭代设置函数：setTermCriteria(const cv::TermCriteria val)： 该类变量需要3个参数：类型、迭代的最大次数、特定的阈值。 类型：迭代的最大次数 TermCriteria::MAX_ITER 、特定的阈值（期望精度） TermCriteria::EPS 或 MAX_ITER + EPS。 还有关于 SVM::trainAuto(...)，函数如下： bool trainAuto( const PtrTrainData data, int kFold = 10, ParamGrid Cgrid = getDefaultGrid(C), ParamGrid gammaGrid = getDefaultGrid(GAMMA), ParamGrid pGrid = getDefaultGrid(P), ParamGrid nuGrid = getDefaultGrid(NU), ParamGrid coeffGrid = getDefaultGrid(COEF), ParamGrid degreeGrid = getDefaultGrid(DEGREE), bool balanced=false) = 0; 该方法通过选择最佳参数 CCC、γ\\gammaγ、ppp、ν uν、coef0\\mathbf{coef0}coef0、degree\\mathbf{degree}degree 来自动训练 SVM 模型。当测试集误差的交叉验证估计值最小时，参数被认为是最佳的。 如果不需要优化参数，则应将相应的网格步长设置为小于或等于1的任何值。 data：训练集； kFold：交叉验证参数。训练集被划分为kFold子集。一个子集用于测试模型，其他子集形成训练集； Cgrid：参数 CCC 的网格； gammaGrid：参数 γ\\gammaγ 的网格； pGrid：参数 ε\\varepsilonε 的网格； nuGrid：参数 ν uν 的网格； coeffGrid：参数 coef0\\mathbf{coef0}coef0 的网格； degreeGrid：参数 degree\\mathbf{degree}degree 的网格； balanced：如果为真且问题是 2 分类，则该方法创建更平衡的交叉验证子集，即子集中的类之间的比例接近整个训练数据集中的比例。 类似地，该函数重载还有： bool trainAuto(InputArray samples, int layout, InputArray responses, int kFold = 10, PtrParamGrid Cgrid = SVM::getDefaultGridPtr(SVM::C), PtrParamGrid gammaGrid = SVM::getDefaultGridPtr(SVM::GAMMA), PtrParamGrid pGrid = SVM::getDefaultGridPtr(SVM::P), PtrParamGrid nuGrid = SVM::getDefaultGridPtr(SVM::NU), PtrParamGrid coeffGrid = SVM::getDefaultGridPtr(SVM::COEF), PtrParamGrid degreeGrid = SVM::getDefaultGridPtr(SVM::DEGREE), bool balanced=false) = 0; 例子-香蕉数据集 数据集地址：https://sci2s.ugr.es/keel/dataset.php?cod=182 该数据集十分简单，只有两个属性和一个标签。 属性 At1 和 At2：分别对应于x轴和y轴的两个属性。 标签 -1 和 +1：表示数据集中的两种香蕉形状之一。 部分数据如下表： At1 At2 Class 0.174 1.92 -1.0 1.64 0.0477 -1.0 -0.478 -0.796 -1.0 -0.447 -1.0 -1.0 -1.04 -0.2 1.0 2.06 -0.482 -1.0 使用 OpenCV 提供的 SVM 模型效果如下： Train Data imported: 5100Test Data imported: 200SVM算法(基于OpenCV实现)：计算花费时长：131ms正确率：0.915 代码地址：Gitee - SVM","tags":[null,null]},{"path":"/wiki/style_transfer/abstract.html","content":"摘要 随着信息技术的发展，图像风格迁移技术在艺术创作、影视特效、文创设计等领域展现出重要价值。近年来出现了很多基于深度学习的风格迁移方法，它们相比传统方法提高了图像风格迁移的质量，但仍存在风格化不明显以及细节丢失或模糊的问题。 本文基于元学习理念和现有的MetaNet模型展开研究，旨在通过改进算法，提升图像风格迁移的效果与效率。改进方法包括优化特征提取、改良图像转换网络结构，以及引入注意力机制。在特征提取中，采用预训练的VGG-19替代VGG-16，增强对深层风格特征的捕捉能力；在图像转换网络中，改进下采样和上采样的操作确保输入输出图像尺寸一致，并引入实例归一化层以保留图像细节特征。在元学习器中，分别引入通道注意力、自注意力和Transformer 模块，验证对通道间依赖、长距离特征关联的建模能力的提升效果。 实验过程中采用MS COCO 2017测试集与WikiArt数据集的子集展开训练，并通过客观指标和主观的人工打分方式综合评估模型。实验纵向对比分析了多个超参数对迁移效果产生的影响，从而确定最优模型。横向方面，与AdaIN、MSG-Net、StyleID等主流风格迁移算法展开对比。本文改进模型在风格相似度评估上优于其他对比模型，得分最高达0.733，并且在推演效率上具有优势，尤其在实时交互场景中表现突出，充分证实了本文方法的有效性。 关键词：深度学习；风格迁移；元学习；注意力机制 Abstract With the development of information technology, image style transfer technology shows important value in the fields of art creation, film and television special effects, and cultural and creative design. In recent years, many deep learning-based style transfer methods have appeared, which improve the quality of image style transfer compared with the traditional methods, but still have the problems of inconspicuous stylization and loss or blurring of details. In this paper, based on the concept of meta-learning and the existing MetaNet model, we aim to improve the effectiveness and efficiency of image style transfer by improving the algorithm. The improvement methods include optimizing feature extraction, improving the image transformation network structure, and introducing the attention mechanism. In feature extraction, pre-trained VGG-19 is used instead of VGG-16 to enhance the ability to capture deep style features; in the image conversion network, the operations of down-sampling and up-sampling are improved to ensure that the input and output image sizes are the same, and an instance normalization layer is introduced to preserve image detail features. In the meta-learner, channel attention, self-attention and Transformer modules are introduced respectively to verify the effect of improving the modeling ability for inter-channel dependency and long-range feature association. A subset of MS COCO 2017 test set and WikiArt dataset is used to start the training during the experiment, and the model is evaluated comprehensively by objective metrics and subjective manual scoring. The experiment vertically compares and analyzes the impact of multiple hyperparameters on the transfer effect to determine the optimal model. Horizontally, the model is compared with mainstream style transfer algorithms such as AdaIN, MSG-Net, and StyleID. The improved model in this paper outperforms other comparative models in style similarity evaluation, with a score of up to 0.733, and has an advantage in deduction efficiency, especially in real-time interaction scenarios, which fully confirms the effectiveness of this paper’s method. Keywords：Deep Learning; Style Transfer; Meta Learning; Attention Mechanism"},{"title":"总结与展望","path":"/wiki/style_transfer/conclusion.html","content":"5.1 研究总结 早期的图像风格迁移技术主要依赖手工设计特征与数学建模等传统方法实现。这类方法不仅需要研究人员针对不同场景设计复杂处理流程，而且存在开发周期长、人力成本高和迁移效果不佳的问题。在深度学习技术的推动下，基于神经网络的图像风格迁移算法取代了传统方法，能够提升处理效率，并且生成视觉效果更细腻、艺术表现力更强的风格化图像。基于此，本文对基于元学习的深度学习图像风格迁移方法展开研究。具体工作如下： (1)本文首先阐述了研究背景与意义。图像风格迁移技术能够完成在艺术创作、影视特效、文创设计等领域的任务。接着通过梳理传统方法的局限性和深度学习方法的发展脉络，明确了研究的必要性和应用价值。然后本文介绍了图像风格迁移相关的理论基础，为后续模型改进和实验设计提供了理论支撑。 (2)提出了一种基于改进的 MetaNet图像风格迁移算法。在元学习理论的基础上对MetaNet 进行改进，在特征提取方面采用深度更深的预训练VGG-19模型代替原来的预训练VGG-16模型，增强模型对复杂风格图像的纹理和色彩分布的表达能力。同时改进图像转换网络的结构，通过引入最大池化层代替原来的固定步幅卷积下采样，结合双线性插值动态恢复空间尺寸的上采样方法，并且使用实例归一化层增强模型的特征学习能力。此外，本文尝试在元学习器中引入基础通道注意力模块、增强通道注意力模块、自注意力模块和Transformer四种注意力模块，加强训练过程中深层图像空间的表达，减少内容特征和风格特征的丢失，提高图像风格迁移效果。 (3)使用COCO 2017测试数据集和WikiArt数据集子集进行模型训练。通过设计多组对比实验，从注意力机制类型、VGG版本、轮换批次、批次大小等不同的超参数出发进行纵向对比，也与AdaIN、MSG-Net和StyleID等主流风格迁移算法进行横向对比。实验中采用SSIM结构相似性指数、PSNR峰值信噪比、风格Gram矩阵余弦相似度等客观指标，结合人工视觉评分，定量分析生成图像的内容保留度和风格匹配度。结果表明，改进后的算法在风格Gram矩阵余弦相似度指标上高于基线模型和其他对比算法，证明其对风格特征的捕捉能力更强；同时，在SSIM和PSNR指标上保持稳定，说明内容结构未因风格迁移而严重失真，综合性能优于部分现有方法，验证了改进策略的有效性和优越性。在人工视觉评分上，基于扩散模型的StyleID方法得分高于本文的改进方法及其他方法，图像风格迁移效果更出色。然而StyleID方法需要较长的推演时间，达到本研究改进方法所需时间的31倍。另外，StyleID方法还需对输入的内容图像和风格图像执行预计算操作，占用大量额外存储空间。与之相比，本研究方法无需预计算步骤，直接通过元学习器动态 生成转换网络参数，在保持高效推理速度的同时避免了额外存储开销，在实际应用中更具部署优势。 5.2 研究展望 本文以图像风格迁移作为研究领域，深入研究与分析基于深度学习的图像风格迁移方法，并提出基于MetaNet的改进算法。实验结果表明，相较于基线模型与主流方法，本文算法在风格迁移结果图像的质量与效果上均实现显著提升。但未来研究仍存在一些改进的方向： (1)图像风格迁移领域尚未形成统一且标准化的评价指标体系。作为人工智能领域的重要研究方向，图像风格迁移算法的科学性亟需一套严谨、可量化的评估标准予以支撑。然而，现阶段的效果评估主要依赖主观评分与传统客观质量评估指标。传统图像质量评估指标难以较好地衡量风格迁移任务中内容保留与风格重构的复杂特性；另外，主观的审美认知受个体影响较大，使得主观评价结果难以形成普适性结论。 (2)风格迁移效果与基于扩散模型的风格迁移相比仍有明显差距。基于扩散模型的风格迁移能够更细腻地实现风格与内容的融合，生成图像的视觉效果更具真实感和艺术感，而本文改进的风格迁移方法在色彩过渡、纹理细节的呈现以及风格与内容的自然融合度等方面均存在不足，距离基于扩散模型的风格迁移水平尚有一段距离。 (3)本研究缺乏图像风格迁移系统的实现和多模态融合。对算法改进但未落地成实际应用系统，后续研究可尝试构建图像风格迁移系统，整合文本描述、视频序列等多模态输入，以语义导向为核心优化风格迁移过程，进而满足多元场景的应用需求。"},{"title":"实验与评估","path":"/wiki/style_transfer/experiment.html","content":"4.1 实验设置 4.1.1 数据集介绍 本研究的实验中内容图像数据选用Microsoft COCO 2017数据集中的测试集，风格图像数据使用WikiArt数据集的子集。 Microsoft COCO 2017 是微软团队提供的一个用于进行图像识别的数据集，覆盖人、汽车、动物等多个物体类别和天空、草地、建筑等多种背景。COCO全称Common Objects in Context，实验中使用的 COCO 2017 test 数据集由 40670 张高度真实且场景复杂图像组成^[38]^。Microsoft COCO 2017 数据集多样的物体以及丰富的背景可以为图像风格迁移提供有力的内容图像支持。 WikiArt 数据集是一个非营利性的线上艺术博物馆项目。目前为止，数据集已经收录了3293位艺术家的169057件画作，包括61个流派。实验中使用的Wikiart数据集子集包括80000张图片，涉及抽象表现主义、巴罗克风格、流行艺术、现实主义、印象主义、文艺复兴盛期和晚期等20个流派。WikiArt数据集记录了许多艺术家的真实画作，为图像风格迁移提供了有效的风格图像支持。 4.1.2 实验环境配置 本文中的所有实验均依托超算互联网平台。在训练过程中，硬件层面CPU使用的是Hygon C86 7285 型号的 32 核处理器，浮点计算使用异构加速卡，加速卡类型为DCU，显存16GB；软件方面，配置DTK 25.04开发工具包、PyTorch 2.4.1深度学习框架及Python 3.10编程语言环境。 在整个训练过程中总共执行100次迭代。训练中采用余弦退火动态学习率调整策略，初始学习率设置为0.001，最小学习率设置为0.00001，可以保证训练的稳定性，提高模型的收敛效率。选择Adam优化器，能够提高了训练过程的稳定性和收敛速度。标准情况下，内容损失权重设置为1，风格损失权重设置为150，总变异损失权重设置为0.00001。 除了上述的迭代轮次、学习率、优化器、内容损失权重、风格损失权重之外，本文实验的超参数变量还有VGG模型的版本(16还是19)、批次大小、轮换风格图像的轮次、图像转换网络卷积层的通道基数base、是否引入注意力机制以及注意力机制的种类。 4.1.3 评估指标 实验的评估主要采用客观的SSIM指标、PSNR指标、风格特征Gram矩阵余弦相似度、主观的人工视觉判别意见得分以及模型推演速度作为图像风格迁移生成图像质量和效率的评价标准。前两者SSIM指标和PSNR指标用于评估风格迁移在内容上的性能，风格特征Gram矩阵余弦相似度和主观人工评分则用于评估风格迁移在风格上的性能。 SSIM(Structural Similarity)指的是结构相似性指数，用于衡量两幅图像在亮度(均值)、色彩对比度(方差)与结构(协方差)三个维度上的相似性，取值范围为-1到1，值越接近1表示两幅图像越相似。对于亮度的计算如式4.1，色彩对比度的计算如式4.2，结构相似计算如式4.3，其中，I(x,y)I(x,y)I(x,y) 表示图像的亮度特征，c(x,y)c(x,y)c(x,y) 表示图像的色彩对比度特征，s(x,y)s(x,y)s(x,y) 表示图像的结构特征，μx\\mu_xμx​ 和 μy\\mu_yμy​ 分别表示图像x和y的均值，σx\\sigma_xσx​ 和 σy\\sigma_yσy​ 分别表示图像x和y的方差，σxy\\sigma_{xy}σxy​ 表示图像x和y的协方差，C1C_1C1​、C2C_2C2​ 和 C3C_3C3​ 都为常数。 I(x,y)=2μxμy+C1μx2+μy2+C1(4.1)I(x,y)=\\frac {2 \\mu_x \\mu_y + C_1} {\\mu_x^2 + \\mu_y^2 + C_1}\\tag{4.1} I(x,y)=μx2​+μy2​+C1​2μx​μy​+C1​​(4.1) c(x,y)=2σxy+C2σx2+σy2+C2(4.2)c(x,y)=\\frac {2 \\sigma_{xy} + C_2}{\\sigma_x^2 + \\sigma_y^2 + C_2}\\tag{4.2} c(x,y)=σx2​+σy2​+C2​2σxy​+C2​​(4.2) s(x,y)=σxy+C3σxσy+C3(4.3)s(x,y)=\\frac {\\sigma_{xy} + C_3}{\\sigma_x \\sigma_y + C_3}\\tag{4.3} s(x,y)=σx​σy​+C3​σxy​+C3​​(4.3) PSNR(Peak Signal-to-Noise Ratio)指的是峰值信噪比，通过量化生成图像与原图像的像素级差异从而评估生成质量。PSNR的数学定义如公式4.4所示，其中 III 为内容图像，JJJ 为迁移图像，MAXIMAX_IMAXI​ 表示图像像素的最大可能值，MSEMSEMSE 表示均方误差。PSNR的值越高，说明像素差异越小，图像的结构则越接近原内容图像。PSNR能够有效捕捉迁移后图像与内容图像在轮廓、物体布局等低频结构上的一致性。例如，当风格迁移模型过度扭曲内容结构时，PSNR会显著下降，从而在内容保留方面提供客观量化依据。 PSNR=10log⁡10MAXI2MSE(4.4)PSNR=10\\log_{10}\\frac{MAX_I^2}{MSE}\\tag{4.4} PSNR=10log10​MSEMAXI2​​(4.4) MSE=1mn∑i=1m−1∑j=1n−1(I(i,j)−J(i,j))2(4.5)MSE=\\frac {1}{mn}\\sum_{i=1}^{m-1}\\sum_{j=1}^{n-1}(I(i,j)-J(i,j))^2\\tag{4.5} MSE=mn1​i=1∑m−1​j=1∑n−1​(I(i,j)−J(i,j))2(4.5) 风格Gram矩阵余弦相似度(Style Gram Matrix Cosine Similarity)是一种评估两幅图像风格相似性的指标，本文中简称为SGMCS，下同。该指标的计算流程如下。首先，通过预训练的VGG-19卷积神经网络模型提取风格图像和迁移后图像的某些层输出作为风格特征。接着对提取到的风格特征计算Gram矩阵。Gram矩阵的每个元素表示特征图中不同通道之间的内积，可以反映特征通道之间的相关性，能够有效表示图像的风格信息。然后将Gram矩阵其展平为一维向量，计算风格迁移后图像跟原风格图像的一维向量的余弦相似度。SGMCS的计算表达式如公式4.6，其中Gram的计算如公式4.7，ϵ\\epsilonϵ 为极小常数，此处取值为避免分母为0。Gram计算公式中输入为 I∈RC×H×WI\\in\\mathbb{R}^{C\\times H\\times W}I∈RC×H×W，重塑后 I′∈RC×(H×W)I'\\in\\mathbb{R}^{C\\times(H\\times W)}I′∈RC×(H×W)。SGMCS的计算结果范围在[-1,1]之间，值越接近1，表示两幅图像的风格相似度越高；值越接近-1，表示风格越是相反；值为0则表示两者风格完全不相关。 SGMCS(Is,It)=Gram(Is)⋅Gram(It)∥Gram(Is)∥∥Gram(It)∥+ϵ(4.6)\\text{SGMCS}(I_s, I_t) = \\frac {Gram(I_s)\\cdot Gram(I_t)}{\\Vert Gram(I_s)\\Vert \\Vert Gram(I_t)\\Vert + \\epsilon}\\tag{4.6} SGMCS(Is​,It​)=∥Gram(Is​)∥∥Gram(It​)∥+ϵGram(Is​)⋅Gram(It​)​(4.6) Gram(I)=I′⋅I′T(4.7)Gram(I) = I' \\cdot I'^T\\tag{4.7} Gram(I)=I′⋅I′T(4.7) 主观的人工视觉判别得分是由人类主观的评价得到。实验中选取若干个风格图像样本和内容图像样本进行图像风格迁移，然后评分员对风格迁移后的图像进行评分。分值范围从0到10分，其中0分表示质量最差，表示可能出现严重的语义扭曲、风格特征完全缺失或存在显著伪影；10分表示质量最好，表示迁移效果理想。在得到一系列评分数据后，人为剔除异常评分以保证数据有效性。最终评估指标通过计算有效评分的算术平均值获得，即某风格迁移方法的最终得分为所有评分员对该方法生成图像评分的均值。 模型推演速度SPI(Second Per Image)指的是单张图像从读取、处理到输出所需要的时间，可以衡量模型从输入内容图像、风格图像到输出风格迁移图像的效率。SPI的计算过程如公式4.7。模型推演速度受模型结构的复杂度、硬件环境、软件环境等因素影响，仅供参考。在实验设计中加入模型推演速度的评估，将模型聚焦于实时交互场景和边缘设备部署等方面，保证风格迁移效果的同时降低图像风格迁移所占用的时间。本章中模型推演速度的测试环境配置如下：处理器为16 vCPU的Intel ® Xeon ® Platinum 8474C，显卡采用RTX 4090D(显存24GB)，内存容量80GB，操作系统为Ubuntu22.04，软件环境为Python3.12、PyTorch2.5.1及CUDA12.4。 4.2 实验流程 本文实验包括网络的训练、网络参数调整以及与其他图像风格迁移算法的比较分析。 本文元网络训练流程如图4.1所示。训练开始时初始化VGG模型、图像转换网络和元学习器。在训练过程中，模型按照设定的轮次进行循环训练。在每一轮中，内容图像数据集被划分为指定批次大小的若干个小批量输入到网络中进行训练。每间隔固定的批次数，随机选取一张新的风格图像提取风格特征，用于训练学习当前阶段风格的迁移。在每个批次中，模型对该批次的内容图像进行风格迁移，并与原内容图像和原风格图像计算内容损失、风格损失，以及与自身计算总变分损失。随后，模型根据计算的损失利用优化器优化模型参数，从而降低模型损失，提升图像风格迁移的效果。 图4.1训练流程 4.3 纵向对比 纵向对比主要针对网络自身的不同参数取值所产生的效果进行对比。本节对于MetaNet的实验固定迭代轮次为100，固定使用余弦退火动态调整学习率和Adam优化器，其余参数如风格损失权重、VGG模型的版本(16还是19)、批次大小、轮换风格图像的轮次、图像转换网络卷积层的通道基数base、是否引入注意力机制以及注意力机制的种类都作为变量进行实现对比分析结果。实验使用10张风格图像和500张内容图像，共生成5000张迁移图像。在此基础上计算结构相似性指数、峰值信噪比指数、Gram特征余弦相似度和FID指数。 其中基线模型的参数为：无注意力机制，特征提取网络选用VGG-16模型，风格损失权重设置为50，内容损失权重设置为1，总变分损失权重为1e-6，批次大小设定为8，每20批次内容图像轮换一次风格图像，图像转换网络初始通道基数base设置为8。 4.3.1 风格损失权重影响实验 针对风格损失权重进行对比实验，分别取值为50、100、150、200。实验中，添加基础通道注意力模块，图像转换网络初始通道基数base设置为32，其余参数同基线模型的参数。各个模型训练时长和所占资源相近，实验指标情况如表4-1所示，其中模型名字简称为风格损失权重的取值。 从表4-1可知，随着风格损失权重逐步提升，SSIM指标从初始的0.441下降至0.338，表明原内容图像与风格迁移后的图像在结构上的相似度越来越低。SSIM指标的下降可能是因为风格损失权重的增加，使得风格在迁移中的占比越来越大，内容细节在迁移过程中可能被忽视。而PSNR指标数值稳定地维持在27.89至27.94区间内，波动幅度较小，图像的整体保真度并未受到显著影响。风格Gram矩阵余弦相似度同样随着风格损失权重的升高而升高，与预期的理论表现高度契合。推演速度无明显差异，说明风格损失权重的调整对计算效率影响较小。 表4-1风格损失权重实验结果 模型 SSIM PSNR SGMCS SPI 人工评分 50 0.441457 27.919930 0.686667 0.155095 4.1 100 0.366497 27.939641 0.697833 0.149371 6.6 150 0.362293 27.889932 0.696696 0.148403 6.5 200 0.337894 27.901066 0.701731 0.152467 7.3 图4.2风格损失权重不同取值效果对比 4.3.2 注意力机制的种类影响实验 针对注意力机制模块的种类进行对比实验，分别设置为基础通道注意力模块、增强通道注意力模块、自注意力机模块和Transformer模块。实验中，无注意力机制的模型为基线模型，其余的参数同基线模型的参数。实验指标情况如表4-2，其中模型名字简称为注意力机制的种类。 从表4-2可知，在SSIM指标和PSNR指标上，添加基础通道注意力模块的模型的SSIM指标相比基线模型提升了3.96%，PSNR指标提升了0.21%，表明基础通道注意力模块能够有效捕捉并还原图像中的细节；而添加增强通道注意力的模型的SSIM指标增幅比添加基础通道注意力的模型低，内容相似度有所下降。添加Transformer的模型PSNR指标为所有模型最高，但SSIM指标略高于基线，表明Transformer提升了图像整体亮度和对比度的稳定性，但在局部细节的处理上未能显著优于其他注意力模型。在风格Gram矩阵余弦相似度上，添加增强通道注意力的模型高于其他所有模型，可能是因为增强了通道注意力的强度，使得模型更注重风格的特征，从而提升了风格的匹配度。添加Transformer的模型在该项上得分在所有模型中最低，表明该模型更侧重于图像内容而非风格纹理，风格相似度显著降低。添加自注意力的模型整体表现不佳。究其原因，可能是自注意力机制在建模长距离依赖时，可能因计算参数冗余或参数解析能力不足，反而降低了图像局部结构的还原效果，需进一步优化。综合SSIM指标和风格Gram矩阵余弦相似度指标来看，添加各种注意力机制能够在风格迁移效果大致不变的情况下，有效保留原内容图像中的内容特征。 表4-2注意力机制实验结果 模型 SSIM PSNR SGMCS SPI 人工评分 无注意力(基线模型) 0.408205 27.879501 0.610139 0.148580 5.3 基础通道注意力 0.424355 27.938609 0.609673 0.154184 5.7 增强通道注意力 0.411272 27.961223 0.610794 0.158146 7.1 自注意力 0.391212 27.889798 0.605021 0.154176 6.4 Transformer 0.410037 27.964593 0.593184 0.158225 4.1 4.3.3 VGG模型影响实验 针对VGG模型的不同选择，分别使用VGG-16和VGG-19进行实验，比较图像风格迁移效果。实验中添加了基础通道注意力模块，风格损失权重设置为100，图像转换网络通道基数base设置为32，其余参数同基线模型的参数。 实验指标情况如表4-3所示。基于预训练的VGG-19模型的SSIM指标略高于基于预训练VGG-16的模型。但是两者指标的数值相差不大，可以认为在保留图像结构细节上的能力接近。另外，这两个模型的PSNR指标相近，可以认为VGG模型并不影响峰值信噪比。在风格Gram矩阵余弦相似度指标上，基于预训练的VGG-19模型的高于基于预训练VGG-16的模型，说明预训练的VGG-19模型在提取风格特征上更具有优势，可能是因为VGG-19具有更深的网络结构，能够提取更深层的风格特征。 表4-3VGG模型实验结果 模型 SSIM PSNR SGMCS SPI 人工评分 VGG-16 0.366508 27.939701 0.643284 0.154881 6.4 VGG-19 0.367502 27.939578 0.653839 0.153120 6.7 图4.3不同VGG模型效果对比 4.3.4 图像转换网络通道基数影响实验 针对图像转换网络通道基数base进行对比实验，分成两组进行实验，表4-5中模型名字为批次大小以及组别，如“8(1)”表示第一组中图像转换网络通道基数base取值为8的情况。第一组无特别参数设置，“8(1)”即基线模型；第二组添加基础通道注意力模块，其余参数同基线模型。 图像转换网络通道基数base直接影响图像转换网络的结构复杂度，也间接影响了元学习器的模型参数量。参数量影响模型的大小。表4-4给出了base与图像转换网络和元学习器之间参数量的关系。当base为32时，元学习器的参数量是base为8时参数量的13倍，图像转换网络的参数量是base为8时参数量的15倍。 实验指标情况如表4-5所示。各个模型的PSNR指标基本保持在较小的区间内浮动。在SSIM指标和风格Gram矩阵余弦相似度上，无论是第一组还是第二组，图像转换网络通道基数base为32的模型得分都高于base为8的模型，说明通道基数base的增加能够有效提高模型保留原内容图像中内容信息的能力以及迁移原风格图像中风格纹理特征的能力。但从推演速度来看，由于base的增加，导致模型复杂度增加，推理运算时长增加。总而言之，增加通道数可能增强模型对图像中复杂结构和特征的捕获能力，进而提升内容保留和风格迁移效果，但同时需要承担推理速度下降的代价，在实际应用中需根据对模型性能和速度的具体需求进行权衡。 虽然base为32的模型的性能较强，但是从模型参数量和模型推演速度来看，应该结合计算资源、模型训练效率及任务性能需求综合权衡，避免因过度追求通道基数导致参数量爆炸而引发的优化困难或部署成本上升。 表4-4通道基数影响网络参数量 图像转换网络通道基数 图像转换网络参数量 元学习器参数量 8 107,971 16,867,720 32 1,676,035 220,797,600 表4-5图像转换网络通道基数实验结果 模型 SSIM PSNR SGMCS SPI 人工评分 8(1) 0.408205 27.879501 0.610139 0.148580 5.9 32(1) 0.434521 27.904213 0.630926 0.159106 6.4 8(2) 0.424355 27.938609 0.609673 0.155636 6.1 32(2) 0.441471 27.919928 0.627995 0.162235 5.7 图4.4不同base效果对比 4.3.5 轮换批次影响实验 轮换批次指的是训练中每隔多少批次更换一次风格图像进行学习。针对训练过程中的轮换批次进行对比实验，分别取值为10和20。实验中，添加基础通道注意力模块，风格损失权重设置为150，图像转换网络通道基数base设置为32，其余参数同基线模型的参数。实验指标情况如表4-6所示，其中模型名字简称为轮换批次的取值。 由表4-6可知，每10批次轮换一次风格图像比每20批次轮换一次风格图像在风格Gram矩阵余弦相似度上得分高2.9%。这在数据集总样本数不变的情况下，提高风格图像的轮换频率能够使得模型学习到更多种类的风格样本，从而提高模型的迁移泛化能力。而随着风格迁移的效果的提升，SSIM指标会相应降低，对原内容图像结构细节的保留能力下降。此外，实验中两者的SPI指标没有显著变化，说明风格图像轮换频率的调整仅影响模型训练过程中对风格特征的学习策略，并未改变模型本身的网络结构，因此不影响模型的原来的复杂度。 表4-6轮换批次实验结果 模型 SSIM PSNR SGMCS SPI 人工评分 10 0.353660 27.893030 0.660653 0.158067 7.8 20 0.362311 27.890001 0.641875 0.156689 6.5 图4.5不同轮换批次效果对比 4.3.6 批次大小影响实验 批次大小指的是在一次梯度更新中所使用的样本数量。针对批次大小进行对比实验，分成两组取值，表4-7和表4-8中模型名字为批次大小以及组别，如“4(1)”表示第一组中批次大小取值为4的情况。第一组基于VGG-19预训练模型，添加Transformer模块，风格损失权重设置为150；第二组添加基础通道注意力模块，风格损失权重设置为100，其余参数同基线模型。 批次大小参数直接影响训练的过程，在总样本数一致的情况下，更大的批次大小意味着更新梯度频次更少，所以还需考虑训练所需时长。训练时长基于本章4.1小节中实验设置的环境下测量，由表4-7可知批次大小越小，训练时长越长。在第一组中，批次大小为4的模型训练时长甚至比批次大小为8的模型长了11小时。 实验指标情况如表4-8所示。对于SSIM指标，第一组的批次大小从4扩大到8时，指标提升3.9%；第二组的批次大小从8扩大到16时，指标提升了5.2%。这说明更大的批次大小使得模型处理了更多的内容样本，模型能够花费更多精力地学习内容图像的结构特征，从而更好地保留原内容图像的细节信息。但是对于风格Gram矩阵余弦相似度而言，第一组的指标下降了1%，第二组的指标下降了0.8%。这说明批次大小增加会导致模型在风格特征学习上出现一定程度的弱化。这种情况可能是因为在数据集总样本数不变的情况下，批次大小越大，每一轮所迭代的次数越少，能够轮换学习的新风格图像越少，模型对风格特征的学习不够充分。综合可得，增大批次大小能够增强模型对内容结构的学习能力，但因减少迭代次数和风格样本的接触频率，导致风格特征学习的效果下降。 表4-7批次大小与训练时长 模型 训练时长 4(1) 2天3小时18分钟 8(1) 1天16小时19分钟 8(2) 1天11小时56分钟 16(2) 1天9小时26分钟 表4-8批次大小实验结果 模型 SSIM PSNR SGMCS SPI 人工评分 4(1) 0.343987 27.881804 0.681195 0.158763 8.0 8(1) 0.357377 27.879289 0.674350 0.161896 7.7 8(2) 0.366508 27.939701 0.643284 0.156573 6.6 16(2) 0.385595 27.999234 0.638068 0.158555 5.2 4.4 横向对比 本小节对多个模型展开横向对比分析，进行对比的模型包括基线模型、本文改进模型、AdaIN方法、MSG-Net方法以及StyleID方法[39]。 基准模型被定义为未经任何特定参数调整的原始模型，基于Shen的思想实现。经过重复实验后，用于横向对比的本文改进模型的参数设置为：添加Transformer模块，特征提取网络选用VGG-19模型，风格损失权重设置为200，内容损失权重设置为1，总变分损失权重设置为10-6，批次大小设定为4，每10批次内容图像轮换一次风格图像，图像转换网络初始通道基数base设置为32。 AdaIN(Adaptive Instance Normalization)方法意为自适应实例归一化，通过将内容图像的特征进行实例归一化处理后，再用风格图像的均值和方差替换内容特征的对应统计量。p MSG-Net(Multi-style Generative Network)是一种多风格生成网络，通过Siamese网络提取多尺度Gram矩阵，再使用CoMatch层匹配风格Gram矩阵，实现风格迁移。 StyleID(Style Injection in Diffusion)是一种基于扩散模型的方法，不进行训练，直接微调扩散模型进行快速风格迁移。 表4-9横向对比评估指标 模型 SSIM PSNR SGMCS SPI 人工评分 基线模型 0.408205 27.879501 0.610139 0.148580 5.3 本文改进方法 0.330672 27.886268 0.733233 0.171477 8.4 AdaIN 0.102123 27.901968 0.720675 0.065824 8.3 MSG-Net 0.065857 27.889683 0.629356 0.383283 8.0 StyleID 0.144267 27.911183 0.674784 7.259386 9.3 各模型间的对比结果如表4-9所示。在SSIM指标上，基线模型得分最高，说明它在保留原始内容方面的卓越表现。另一方面，AdaIN、MSG-Net、StyleID等方法的得分均低于0.15，这可能是因为风格迁移过程中风格对图像的亮度、对比度产生了明显的变化，与原内容图像的亮度、对比度相差甚远，从而导致SSIM指标得分偏低。同时也存在另一种可能性，即SSIM指标在图像风格迁移任务中存在评估局限性，无法全面精准地衡量风格迁移后的图像质量。在PSNR指标上，所有模型的得分接近，说明各个模型在降噪能力层面的表现差异并不显著，处于同一水平区间。在风格Gram矩阵余弦相似度上，本文提出的改进方法得分最高，说明该模型迁移后的风格与原风格相似度最大，学习到的风格图像特征更贴切全面。其他模型的得分不理想，但是结合表4-9的人工评分和图4.6的结果分析，可能是因为该指标的特征计算方式可能存在片面性，未能合理评估风格迁移任务中的效果，导致一些风格迁移效果良好的模型在该指标中未能得到理想分数。在推演速度上，AdaIN模型速度最快；本文改进方法在提升风格迁移效果的同时也保持可观的推演效率；而StyleID模型的推演速度最慢，说明基于扩散模型的图像风格迁移方法在计算过程中较为复杂。另外StyleID需要大量的预计算空间，如一个由10张内容图像和12张风格图像组成近4MB空间大小的图像风格迁移任务需要70GB左右的存储空间进行存储预计算量，且在推演过程中显存占用高达20GB。这进一步说明基于扩散模型的图像风格迁移方法需要更强大的硬件存储和计算资源。 本文改进方法模型的更多结果如图4.7和图4.8所示。迁移所使用的内容图像为校内建筑景色，风格则选取经典的艺术画作。通过本文的改进风格迁移模型，将校园景色分别呈现出不同风格。总体来看，风格迁移技术通过改变色彩、笔触、纹理等元素，使同一内容图像展现出从抽象到写实、古典到现代等多样艺术风格，具备丰富的视觉表现力与艺术模仿能力。 图4.6各模型间迁移对比 图4.7本研究改进模型迁移效果1 图4.8本研究改进模型迁移效果2 4.5 本章小结 本章介绍了本文改进模型的训练环境、训练流程，并展开评估对比分析。 实验依托超算互联网平台，使用Hygon处理器和DCU加速卡，基于PyTorch框架实现算法。训练采用Microsoft COCO 2017 test数据集作为内容图像，WikiArt数据集子集作为风格图像。在评估环节中，采用SSIM指标和PSNR指标衡量风格迁移前后图像内容的相似性，采用风格Gram矩阵余弦相似度评估风格的相似度，采用推演速度评估模型效率，同时引入人工主观评分对图像质量进行全面评估。 在模型评估对比部分，将风格损失权重、注意力机制、VGG模型版本、图像转换网络通道基数、轮换批次和批次大小作为变量进行实验，分别评估每个变量对风格迁移效果的影响。最后，与AdaIN、MSG-Net、StyleID等方法进行横向对比，展示本文改进模型在风格迁移效果上的优越性。 本章通过系统性实验验证了模型设计的有效性，揭示了关键超参数对风格迁移效果的影响效果，为模型优化提供了数据支撑。未来可进一步探索轻量化网络结构、动态调整损失权重策略，或结合更复杂注意力机制，以在边缘设备部署、实时交互等场景中实现更优性能。 [38] Lin T Y, Maire M, Belongie S, et al. Microsoft COCO Common Objects in Context[M/OL]//Computer Vision – ECCV 2014,Lecture Notes in Computer Science. 2014 740-755. [39] Chung J, Hyun S, Heo J P. Style Injection in Diffusion: A Training-free Approach for Adapting Large-scale Diffusion Models for Style Transfer[C]// roceedings of the IEEE/CVF conference on computer vision and pattern recognition. 2024 8795-8805."},{"title":"基于深度学习的图像风格迁移算法研究","path":"/wiki/style_transfer/index.html","content":"2025届毕业设计课题，Fingsinz [项目文档] [项目代码]"},{"title":"绪论","path":"/wiki/style_transfer/introduction.html","content":"1.1 课题研究背景及意义 随着信息技术的高速发展，当今社会信息的呈现方式日益多样化，图像已经成为一种至关重要的信息载体。人们的手机、相机等设备都可以获取大量的图像数据，自然而然地也产生了对图像数据处理的需求。计算机技术、数字图像处理技术以及深度学习技术的发展为图像处理领域的研究提供了强大的技术支持。 图像风格迁移技术的目的是将一张内容图像从原始风格转换成特定图像的风格。 图像风格是指一幅图像所呈现出的视觉特征，如色彩、纹理、笔触等。不同的色彩搭配能够营造出迥异的氛围与情感基调，如梵高的《星月夜》中浓郁且对比强烈的蓝、黄色彩，赋予画面神秘而奇幻的风格；纹理体现图像表面的细腻质感，像古典油画中厚重的笔触纹理、木质材料的天然木纹纹理等；笔触反映了创作者的绘画手法，细腻流畅或粗犷豪放的笔触能传达出截然不同的艺术韵味，例如中国传统水墨画中灵动多变的笔墨笔触。 图像内容指的是一幅图像所描绘的具体对象、场景及其布局结构。内容包括图像中的人物、物体、风景等实体元素以及这些元素之间的空间关系与组合方式。这些元素共同传达出画面的主题，也是图像语义理解的关键所在。 图1.1风格图像迁移示例 在图像风格迁移的过程中，图像的风格与内容具有一定程度的相对独立性，所以能够将一种风格图像的风格特征抽取出来，并迁移至具有不同内容的另一幅图像上。如图 1.1所示，将世界名画梵高的《星月夜》画作与校园的景色相融合，既保留原内容中校园建筑和道路主体，同时融入了梵高的风格元素，展现全新风格魅力的视觉效果。 在艺术创作领域上，传统艺术创作受限于艺术家个人的技能、风格和创作工具，图像风格迁移技术的出现打破了艺术风格之间的壁垒，也降低了艺术创作的门槛。人们可以利用这一技术将富含特色的艺术绘画作品的风格应用到自己的照片中，创造出独特的艺术效果和氛围。例如，将自己的自拍照转化成素描画作，或者将现代摄影作品转化为古典油画风格或者山水画风格，或者将抽象画风应用到纪录照片上，拓展艺术创作的可能性，使艺术创作更加普及化、大众化^[1][2][3][4]^。在影视制作中，图像风格迁移可以用于特效制作，例如将现实拍摄下的场景转化为奇幻的动画风格^[5][6]^，或者将拍摄历史场景还原为特定的历史时期风格，增强影视作品的视觉效果和艺术感染力的同时降低制作成本。在医学上，医学图像通常具有高度复杂的结构和丰富的细节信息，通过风格迁移生成的图像既保留了图像的风格，又保留了图像的内容,使得生成的图像更具真实感和可信度^[7]^。此外，图像风格迁移技术还可以应用于文化创意产业领域。以戴娟的相关实践为例^[8]^，她运用图像风格迁移算法，通过将不同艺术风格与大熊猫形象有机融合，不仅为传统的文创设计赋予了崭新的视觉呈现形式，同时也拓展了文化周边产品的文化内涵与艺术感染力，进一步彰显了图像风格迁移算法在各领域应用中的潜力。 1.2 国内外研究现状 目前，图像风格迁移算法的研究可以分为传统风格迁移和基于神经网络的风格迁移两个发展阶段。从图像风格迁移任务实现的维度上来看，又可以分为三个阶段，分别是固定内容的固定风格迁移、任意内容的固定风格迁移和任意内容的任意风格迁移。 1.2.1 传统风格迁移方法 在深度学习兴起之前，传统的风格迁移方法主要基于手工设计算法和人工特征工程等计算机图形学知识实现风格迁移，比如通过数学建模或拼接现有图像的小块补丁进行融合内容与风格特征。这个阶段的图像风格迁移技术局限在固定内容图像或任意内容图像迁移 到固定的风格。 固定的内容图像迁移到固定的风格主要通过传统图像处理技术实现。传统的图像处理技术中，基于滤波的方法有利用高斯滤波、拉普拉斯滤波等线性滤波器提取图像的低频轮廓和高频细节，试图通过调整不同频率成分的分布来模拟风格特征；基于纹理合成技术则通过统计风格图像的纹理模式(如灰度共生矩阵、局部二进制模式等)，在内容图像上复制类似的纹理结构。这些传统处理方法显然需要特殊情况特殊处理，要求研究人员针对特定的内容和风格进行定制分析。例如，在处理风景图像的风格迁移时，可能需要设计专门捕捉云层纹理的滤波器；而在处理人物肖像时，则需调整纹理模板以适配面部特征。这种人工设计的方式暴露出两大核心缺陷：一方面，算法的泛化能力非常弱，每一种新的内容或风格组合都需要重新设计处理流程，不能形成通用的解决方案；另一方面，传统方法仅仅解读图像的浅层视觉特征(如颜色分布、边缘方向、纹理重复模式等)，完全缺乏对图像深层语义的理解。 有的研究人员尝试从不同角度挖掘风格图像中的纹理基元，通过拼接重组生成新图像。Efros等人提出了通过对目标图像的风格纹理进行拼接和重组操作，利用纹理元素之间的组合关系，最终合成全新风格的图像^[9]^。他们的方法能较好地复制风格图像的重复纹理(如砖墙、布料)，但在处理非周期性纹理(如绘画笔触)时，容易出现明显的拼接痕迹。 研究人员们还试图通过模拟绘画的物理过程实现风格迁移。Hertzmann等人提出了图像类比框架进行图像纹理合成，通过建立内容图像与风格图像的局部块对应关系，将风格图像的色彩分布、边缘方向等统计特性迁移到内容图像，可以合成各种艺术绘画风格^[10]^。 然而这些传统方法存在显著的缺陷，它们本质上是人工进行设计不同风格的特征表达，只是提取了图像的底层特征，未能表达图像的高层抽象特征。当遇到颜色和纹理复杂的图像时，生成的图像风格效果粗糙，不能满足如今高质量图像的需求。 1.2.2 神经网络风格迁移方法 随着深度学习技术的逐渐发展以及人们对图像质量要求的不断攀升，这些传统方法所固有的局限性逐渐暴露出来。在特征提取这一关键层面，传统方法局限于运用相对简单的技术手段对图像底层特征的获取，仅聚焦于图像的基本像素信息、颜色直方图等初级特征。这种情况下图像所蕴含的高层抽象特征，如图像所传达的语义信息、物体之间的逻辑关系等深层次内涵，难以精准捕捉。正是因为传统方法缺乏对复杂特征的深度处理能力，所以此类传统方法所生成的图像在风格呈现效果上显得颇为粗糙，图像可能出现纹理模糊、风格杂糅不自然等问题，无法满足在视觉美感、语义准确性等方面的严苛需求。深度学习技术凭借自身强大的自动特征学习本领，依托海量的数据支撑以及复杂的神经网络架构，能够深入挖掘图像中的深层次信息，精准分离图像的内容与风格特征，并通过复杂的模型架构与训练机制，实现两者的有机融合，进而生成高度逼真、风格独特的图像^[11][12]^。 早期的基于神经网络的固定内容的固定风格迁移方法将生成图像作为可优化变量。这样的风格迁移方法局限于较高的计算复杂度，而且固定输入的设定导致其缺乏对动态内容或风格的泛化能力。2015年，Gatys等人提出了基于卷积神经网络的图像风格迁移算法，将生成图像视为优化变量，通过预训练卷积神经网络提取的内容特征与风格特征，构建内容和风格双损失函数推进像素优化，首次证明了神经网络提取的深度特征可以有效分离内容与风格，为后续研究奠定了理论基础^[13]^。 每次生成图像都需要对像素值进行数百次迭代优化的生成方式已经无法满足效率需求，研究人员们着手研究基于神经网络的任意内容的固定风格迁移方法。迁移方法基于深度卷积神经网络，通常采用编码器-解码器架构。编码器负责提取内容图像的语义特征，将图像数据变得抽象；解码器则将编码后的语义特征与目标风格信息结合，恢复图像内容生成风格化图像。 任意内容图像的固定风格迁移将优化目标从图像空间转移到网络参数空间。2016年，斯坦福大学李飞飞团队针对Gatys方法的效率瓶颈，提出了基于感知损失的图像风格迁移方法，使用感知损失代替原损失，设计了一个包含残差连接的深层网络，直接以内容图像到风格图像作为训练数据，通过训练图像变换网络参数生成直接逼近最优解图像^[14]^。基于预训练模型的风格迁移算法在训练时，首先固定预训练网络模型的参数，然后仅对转换网络的权值进行更新。通过随机梯度下降等优化算法，在大规模内容图像数据集上进行迭代训练，使转换网络学习从任意内容图像到目标风格的映射关系。训练完成后，对于新的内容图像，只需将其输入训练好的网络，通过前向传播即可快速生成风格化结果，无需像早期方法那样对单张图像进行耗时的迭代优化。 后续还针对Gatys 提出的方法进行了诸多改进。Li等人并未使用特征映射的Gram矩阵来表征风格，而是证实了其他几种损失函数同样能够有效地完成任务。其中，均值方差表示法尤为突出，相较于Gram矩阵表示，它更为紧凑，且性能表现相近^[15]^。此外，风格还有其他多种表示形式，诸如直方图损失^[16]^、MRF损失^[17]^以及CORAL损失^[18]^。Dumoulin等人提出利用条件实例归一化来适配每种风格。该方法通过调整特征通道的权重，成功实现对多种不同风格的表示^[19]^。Zhu等人提出了循环对抗生成框架，通过两个生成器学习两种图像域的映射，并使用两个判别器尝试区分生成图像和真实图像，在风格转移和季节转移方面彰显了该方法的优越性^[20]^。与此同时，Der-Lor Way等人在动漫风格迁移任务的基础上，提出了一种新颖的动漫风格迁移算法，达到了不错的图像风格迁移效果^[21]^。它们的算法针对图像的前景与背景在风格呈现上的差异，进行不同的处理策略，例如，对于动漫人物作为前景，人物的细节和风格需要更细致地刻画，而画面的背景可能更注重整体氛围的营造和与前景的融合。然而，这些方法无法推广应用于新的风格图像。 面对新风格任务时上述的模型需重新训练。这样每一种风格一个模型的情况在实际应用中成本极高。为了进一步提高图像风格迁移的灵活性和通用性，研究人员开始探索任意内容的任意风格迁移技术。 在这个阶段中，Huang等人提出了新颖的归一化思想，他们通过对齐内容图像与风格图像在预训练VGG-16网络多层特征空间的均值与方差统计量，将风格迁移过程转化为特征分布的匹配问题。虽然该方法能够处理任意新风格，但严重依赖VGG-16网络对图像进行编码，同时需要相应网络对特征进行解码，无法利用更先进的主干网络，这给模型的控制带来了困难^[22]^。Chen等人提出基于图像块的局部风格匹配，引入了风格交换来处理任意风格迁移。该方法将内容图像和风格图像分割为重叠的图像块，通过K近邻搜索在风格图像中找到与内容块最相似的补丁，然后将其替换到内容图像中，但是处理的速度非常缓慢^[23]^。Zhang等人提出一个多风格生成网络MSG-Net，设计CoMatch层匹配风格图像的Gram矩阵，捕捉特征之间的相关性。该方法整体采用类似U-Net的编码器-解码器框架，并且跳跃连接中引入风格调节模块，在风格实时迁移中实现了高质量的输出^[24]^。 再后来，基于 Transformer的风格迁移算法利用自注意力机制和交叉注意力机制进行风格迁移，其中自注意力机制旨在捕捉图像内部的长距离依赖关系，而交叉注意力机制则用于融合内容图像和风格图像的特征，进而实现风格迁移。2022年，Jianbo Wang等人将自然语言处理中的Transformer架构引入风格迁移，提出了一种新颖的STyle TRansformer(STTR)网络，在风格迁移结果上具有令人满意的有效性和效率^[25]^。他们的网络将内容和风格图像分解为视觉标记，以实现细粒度的风格转换。网络中用到了两种注意力机制，其中自注意力机制用于编码内容和内容标记，然后在内容和风格标记之间融入交叉注意力机制。与其他一些基于传统卷积神经网络的方法相比，STTR的创新点在于其采用视觉标记化和双注意力机制，突破了传统全局特征转换的局限。 2023 年，Chiyu Zhang等人提出了一种基于Transformer的新方法用于图像风格迁移，并引入基于Canny算子的边缘检测分支，可以明显增强内容细节。与其他基于Transformer的图像风格迁移方法相比，该方法能够有效避免因过度渲染风格特征而生成模糊结果^[26]^。颜明强等人提出了一个基于自注意力机制的渐进式流形特征映射模块(MFMM-AM)，用于协调一致地匹配相关内容和风格流形之间的特征；然后通过在图像特征空间中应用精确直方图匹配来实现风格和内容特征图的高阶分布匹配，减少了图像信息的丢失^[27]^。 到目前，纪宗杏等人提出了一种新型的基于双路视觉 Transformer的图像风格迁移方法Bi-Trans，对内容图像域和风格图像域进行独立编码，通过交叉注意力机制与条件实例归一化将内容图像标定至目标域风格，从而生成风格化图像^[28]^。 1.3 论文研究内容 本文的研究主要针对基于MetaNet网络风格迁移算法存在的局限性进行改进，提出的改进方法提升原来的图像风格迁移效果。主要研究内容和创新点如下： (1)在特征提取方面，本研究采用预训练的VGG卷积神经网络作为特征提取模块，对比VGG-16与VGG-19两种卷积神经网络模型在风格特征提取中的差异，发现深层网络结构对风格迁移的影响机制。 (2)本研究对元学习器与图像转换网络进行双重结构增强，并尝试引入新的超参数以强化模型的能力。元学习器中添加注意力机制增强处理特征信息的能力，同时改进图像转换网络的结构，以优化图像风格迁移的效果。 (3)本研究使用COCO数据集和WikiArt数据集对模型进行训练，联合内容损失函数和风格损失函数以优化模型参数。后续对元网络与现有的图像风格迁移算法进行对比分析，评估模型生成图像的质量和效率，展示本研究方法的优越性。 1.4 论文结构安排 本文共五章，结构安排如下： 第一章，绪论。本章首先简要介绍论文研究内容的背景及意义，接着阐述了图像风格迁移领域的国内外研究现状，最后介绍本文的研究内容和文章结构。 第二章，相关理论基础。本章简单介绍卷积神经网络和编码器-解码器架构，为本研究模型的搭建打下基础。接着对本研究进行可行性分析，证明本研究的有效性。 第三章，基于改进的MetaNet风格迁移算法研究。本章首先对原始模型MetaNet进行原理分析，接着阐述本章提出的改进方法，包括去除对图像尺寸的限制、改进的图像转换网络结构设计、添加超参数配置和注意力机制等。 第四章，实验与评估。本章主要介绍本文改进方法的训练环境和配置参数，并将改进的算法和现有的一些风格迁移算法进行实验对比，通过定性和定量分析本文改进方法在风格迁移任务上的优越性。 第五章，总结与展望。本章对本文的研究进行总结，并对后续研究方向展开探讨。 [1] 董心悦,傅鹏.基于改进生成对抗网络的人脸图像风格迁移方法[J].鄂州大学学报,2025,32(02) 94-97. [2] 熊文楷.基于深度学习的中国画风格迁移[J].科技与创新,2023(13) 176-178. [3] Liao M, Huang F. Deep Learning‐Based Application of Image Style Transfer[J]. Mathematical roblems in Engineering, 2022 1-10. [4] 胡琦瑶,刘乾,彭先霖,张翔,彭盛霖,范建平.SN-CL GAN 基于谱归一化的中国传统山水画风格迁移方法[J].西北大学学报（自然科学版）,2025,55(1) 63-74. [5] 刘欢.基于改进生成对抗网络的图像动漫风格迁移研究[D].哈尔滨师范大学,2023. [6] 蔡建禄.基于深度学习的多风格场景卡通化与图像风格化算法研究[D].浙江工商大学,2024. [7] 赖灿芸.基于风格迁移的图像生成模型及其在医学领域的应用[D].浙江工商大学,2024. [8] 戴娟.风格迁移算法在大熊猫文创设计中的运用[J].鞋类工艺与设计,2024,4(18) 192-194. [9] Alexei A. Efros, William T. Freeman． Image Quilting for Texture Synthesis and Transfer[C]//Computer Graphics.Computer Science Division, University of California, Berkeley, Berkeley, CA 94720 USA, 2001 341-346. [10] Hertzmann A, Jacobs E C, Oliver N, et al. Image Analogies[C]// roceedings of SIGGRA H. 2001 327-340. [11] 镇家慧,罗明俐.基于卷积神经网络的图像风格变换[J].数码设计（下）,2021,10(6) 43. [12] 廉露,田启川,谭润,等.基于神经网络的图像风格迁移研究进展[J].计算机工程与应用,2024,60(09) 30-47. [13] Gatys L, Ecker A, Bethge M. A Neural Algorithm of Artistic Style[J].Journal of Vision, 2016, 16(12) 326-326. [14] Johnson J, Alahi A, Fei-Fei L. Perceptual Losses for Real-Time Style Transfer and Super Resolution[C]//Computer Vision–ECCV 2016 14th European Conference, Amsterdam, The Netherlands, October 11-14, 2016, roceedings, art II 14. Springer International Publishing, 2016 694-711. [15] Li C, Wand M. Precomputed Real-Time Texture Synthesis with Markovian Generative Adversarial Networks[C]//Computer vision–ECCV 2016 14th European conference, amsterdam, the netherlands, October 11-14, 2016, proceedings, part III 14. Springer International ublishing, 2016 702-716. [16] Risser E, Wilmot P, Barnes C. Stable and Controllable Neural Texture Synthesis and Style Transfer Using Histogram Losses[J]. CoRR, 2017. [17] Li C, Wand M. Combining markov random fields and convolutional neural networks for image synthesis[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016 2479-2486. [18] Peng X, Saenko K. Synthetic to real adaptation with generative correlation alignment networks[C]//2018 IEEE Winter Conference on Applications of Computer Vision (WACV). IEEE, 2018 1982-1991. [19] Dumoulin V, Shlens J, Kudlur M. A Learned Representation For Artistic Style[J]. CoRR, 2016. [20] Zhu J Y, Park T, Isola P, et al. Unpaired Image-to-Image Translation Using Cycle Consistent Adversarial Networks[C]// roceedings of the IEEE international conference on computer vision. 2017 2223-2232. [21] Way D L, Chang W C, Shih Z C. Deep Learning for Anime Style Transfer[C]// Proceedings of the 2019 3rd international conference on advances in image processing. 2019 139-143. [22] Huang X , Belongie S. Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization[C]// roceedings of the IEEE international conference on computer vision. 2017 1501-1510. [23] Chen Q T, Schmidt M. Fast atch-based Style Transfer of Arbitrary Style[J]. CoRR, 2016. [24] Zhang H, Dana K. Multi-style Generative Network for Real-time Transfer[M/OL]//Lecture Notes in Computer Science,Computer Vision – ECCV 2018 Workshops. 2019 349-365. [25] JianBo Wang, Huan Yang, JianLong Fu, et al. Fine-Grained Image Style Transfer with Visual Transformers[C]//Computer vision – ACCV 2022, art 3 16th Asian conference on computer vision (ACCV), December 4-8, 2022, Macao, China. 2023 427-443. [26] Zhang C, Yang J, Dai Z, et al. Edge Enhanced Image Style Transfer via Transformers[J]. 2023 105-114. [27] 颜明强,余鹏飞,李海燕,等.语义风格一致的任意图像风格迁移[J].计算机科学,2023,50(07) 129-136. [28] 纪宗杏,贝佳,刘润泽,等.基于双路视觉 Transformer 的图像风格迁移[J].北京航空航天大学学报,2024 1-12."},{"title":"基于改进的 MetaNet 风格迁移算法研究","path":"/wiki/style_transfer/proposed_network.html","content":"3.1 MetaNet 算法原理分析 MetaNet意为元网络，是一种基于元学习的深度学习模型，用于解决图像风格迁移中的速度、灵活性和质量平衡问题。本文讨论的超网络和元网络都是一种为其他网络生成权重参数的网络。在早期，Ha等人提出使用静态的超网络为卷积神经网络生成权重参数，并使用动态的超网络为循环网络生成权重参数^[34]^。 元网络遵循元学习规律，通过分层学习策略实现跨任务知识迁移和单个任务的快速适应，生成的网络更为灵活和全面。元网络的工作采用两级学习，分别是跨任务执行的元级(Meta-Level)模型的缓慢学习和每个任务内执行的基本级(Base-Level)模型的快速学习。 跨任务执行的元级模型缓慢学习意思是模型处理大规模跨任务数据时进行的长期知识积累。学习过程呈现显著的缓慢变化，称为“缓变性”。而且参数更新周期覆盖多个任务集合，优化目标聚焦于提取跨任务的通用先验知识，例如不同任务共享的特征表示空间、优化器超参数配置或归纳偏置模式。缓变学习机制使得元级模型能够捕捉任务间的共性结构，形成可迁移的元知识，如适用于多种任务类型的初始化参数分布或动态调整策略。 每个任务内执行的基本级学习指的是针对具体任务场景中，网络在元级知识支撑下可以实现快速完成任务。当处理单个新任务时，基本级模型从元级输出的先验知识出发，只需通过少量样本或迭代步骤完成任务特定的参数调整。这种快速学习过程通常表现为在元级提供的初始状态基础上，进行局部参数的梯度更新或结构微调，其学习速率显著高于元级。例如在小样本学习场景中，基本级模型可利用元级预训练的特征提取器，仅通过数轮迭代即可在新类别上达到理想性能。 Munkhdalai等人在小规模标本学习领域的研究中，提出了一种通过快速参数化实现一次性分类的元网络，能够快速泛化完成任务。他们设计的元网络核心在于构建一个能够动态生成特殊任务特定参数的元学习器，通过对支持集的快速编码，直接生成目标任务分类器所需的权重参数。这样的快速参数化过程无需重复迭代训练基本模型，而是通过元网络的前向传播实现一次性参数映射，将传统小样本学习中的模型适应时间从分钟级缩短至毫秒级^[35]^。 在某些情况下，为了得到一个图像变换网络，需要通过SGD在风格图像数据集上多次训练最小化风格图像与输出结果图像的损失。训练的目标是获得一个性能较好的网络，在输入内容图像域与风格图像域之间建立一个映射。元网络的思想与SGD的思想不同，元网络尝试建立一个生成网络的网络，输入风格图像，输出相应的图像变换网络。 基于元网络的图像风格迁移算法构建基于三个逐步递进的条件假设，从传统的参数优化问题过渡到动态网络的生成。令f(x)和h(x)为固定可微函数，记||·||为正则化，考虑优化问题式3.1。将a看作输入内容图像，b看作输入风格图像，f(x)看作内容感知函数，h(x)看作风格感知函数。 ∥f(x)−f(a)∥+λ∥h(x)−h(b)∥(3.1)\\Vert f(x) - f(a) \\Vert + \\lambda \\Vert h(x) - h(b) \\Vert\\tag{3.1} ∥f(x)−f(a)∥+λ∥h(x)−h(b)∥(3.1) 3.1.1 条件假设一 固定a=a0，b=b0。这种条件下，对应固定内容图像的固定风格迁移。a0可以表示是苹果、汽车或建筑等某已知的内容图像，而b0表示是印象派、巴罗克风格或抽象派等某特定的绘画风格。 为了解决这个问题，假设f(x)和h(x)是凸函数，则公式3.1是一个关于x的凸优化问题。凸优化问题中，不存在局部最小值，任何一个局部最优解就是全局最优解。基于凸优化问题的特性，该假设的解决方法是使用梯度下降法。梯度下降法是机器学习和深度学习领域最常用的迭代优化算法之一。梯度是一个向量，它的方向指的是目标函数在该点处增长最快的方向。梯度下降则根据梯度信息调整参数的更新方向，使得目标函数逼近最优解。在图像不断更新的过程中，梯度的方向指的是损失函数增长最快的方向，所以根据梯度的反向逐步更新合成图像。经过梯度下降迭代后，使得损失函数最小的图像即是目标图像。但是梯度下降法在实际应用中需要经过数百次的优化迭代才能得到每个样本的收敛结果。每次迭代都涉及损失函数和梯度的矩阵计算，消耗大量的计算资源和时间。 3.1.2 条件假设二 固定b=b0，让a可变。无论输入什么内容a，整个风格迁移过程只能向着一种特定的风格迁移。 为了解决条件假设二的问题，考虑引入一个具有可学习参数w的从a到输出x的映射 N:a∣→x\\mathcal{N}:a|\\rightarrow xN:a∣→x，将输入内容图像a通过参数w进行计算得到结果x。该过程为如公式3.2所示。为了找到这一映射，把学习映射的过程当作训练神经网络的过程，w包含神经网络的权重和偏置等可学习参数。通过大量的风格图像来训练神经网络，不断地调整参数w的值，将风格图像中的特征和风格信息编码到参数w中。 x=N(a;w)(3.2)x=\\mathcal{N}(a;w)\\tag{3.2} x=N(a;w)(3.2) 当神经网络训练至收敛时，参数w就被确定下来。对于每一张新的内容图像，只需要通过图像变换网络的前向传播即可生成对应的图像。一次前向传播的过程大大减少了计算的时间，在条件允许下可实现图像的实时风格迁移。 3.1.3 条件假设三 当a和b都可变。这种条件下，网络需要处理内容和风格两个变量，自适应生成对应的风格迁移结果，对应图像风格迁移的第三个阶段——任意内容的任意风格迁移。 根据条件假设2，已经存在 N(⋅;w)\\mathcal{N}(\\cdot;w)N(⋅;w)，引入元学习驱动的每个任务内执行的基本级模型的快速学习。假设存在高层映射 w=𝑚𝑒𝑡𝑎N(b;θ)w=𝑚𝑒𝑡𝑎\\mathcal{N}(b;θ)w=metaN(b;θ)，通过输入b和参数θ计算图像转换网络的参数w，如公式3.3所示。对于每一个给定的风格特征b，都可以寻找一个最优的w，然后结合参数w和输入a计算得到输出x。 w=metaN(b;θ)(3.3)w = meta\\mathcal{N}(b;\\theta)\\tag{3.3} w=metaN(b;θ)(3.3) 总而言之，元学习经过海量数据训练学习得到元级知识后，当需要迁移新的风格时，只需三个步骤即可生成迁移后的图像：第一步，将新风格图像输入预处理模型得到风格特征；第二步，将提取的风格特征传入训练后的元学习模型中，得到图像转换网络的权重参数w；第三步，将输入内容输入到由w参数化的神经网络中，经过一次前向传播得到迁移后的图像。这种范式突破了传统深度学习模型每一个模型只能完成每一个小任务的局限，实现了通过元级知识积累的任务级快速适配。 3.1.4 MetaNet网络架构 Shen等人提出的元网络由一个预训练的VGG-16网络、元学习器和图像转换网络组成，思想是元网络两级学习中的每个任务内执行的基本级模型的快速学习。VGG-16网络从风格图像中提取风格特征，然后将纹理特征输入到元学习器中。元学习器经过大量风格图像的特征训练后，将风格特征投影到图像变换网络的参数中。图像转换网络经过元学习器填充权重参数后，便形成了某种风格的迁移转换网络。通过这种方式，他们首次提供了一种新的方法，在一次前馈传播中接受新风格图像并生成对应图像的图像变换网络^[36]^。这种方法的思想是让模型学习如何学习，即学习图像转换网络的生成方式，从而实现对新风格的快速适应。 Shen提出的一个图像转换网络版本结构如图3.1所示，其中每个残差块由2层卷积层组成，5个残差块共10层卷积，整个图像转换网络共14层卷积层。下采样部分首先经过较大(40×40)的反射填充层将边界扩大，然后经第一个9×9卷积层将通道数增加到8，最后依次经过第二第三层3×3卷积层将输出特征图尺寸缩小一半，通道数翻倍；上采样部分首先依次经过第一第二层3×3反卷积层减少通道数和恢复特征图尺寸，然后经过第三层9×9卷积层将通道数降至3，从而输出正常的三通道彩色图像。每一个残差块都是两层3×3不填充卷积层，将输出特征图的长和宽各减少4。经过5个残差块后与下采样块连接。除了第一层卷积层和最后一层卷积层之外，每个卷积层后面接上一个实例批次归一化层和一个激活函数ReLU层，为了简化起见，图中省略。在模型训练阶段，绿色的卷积层卷积核与元网络一同训练。其他卷积层卷积核和残差块的卷积核固定不参与训练，后续不进行更新。在模型推理阶段，所有淡蓝色的卷积层卷积核和残差块卷积核都由元学习器生成。 元网络的整体架构如图3.2所示。左侧将风格图像输入到预训练的VGG-16模型中，将VGG-16模型的第3、8、15、22层输出作为风格特征。元学习器指的是中间部分的全连接层。风格特征经过元学习器的两个全连接层得到对应图像变换网络中每个不参与训练的卷积层卷积核参数。其中第一个全连接层的输入维度为风格特征的维度，输出维度为1972；第二个全连接层将前一层的输出分组映射到图像生成网络各卷积层的卷积核权重参数。上述提到图像转换网络共需生成参数14层，每层的权重参数由128维向量通过全连接层生成，共得维度14×128维，即1972维。同时，通过预训练的VGG-16分别计算风格迁移后的生成图像的风格损失和内容损失。 图3.1图像转换网络的结构图 图3.2MetaNet整体架构 在元学习器的风格图像特征处理方面，假设输入风格图像的大小为256×256，那么通过预训练VGG-16模型提取的特征输出尺寸分别为(64，256，256)、(128，128，128)、(256，64，64)、(512，32，32)。假设取Gram矩阵作为特征进行计算，输出尺寸为(64，64)、(128，128)、(256，256)、(512，512)，依靠这些尺寸特征生成对应的权值，可想而知计算量是非常庞大的。Shen提到，只计算卷积层输出的均值和标准差作为风格特征。通过这个思路进行计算，风格特征的维度变为(64+128+256+512)×2，即1920维。但是直接使用这1920维特征向量生成14层卷积层的卷积核权重参数还是比较困难，所涉及参数量仍然非常庞大，十分占用硬件资源。为了解决这个问题，设定图像转换网络的每层不参与训练的卷积层卷积核权重参数由单独的128维向量通过全连接层生成，14层卷积层共计1972个输出，元学习器将这些输出分组映射到图像转换网络中的每层权重参数，“*”表示图像转换网络中某层卷积层所需的参数数量，具体结构如图3.3所示。 图3.3元学习器分组映射 3.1.5 损失函数设计 Shen等人设计的损失函数由图像内容损失、图像风格损失和图像全变分损失组成。 图像内容损失定义为图像风格迁移后的图像与原输入内容图像的内容特征均方误差。如图3.2所示，内容特征通过预训练VGG-16模型的relu3_3层输出得到。均方误差是比较常用的误差，通过预测值与真实值之间的差值平方和的均值计算得到。均方误差计算公式如式3.4，其中 f(xi)f(x_i)f(xi​) 为预测值，n为计算样本总数。均方误差的函数曲线光滑连续且处处可导，随着误差减小，梯度也随之减小，这一特性有利于训练过程中的收敛。 MSE=∑i=1n(f(xi)−yi)2n(3.4)MSE=\\frac{\\sum_{i=1}^n(f(x_i)-y_i)^2}{n}\\tag{3.4} MSE=n∑i=1n​(f(xi​)−yi​)2​(3.4) 图像风格损失定义为图像风格迁移后的图像与原输入风格图像的风格特征均方误差。风格特征由图像经过预训练VGG-16模型的relu1_2层、relu2_2层、relu3_3层和relu4_3层输出特征图的均值和标准差拼接得到。 全变分损失的目的提高风格迁移后图像的质量，保持图像平滑。在图像生成的过程中，图像上的微小噪声会对结果产生比较大的影响，且受噪声污染的图像的总变分比无噪声图像的总变分大。所以将总变分损失作为正则项引入到损失函数中，以此达到一定程度上的降噪处理。 3.2 模型改进设计 3.2.1 图像转换网络结构设计 内容图像在输入图像转换网络时，原网络设置卷积层的卷积核步幅大小为2，在特征途中每隔2个像素进行卷积操作，以此进行下采样操作。虽然这种下采样方式的计算速度较快，但是容易出现特征信息提取丢失问题。如果一张高频细节比较丰富图像经过每隔2个像素的下采样操作，得到的结果相当于丢弃一半的空间信息。同时，固定的步幅卷积仅仅通过加权求和进行特征聚合，缺乏了对局部特征的选择性提取。所以，在改进方法中，将下采样卷积层的卷积核步幅大小设置为1，同时在后面增加一层2×2的最大池化层，以此进行下采样操作。在上采样操作中，网络通过双线性插值的方法代替原来固定缩放因子的方式，并且借助PyTorch深度学习框架的相关函数，动态尺寸计算实现恢复原来的空间尺寸。双线性插值法通过在两个方向上分别进行线性插值来得到未知点的像素值。 经过改进后的图像转换网络结构如图3.4，整个图像转换网络总卷积层数不变，增加设置base作为卷积层的通道基数，控制卷积通道变化，每经过一个下采样块，输出特征图的尺寸就缩小一半，同时通道数加倍。原来设计中base为8，改进后base为32，增加图像转换网络的通道数以获得更多更全面的特征。与原来的设计一致，仍然保持第一层卷积层和最后一层卷积层（绿色卷积层）卷积核与元学习器一同训练。其他卷积层卷积核和残差块的卷积核参数使用Kaiming Normal正态初始化固定，后续不参与训练不进行更新，在推演时由元学习器生成。另外说明的是，残差块内部和上采样部分仍然包含反射填充层、实例归一化层和ReLU激活层，为简便起见，图中省略。下采样部分中引入最大池化层，通过选取2×2窗口中的最大值作为输出，最大值能够灵敏地捕捉到图像中最强的特征，同时能够抑制噪声信号。池化窗口使用2×2对应原来下采样卷积核步幅为2，以此达到相同的下采样效果。为了尽可能减少不同图像间亮度、对比度差异并且同时保留各图像的纹理风格信息，改进的网络中引入实例归一化层。实例归一化层可以针对单个样本单通道进行归一化，保留图像像素的细节。除了实例归一化，还有同批次所有样本同通道的批次归一化、单样本的单层所有通道的层归一化和单样本通道分组的分组归一化。与其他归一化方法相比，实例归一化更适用于图像风格迁移场景，而且忽略跨样本统计信息，避免风格混合不明确。 图3.4改进后的图像转换网络 3.2.2 注意力模块设计 原网络结构中没有包含注意力机制。在模型改进中，针对元学习网络的模型结构分别设计了通道注意力模块、自注意力模块和Transformer模块。加入注意力模块后网络流程如图3.5所示，注意力机制模块用于增强元学习器的特征处理能力^[37]^。 图3.5网络流程图 通道注意力模块通过对特征图的通道维度进行学习，能够有效学习不同通道特征的重要程度。通道注意力模块首先对输入特征进行全局维度的压缩，获取通道维度上的全局统计量，随后通过全连接层对通道统计信息进行非线性变换，生成与通道数量一致的权重向量，最后将生成的通道权重与原始输入特征进行逐通道相乘，实现对重要通道特征的增强和对次要通道特征的抑制。在本研究模型中，预训练的VGG模型将提取到的1920维风格特征输入到元学习器中并前向传播，经过全连接层生成G×128个输出，然后将一整批次大小的G×128个特征输入到基础通道注意力机制模块的输入层中。添加的基础通道注意力模块如图3.6所示，其中B表示批次大小，G表示分组数，此处G为14，即图像转换网络中不参与训练更新学习的14层卷积层。在基础通道注意力模块中，首先将输入分组重塑为三维的特征。接着基于SENet的思想，通过全局平均池化压缩三维分组信息形成B×128的二维特征，然后将二维特征输入到全连接块学习分组通道间的权重。全连接块包括两层全连接层和两层激活函数层，全连接层由ratio变量控制。二维特征经全连接块压缩激活处理后，再通过维度恢复操作还原为与输入分组维度匹配的特征，得到通道特征的注意力权重向量。最后将三维特征和通道特征的注意力权重通过张量广播相乘，得到添加注意力机制后的G×128个输出。这G×128个输出经过后续G个全连接层分组映射连接到图像转换网络中不参与训练的卷积层卷积核权重参数。 图3.6含基础通道注意力模块的元学习器 基础通道注意力仅关注全局信息。为了进一步考虑局部信息，对基础通道注意力机制进行增强改进，设计增强通道注意力机制模块，如图3.7所示。含增强通道注意力模块的元学习器输入同样为批次大小的1920维风格特征，经过隐藏层映射为G×128的特征，再输入到增强通道注意力模块中。与基础通道注意力模块相比，增强通道注意力模块主要引入全局权重和分组权重两部分，通过调整它们间的比例加权平衡局部与全局的特征信息。分组权重部分参考原来基础通道注意力模块的计算权重方式，学习每组内部的通道信息。另外，分组权重部分使用GELU（Gaussian Error Linear Unit）激活函数代替原来的ReLU激活函数，GELU函数可以近似地表达为公式3.5。GELU函数在x小于0的部分取值并不为零，在一定程度上可以缓解神经元失活的问题，避免梯度消失。分组权重模块还对全连接层的输出进行层归一化操作，提升模型的表达能力。全局权重由一层全连接层和一层Sigmoid激活函数层组成，融合所有分组的全局信息。 GELU(x)=0.5x[1+tanh⁡(2/π(x+0.047715x3))](3.5)\\text{GELU}(x)=0.5x[1+\\tanh(\\sqrt{2/\\pi(x+0.047715x^3)})]\\tag{3.5} GELU(x)=0.5x[1+tanh(2/π(x+0.047715x3)​)](3.5) 图3.7含增强通道注意力模块的元学习器 自注意力机制能够捕捉输入特征图中不同位置的长距离依赖关系，将每个元素同时当成查询（Query）、键（Key）和值（Value），通过三者的计算实现对上下文的感知表示。自注意力机制模块设计如图3.8。元学习器在得到提取的风格特征并经过全连接层之后，将批次大小和G×128参数数量二维的特征空间变换为批次大小、通道数、高度和宽度的四维伪空间，其中通道数为参数数量G×128，高度和宽度均为1，以便于后续的投影和矩阵运算。随后将该尺寸的特征输入到自注意力模块的输入层，分别计算查询投影、键投影、值投影。查询投影通过降维生成查询向量，查询向量用于捕捉“需要关注什么”，能够聚焦于关键的语义信息，从而为后续的注意力权重计算提供引导。键投影通过降维生成键向量，键向量表示“被关注的内容”，能够描述输入特征中各个位置的特征表示，与查询向量共同计算位置之间的相似度。值投影保持原来的维度生成值向量，值向量表示“实际传递的信息”，同时也保留了输入特征的完整信息。计算得到查询向量、键向量和值向量后，将查询向量和键向量重塑为对应的尺度，使其适合进行矩阵乘法，计算每对位置的相似度。通过Softmax函数处理后，生成注意力权重矩阵。接着将值投影与注意力权重矩阵进行矩阵乘法，最后用参数γ进行残差连接，对值特征进行加权聚合，增强重要位置的特征。残差链接可以防止深层网络退化，保留原始特征中的重要信息，使得模型的训练较为稳定，参数γ用于调整残差连接的权重。 图3.8含自注意力模块的元学习器 Transformer基于自注意力机制实现捕捉序列中元素间的全局依赖关系。在自然语言处理领域，Transformer被广泛应用于机器翻译、文本生成、问答系统等任务，但经过一定修改之后，可以扩展应用在图像处理领域。本设计中简单构建一个应用于视觉处理领域的Vision Transformer模块（以下简称ViT模块），具体流程如图3.9所示。首先预训练的VGG模型对输入风格图像进行特征提取，得到1920维风格特征向量。接着风格特征向量输入到含Transformer的元学习器中，经过全连接层将1920维映射到指定的Embed大小，再通过变换操作得到关于批次大小、通道数、高度和宽度的四维伪空间，其中通道数与 Embed 大小一致。得到四维伪空间特征后进入到ViT模块，ViT模块首先对输入的四维伪空间数据进行1×1卷积的Patch Embedding处理。1×1卷积能够在不改变特征图空间维度的前提下，对通道维度进行线性组合，从而将每个空间位置的特征转换为嵌入向量。接着将嵌入向量进行展平操作，并重塑为关于长度、批次大小和通道数的三维空间特征。该三维空间特征会输入到若干个Transformer块中进行加强处理。其中每个Transformer块由多头注意力模块、残差连接、层归一化、前馈网络等部分组成。三维特征进入多头注意力机制模块，通过多个不同的注意力头并行计算，从不同角度捕获全局上下文依赖关系，获取序列中各元素之间的全局关联信息。与单一的注意力机制相比，多头注意力机制显然扩展了模型对特征的处理和理解能力。随后特征通过残差连接与输入特征相加，再进行层归一化操作，稳定输出并防止梯度消失问题。最后通过前馈网络增强数据的非线性表示能力，使模型能够学习到更复杂的特征表示。 图3.9含Transformer的元学习器 3.3 本章小结 本章围绕基于改进的MetaNet的图像风格迁移算法展开，介绍了MetaNet的核心原理、网络结构以及改进设计。 在MetaNet的算法原理部分，阐述了基本级模型通过元级模型积累的元级知识在单任务上的快速执行。通过三个条件假设，逐步推导从固定内容与风格的迁移问题过渡到任意内容与风格的动态生成场景，介绍了元网络通过生成图像转换网络参数实现快速风格迁移的核心思想。接着介绍了MetaNet的整体架构，包括特征提取器、元学习器和图像转换网络三部分。最后介绍内容损失、风格损失和全变分损失组成的损失函数体系，确保生成图像在内容、风格和结构上的一致性。 在模型改进设计中，针对原网络的不足做出两点改进：一是对图像转换网络进行网络层上的优化；二是对元学习器引入注意力模块。在图像转换网络的改进上，使用池化层代替原来的固定步幅卷积下采样，使用双线性插值代替原来的固定缩放因子，还引入通道基数超参数和实例归一化层，优化网络结构。在元学习器的改进上，引入通道注意力、自注意力和Transformer模块，用于提升元学习器的特征处理能力。 本章通过理论分析以及改进设计，搭建起新的图像风格迁移模型，为后续算法的实验验证奠定基础。 [34] Ha D, Dai A, Le QuocV. HyperNetworks[M/OL]//Hypernetworks in the Science of Complex Systems. 2014 151-176. [35] Munkhdalai T, Yu H. Meta Networks[C]//International conference on machine learning. MLR, 2017 2554-2563. [36] Shen F, Yan S, Zeng G. Neural Style Transfer via Meta Networks[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018 8061-8069. [37] 王树声,李文书.基于神经网络与注意力的任意图像风格迁移研究综述[J].软件工程,2025,28(02) 27-31."},{"title":"相关理论基础","path":"/wiki/style_transfer/related_work.html","content":"2.1 卷积神经网络 卷积神经网络(Convolutional Neural Network，CNN)是一种前馈神经网络，其核心思想通过局部连接、权值共享和空间下采样等机制，有效降低参数数量并提取数据的层次化特征，在图像识别、目标检测等计算机视觉领域以及自然语言处理、语音识别等领域取得了显著成就。CNN的基本结构由卷积层、激活函数层、池化层和全连接层构成。 卷积层是卷积神经网络的关键组成部分。卷积操作由卷积核完成。每个卷积核相当于 一个特征检测器，通过参数可训练的卷积核在输入特征图上进行卷积操作提取局部特征，例如边缘、纹理、颜色等。卷积核权重参数共享机制使得网络对平移变化具有鲁棒性，同时大幅度减少权重参数数量。一般卷积操作包含三个关键参数：卷积核大小决定感受野大小；步长大小表示卷积核每次移动的大小，影响控制输入特征图降采样速度；填充方式指的是在输入特征矩阵外围进行填充，会影响输出特征图的空间维度。一次卷积操作后的输 出特征图大小如式(2.1)所示： output=input+2p−ks(2.1)output=\\frac {input + 2p - k} {s}\\tag{2.1} output=sinput+2p−k​(2.1) 其中，input为输入特征矩阵大小，k为卷积核大小，s为步长，p为填充补零数，output为卷积后得到的输出特征矩阵大小。 激活函数层可以引入非线性因素打破线性模型的局限性，使网络能够学习和拟合更复杂的函数映射关系。常用的激活函数有Sigmoid、ReLU、Tanh和Leaky ReLU等。Sigmoid激活函数输出结果范围是(0，1)，适合用于输出预测概率的模型。Tanh激活函数是Sigmoid的变形，其输出结果范围是(-1，1)。ReLU(Rectified Linear Unit)激活函数可以加快模型收敛，并且可以缓解梯度消失问题。ReLU 函数计算过程相对简单，仅需对输入值执行简单的阈值操作，数学表达式如式(2.2)所示。ReLU函数能够有效缓解传统神经网络中普遍存在的梯度消失问题，但缺点是会出现神经元死亡的问题。Leaky ReLU解决了ReLU输入值为负时神经元死亡的问题，同时不需要进行指数运算，计算复杂度低，数学表达式如式(2.3)所示。 ReLU(x)={x,x00,x≤0(2.2)\\text{ReLU}(x) = \\begin{cases} x, x 0 \\\\ 0, x \\leq 0 \\end{cases}\\tag{2.2} ReLU(x)={x,0,​x0x≤0​(2.2) LeakyReLU(x)={x,x0ax,x≤0(2.3)\\text{Leaky ReLU}(x) = \\begin{cases} x, x 0 \\\\ ax, x \\leq 0 \\end{cases}\\tag{2.3} LeakyReLU(x)={x,ax,​x0x≤0​(2.3) 池化层实际上是下采样层，主要通过最大值或平均值操作对特征图进行空间下采样。每次卷积操作后，特征会变得越来越高维，但是特征矩阵的大小却没什么变化。这种情况下会生成大量的参数，增大了网络的计算量，所以一般会加上一个池化层进行降低维度减少参数量。常见的池化方法有最大池化、平均池化和随机池化等。 全连接层位于卷积神经网络的末端，是由多个神经元组成的单层结构。全连接层将经过多次卷积和池化操作后得到的特征图展平，然后与该层的神经元进行连接，对提取到的特征进行分类或回归等任务。 2.1.1 VGG卷积神经网络 VGG(Visual Geometry Group)网络由牛津大学的计算机视觉组(Visual Geometry Group)和Google DeepMind公司的研究人员共同研发，凭借其独特设计与卓越性能，在计算机视觉领域中的图像识别、目标检测、语义分割等多个关键方向具有重要的地位。 VGG网络的架构比较简单，主要通过堆叠一系列的卷积层和池化层来构建深度网络，最后连接全连接层以完成目标任务。VGG网络的卷积层配置的核心特征是使用小尺寸卷积核。与大尺寸卷积核相比，小尺寸卷积核在保持相同感受野的前提下，通过增加卷积层的数量引入更多非线性变换，从而能够学习更复杂的特征表示；同时，小卷积核的参数规模更小，可有效减少网络参数总量，降低模型过拟合的风险。随着网络深度的增加，模型能够逐层提取从低级到高级的抽象特征，其中VGG-16和VGG-19模型因深度与性能的平衡优化表现突出^[29]^。VGG-16的模型结构图如图2.1所示。 图2.1VGG模型结构图 VGG-16网络卷积层共13层，均采用3×3大小的小卷积核，步长为1，填充为1，通道数逐渐从64增大到512；池化层共5层，均采用2×2最大池化，步长为2，每次将输入特征图大小减半；全连接层3层，最后一层对应任务的输出，此处K取1000则为ImageNet的1000类分类任务。VGG-19网络相比VGG-16网络增加了3层卷积层，将神经网络的层次进一步加深，可以捕获更深层抽象的特征。 VGG模型最初是为ImageNet大规模图像分类任务设计。但在ImageNet数据集上预训练后，VGG模型能够很好的提取到多种层次的特征，可以将它的特征提取能力用在风格迁移任务上。 2.1.2 ResNet卷积神经网络 深度神经网络在图像识别等任务中取得了显著的成果，但随着网络深度的增加，会出现训练困难、性能退化等问题。传统的神经网络在增加深度时，由于梯度消失和梯度爆炸等问题，使得网络难以训练，并且准确率可能会饱和甚至下降。为了解决这个问题，何恺明等人在2015年提出了ResNet^[30]^。ResNet在2015年的ImageNet大规模视觉识别挑战赛(ILSVRC)中获得了冠军，其出色的性能引起了广泛的关注。 ResNet的核心思想是残差学习。与传统神经网络直接学习输入到输出的映射不同，残差学习仅学习输入与输出之间的残差。假设存在映射H(x)，传统网络则直接学习H(x)，而ResNet学习一个残差函数F(x)=H(x)-x，原来的映射变成H(x)=F(x)+x，如图2.2所示。当残差为0时，网络可以直接学习恒等映射，从而使得网络更容易训练。ResNet通过残差学习使得网络可以更深，从而能够学习到更复杂的特征表示。在ImageNet数据集上的实验表明，ResNet可以达到非常深的深度，例如ResNet-152有152层，而传统的网络很难达到这样的深度。 图2.2残差学习 残差网络通过叠加残差块，具有分层的特征提取机制。在浅层特征提取上，像ResNet-18网络的前三个残差块，主要聚焦于学习图像边缘、纹理这类基础视觉特征；而中层特征提取上，像ResNet-50网络的第4至6个残差块，会将局部特征进行整合，进而形成物体部件；到了深层特征提取上，像ResNet-152的后十个残差块，能够把部件特征进一步抽象，转化为物体整体结构以及类别语义信息。这种逐层推进的特征学习方式，让深层网络可以捕捉到更为复杂的视觉模式，进而增强分类任务的判别能力。 2.2 编码器-解码器架构 编码器-解码器架构本质是一种从序列到序列的算法，用于完成自然语言处理和计算机视觉等领域中的处理从序列到序列的任务。编码器-解码器架构包括编码器和解码器，编码器通常可以是卷积神经网络、循环神经网络、LSTM或者是GRU，将可变长度的输入序列编码成中间形态的向量；解码器则根据编码器得到的中间表示逐步解析生成输出序列。 在自然语言处理领域的机器翻译中，需要将一种语言序列转换到另一种语言序列；在计算机视觉领域的图像转换中，需要将具有某种特征序列的图像转换到另一种特征序列的图像。早期研究机器翻译时，Sutskever等人提出了使用两层LSTM来构建序列到序列的模型，通过编码器将输入序列转换成固定的中间向量，再由解码器生成目标序列，实现了长度不一致的序列转换^[31]^。但是由于编码器输出固定的向量，导致有些信息丢失，影响质量。在只使用循环神经网络的实现中，编码器的输出受到限制，容易导致信息丢失、长距离依赖捕捉不足等情况。 U-Net是一个典型的编码器-解码器架构例子。U型网络结构由一个收缩路径和一个对称的扩展路径组成。收缩路径相当于编码器，与普通的卷积网络相同，通过一系列的卷积和池化下采样操作降低图像的分辨率，提取图像的特征；扩展路径与之相反，通过一系列的上采样操作和跳跃连接将收缩路径的浅层特征与扩展路径的深层特征拼接，最终达到任务的效果^[32]^。由于U-Net具有跳跃连接的操作，在一定程度上缓解了信息丢失和长距离依赖捕捉不足的情况。U-Net架构最初用于医学图像分割领域。但是后续出现了许多U-Net变体，使得该架构在图像生成方面得到广泛应用。 2.3 可行性分析 2.3.1 技术可行性 从早期以卷积神经网络(CNN)为核心的方法，到基于生成对抗网络(GAN)的方法，再到目前基于扩散模型和Transformer的融合技术，风格迁移技术呈现出多技术路线并行发展状况。 本文提出的基于MetaNet网络改进的图像风格迁移算法在技术层面具有较高的可行性。MetaNet网络基于元学习的技术框架，元级学习通过对大量的数据进行深度学习，能够识别出不同任务间的共性特征与模式，从而形成一套具有普适性的知识体系。当面对新的风格任务时，基本级利用元级所积累的知识快速生成适配该任务的图像转换网络参数，大大地提高了任务执行的效率与准确性。Munkhdalai等人关于Meta Networks的研究成果，有力地证实了元学习在小样本学习以及动态参数生成领域的显著成效，充分表明该技术框架在实际应用中的强大潜力与可行性。 风格图像经VGG预训练模型提取特征后，元学习器根据风格特征输出图像转换网络的权重参数，避免传统方法中针对每个风格单独训练的耗时问题。VGG预训练模型具有深度且结构稳定的卷积神经网络架构，在图像特征提取领域展现出卓越的技术可行性。它通过多层的卷积和池化操作，能够从风格图像中逐层抽象出从低级边缘到高级语义的丰富特征。大量公开数据集的预训练使得模型参数得到充分优化，对各类风格图像具有良好的泛化能力，可精准捕捉风格图像的关键特征。 本文改进的模型中还对图像转换网络进行优化，使用池化层代替原来的固定步幅卷积下采样避免信息丢失，使用双线性插值代替原来的固定缩放因子确保输入输出图像尺寸一致。另外元学习器还引入了注意力模块，提升对通道间依赖、长距离特征关联的建模能力，减少特征丢失。后续实验证明，本文改进模型推理效率高，满足实时需求，适合艺术创作、文创设计等场景。 2.3.2 经济可行性 本文提出的基于MetaNet网络改进的图像风格迁移算法初始硬件投入成本低、单图处理成本低、存储需求小，在经济层面同样具有较高的可行性。 在硬件支撑方面，本文改进模型的训练在海光32核CPU和16GB显存的DCU上完成。改进模型的元学习器仅含220M参数，模型空间占用846MB，可在主流的GPU(如RTX3090/4090)上部署推演。本文改进模型凭借较低的硬件资源需求，能够在实时交互场景中快速响应，具有良好的投入产出比。在软件环境方面，本文改进模型通过使用PyTorch开源深度学习框架以及广泛可用的GPU加速技术实现。PyTorch框架拥有丰富的工具包与便捷的操作接口，能够显著降低开发难度。 图像风格迁移技术可用于艺术创作、文创设计、影视特效、广告制作以及个性化内容生成等场景。许多在线平台与软件都纷纷提出了图像风格迁移功能，这些工具从免费到专业分层，覆盖艺术创作、电商设计、影视制作等场景。2019年，微软(亚洲)互联网工程院推出的人工智能绘画系统“微软小冰”具有独特的创作能力，它可以对已有的画面进行风格迁移或滤镜效果处理，最终生成100%原创的绘画作品。抖音、快手等短视频平台也推出了各种风格化特效，例如最近火热的AI漫画人脸特效。此外，“Snapchat”和“美图秀秀”也推出了各种美化照片的滤镜，让普通用户可以轻松参与图像风格化的创作^[33]^。阿里云提出的通义万相支持全局或局部风格化、线稿生图等功能，适合电商设计和文创领域。在游戏和电影创作领域，电影《梵高之眼》运用风格迁移算法，将梵高经典作品的绘画元素迁移到影片，成功呈现出独特的动画艺术效果。由此可见，图像风格化在商业领域有着大规模的落地应用，具有极高的商业价值。 2.4 本章小结 本章系统地介绍了图像风格迁移相关的理论基础、经典模型以及可行性分析。 在相关理论部分，首先介绍了卷积神经网络(CNN)的基本架构，包括卷积层、激活函数层、池化层和全连接层的功能与特性。接着介绍了两个经典的卷积神经网络模型：VGG和ResNet。VGG网络主要通过堆叠一系列的卷积层和池化层来构建深度网络，最后连接全连接层以完成目标任务。ResNet提出残差学习机制，通过快捷连接解决深层网络训练中的梯度消失与性能退化问题，使网络深度大幅增加。 在网络架构部分，介绍了编码器-解码器架构。该架构通过编码器将输入序列编码为中间向量，再由解码器逐步解析生成输出序列。以 U-Net 为例，其对称结构结合跳跃连接，缓解了信息丢失问题，在医学图像分割和图像生成领域广泛应用。 在可行性分析部分，技术可行性上，基于MetaNet的改进算法利用元学习技术，结合VGG预训练模型提取风格特征，动态生成图像转换网络参数，避免了传统方法的重复训练问题。通过优化下采样和上采样操作、引入注意力模块，提升了模型效率与特征建模能力。经济可行性上，模型对硬件资源需求低，可在主流GPU上部署，结合PyTorch开源框架降低开发成本，且在艺术创作、影视特效、电商设计等场景具有广泛的商业应用价值，如微软小冰、阿里云通义万相等案例已验证其落地潜力。 本章从理论出发，了解图像风格迁移的核心技术，以及论述该技术的可行性，为后续研究提供了坚实的理论基础。 [29] Simonyan K, Zisserman A. Very Deep Convolutional Networks for Large-Scale Image Recognition[J]. CoRR, 2014. [30] He K, Zhang X, Ren S, et al. Deep Residual Learning for Image Recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016 770-778. [31] Sutskever I, Vinyals O, Le Q V. Sequence to Sequence Learning with Neural Networks[J]. Advances in neural information processing systems, 2014, 27. [32] Ronneberger O, Fischer P, Brox T. U-net Convolutional networks for biomedical image segmentation[C]//Medical image computing and computer-assisted intervention–MICCAI 2015 18th international conference, Munich, Germany, October 5-9, 2015, proceedings, part III 18. Springer international publishing, 2015 234-241. [33] 张娜韦.基于深度学习的图像风格迁移方法研究[D].中国石油大学(北京),2023."}]