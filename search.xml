<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Qt5.14.2项目打包成软件记录</title>
    <url>/2023/10/</url>
    <content><![CDATA[<p>介绍如何将Qt项目打包成软件发布</p>
<h2 id="1-编译出-exe文件">1. 编译出.exe文件</h2>
<p>打开需要打包的项目，在左下角选择合适的构建部件和版本，版本要选择<code>Release</code>，至于64bit还是32bit看需求。</p>
<p>选择后点击锤子编译项目，此处我以<code>MinGWx64,Release</code>编译。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_qt.jpg" alt="选择构建部件和版本"></p>
<p>点击左侧的项目，查看构建目录（项目目录跟构建目录尽量别带中文）。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_qt2.jpg" alt="查看构建目录"></p>
<p>打开构建目录，发现出现一个.exe文件。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_exe.jpg" alt="编译出.exe文件"></p>
<h2 id="2-打包项目">2. 打包项目</h2>
<p>将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到<code>F:\test\HelloWorld1.0</code>，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。</p>
<p>接着打开Qt的安装目录下的bin文件夹，找到<code>windeployqt.exe</code>，复制其路径，我的<code>windeployqt.exe</code>位于<code>D:\Qt\5.14.2\mingw73_64\bin</code>。</p>
<p>回到软件的工作目录（新建的文件夹），在地址栏输入cmd打开命令提示符，按格式输入：</p>
<p><code>windeployqt文件路径 发布软件的路径</code></p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Qt\5.14.2\mingw73_64\bin\windeployqt.exe HelloWorld.exe</span><br></pre></td></tr></table></figure>
<p>慢慢等待打包完成。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_finish.jpg" alt="打包完成"></p>
<p>之后就可以直接打开软件工作目录下的exe执行。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio2022的C++项目打包成软件记录</title>
    <url>/2023/11/</url>
    <content><![CDATA[<p>介绍如何将VS的C++项目打包</p>
<h2 id="1-编译出-exe文件">1. 编译出.exe文件</h2>
<p>选择Release生成，我在此是<code>Realease x64</code>编译。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_vs.jpg" alt="编译"></p>
<h2 id="2-打包项目">2. 打包项目</h2>
<p>将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到F:\test\HelloWorld1.0，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_exe.jpg" alt="软件工作目录"></p>
<p>打开Visual Studio的安装目录，找到<code>dumpbin.exe</code>并复制其路径，可以按照下面的路径查找：<br>
<code>E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.36.32532\bin\Hostx64\x64</code></p>
<p>回到软件工作目录，在地址栏输入cmd打开命令提示符，按格式输入：<br>
<code>dumpbin.exe路径 /dependents 发布软件的路径</code></p>
<p>如：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Microsoft_Visual_Studio</span>\<span class="title">VS</span>\<span class="title">VC</span>\<span class="title">Tools</span>\<span class="title">MSVC</span>\14.36.32532\<span class="title">bin</span>\<span class="title">Hostx64</span>\<span class="title">x64</span>\<span class="title">dumpbin.exe</span> /<span class="title">dependents</span> <span class="title">HelloWorld.exe</span></span></span><br></pre></td></tr></table></figure>
<p>接着将出现的.dll文件找出来，推荐使用<a href="https://www.voidtools.com/zh-cn/downloads/">Everything软件</a>搜索，选择路径上对应的平台（x86或x64），复制到软件的工作目录即可。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_dependents.jpg" alt="软件依赖"></p>
<p>如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_last.jpg" alt="完整的软件工作目录"></p>
<p>这样即可直接点击.exe文件运行。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python源代码打包成.exe文件记录</title>
    <url>/2023/12/</url>
    <content><![CDATA[<p>使用auto-py-to-exe将.py打包成.exe</p>
<h2 id="安装auto-py-to-exe">安装auto-py-to-exe</h2>
<p>打开cmd命令提示符，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install auto-py-to-exe</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_download.jpg" alt="下载auto-py-to-exe"></p>
<p>等待下载完成……</p>
<h2 id="使用auto-py-to-exe">使用auto-py-to-exe</h2>
<p>下载安装完成后，选择文件夹作为输出文件夹，我的选择的路径为 <code>F:\</code>，在此路径打开cmd命令提示符或者通过cmd命令进入到该路径。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_cmd.jpg" alt="cmd窗口"></p>
<p>输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-py-to-exe</span><br></pre></td></tr></table></figure>
<p>即可打开打包窗口。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_use.jpg" alt="打包窗口"></p>
<ul>
<li>
<p>脚本位置：选择需要打包的.py文件</p>
</li>
<li>
<p>单文件/单目录：选择打包的形式，选择将依赖整体打包成一个.exe还是依赖库分离+.exe文件</p>
</li>
<li>
<p>控制台窗口：自行选择</p>
</li>
<li>
<p>图标、附加文件、高级、设置：自行选择</p>
</li>
</ul>
<p>我的打包结果：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_result.jpg" alt="单文件打包结果"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_result1.jpg" alt="单目录打包结果"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何暂停Windows的系统升级</title>
    <url>/2023/13/</url>
    <content><![CDATA[<p>关闭Windows的自动更新</p>
<h2 id="1-修改注册表编辑器">1.修改注册表编辑器</h2>
<p>按住 <code>Win</code> + <code>R</code> 输入 <code>regedit</code> 进入注册表编辑器。</p>
<p>找到 <code>HKEY_LOCAL_MACHINE → SOFTWARE → Microsoft → WindowsUpdate → UX → Settings</code></p>
<p>点击右边空白处，选择新建DWORD（32位）值，重命名为 <code>FlightSettingsMaxPauseDays</code> ，</p>
<p>双击打开，选择十进制，输入想要暂停的最大天数，我这里输入 <code>8888</code> 。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/13_1.jpg" alt="添加新项"></p>
<h2 id="2-打开系统设置">2.打开系统设置</h2>
<p>按住 <code>Win</code> + <code>I</code> 打开系统设置，搜索 <code>Windows更新</code> ，进入Windows更新设置，在暂停更新处选择最大值即可。</p>
<p>Windows 10的暂停更新在 <code>Windows 更新设置 → 高级选项 → 暂停更新</code></p>
<p>效果如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/13_2.jpg" alt="暂停8888天"></p>
<h2 id="3-恢复更新">3.恢复更新</h2>
<p>直接点击继续更新即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Ping指令进行基本网络检测</title>
    <url>/2023/15/</url>
    <content><![CDATA[<p>利用Ping指令对本地IP、网关和远程网站等进行基本网络检测</p>
<p>关键词：网络</p>
<hr>
<h2 id="测试tcp-ip协议栈">测试TCP/IP协议栈</h2>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ping</span> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>127.0.0.1</code> 是你本地主机的环回地址，实际上只要是 <code>127.0.0.1</code> 到 <code>127.255.255.254</code> 都是本地主机环回地址。</p>
<ul>
<li>作用：用于检查本地主机TCP/IP协议栈是否正常。</li>
</ul>
<h2 id="测试本地网卡">测试本地网卡</h2>
<p>打开cmd（命令提示符），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span></span><br></pre></td></tr></table></figure>
<p>记住自己的本地ip，接着输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ping</span> [本地ip]</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：用于检查本地网卡工作是否正常。</li>
</ul>
<h2 id="测试与网关的链路">测试与网关的链路</h2>
<p>打开cmd（命令提示符），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span></span><br></pre></td></tr></table></figure>
<p>记住自己的默认网关，接着输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ping</span> [默认网关]</span><br></pre></td></tr></table></figure>
<ul>
<li>用于检查本地主机与网关的链路是否正常。</li>
</ul>
<h2 id="测试与外网远程网站的链路">测试与外网远程网站的链路</h2>
<p>以连通百度网站为测试：</p>
<p>打开cmd（命令提示符），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ping</span> www.baidu.com</span><br></pre></td></tr></table></figure>
<ul>
<li>用于检查本地主机与外网远程网站的链路是否正常。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个博客</title>
    <url>/2023/1/</url>
    <content><![CDATA[<p>博客建成：Hello World</p>
<span id="more"></span>
<ul>
<li>前言</li>
</ul>
<p>之前常常看博客学习内容，想着自己也可以做一个博客，记录自己的学习内容。所以此博客随之诞生。取名Fingsinz’s space。</p>
<ul>
<li>用途</li>
</ul>
<p>我想着，这个博客分为几个栏目，可以记录我的学习笔记，可以分享我平常使用体验较好的软件网站，甚至可以分享我毫无营养的日常……看看侧栏，于是分成了主页、日常、比较、好物分享、归档、关于几个模块。我还增加了搜索功能，便于搜索关键词。</p>
<ul>
<li>更多</li>
</ul>
<p>我并不是主攻前端方向，学习到的知识也较为浅薄，所以该博客还有很大改进空间。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>Qt for Android配置记录</title>
    <url>/2024/16/</url>
    <content><![CDATA[<p>关键词：Qt、C++、Android</p>
<hr>
<h2 id="前言">前言</h2>
<p>一开始想着弄个安卓软件玩玩，但是不想学 Java，于是乎发现了 Qt for Android。</p>
<h2 id="配置过程">配置过程</h2>
<h3 id="前期准备">前期准备</h3>
<p>使用的是 Qt6.5.3 的 Android 组件。</p>
<p><em>我尝试过使用 Qt6.6.1 和 Qt5.15.2 的 Android 组件，但不成功，原因未知。</em></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_qtversion.jpg" alt="Qt Version"></p>
<p>Java 方面，JDK 使用 Java 17，<a href="https://www.oracle.com/cn/java/technologies/downloads/#java17">下载地址</a></p>
<p>这里简单说一下 JDK、SDK 和 NDK：</p>
<ul>
<li>JDK：Java Development Kit，是整个Java的核心，其中包括Java编译器、Java运行工具、Java文档生成工具、Java打包工具等</li>
<li>SDK：Software Development Kit，软件开发工具包</li>
<li>NDK：Native Development Kit，是 Android 的一个工具开发包</li>
</ul>
<h3 id="创建-qt-android-项目">创建 Qt Android 项目</h3>
<h4 id="1-新建项目">1.新建项目</h4>
<p>像之前一样正常新建项目</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_step1.jpg" alt="新建项目"></p>
<h4 id="2-选择安卓构建开发">2.选择安卓构建开发</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_step2.jpg" alt="安卓编译"></p>
<p>点击管理，可以进入设置页面。设置好 JDK 路径 和 SDK 路径。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_step3.jpg" alt="设置SDK"></p>
<p>可能还需下载配置安卓 OpenSSL。</p>
<p>设置完成如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_step4.jpg" alt="设置完成"></p>
<h4 id="3-正常项目开发">3.正常项目开发</h4>
<p>完成设置后进入项目，可以进行代码编写和界面设计</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_step5.jpg" alt="页面设计"></p>
<p>release下需要生成 apk 签名：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_step6.jpg" alt="签名填写"></p>
<h4 id="4-效果展示">4.效果展示</h4>
<p>编译并连接手机运行，手机打开开发者选项，进入 USB 调试，打开 USB 安装功能（建议打开文件传输功能）。编译过程比较漫长。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_screenshot.jpg" alt="运行效果"></p>
<h2 id="问题汇总">问题汇总</h2>
<ol>
<li>编译时下载 gradle 卡住超时退出。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/16_problem1.jpg" alt="下载超时"></p>
<ul>
<li>解决办法：找到 <code>..\build-demo-Qt_6_5_3_Clang_arm64_v8a-Debug\android-build\gradle\wrapper</code> 目录下的 <code>gradle-wrapper.properties</code>，使用记事本打开，修改为 <code>distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-8.0-bin.zip</code>，然后继续编译生成。</li>
</ul>
<ol start="2">
<li>出现红色报错 <font color="red">Failure [INSTALL_FAILED_USER_RESTRICTED: Install canceled by user]</font>。</li>
</ol>
<ul>
<li>解决办法：确认手机是否进入 USB 调试模式，且打开 USB 安装。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Qt</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下 vcpkg 的配置与使用</title>
    <url>/2024/19/</url>
    <content><![CDATA[<p>关键词：C++</p>
<span id="more"></span>
<hr>
<h2 id="什么是-vcpkg">什么是 vcpkg</h2>
<blockquote>
<p>vcpkg 是 Microsoft 和 C++ 社区维护的免费开放源代码 C/C++ 包管理器。</p>
</blockquote>
<p><em>使用上就类似于 Python 的 pip。</em></p>
<h2 id="下载-vcpkg">下载 vcpkg</h2>
<p>前提条件：</p>
<ul>
<li>Git</li>
<li>CMake</li>
<li>IDE（我使用的是 Visual Studio 2022）</li>
</ul>
<p>步骤如下：</p>
<ol>
<li>使用 Git 命令下载 vcpkg，Git 会自动新建一个文件夹。</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Microsoft/vcpkg</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>运行文件夹下的 <code>bootstrap-vcpkg.bat</code> 文件，下载 <code>vcpkg.exe</code>。（如果下载卡顿可以自己去 Github 的 Release 处下载）</li>
</ol>
<h2 id="使用-vcpkg">使用 vcpkg</h2>
<p>运行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure>
<p>让系统里所有 C++ 编辑器都能与 vcpkg 建立链接。</p>
<h3 id="对于库的安装和卸载">对于库的安装和卸载</h3>
<ul>
<li>查找库：</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">vcpkg search [packages]</span><br></pre></td></tr></table></figure>
<ul>
<li>安装库：</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">vcpkg install [packages to install]</span><br></pre></td></tr></table></figure>
<p><em>安装库还是从 Github 里下载安装，网络问题自行解决。</em></p>
<ul>
<li>卸载库：</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">vcpkg remove [packages to remove]</span><br></pre></td></tr></table></figure>
<h3 id="更多命令">更多命令</h3>
<ul>
<li>集成到全局： <code>vcpkg integrate install</code></li>
<li>移除全局： <code>vcpkg integrate remove</code></li>
<li>集成到工程： <code>vcpkg integrate project</code>（在“\scripts\buildsystems”目录下，生成nuget配置文件）</li>
<li>查看支持的架构： <code>vcpkg help triplet</code></li>
<li>指定编译某种架构的程序库： <code>vcpkg install xxxx:x64-windows（x86-windows）</code></li>
<li>卸载已安装库： <code>vcpkg remove xxxx</code></li>
<li>指定卸载平台： <code>vcpkg remove xxxx:x64-windows</code></li>
<li>移除所有旧版本库： <code>vcpkg remove --outdated</code></li>
<li>查看已经安装的库： <code>vcpkg list</code></li>
<li>更新已经安装的库： <code>vcpkg update xxx</code></li>
<li>导出已经安装的库： <code>vcpkg export xxxx --7zip（–7zip –raw –nuget –ifw –zip）</code></li>
</ul>
<h3 id="visual-studio-中使用">Visual Studio 中使用</h3>
<p>安装完之后（以及集成到全局的情况下），可以在 VS 项目中直接 <code>#include</code>。</p>
<p><em>可能里面的库不是那么全。</em></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains系软件的数据位置修改</title>
    <url>/2024/18/</url>
    <content><![CDATA[<p>日常记录</p>
<span id="more"></span>
<hr>
<p><em>以 CLion 为例。</em></p>
<p><em>需要关闭软件后操作。</em></p>
<h2 id="查找原来的数据位置">查找原来的数据位置</h2>
<ul>
<li>config 项默认在：<code>C:/Users/用户名/AppData/Roaming/JetBrains/产品</code></li>
<li>system 项默认在：<code>C:/Users/用户名/AppData/Local/JetBrains/产品</code></li>
</ul>
<h2 id="把原来的数据拷贝到新位置">把原来的数据拷贝到新位置</h2>
<ul>
<li>比如我需要把原来的数据拷贝到 <code>E:/CLion</code> 下新建的 <code>.CLion</code> 文件夹。</li>
</ul>
<ol>
<li>
<p>将 <code>C:/Users/用户名/AppData/Roaming/JetBrains/CLion</code> 下所有内容复制到 <code>E:/CLion/.CLion</code> 下新建的文件夹 <code>config</code> 。</p>
</li>
<li>
<p>将 <code>C:/Users/用户名/AppData/Local/JetBrains/产品</code> 下所有内容复制到 <code>E:/CLion/.CLion</code> 下新建的文件夹 <code>system</code> 。</p>
</li>
</ol>
<h2 id="修改配置文件指定路径">修改配置文件指定路径</h2>
<p>找到 CLion 安装目录下的 <code>bin</code> 目录，打开 <code>idea.properties</code> 配置文件，修改路径如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the settings directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.config.path</span>=<span class="string">E:/CLion/.CLion/config</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the caches directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.system.path</span>=<span class="string">E:/CLion/.CLion/system</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the user-installed plugins directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.plugins.path</span>=<span class="string">E:/CLion/.CLion/config/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the logs directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.log.path</span>=<span class="string">E:/CLion/.CLion/system/log</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此处为我自己个人的配置，自行选择合适的路径修改。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>使用免安装版VSCode</title>
    <url>/2024/17/</url>
    <content><![CDATA[<p>日常记录</p>
<span id="more"></span>
<hr>
<p><em>记录免安装VSCode的配置和插件安装位置设置</em></p>
<p>VSCode 下载地址：<a href="https://code.visualstudio.com/Download#">https://code.visualstudio.com/Download#</a></p>
<ul>
<li>选择 <code>.zip</code> 格式。</li>
</ul>
<p>下面是关于修改插件默认安装位置：</p>
<ol>
<li>
<p>创建自定义文件夹，如 VSCode 目录下的 <code>extensions</code>。</p>
</li>
<li>
<p>使用命令定位到自定义文件夹。</p>
</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">code --extensions-<span class="built_in">dir</span> &quot;<span class="built_in">path</span>/to/extensions&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>给快捷方式也定位到自定义文件夹，在 <code>.exe</code> 后添加上 <code>--extensions-dir &quot;path/to/extensions</code>。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/17_quick.jpg" alt="修改目标"></p>
<p><strong>Reference：</strong> <a href="https://blog.csdn.net/weixin_43751329/article/details/122506815">https://blog.csdn.net/weixin_43751329/article/details/122506815</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>记录Keil_C51和Keil_MDK的安装</title>
    <url>/2023/2/</url>
    <content><![CDATA[<p>介绍Keil_C51和Keil_MDK的安装</p>
<p>关键词：Keil</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h1>什么是Keil C51和Keil MDK</h1>
<ul>
<li>
<p>Keil是一家公司名称，也是一款软件名称。Keil 有四大软件（IDE），包括 MDK、C51、C251、C166。</p>
</li>
<li>
<p>Keil C51和MDK是针对不同类型MCU的两款集成开发工具。</p>
</li>
</ul>
<h1>Keil C51</h1>
<h2 id="下载安装程序">下载安装程序</h2>
<p><a href="https://www.keil.com/download/product/">Keil官网下载</a></p>
<h2 id="安装过程">安装过程</h2>
<p>像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装，个人信息随便填，等待安装完成。</p>
<p>此次我安装路径设置为<code>G:\Keil_C51</code>中。</p>
<h2 id="启动软件">启动软件</h2>
<p>UV4可执行文件位于：<code>G:\Keil_C51\UV4</code></p>
<h1>Keil MDK</h1>
<h2 id="下载安装程序">下载安装程序</h2>
<p><a href="https://www.keil.com/download/product/">Keil官网下载</a></p>
<h2 id="安装过程">安装过程</h2>
<p>像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装本体和Pack文件，个人信息随便填，等待安装完成。</p>
<p>此次我将本体路径设置为<code>G:\Keil_MDK</code>中，Pack路径设置为<code>G:\Keil_MDK\</code>。</p>
<h2 id="启动软件">启动软件</h2>
<p>UV4可执行文件位于：<code>G:\Keil_MDK\UV4</code></p>
<h1>Keil Key Generator</h1>
<p><a href="https://blog.csdn.net/qq_22329595/article/details/108703002">参考此博客</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Keil</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下保持SSH长时间挂起</title>
    <url>/2024/21/</url>
    <content><![CDATA[<p>关键词：SSH</p>
<span id="more"></span>
<hr>
<h2 id="问题描述">问题描述</h2>
<p>实际上，终端 SSH 连接在长时间不操作会出现自动中断，需要再次连接，十分麻烦。</p>
<h2 id="问题解决">问题解决</h2>
<p>更改自己客户端 ssh 配置：</p>
<ol>
<li>
<p>用记事本打开 <code>C:/Users/用户名/.ssh/config</code>。</p>
</li>
<li>
<p>添加一行：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerAliveInterval 60</span><br></pre></td></tr></table></figure>
<ul>
<li>该行意思是：每隔60秒自动发送一个空的请求以保持连接。</li>
<li>秒数可以根据自己实际调整。</li>
</ul>
<p><strong>Reference：</strong> <a href="https://zhuanlan.zhihu.com/p/431249844">解决ssh连接长时间不操作断开连接的问题（client_loop/ send disconnect/ Broken pipe） - KelvinF97的文章 - 知乎</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt的下载地址记录</title>
    <url>/2023/14/</url>
    <content><![CDATA[<p>Qt（C++）和pyQt的安装记录</p>
<h2 id="qt-c-plus-plus">Qt（C plus plus）</h2>
<ul>
<li>
<p><a href="https://www.qt.io/offline-installers">开源版离线官网下载</a></p>
</li>
<li>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/">清华镜像下载</a></p>
</li>
</ul>
<h2 id="qt-python">Qt（Python）</h2>
<p>参考<a href="https://zhuanlan.zhihu.com/p/162866700">此篇文章</a></p>
<ol>
<li>下载PyQt5</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install PyQt5</span><br></pre></td></tr></table></figure>
<p>网络不好的可选择豆瓣的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install PyQt5 -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>下载PyQt5-tools</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install PyQt5-tools</span><br></pre></td></tr></table></figure>
<p>网络不好的可选择豆瓣的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install PyQt5-tools -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>
<p>PyQt 5.15.x 之前，安装完成后在 <code>%Python_path%\Lib\site-packages</code> 目录中可以看到PyQt5、pyqt5-tools、PyQt5-sip 目录。</p>
<p>PyQt 5.15.x 之后，安装完成后在 <code>%Python_path%\Lib\site-packages</code> 目录中可以看到PyQt5、pyqt5-tools、PyQt5-sip 以及多了的 qt_applications 、qt5-tools 目录。</p>
<ol start="3">
<li>添加环境变量</li>
</ol>
<p>在系统变量Path中添加 <code>pyqt5-tools</code> 目录的绝对路径。</p>
<ol start="4">
<li>验证</li>
</ol>
<p>运行下面代码，出现窗口即为成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">widget = QWidget()</span><br><span class="line">widget.resize(<span class="number">640</span>, <span class="number">480</span>)</span><br><span class="line">widget.setWindowTitle(<span class="string">&quot;Hello, PyQt5!&quot;</span>)</span><br><span class="line">widget.show()</span><br><span class="line">sys.exit(app.<span class="built_in">exec</span>())</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>使用clang-format给你代码格式化</title>
    <url>/2024/22/</url>
    <content><![CDATA[<p>关键词：C++</p>
<span id="more"></span>
<hr>
<h2 id="clang-format-简介">clang-format 简介</h2>
<p>Clang 本身是一个 C++ 的编译器。而 Clang-Format 是其中的一个格式化工具，可用于格式化（排版）多种不同语言的代码。</p>
<h2 id="clang-format-安装">clang-format 安装</h2>
<p>安装 clang-format 十分简单：</p>
<p>对于 Ubuntu：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install clang-format</span><br></pre></td></tr></table></figure>
<p>对于 Windows：</p>
<ul>
<li>
<p>从 Github 的 Release 中下载安装包 <code>LLVM-xx.x.xx-winxx.exe</code>；</p>
</li>
<li>
<p>下载链接：<a href="https://github.com/llvm/llvm-project/releases">https://github.com/llvm/llvm-project/releases</a></p>
</li>
</ul>
<h2 id="clang-format-使用">clang-format 使用</h2>
<p><strong>Windows OS 记得将clang路径下的bin目录添加到环境变量。</strong></p>
<p>通过以下命令获取帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>基本的使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以LLVM代码风格格式化main.cpp, 结果直接写到main.cpp</span></span><br><span class="line">clang-format -style=LLVM -i main.cpp</span><br></pre></td></tr></table></figure>
<p>但是更多情况下，是使用 <code>.clang-format</code> 文件进行格式的规定。</p>
<p>我自己暂时使用的格式定义如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 风格：Google, LLVM, Chromium, Mozilla, WebKit, Microsoft, GUN</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">LLVM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto</span></span><br><span class="line"><span class="attr">Language:</span> <span class="string">Cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准: Cpp03, Cpp11, Auto</span></span><br><span class="line"><span class="attr">Standard:</span> <span class="string">Auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格</span></span><br><span class="line"><span class="attr">Cpp11BracedListStyle:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问说明符(public、private等)的偏移</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">AlwaysBreak</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平对齐二元和三元表达式的操作数</span></span><br><span class="line"><span class="attr">AlignOperands:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许函数声明的所有参数在放在下一行</span></span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的块放在同一行</span></span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的case标签放在同一行</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span></span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">Empty</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的if语句保持在同一行</span></span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的循环保持在同一行</span></span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数),  # AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterReturnType:</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在template声明后换行</span></span><br><span class="line"><span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># false表示函数实参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="attr">BinPackArguments:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># false表示所有形参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="attr">BinPackParameters:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构造函数的初始化列表的逗号前换行</span></span><br><span class="line"><span class="attr">BreakConstructorInitializersBeforeComma:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行字符的限制，0表示没有限制</span></span><br><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造函数的初始化列表的缩进宽度</span></span><br><span class="line"><span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延续的行的缩进宽度</span></span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承最常用的指针和引用的对齐方式</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为命名空间添加缺失的命名空间结束注释</span></span><br><span class="line"><span class="attr">FixNamespaceComments:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进case标签</span></span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always</span></span><br><span class="line"><span class="attr">UseTab:</span> <span class="string">Never</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进宽度</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续空行的最大数量</span></span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All</span></span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PenaltyBreakAssignment:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在call(后对函数调用换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个注释中引入换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakComment:</span> <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次在&lt;&lt;前换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个字符串字面量中引入换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakString:</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个在行字符数限制之外的字符的penalty</span></span><br><span class="line"><span class="attr">PenaltyExcessCharacter:</span> <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数的返回类型放到它自己的行的penalty</span></span><br><span class="line"><span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指针和引用的对齐: Left, Right, Middle</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许排序#include</span></span><br><span class="line"><span class="attr">SortIncludes:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续宏定义的值对齐</span></span><br><span class="line"><span class="attr">AlignConsecutiveMacros:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>更多的格式定义如下：</p>
<details><summary>展开</summary>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto</span></span><br><span class="line"><span class="attr">Language:</span> <span class="string">Cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于风格：Google, LLVM, Chromium, Mozilla, WebKit, Microsoft, GUN</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">LLVM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问说明符(public、private等)的偏移</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续赋值时，对齐所有等号</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续声明时，对齐所有声明的变量名</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左对齐逃脱换行(使用反斜杠换行)的反斜杠</span></span><br><span class="line"><span class="attr">AlignEscapedNewlinesLeft:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平对齐二元和三元表达式的操作数</span></span><br><span class="line"><span class="attr">AlignOperands:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对齐连续的尾随的注释</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许函数声明的所有参数在放在下一行</span></span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的块放在同一行</span></span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的case标签放在同一行</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span></span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">Empty</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的if语句保持在同一行</span></span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的循环保持在同一行</span></span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在定义返回类型后换行(deprecated)</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), </span></span><br><span class="line"><span class="comment">#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterReturnType:</span>	<span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在多行string字面量前换行</span></span><br><span class="line"><span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在template声明后换行</span></span><br><span class="line"><span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># false表示函数实参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="attr">BinPackArguments:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># false表示所有形参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="attr">BinPackParameters:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效</span></span><br><span class="line"><span class="attr">BraceWrapping:</span>   </span><br><span class="line">  <span class="comment"># class定义后面</span></span><br><span class="line">  <span class="attr">AfterClass:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 控制语句后面</span></span><br><span class="line">  <span class="attr">AfterControlStatement:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># enum定义后面</span></span><br><span class="line">  <span class="attr">AfterEnum:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 函数定义后面</span></span><br><span class="line">  <span class="attr">AfterFunction:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 命名空间定义后面</span></span><br><span class="line">  <span class="attr">AfterNamespace:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># ObjC定义后面</span></span><br><span class="line">  <span class="attr">AfterObjCDeclaration:</span>	<span class="literal">false</span></span><br><span class="line">  <span class="comment"># struct定义后面</span></span><br><span class="line">  <span class="attr">AfterStruct:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># union定义后面</span></span><br><span class="line">  <span class="attr">AfterUnion:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># catch之前</span></span><br><span class="line">  <span class="attr">BeforeCatch:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># else之前</span></span><br><span class="line">  <span class="attr">BeforeElse:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 缩进大括号</span></span><br><span class="line">  <span class="attr">IndentBraces:</span>	<span class="literal">false</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)</span></span><br><span class="line"><span class="attr">BreakBeforeBinaryOperators:</span>	<span class="string">NonAssignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), </span></span><br><span class="line"><span class="comment">#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), </span></span><br><span class="line"><span class="comment">#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom</span></span><br><span class="line"><span class="comment">#   注：这里认为语句块也属于函数</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span>	<span class="string">Custom</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在三元运算符前换行</span></span><br><span class="line"><span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构造函数的初始化列表的逗号前换行</span></span><br><span class="line"><span class="attr">BreakConstructorInitializersBeforeComma:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行字符的限制，0表示没有限制</span></span><br><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变</span></span><br><span class="line"><span class="attr">CommentPragmas:</span>	<span class="string">&#x27;^ IWYU pragma:&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造函数的初始化列表要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span>	<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造函数的初始化列表的缩进宽度</span></span><br><span class="line"><span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延续的行的缩进宽度</span></span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格</span></span><br><span class="line"><span class="attr">Cpp11BracedListStyle:</span>	<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承最常用的指针和引用的对齐方式</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span>	<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭格式化</span></span><br><span class="line"><span class="attr">DisableFormat:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)</span></span><br><span class="line"><span class="attr">ExperimentalAutoDetectBinPacking:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要被解读为foreach循环而不是函数调用的宏</span></span><br><span class="line"><span class="attr">ForEachMacros:</span>	[ <span class="string">foreach</span>, <span class="string">Q_FOREACH</span>, <span class="string">BOOST_FOREACH</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，</span></span><br><span class="line"><span class="comment">#   可以定义负数优先级从而保证某些#include永远在最前面</span></span><br><span class="line"><span class="attr">IncludeCategories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>	<span class="string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>	<span class="number">2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>	<span class="string">&#x27;^(&lt;|&quot;(gtest|isl|json)/)&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>	<span class="number">3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>	<span class="string">&#x27;.*&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>	<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 缩进case标签</span></span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进宽度</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数返回类型换行时，缩进函数声明或函数定义的函数名</span></span><br><span class="line"><span class="attr">IndentWrappedFunctionNames:</span>	<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留在块开始处的空行</span></span><br><span class="line"><span class="attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始一个块的宏的正则表达式</span></span><br><span class="line"><span class="attr">MacroBlockBegin:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束一个块的宏的正则表达式</span></span><br><span class="line"><span class="attr">MacroBlockEnd:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续空行的最大数量</span></span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All</span></span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">Inner</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ObjC块时缩进宽度</span></span><br><span class="line"><span class="attr">ObjCBlockIndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在ObjC的@property后添加一个空格</span></span><br><span class="line"><span class="attr">ObjCSpaceAfterProperty:</span>	<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在ObjC的protocol列表前添加一个空格</span></span><br><span class="line"><span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在call(后对函数调用换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个注释中引入换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakComment:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次在&lt;&lt;前换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个字符串字面量中引入换行的penalty</span></span><br><span class="line"><span class="attr">PenaltyBreakString:</span>	<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个在行字符数限制之外的字符的penalty</span></span><br><span class="line"><span class="attr">PenaltyExcessCharacter:</span>	<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数的返回类型放到它自己的行的penalty</span></span><br><span class="line"><span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指针和引用的对齐: Left, Right, Middle</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Left</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许重新排版注释</span></span><br><span class="line"><span class="attr">ReflowComments:</span>	<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许排序#include</span></span><br><span class="line"><span class="attr">SortIncludes:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在C风格类型转换后添加空格</span></span><br><span class="line"><span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在赋值运算符之前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeAssignmentOperators:</span>	<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开圆括号之前添加一个空格: Never, ControlStatements, Always</span></span><br><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatements</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在空的圆括号中添加空格</span></span><br><span class="line"><span class="attr">SpaceInEmptyParentheses:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尾随的评论前添加的空格数(只适用于//)</span></span><br><span class="line"><span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尖括号的&lt;后和&gt;前添加空格</span></span><br><span class="line"><span class="attr">SpacesInAngles:</span>	<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格</span></span><br><span class="line"><span class="attr">SpacesInContainerLiterals:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在C风格类型转换的括号中添加空格</span></span><br><span class="line"><span class="attr">SpacesInCStyleCastParentheses:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在圆括号的(后和)前添加空格</span></span><br><span class="line"><span class="attr">SpacesInParentheses:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响</span></span><br><span class="line"><span class="attr">SpacesInSquareBrackets:</span>	<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准: Cpp03, Cpp11, Auto</span></span><br><span class="line"><span class="attr">Standard:</span> <span class="string">Cpp11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tab宽度</span></span><br><span class="line"><span class="attr">TabWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always</span></span><br><span class="line"><span class="attr">UseTab:</span> <span class="string">Never</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
</details>
<h2 id="vscode-中使用">VSCode 中使用</h2>
<p>VSCode 中需要安装插件 <code>Clang-Format</code>，安装后需要把 <code>.clang-format</code> 文件放到 VSCode 的工程目录下。</p>
<p><em>Windows 下如果没把 clang 的 bin 目录放置到环境变量中，需要在设置中设置 clang-format 路径。</em></p>
<p>格式化快捷键：<code>shift + alt + f</code></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL安装记录</title>
    <url>/2024/20/</url>
    <content><![CDATA[<p>关键词：Linux</p>
<span id="more"></span>
<hr>
<h2 id="wsl-简介">WSL 简介</h2>
<p>开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。 通过适用于 Linux 的 Windows 子系统 (WSL)，开发人员可以安装 Linux 发行版，并直接在 Windows 上使用 Linux 应用程序、实用程序和 Bash 命令行工具，不用进行任何修改，也无需承担传统虚拟机或双启动设置的费用。</p>
<p>WSL 目前已发布两代产品：WSL 1 和 WSL 2。</p>
<ul>
<li>WSL 1 实现了 Linux 兼容层，将 Linux 系统调用转换为 Windows NT 系统调用；</li>
<li>WSL 2 则利用 Windows 的 Hyper-V 功能，通过虚拟化技术直接运行 Linux 虚拟机，更接近原生 Linux 操作系统体验。</li>
</ul>
<h2 id="wsl-的前提条件">WSL 的前提条件</h2>
<ol>
<li>检查 Windows 版本，WSL 需要 Windows 10 1903 （内部版本 18362）或更高版本（x64）。如果版本较低，请更新 Windows 10 系统。（设置 → 关于可以看）</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_WindowsVersion.jpg" alt="Windows版本"></p>
<ol start="2">
<li>检查 BIOS 是否开启了虚拟化。（打开任务管理器 → 性能 → CPU处）<em>如果没有开启虚拟化，需要进入 BIOS 的 Configuration 处设置。</em></li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_BIOSV.jpg" alt="BIOS虚拟化"></p>
<ol start="3">
<li>启用 WSL 功能。（搜索打开“启用或关闭 Windows 功能”，滑到最下面，启用“媒体功能”、“适用于 Linux 的 Windows 子系统”、“虚拟机平台”和“远程差分压缩 API 支持”）</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_openSet.jpg" alt="启用WSL功能"></p>
<h2 id="安装-linux">安装 Linux</h2>
<ol>
<li>
<p>在 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#downloading-distributions">此处</a> 下载自己需要的 Linux 发行版本。（此处下载 Ubuntu 20.04 为例）</p>
</li>
<li>
<p>下载得到的是一个 <code>.AppxBundle</code> 文件，将其重命名为 <code>.zip</code> 并解压。</p>
</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_unpack.jpg" alt="解压后的文件"></p>
<ol start="3">
<li>选择自己电脑架构的 <code>.appx</code> 文件，再将其命名为 <code>.zip</code> 并解压。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_unpack2.jpg" alt="获取自己架构的包"></p>
<ol start="4">
<li>运行 <code>ubuntu.exe</code>，过程中需要注册账号名和密码。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_install.jpg" alt="安装成功"></p>
<h2 id="运行并配置-wsl">运行并配置 WSL</h2>
<ol>
<li>直接使用 cmd 输入 <code>wsl</code> 可进入默认 WSL，输入 <code>wsl --list</code> 查看安装了的 Linux 版本。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_useWSL.jpg" alt="使用WSL"></p>
<ol start="2">
<li>更改 Ubuntu 的 apt 下载镜像：</li>
</ol>
<p>使用以下命令确定 Ubuntu 的 codename：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_codename.jpg" alt="查看codename"></p>
<p>此处我为 focal。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>将里面的内容替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p><em>如果你的 codename 为其他，需要将上面的内容中的 focal 修改为你自己的 codename。</em></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/20_change.jpg" alt="更改下载源"></p>
<p><em>要是不习惯 vim 操作，可以偷懒使用 Windows 的文件管理器，打开你的 Ubuntu 文件夹，找到里面的 rootfs\etc\apt\，然后用记事本打开 sources.list 进行修改。</em></p>
<p>修改后运行下面的命令进行更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置 DNS 网关：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>添加阿里 DNS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 127.0.0.53</span><br></pre></td></tr></table></figure>
<p><em>此处好像记事本打不开…</em></p>
<p>保存后再运行一次下面命令进行更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>添加 gcc/g++ 环境</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure>
<h2 id="升级到-wsl-2">升级到 WSL 2</h2>
<p>先使用下面的命令检查自己的 WSL：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl -l --v</span><br></pre></td></tr></table></figure>
<p>如果版本不是 2 而想升级到 2 的步骤如下：</p>
<ol>
<li>
<p>下载 Linux 内核更新包：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">下载地址</a></p>
</li>
<li>
<p>接着运行下载到的更新包。</p>
</li>
</ol>
<p><em>在升级后，我再进入 WSL 时出现了“参考的对象类型不支持尝试的操作”的情况，解决方式参考：<a href="https://blog.csdn.net/marin1993/article/details/119841299">CSDN</a></em></p>
<h2 id="注销-wsl">注销 WSL</h2>
<p>在 cmd 中输入 <code>wsl --unregister &lt;Linux&gt;</code> 进行删除 WSL。</p>
<p>另外如果忘记了 root 账户密码的话，可以修改：</p>
<ol>
<li>打开 powershell 或 cmd，输入 <code>wsl -u root</code> 会直接进入 root 模式，在改模式下直接修改 root 密码；</li>
<li>输入 <code>passwd root</code>，终端会提示让你输入新的密码。</li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><a href="https://docs.eesast.com/docs/tools/wsl">WSL 安装与使用</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">如何使用 WSL 在 Windows 上安装 Linux</a></li>
<li><a href="https://blog.csdn.net/qq_46092061/article/details/118878697">Ubuntu18.04…5 配置国内镜像源：解决E: Failed to fetch</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">下载 Linux 内核更新包</a></li>
<li><a href="https://blog.csdn.net/xdg15294969271/article/details/122374964">Windows下WSL的root密码忘记解决办法</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C++继承中的virtual以及虚指针、虚表</title>
    <url>/2024/23/</url>
    <content><![CDATA[<p>关键词：C++</p>
<span id="more"></span>
<hr>
<p>在使用 C++ 类的继承时，经常会使用到 <code>virtual</code> 关键字，无论是声明 <strong>虚函数</strong> 还是 <strong>虚继承</strong>。</p>
<h2 id="基础概念">基础概念</h2>
<p><code>virtual</code> 说明符指定非静态成员函数为虚函数并支持动态调用派发。</p>
<h3 id="虚函数">虚函数</h3>
<p>虚函数是可在派生类中覆盖其行为的成员函数，解决函数重名（重写）的调用问题。</p>
<ul>
<li>与非虚函数相反，即使没有关于该类实际类型的编译时信息，仍然保留被覆盖的行为。</li>
<li>当使用到基类的指针或引用来处理派生类时，对被覆盖的虚函数的调用，将会调用定义于派生类中（重写）的函数版本。</li>
<li>当使用有限定名字查找（即函数名出现在作用域解析运算符 <code>::</code> 的右侧）时，使用的是限定查找的函数版本。</li>
</ul>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;base\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;derived\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line">	Derived d;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过引用调用虚函数</span></span><br><span class="line">	Base &amp;br = b;</span><br><span class="line">	Base &amp;dr = d;</span><br><span class="line">	br.<span class="built_in">f</span>(); <span class="comment">// base</span></span><br><span class="line">	dr.<span class="built_in">f</span>(); <span class="comment">// derived</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过指针调用虚函数</span></span><br><span class="line">	Base *bp = &amp;b;</span><br><span class="line">	Base *dp = &amp;d;</span><br><span class="line">	bp-&gt;<span class="built_in">f</span>(); <span class="comment">// base</span></span><br><span class="line">	dp-&gt;<span class="built_in">f</span>(); <span class="comment">// derived</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非虚函数调用</span></span><br><span class="line">	br.Base::<span class="built_in">f</span>(); <span class="comment">// base</span></span><br><span class="line">	dr.Base::<span class="built_in">f</span>(); <span class="comment">// base</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意要把父类的析构函数声明为虚函数，这样子类析构时会正确调用子类的析构函数，避免了内存泄漏的风险。</p>
<h4 id="虚函数指针和虚函数表">虚函数指针和虚函数表</h4>
<p>虚函数指针（vfptr）指向一个虚函数表（vftable），虚函数表记录了虚函数的地址。</p>
<p>虚表是属于类的，一个类只需要一个虚表即可，同一个类的所有对象都使用同一个虚表。</p>
<h3 id="虚继承">虚继承</h3>
<p>虚继承解决的是 C++ 多重继承带来的问题。</p>
<ul>
<li>从不同途径继承来的同一基类，会在子类中存在多份拷贝，既浪费存储空间，也存在二义性。</li>
</ul>
<p>虚继承底层实现与编译器相关，一般通过虚基指针和虚基表实现。</p>
<ul>
<li>每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间）。</li>
</ul>
<h4 id="虚基指针和虚基表">虚基指针和虚基表</h4>
<p>虚基指针（vbptr）指向一个虚基表（vbtable），虚基表记录了虚基类与本类的偏移地址，通过偏移地址找到虚基类成员，而不用持有拷贝浪费空间。</p>
<p>与虚函数指针和虚函数表相比：</p>
<ul>
<li>虚基类依旧存在继承类中，占用存储空间；虚函数不占用存储空间。</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。</li>
</ul>
<h2 id="从内存布局看">从内存布局看</h2>
<h3 id="无继承">无继承</h3>
<p>单纯一个类时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>VS 所输出内存布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(4):</span><br><span class="line">	+---</span><br><span class="line"> 0	| m_a</span><br><span class="line">	+---</span><br></pre></td></tr></table></figure>
<p>内存大小为一个 <code>int</code> 变量的大小。</p>
<h3 id="单继承">单继承</h3>
<h4 id="1-非虚继承无虚函数">1.非虚继承无虚函数</h4>
<p>情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基类 A 的内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(4):</span><br><span class="line">	+---</span><br><span class="line"> 0	| m_a</span><br><span class="line">	+---</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，不存在 <code>&#123;vfptr&#125;</code> 虚函数指针，只存在 <code>m_a</code> 变量（4 字节）。所以占内存 4 字节。</li>
</ul>
<p>派生类 B 的内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B	size(8):</span><br><span class="line">	+---</span><br><span class="line"> 0	| +--- (base class A)</span><br><span class="line"> 0	| | m_a		基类数据成员</span><br><span class="line">	| +---</span><br><span class="line"> 4	| m_b		子类数据成员</span><br><span class="line">	+---</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，不存在 <code>&#123;vfptr&#125;</code> 虚函数指针，只存在 <code>m_b</code> 变量（4 字节）和继承得到的 <code>m_a</code> 变量，所以占内存 8 字节。</li>
</ul>
<p>结果：</p>
<ul>
<li>由于不存在虚函数表，故并不会调用定义于派生类中（重写）的函数版本。</li>
</ul>
<h4 id="2-非虚继承有虚函数">2.非虚继承有虚函数</h4>
<p>情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基类 A 的内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(16):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;</span><br><span class="line"> 8	| m_a</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">A::$vftable@:</span><br><span class="line">	| &amp;A_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;A::f</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，存在 <code>&#123;vfptr&#125;</code> 虚函数指针（8 字节，64位系统）、 <code>m_a</code> 变量（4 字节）。同时进行内存对齐（+4 字节），所以占内存 16 字节。</li>
<li>在虚函数表中，存在虚函数 <code>f</code>。</li>
</ul>
<p>子类 B 的内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B	size(24):</span><br><span class="line">	+---</span><br><span class="line"> 0	| +--- (base class A)</span><br><span class="line"> 0	| | &#123;vfptr&#125;		虚函数指针</span><br><span class="line"> 8	| | m_a			基类数据成员</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">16	| m_b			子类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">B::$vftable@:		虚函数表</span><br><span class="line">	| &amp;B_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;B::f</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，存在 <code>&#123;vfptr&#125;</code> 虚函数指针（8 字节，64位系统）、 <code>m_a</code> 变量（4 字节），同样进行内存对齐（+4 字节），再加上子类自身的成员变量 <code>m_b</code> （4 字节），再加以内存对齐（+4 字节），所以占内存 24 字节。</li>
<li>在虚函数表中，存在虚函数 <code>f</code>，指明了函数版本。</li>
</ul>
<p>结果：</p>
<ul>
<li>虚函数表指明了函数版本，调用定义于派生类中（重写）的函数版本。</li>
</ul>
<h4 id="3-虚继承无虚函数">3.虚继承无虚函数</h4>
<p>情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>父类 A 的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(4):</span><br><span class="line">	+---</span><br><span class="line"> 0	| m_a</span><br><span class="line">	+---</span><br></pre></td></tr></table></figure>
<ul>
<li>只有数据区域的变量。</li>
</ul>
<p>子类 B 的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B	size(24):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vbptr&#125;		虚基指针</span><br><span class="line"> 8	| m_b			子类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">16	| m_a			基类数据成员</span><br><span class="line">	+---</span><br><span class="line">B::$vbtable@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 16 (Bd(B+0)A)		表示类 B 的虚基类 A 位于偏移 16 + 0 = 16 处</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      16       0       4 		0</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，存在虚基指针 <code>&#123;vbptr&#125;</code>，且虚基类位于子类存储空间的末尾。</li>
<li>存在虚基表 <code>&#123;vbtable&#125;</code>。</li>
</ul>
<p>结果：</p>
<ul>
<li>由于不存在虚函数表，不会调用定义于派生类中（重写）的函数版本。</li>
</ul>
<h4 id="4-虚继承有虚函数">4.虚继承有虚函数</h4>
<p>情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>父类 A 的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(16):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;</span><br><span class="line"> 8	| m_a</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">A::$vftable@:</span><br><span class="line">	| &amp;A_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;A::f</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，存在 <code>&#123;vfptr&#125;</code> 虚函数指针（8 字节，64位系统）、 <code>m_a</code> 变量（4 字节）。同时进行内存对齐（+4 字节），所以占内存 16 字节。</li>
<li>在虚函数表中，存在虚函数 <code>f</code>。</li>
</ul>
<p>子类 B 的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B	size(32):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vbptr&#125;		虚基指针</span><br><span class="line"> 8	| m_b			子类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">16	| &#123;vfptr&#125;		虚基类虚函数指针</span><br><span class="line">24	| m_a			虚基类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">B::$vbtable@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 16 (Bd(B+0)A)		表示类 B 的虚基类 A 位于偏移 16 + 0 = 16 处</span><br><span class="line">B::$vftable@:</span><br><span class="line">	| -16</span><br><span class="line"> 0	| &amp;B::f</span><br><span class="line">B::f this adjustor: 16</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      16       0       4 		0</span><br></pre></td></tr></table></figure>
<ul>
<li>在数据区域，存在 <code>&#123;vbptr&#125;</code> 虚基指针 和 <code>&#123;vfptr&#125;</code> 虚函数指针。</li>
<li>在虚函数表中，存在虚函数 <code>f</code>，指明了函数版本。</li>
<li>如果派生类没有独立的虚函数，此时派生类对象不会产生虚函数指针。</li>
</ul>
<hr>
<p>若派生类中有独立的虚函数，会产生虚函数指针：</p>
<p>如下情形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;	<span class="comment">// 派生类中独立的虚函数</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;tmp\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>导致内存布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B	size(40):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;		虚函数指针</span><br><span class="line"> 8	| &#123;vbptr&#125;		虚基指针</span><br><span class="line">16	| m_b			子类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">24	| &#123;vfptr&#125;		虚基类虚函数指针</span><br><span class="line">32	| m_a			虚基类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">B::$vftable@B@:		类 B 的虚函数表</span><br><span class="line">	| &amp;B_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;B::f1</span><br><span class="line">B::$vbtable@:</span><br><span class="line"> 0	| -8</span><br><span class="line"> 1	| 16 (Bd(B+8)A)		表示类 B 的虚基类 A 位于偏移 16 + 8 = 24 处</span><br><span class="line">B::$vftable@A@:		类 A 的虚函数表</span><br><span class="line">	| -24</span><br><span class="line"> 0	| &amp;B::f</span><br><span class="line">B::f this adjustor: 24</span><br><span class="line">B::f1 this adjustor: 0</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      24       8       4 		0</span><br></pre></td></tr></table></figure>
<ul>
<li>如果派生类拥有自己的虚函数，此时派生类对象就会产生自己本身的虚函数指针 <code>&#123;vfptr&#125;</code>，并且该虚函数指针位于派生类对象存储空间的最开始位置。</li>
<li>虚函数指针 <code>&#123;vfptr&#125;</code> 放在了虚基指针 <code>&#123;vbptr&#125;</code> 的前面，为了加快虚函数的查找速度。</li>
</ul>
<hr>
<p>结果：</p>
<ul>
<li>虚函数表指明了函数版本，调用定义于派生类中（重写）的函数版本。</li>
</ul>
<h3 id="多继承">多继承</h3>
<h4 id="1-简单多继承">1.简单多继承</h4>
<p>情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A, <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myVirtual</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时基类 A 和 B 的内存布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(16):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;</span><br><span class="line"> 8	| m_a</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">A::$vftable@:</span><br><span class="line">	| &amp;A_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;A::f1</span><br><span class="line"> 1	| &amp;A::f2</span><br><span class="line"></span><br><span class="line">class B	size(16):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;</span><br><span class="line"> 8	| m_b</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">B::$vftable@:</span><br><span class="line">	| &amp;B_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;B::f1</span><br><span class="line"> 1	| &amp;B::f2</span><br></pre></td></tr></table></figure>
<p>子类 C 的内存布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C	size(56):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;		虚函数指针</span><br><span class="line"> 8	| &#123;vbptr&#125;		虚基指针</span><br><span class="line">16	| m_c</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">24	| &#123;vfptr&#125;		虚基类虚函数指针</span><br><span class="line">32	| m_a			虚基类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base B)</span><br><span class="line">40	| &#123;vfptr&#125;		虚基类虚函数指针</span><br><span class="line">48	| m_b			虚基类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">C::$vftable@C@:		类 C 的虚函数表</span><br><span class="line">	| &amp;C_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;C::myVirtual</span><br><span class="line">C::$vbtable@:</span><br><span class="line"> 0	| -8</span><br><span class="line"> 1	| 16 (Cd(C+8)A)		表示类 C 的虚基类 A 位于偏移 16 + 8 = 24 处</span><br><span class="line"> 2	| 32 (Cd(C+8)B)		表示类 C 的虚基类 A 位于偏移 32 + 8 = 40 处</span><br><span class="line">C::$vftable@A@:		类 A 的虚函数表</span><br><span class="line">	| -24</span><br><span class="line"> 0	| &amp;C::f1</span><br><span class="line"> 1	| &amp;C::f2</span><br><span class="line">C::$vftable@B@:</span><br><span class="line">	| -40</span><br><span class="line"> 0	| &amp;thunk: this-=16; goto C::f1</span><br><span class="line"> 1	| &amp;thunk: this-=16; goto C::f2</span><br><span class="line">C::myVirtual this adjustor: 0</span><br><span class="line">C::f1 this adjustor: 24</span><br><span class="line">C::f2 this adjustor: 24</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      24       8       4 		0</span><br><span class="line">               B      40       8       8 		0</span><br></pre></td></tr></table></figure>
<ul>
<li>数据区域照常继承。</li>
<li>虚函数表区域中存在三个虚函数表， <code>vftable@C@</code>、 <code>vftable@A@</code>、 <code>vftable@B@</code>；存在一个虚基表 <code>$vbtable@</code>。</li>
<li>派生类会覆盖基类的虚函数，只有第一个虚函数表（此处为 <code>vftable@A@</code> ）中存放的是真实的被覆盖的函数的地址；其它的虚函数表中（如 <code>vftable@B@</code> ）存放的并不是真实的对应的虚函数的地址，而只是一条跳转指令。</li>
</ul>
<h4 id="2-棱形继承-钻石继承">2.棱形继承（钻石继承）</h4>
<p>情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myVirtual</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;D\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时 A 类的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A	size(16):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;</span><br><span class="line"> 8	| m_a</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">A::$vftable@:</span><br><span class="line">	| &amp;A_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;A::f</span><br></pre></td></tr></table></figure>
<p>B 类和 C 类内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B	size(32):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vbptr&#125;</span><br><span class="line"> 8	| m_b</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">16	| &#123;vfptr&#125;</span><br><span class="line">24	| m_a</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">B::$vbtable@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 16 (Bd(B+0)A)</span><br><span class="line">B::$vftable@:</span><br><span class="line">	| -16</span><br><span class="line"> 0	| &amp;B::f</span><br><span class="line">B::f this adjustor: 16</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      16       0       4 		0</span><br><span class="line"></span><br><span class="line">class C	size(32):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vbptr&#125;</span><br><span class="line"> 8	| m_c</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">16	| &#123;vfptr&#125;</span><br><span class="line">24	| m_a</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">C::$vbtable@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 16 (Cd(C+0)A)</span><br><span class="line">C::$vftable@:</span><br><span class="line">	| -16</span><br><span class="line"> 0	| &amp;C::f</span><br><span class="line">C::f this adjustor: 16</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      16       0       4 		0</span><br></pre></td></tr></table></figure>
<p>子类 D 的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class D	size(64):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vfptr&#125;		虚函数指针</span><br><span class="line"> 8	| +--- (base class B)</span><br><span class="line"> 8	| | &#123;vbptr&#125;		基类虚基指针</span><br><span class="line">16	| | m_b			基类数据成员</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">24	| +--- (base class C)</span><br><span class="line">24	| | &#123;vbptr&#125;		基类虚基指针</span><br><span class="line">32	| | m_c			基类数据成员</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">40	| m_d			子类数据成员</span><br><span class="line"> 	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">48	| &#123;vfptr&#125;		虚基类虚函数指针</span><br><span class="line">56	| m_a			虚基类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">D::$vftable@D@:		类 D 的虚函数表</span><br><span class="line">	| &amp;D_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;D::myVirtual</span><br><span class="line">D::$vbtable@B@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 40 (Dd(B+0)A)		表示类 B 的虚基类 A 位于偏移 40 + 0 = 24 处</span><br><span class="line">D::$vbtable@C@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 24 (Dd(C+0)A)		表示类 C 的虚基类 A 位于偏移 24 + 0 = 24 处</span><br><span class="line">D::$vftable@B@:		类 B 的虚函数表（因为类 B 和类 C 都有一样的函数，虚继承时只保留类 B 的虚函数表）</span><br><span class="line">	| -48</span><br><span class="line"> 0	| &amp;D::f</span><br><span class="line">D::myVirtual this adjustor: 0</span><br><span class="line">D::f this adjustor: 48</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      48       8       4 		0</span><br></pre></td></tr></table></figure>
<p>再来一个棱形继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myVirtual</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>针对类 D 的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class D	size(72):</span><br><span class="line">	+---</span><br><span class="line"> 0	| +--- (base class B)</span><br><span class="line"> 0	| | &#123;vfptr&#125;		基类虚函数指针</span><br><span class="line"> 8	| | &#123;vbptr&#125;		基类虚基指针</span><br><span class="line">16	| | m_b			基类数据成员</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">24	| +--- (base class C)</span><br><span class="line">24	| | &#123;vfptr&#125;		基类虚函数指针</span><br><span class="line">32	| | &#123;vbptr&#125;		基类虚基指针</span><br><span class="line">40	| | m_c			基类数据成员</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">48	| m_d			子类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base A)</span><br><span class="line">56	| &#123;vfptr&#125;		虚基类虚函数指针</span><br><span class="line">64	| val			虚基类数据成员</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br><span class="line">D::$vftable@B@:		类 B 的虚函数表</span><br><span class="line">	| &amp;D_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;D::g</span><br><span class="line"> 1	| &amp;D::myVirtual</span><br><span class="line">D::$vftable@C@:		类 C 的虚函数表</span><br><span class="line">	| -24</span><br><span class="line"> 0	| &amp;D::h</span><br><span class="line">D::$vbtable@B@:</span><br><span class="line"> 0	| -8</span><br><span class="line"> 1	| 48 (Dd(B+8)A)		表示类 B 的虚基类 A 位于偏移 48 + 8 = 56 处</span><br><span class="line">D::$vbtable@C@:</span><br><span class="line"> 0	| -8</span><br><span class="line"> 1	| 24 (Dd(C+8)A)		表示类 C 的虚基类 A 位于偏移 24 + 8 = 32 处</span><br><span class="line">D::$vftable@A@:		类 A 的虚函数表</span><br><span class="line">	| -56</span><br><span class="line"> 0	| &amp;D::f</span><br><span class="line">D::myVirtual this adjustor: 0</span><br><span class="line">D::f this adjustor: 56</span><br><span class="line">D::g this adjustor: 0</span><br><span class="line">D::h this adjustor: 24</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               A      56       8       4 		0</span><br></pre></td></tr></table></figure>
<p>如果不使用虚继承，出现的问题是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class D	size(56):</span><br><span class="line">	+---</span><br><span class="line"> 0	| +--- (base class B)</span><br><span class="line"> 0	| | +--- (base class A)</span><br><span class="line"> 0	| | | &#123;vfptr&#125;</span><br><span class="line"> 8	| | | val</span><br><span class="line">  	| | | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| | +---</span><br><span class="line">16	| | m_b</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">24	| +--- (base class C)</span><br><span class="line">24	| | +--- (base class A)</span><br><span class="line">24	| | | &#123;vfptr&#125;</span><br><span class="line">32	| | | val		存在两次 val</span><br><span class="line">  	| | | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| | +---</span><br><span class="line">40	| | m_c</span><br><span class="line">  	| | &lt;alignment member&gt; (size=4)</span><br><span class="line">	| +---</span><br><span class="line">48	| m_d</span><br><span class="line">  	| &lt;alignment member&gt; (size=4)</span><br><span class="line">	+---</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 C++ 中结构体内存对齐的讨论</title>
    <url>/2024/24/</url>
    <content><![CDATA[<p>关键词：C++</p>
<span id="more"></span>
<hr>
<p>在 C++ 的实际代码编写中，结构体（类）的内存大小会进行对齐。</p>
<h2 id="内存对齐的测试代码">内存对齐的测试代码</h2>
<p>定义若干个结构体，测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataX</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFOSTRUCT(STRUCT) \</span></span><br><span class="line"><span class="meta">	cout &lt;&lt; #STRUCT &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sizeof(STRUCT) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; offsetof(STRUCT, a) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; offsetof(STRUCT, b) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; offsetof(STRUCT, c) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; offsetof(STRUCT, d) &lt;&lt; endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">INFOSTRUCT</span>(DataX);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>offsetof</code> 是一个宏，可以计算成员的偏移量。</li>
</ul>
<h2 id="理解例子">理解例子</h2>
<h3 id="data0-data1-data2">Data0 &amp; Data1 &amp; Data2</h3>
<p>先来看这三个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data0</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">short</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data1</span> &#123;</span><br><span class="line">	<span class="type">short</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data2</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">short</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码在 VS 中输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data0   8       0       1       2       4</span><br><span class="line">Data1   12      0       2       4       8</span><br><span class="line">Data2   12      0       2       4       8</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu-18.04 Clang++ 编译后是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ ./test</span><br><span class="line">Data0   8       0       1       2       4</span><br><span class="line">Data1   12      0       2       4       8</span><br><span class="line">Data2   12      0       2       4       8</span><br></pre></td></tr></table></figure>
<p>这三个结构体的成员变量都有两个 <code>char</code>、一个 <code>short</code> 和一个 <code>int</code>，因为声明位置不同，导致了内存大小分别为8、12、12。</p>
<p>根据已知的内存大小和成员偏移量，尝试表示出其内存布局：</p>
<table>
	<tr align="center" valign="center">
		<td>Data0</td>
		<td>Data1</td>
		<td>Data2</td>
	</tr>
	<tr align="center" valign="center">
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data0Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data1Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data2Layout.png"></td>
	</tr>
</table>
<ul>
<li>
<p>结构体 <code>Data0</code> 的内存大小最小，排布最紧凑，空间利用最合理。</p>
<ul>
<li>内存对齐为 4 字节，内存大小为 8 字节。</li>
</ul>
</li>
<li>
<p>结构体 <code>Data1</code> 和 <code>Data2</code> 的内存布局中因为对齐机制，所以存在空的补位。</p>
<ul>
<li>内存对齐为 4 字节，内存大小为 12 字节。</li>
</ul>
</li>
</ul>
<h3 id="data3-data4">Data3 &amp; Data4</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data3</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data4</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码在 VS 中输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data3   24      0       8       16      18</span><br><span class="line">Data4   24      0       8       16      18</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu-18.04 Clang++ 编译后是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ ./test</span><br><span class="line">Data3   24      0       8       16      18</span><br><span class="line">Data4   24      0       8       16      18</span><br></pre></td></tr></table></figure>
<p>这两个结构体， <code>Data4</code> 是在 <code>Data3</code> 的基础上增加了一些新的成员变量形成的，但是内存大小都为 24。</p>
<p>根据已知的内存大小和成员偏移量，尝试表示出其内存布局：</p>
<table>
	<tr align="center" valign="center">
		<td>Data3</td>
		<td>Data4</td>
	</tr>
	<tr align="center" valign="center">
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data3Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data4Layout.png"></td>
	</tr>
</table>
<ul>
<li>在内存对齐下，<code>Data3</code> 的最后几个字节浪费了，而 <code>Data4</code> 增加的新成员正好利用上了，而且还不会额外增加内存大小。</li>
<li>内存对齐为 8 字节，内存大小为 24 字节。</li>
</ul>
<h3 id="data5-data6">Data5 &amp; Data6</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data5</span> &#123;</span><br><span class="line">	<span class="type">short</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) Data6 &#123;</span><br><span class="line">	<span class="type">short</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">char</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码在 VS 中输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data5   10      0       2       4       8</span><br><span class="line">Data6   16      0       2       4       8</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu-18.04 Clang++ 编译后是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ ./test</span><br><span class="line">Data5   10      0       2       4       8</span><br><span class="line">Data6   16      0       2       4       8</span><br></pre></td></tr></table></figure>
<p>结构体 <code>Data5</code> 使用了 <code>#pragma pack()</code> 的方式规定了内存对齐的大小；而结构体 <code>Data6</code> 使用 C++11 的关键字 <code>alignas()</code> 规定内存对齐的大小。</p>
<p>根据已知的内存大小和成员偏移量，尝试表示出其内存布局：</p>
<table>
	<tr align="center" valign="center">
		<td>Data5</td>
		<td>Data6</td>
	</tr>
	<tr align="center" valign="center">
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data5Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data6Layout.png"></td>
	</tr>
</table>
<ul>
<li>
<p><code>Data5</code> 规定了内存对齐为 2，所以在 10 个字节的时候就停下。如果把两个 <code>char</code> 连在一起声明，会更省空间，达到大小为 8。</p>
<ul>
<li>内存对齐为 2 字节，内存大小为 10 字节。</li>
</ul>
</li>
<li>
<p><code>Data6</code> 规定了内存对齐为 8，所以比内存对齐为 4 的布局多出更多空间。</p>
<ul>
<li>内存对齐为 8 字节，内存大小为 16 字节。</li>
</ul>
</li>
</ul>
<h3 id="data7-data8-data9-data10">Data7 &amp; Data8 &amp; Data9 &amp; Data10</h3>
<p>对于复杂结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data7</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">		<span class="type">char</span> _a[<span class="number">5</span>];</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data8</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">		<span class="type">int</span> _a;</span><br><span class="line">		<span class="type">char</span> _b;</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data9</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">		<span class="type">char</span> _a;</span><br><span class="line">		<span class="type">int</span> _b;</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data10</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) _Data &#123;</span><br><span class="line">		<span class="type">char</span> _a;</span><br><span class="line">		<span class="type">int</span> _b;</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码在 VS 中输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data7   16      0       1       8       12</span><br><span class="line">Data8   20      0       4       12      16</span><br><span class="line">Data9   20      0       4       12      16</span><br><span class="line">Data10  24      0       8       16      20</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu-18.04 Clang++ 编译后是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ ./test</span><br><span class="line">Data7   16      0       1       8       12</span><br><span class="line">Data8   20      0       4       12      16</span><br><span class="line">Data9   20      0       4       12      16</span><br><span class="line">Data10  24      0       8       16      20</span><br></pre></td></tr></table></figure>
<p>尝试画出内存布局图：</p>
<table>
	<tr align="center" valign="center">
		<td>Data7</td>
		<td>Data8</td>
		<td>Data9</td>
		<td>Data10</td>
	</tr>
	<tr align="center" valign="center">
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data7Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data8Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data9Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data10Layout.png"></td>
	</tr>
</table>
<ul>
<li>
<p><code>Data7</code>：</p>
<ul>
<li>内嵌结构体内存对齐为 1 字节，内存大小为 5 字节。</li>
<li>外部结构体内存对齐为 4 字节，内存大小为 16 字节。</li>
</ul>
</li>
<li>
<p><code>Data8</code>：</p>
<ul>
<li>内嵌结构体内存对齐为 4 字节，内存大小为 8 字节。</li>
<li>外部结构体内存对齐为 4 字节，内存大小为 20 字节。</li>
</ul>
</li>
<li>
<p><code>Data9</code>：</p>
<ul>
<li>内嵌结构体内存对齐为 4 字节，内存大小为 8 字节。</li>
<li>外部结构体内存对齐为 4 字节， 内存大小为 20 字节。</li>
</ul>
</li>
<li>
<p><code>Data10</code>：</p>
<ul>
<li>内嵌结构体内存对齐为 8 字节，内存大小为 8 字节。</li>
<li>外部结构体内存对齐为 8 字节， 内存大小为 24 字节。</li>
</ul>
</li>
</ul>
<h3 id="data11-data12-data13">Data11 &amp; Data12 &amp; Data13</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data11</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">		<span class="type">double</span> _a;</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data12</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">		<span class="type">char</span> _a[<span class="number">8</span>];</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data13</span> &#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">		<span class="type">int</span> _a[<span class="number">2</span>];</span><br><span class="line">	&#125; b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码在 VS 中输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data11  24      0       8       16      20</span><br><span class="line">Data12  20      0       1       12      16</span><br><span class="line">Data13  20      0       4       12      16</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu-18.04 Clang++ 编译后是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ clang++ test.cpp -o test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ ./test</span><br><span class="line">Data11  24      0       8       16      20</span><br><span class="line">Data12  20      0       1       12      16</span><br><span class="line">Data13  20      0       4       12      16</span><br></pre></td></tr></table></figure>
<p>尝试画出内存布局图：</p>
<table>
	<tr align="center" valign="center">
		<td>Data11</td>
		<td>Data12</td>
		<td>Data13</td>
	</tr>
	<tr align="center" valign="center">
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data11Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data12Layout.png"></td>
		<td><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/24_Data13Layout.png"></td>
	</tr>
</table>
<ul>
<li>
<p><code>Data11</code>：</p>
<ul>
<li>内嵌结构体内存对齐为 8 字节，内存大小为 8 字节。</li>
<li>外部结构体内存对齐为 8 字节，内存大小为 24 字节。</li>
</ul>
</li>
<li>
<p><code>Data12</code>：</p>
<ul>
<li>内嵌结构体成员为 <code>char</code> 数组，比较特殊，内存对齐为 1 字节，内存大小为 8 字节。</li>
<li>外部结构体内存对齐为 4 字节，内存大小为 20 字节。</li>
</ul>
</li>
<li>
<p><code>Data13</code>：</p>
<ul>
<li>内嵌结构体内存对齐为 4 字节，内存大小为 8 字节。</li>
<li>外部结构体内存对齐为 4 字节， 内存大小为 20 字节。</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<ol>
<li>一般情况下，默认最小对齐单位为 2 字节， <strong>对齐最宽的基本类型</strong> （ <em>如内存最大成员为 <code>int</code>，则内存对齐为 4</em> ）。 <strong>结构体的总大小为结构体最宽基本类型成员大小的整数倍</strong>。</li>
<li>嵌套成员的情况下（ <em>如结构体成员包含结构体，结构体成员包含类等情况</em> ）， <strong>内部结构体对齐后视作整体再参与外部对齐，内存对齐等于成员的最大内存对齐</strong>。</li>
<li><code>char</code> 类型比较特殊，趋向紧密。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云对象存储OSS实现图床</title>
    <url>/2023/3/</url>
    <content><![CDATA[<p>注册登录阿里云👉开启对象存储👉配置Key👉放心上传</p>
<p>关键词：对象存储OSS</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h2 id="1-什么是图床">1.什么是图床</h2>
<p>图床是一种概念，顾名思义用于网络上存放图片。当网站图片过多时，整个网站的存储大小会变得较大，负担也变得较大。为了减轻负担，可以选择把图片置于一种存储容器（图床）中，之后显示图片就只需引用网络链接即可。</p>
<h2 id="2-开启对象存储服务">2.开启对象存储服务</h2>
<p>进入<a href="https://cn.aliyun.com/">阿里云官网</a>，点击右上角控制台，搜索对象存储OSS。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/3_1.png" alt="阿里云页面"></p>
<p>选择创建Bucket，设置建议如下：</p>
<ul>
<li>Bucket名称：自定义</li>
<li>地域：选择距离自己较近的</li>
<li>存储类型：默认不动</li>
<li>存储荣誉类型：默认不动</li>
<li>读写权限：公共读</li>
</ul>
<p>创建成功后可在Bucket列表查看。</p>
<h2 id="3-使用picgo工具进行图片上传">3.使用PicGo工具进行图片上传</h2>
<p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">下载地址</a></p>
<p>下载后选择合适的盘符安装，打开软件。<br>
初始时可能不显示界面，需要去系统任务栏右键软件图标，选择打开主窗口。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/3_2.png" alt="软件打开"></p>
<p>接着选择图床设置，此处使用阿里云OSS。</p>
<p>回到阿里云OSS控制台，移动至右上角悬浮，点击AccessKey管理。创建一个新AccessKey，复制并粘贴到PicGo中。</p>
<p>配置参数建议如下：</p>
<ul>
<li>设定KeyID：AccessKey中复制得来</li>
<li>设定KeySecret：AccessKey中复制得来</li>
<li>设定Bucket：你Bucket得名字</li>
<li>设定存储区域：OSS选择的地域</li>
<li>设定存储路径：图片上传至OSS的文件夹或路径</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/3_3.png" alt="配置Key"></p>
<p>配置完成后即可上传图片，在PicGo的相册中可以获得图片的连接，可在HTML或者Markdown等文件中调用。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>对象存储OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv5由pt文件转onnx文件报错解决</title>
    <url>/2023/7/</url>
    <content><![CDATA[<p>ONNX: export failure ❌ 5.9s: Unsupported ONNX opset version: 17</p>
<h2 id="报错窗口">报错窗口</h2>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/7_error.png" alt="报错"></p>
<h2 id="报错原因">报错原因</h2>
<p>export.py文件中parse_opt()函数设置的opset版本错误。</p>
<h2 id="解决方案">解决方案</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到parse_opt()函数中的此行，将default值改为12</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--opset&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">12</span>, <span class="built_in">help</span>=<span class="string">&#x27;ONNX: opset version&#x27;</span>)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLOv5</tag>
        <tag>onnx</tag>
      </tags>
  </entry>
  <entry>
    <title>C++报错：表达式必须含有常量值</title>
    <url>/2023/6/</url>
    <content><![CDATA[<p>关于在Visual Studio 2022使用C++ 20语法的表达式开辟数组空间报错</p>
<hr>
<h2 id="错误原因">错误原因</h2>
<ol>
<li>
<p>c++中不允许使用变量作为数组的长度定义数组，必须为常量值，c++中所有的内存需求都是在程序执行前通过定义的常量来确定的。</p>
</li>
<li>
<p>声明为const或constexpr的表达式在编译时计算结果不是常数。</p>
</li>
<li>
<p>编译器必须能够在表达式被使用时确定表达式的值。</p>
</li>
</ol>
<h2 id="错误示例">错误示例</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> d[a * b * c]; <span class="comment">// error</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> tmp = a * b * c;</span><br><span class="line">	<span class="type">int</span> d[tmp]; <span class="comment">// error，如错误原因2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范3</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> array_size; <span class="comment">// error</span></span><br><span class="line">    <span class="type">int</span> size_array[array_size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> test::array_size = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案">解决方案</h2>
<p>使用<code>new</code>进行动态内存分配，<strong>记得通过<code>delete</code>回收分配的内存</strong>，如上述代码改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> *d = <span class="keyword">new</span> <span class="type">int</span>[a * b * c];</span><br><span class="line">	<span class="keyword">delete</span>[] d;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于new分配内存的使用：</p>
<ol>
<li>单变量分配</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type *p = <span class="keyword">new</span> Type;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">Type *p = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="number">2</span>); <span class="comment">//动态分配内存并初始化</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>一维数组申请</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type *p = <span class="keyword">new</span> Type[n];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">Type *p = <span class="keyword">new</span> Type[n]();<span class="comment">//动态分配内存并初始化全部为0</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>二维数组申请</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type **p = <span class="keyword">new</span> Type *[m];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	p[i] = <span class="keyword">new</span> Type[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个自己的简单博客</title>
    <url>/2023/4/</url>
    <content><![CDATA[<p>简单几步，基于Hexo搭建一个属于自己的简单博客</p>
<p>关键词：Hexo、博客</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h2 id="工具准备">工具准备</h2>
<h3 id="nodejs">Nodejs</h3>
<p>Nodejs简单来说就是运行在服务端的JavaScript，博客交互需要用到Nodejs。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/4_NodejsDonwload.png" alt="Nodejs下载页面"></p>
<p>选择合适的软件版本下载，<a href="https://nodejs.cn/download/">下载地址：https://nodejs.cn/download/</a></p>
<p>下载完成后按正常流程安装，可安装在非系统盘，记得选择“Add to PATH”配置PATH环境变量。我的Nodejs安装在<code>E:\Nodejs</code>中。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/4_Node.png" alt="选择"></p>
<p>注：为了软件安装简洁可控，还需要对Nodejs的内容（Cache和global）进行规划，具体可参考<a href="https://juejin.cn/post/7227434605392642104">nodejs的安装及详细环境配置</a>或<a href="https://blog.csdn.net/Ouchieve_111/article/details/70878090">修改项目默认node_modules路径</a>或<a href="https://blog.csdn.net/scorpio_meng/article/details/83314675">node安装后的设置(node_global和node_cache) - windows</a>，或自行搜索。</p>
<h3 id="git">Git</h3>
<p>Git是一个分布式版本控制系统，简单理解为它可以帮助我们管理文件各种版本，博客的更新之类的。</p>
<p><a href="https://git-scm.com/">下载地址：https://git-scm.com/</a></p>
<p>下载完成后按正常流程安装，可安装在非系统盘，其他选项可以保持默认。我的Git安装在<code>E:\Git</code>中。</p>
<h3 id="验证环境">验证环境</h3>
<p>验证Nodejs是否安装成功，在桌面鼠标右键，选择菜单中的Git Bash Here。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/4_%E5%8F%B3%E9%94%AE.jpg" alt="右键菜单"></p>
<p>在弹出的窗口中输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>若出现了对应的版本号，则说明安装成功。若不出现版本号，则检查Nodejs的安装过程，或者必应搜索相关帮助。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/4_%E9%AA%8C%E8%AF%81.png" alt="验证Nodejs安装"></p>
<h3 id="cnpm">cnpm</h3>
<p>上面的<code>npm -v</code>查看了npm的版本，可以简单理解为npm是一种下载工具。而npm下载一般是通过国外网络下载，速度比较慢。因此需要先通过npm安装cnpm（国内下载），之后就是用cnpm代替npm。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<p><em>可能出现镜像源过期的情况。</em></p>
<p>通过查询版本号验证是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>
<h2 id="安装hexo">安装Hexo</h2>
<p>Hexo是一种博客框架，通过它可以将简单的Markdown语言转化为带装饰的网页。</p>
<p>通过下面命令安装Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>也可以通过查询版本号确认Hexo是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -V</span><br></pre></td></tr></table></figure>
<p>Hexo的常用命令：<code>hexo -s</code>本地查看博客，<code>hexo g</code>生成博客，<code>hexo clean</code>删除当前博客所有网页页面。</p>
<h2 id="开始建造你的博客">开始建造你的博客</h2>
<ol>
<li>创建一个新的文件夹，尽量不再移动。</li>
</ol>
<p>如我在F盘创建了一个文件夹叫<code>15.Blog</code>，就在15.Blog文件夹下右键选择Git Bash。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/4_%E5%8D%9A%E5%AE%A21.png" alt=""></p>
<ol start="2">
<li>初始化博客</li>
</ol>
<p>在窗口中输入命令，等待完成。（如果运行至<code>Install dependencies</code>卡住，可以<code>Ctrl + C</code>结束命令）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看博客</li>
</ol>
<p>在窗口中输入命令，查看博客的初始页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>给博客下载主题——Next</li>
</ol>
<p>点击<a href="https://hexo.io/themes/">此处</a>寻找合适的主题，以Next为例，因为该主题基础、自定义程度高。</p>
<p>可以用git指令将Github的主题压缩包下载到博客的<code>themes/</code>文件夹中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 复制的地址 themes/主题名字</span><br></pre></td></tr></table></figure>
<p>上面指令意思是将指定地址的内容克隆到本地<code>themes/</code>文件夹并命名为指定名字。<br>
也可以直接下载压缩包粘贴至<code>themes/</code>文件夹中。</p>
<ol start="5">
<li>修改配置文件</li>
</ol>
<p>在博客的根目录中有一个名为<code>_config</code>的文本文件，在主题目录也有一个名为<code>_config</code>的文本文件，此处做区分，前者为博客配置文件，后者为主题配置文件。</p>
<p>打开博客配置文件，可以根据<a href="https://hexo.io/zh-cn/docs/configuration">官方配置介绍</a>进行修改个性化博客。<br>
将博客配置文件中<code>themes</code>一行填入刚下载的next主题，即可使用该主题。在博客目录打开Git Bash，输入<code>hexo s</code>可以查看博客。</p>
<p>注意：有些主题你更换之后是暂时无法预览的，因为有的主题还需要安装它需要的依赖。</p>
<h2 id="编写你的第一条博客">编写你的第一条博客</h2>
<p>在博客根目录打开Git Bash，输入下面的指令即可创建文章。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure>
<p>每次生成的文章都固定在你的博客根目录下面的<code>source/_posts</code>下，并以Markdown文件形式编写保存。</p>
<h2 id="部署你的博客到github">部署你的博客到Github</h2>
<p>首先需要有一个Github账号，并且新建仓库名为<code>用户名+.github.io</code>。</p>
<p>接着需要进行一系列的密钥绑定：</p>
<ol>
<li>在博客根目录打开Git Bash，输入下面的命令，接着会出现你的密钥。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “your_email@youremail.com“</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>在Github页面点击头像-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key，接着把密钥复制上去。</p>
</li>
<li>
<p>再在Git Bash中执行下面命令。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>接着提示<code>Are you sure you want to continue connecting (yes/no/[fingerprint])? </code>，输入yes回车即可。</p>
<ol start="4">
<li>
<p>点击项目仓库，在左上角的Clone or download中点击Use SSH，复制git开头的地址。</p>
</li>
<li>
<p>打开博客配置文件，找到deploy一行，按照下面的指示修改。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: 复制到的地址</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>在博客根目录打开Git Bash，分别执行下列命令。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>安装上传插件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>使用下面指令上传博客。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>打开项目仓库，选择上方的Settings，找到Pages，在Source处选择Deploy from a branch。之后就会出现一个网站地址，便是博客地址。</li>
</ol>
<h2 id="注">注</h2>
<p>如有纰漏，可同步参考<a href="https://www.cnblogs.com/huanhao/p/hexobase.html">此篇博客</a>或自行搜索他人教程相互参考。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio2022的OpenCV4.5.2和CUDA12.0项目配置</title>
    <url>/2023/9/</url>
    <content><![CDATA[<p>记录一次环境配置</p>
<h2 id="opencv的环境配置">OpenCV的环境配置</h2>
<h3 id="opencv下载安装">OpenCV下载安装</h3>
<p>前往官网选择适合的OpenCV版本下载，并安装到合适的位置。</p>
<p><a href="https://opencv.org/releases/">官网下载OpenCV</a></p>
<p>我的OpenCV安装在：<code>D:\opencv4.5.2</code></p>
<h3 id="添加opencv到系统path变量">添加OpenCV到系统Path变量</h3>
<p>打开编辑系统环境变量，点击右下方的环境变量，在系统变量中找到PATH项，点击编辑添加OpenCV目录下的bin文件夹。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_opencv2PATH.jpg" alt="添加OpenCV至PATH"></p>
<p>至于添加的是vc14还是vc15，参照下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">VS版本</th>
<th style="text-align:center">VC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">VS2015</td>
<td style="text-align:center">VC14</td>
</tr>
<tr>
<td style="text-align:center">VS2017及以上</td>
<td style="text-align:center">VC15</td>
</tr>
</tbody>
</table>
<h3 id="添加opencv环境到vs项目">添加OpenCV环境到VS项目</h3>
<p>右键项目，选择最下方属性，打开属性配置窗口，选择是Debug模式或Release模式配置。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_vs1.jpg" alt="VS项目配置窗口"></p>
<h4 id="vc-目录配置opencv">VC++目录配置OpenCV</h4>
<ol>
<li><strong>点击包含目录</strong>，在包含目录中把OpenCV目录下的include文件夹添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\opencv4.5.2\build\include\opencv2</span><br><span class="line">D:\opencv4.5.2\build\include</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>点击库目录</strong>，在库目录中把OpenCV的lib文件添加，此处路径藏得比较深，参考我的添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\opencv4.5.2\build\x64\vc15\lib</span><br></pre></td></tr></table></figure>
<h4 id="链接器配置opencv">链接器配置OpenCV</h4>
<ol>
<li><strong>点击输入，再点击附加依赖项</strong>，将OpenCV的lib文件添加，lib文件存放在上面库目录的文件夹中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opencv_world452.lib</span><br><span class="line">opencv_world452d.lib</span><br></pre></td></tr></table></figure>
<p>注意，此处文件名带<code>d</code>的为Debug版本的依赖项，不带<code>d</code>的为Release版本的依赖项。<br>
在配置Debug版本时把带<code>d</code>的文件放在不带<code>d</code>的文件之上，<br>
在配置Release版本时把不带<code>d</code>的文件放在带<code>d</code>的文件之上。</p>
<p><strong>如果显示找不到opencv_worldxxx.dll</strong> ，请把opencv_worldxxx.dll的路径添加到系统环境变量。</p>
<h2 id="cuda环境配置">CUDA环境配置</h2>
<h3 id="cuda下载安装">CUDA下载安装</h3>
<p><a href="http://fingsinz.space/%E6%97%A5%E5%B8%B8/5/">参考此条博客</a></p>
<p>我的CUDA目录在：<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code></p>
<h3 id="添加cuda环境到vs项目">添加CUDA环境到VS项目</h3>
<p>配置为x64平台。</p>
<p>右键项目→生成依赖项→生成自定义→勾选“CUDA xxx”。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_cuda.jpg" alt="生成依赖项"></p>
<h4 id="vc-目录配置cuda">VC++目录配置CUDA</h4>
<ol>
<li><strong>点击包含目录</strong>，在包含目录中把OpenCV目录下的include文件夹添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>点击库目录</strong>，在库目录中把OpenCV的lib文件夹添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64</span><br></pre></td></tr></table></figure>
<h4 id="链接器配置cuda">链接器配置CUDA</h4>
<ol>
<li><strong>点击常规，再点击附加库目录</strong>，添加下面的目录。<em>似乎不配置这一条也可以</em></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(CUDA_PATH_V12_0)\lib\$(Platform)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>点击输入，再点击附加依赖项</strong>，将CUDA的lib文件添加，输入下面的内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64\*.lib</span><br></pre></td></tr></table></figure>
<h4 id="配置源码文件风格">配置源码文件风格</h4>
<p>右键源文件，可以添加新建项中选择“CUDA C/C++ File”。<br>
右键“<a href="http://xxx.cu">xxx.cu</a>”源文件，点击属性，选择配置属性中的常规，从项类型中找到“CUDA C/C++”。</p>
<h3 id="测试cuda代码">测试CUDA代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">addKernel</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> arraySize = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a[arraySize] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b[arraySize] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="type">int</span> c[arraySize] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add vectors in parallel.</span></span><br><span class="line">    cudaError_t cudaStatus = <span class="built_in">addWithCuda</span>(c, a, b, arraySize);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;addWithCuda failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#123;1,2,3,4,5&#125; + &#123;10,20,30,40,50&#125; = &#123;%d,%d,%d,%d,%d&#125;\n&quot;</span>,</span><br><span class="line">        c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cudaDeviceReset must be called before exiting in order for profiling and</span></span><br><span class="line">    <span class="comment">// tracing tools such as Nsight and Visual Profiler to show complete traces.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaDeviceReset</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaDeviceReset failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function for using CUDA to add vectors in parallel.</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dev_a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *dev_b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *dev_c = <span class="number">0</span>;</span><br><span class="line">    cudaError_t cudaStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose which GPU to run on, change this on a multi-GPU system.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaSetDevice</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaSetDevice failed!  Do you have a CUDA-capable GPU installed?&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate GPU buffers for three vectors (two input, one output)    .</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_c, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_a, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_b, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy input vectors from host memory to GPU buffers.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(dev_a, a, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(dev_b, b, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch a kernel on the GPU with one thread for each element.</span></span><br><span class="line">    addKernel&lt;&lt;&lt;<span class="number">1</span>, size&gt;&gt;&gt;(dev_c, dev_a, dev_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for any errors launching the kernel</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;addKernel launch failed: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(cudaStatus));</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cudaDeviceSynchronize waits for the kernel to finish, and returns</span></span><br><span class="line">    <span class="comment">// any errors encountered during the launch.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaDeviceSynchronize returned error code %d after launching addKernel!\n&quot;</span>, cudaStatus);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy output vector from GPU buffer to host memory.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(c, dev_c, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_c);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_a);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cudaStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_result.jpg" alt="测试结果"></p>
<h3 id="cuda环境的一些碰壁">CUDA环境的一些碰壁</h3>
<ol>
<li>
<p>我的CUDA安装在一个可移动固态硬盘（G盘）中，可能导致了我的CUDA项目只能位于G盘使用，复制粘贴到电脑的盘会出现问题。</p>
</li>
<li>
<p>如果出现了大段指令无法运行，像下面的错误显示，可以复制命令（引号部分）到cmd运行，查看更详细的报错原因。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// VS报错如下</span><br><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	MSB3721	命令“&quot;G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\bin\nvcc.exe&quot; -gencode=arch=compute_52,code=\&quot;sm_52,compute_52\&quot; --use-local-env -ccbin &quot;E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.33.31629\bin\HostX64\x64&quot; -x cu   -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include  -G   --keep-dir x64\Debug  -maxrregcount=0  --machine 64 --compile -cudart static  -g  -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler &quot;/EHsc /W3 /nologo /Od /FdG:\Data\Coding_Master\yolov5-trt\bin\immediate\x64\Debug\vc143.pdb /FS /Zi /RTC1 /MDd &quot; -o G:\Data\Coding_Master\yolov5-trt\bin\x64\File.cu.obj &quot;G:\Data\Coding_Master\yolov5-trt\File.cu&quot;”已退出，返回代码为 1。	yolov5-trt	E:\Microsoft_Visual_Studio\VS\MSBuild\Microsoft\VC\v170\BuildCustomizations\CUDA 12.0.targets	794</span><br><span class="line"></span><br><span class="line">// 复制命令部分，即下面部分到cmd输入</span><br><span class="line">&quot;G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\bin\nvcc.exe&quot; -gencode=arch=compute_52,code=\&quot;sm_52,compute_52\&quot; --use-local-env -ccbin &quot;E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.33.31629\bin\HostX64\x64&quot; -x cu   -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include  -G   --keep-dir x64\Debug  -maxrregcount=0  --machine 64 --compile -cudart static  -g  -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler &quot;/EHsc /W3 /nologo /Od /FdG:\Data\Coding_Master\yolov5-trt\bin\immediate\x64\Debug\vc143.pdb /FS /Zi /RTC1 /MDd &quot; -o G:\Data\Coding_Master\yolov5-trt\bin\x64\File.cu.obj &quot;G:\Data\Coding_Master\yolov5-trt\File.cu&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>还遇到一些其他的坑可以自行必应。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>OpenCV</tag>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下Python3.11.4的安装记录</title>
    <url>/2023/8/</url>
    <content><![CDATA[<p>记录一次安装Python</p>
<h2 id="下载python安装包">下载Python安装包</h2>
<p><a href="https://www.python.org/downloads/windows/">官网</a>选择尽量较新的Python版本下载。</p>
<h2 id="安装python">安装Python</h2>
<p>打开下载的Python安装包，选择<code>Customize installation</code>客制化安装，记得勾选下面的“Add python.exe to PATH”。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py1.jpg" alt="安装步骤1"></p>
<p>接着默认勾选：</p>
<ul>
<li>pip：包管理器，下载包时使用。建议勾选上</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py2.jpg" alt="安装步骤2"></p>
<p>再接着更改安装路径，建议安装在非系统盘。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py3.jpg" alt="安装步骤3"></p>
<p>等待安装完成即可。</p>
<h2 id="测试python">测试Python</h2>
<p>按下<code>Win+R</code>输入<code>cmd</code>打开命令窗口，输入下面命令验证是否安装成功。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure>
<p>如果出现版本号，即为安装成功。</p>
<h2 id="附：更改python的pip安装路径">附：更改Python的pip安装路径</h2>
<p>建议将pip安装的包放至非系统盘。进入Python的安装路径，如我的在<code>D:\Pyhton\Lib</code>，寻找文件<code>site.py</code>，使用记事本打开。使用<code>ctrl+f</code>查找关键字<code>USER_SITE</code>等字，将路径更改为自定义的路径。我更改情况如下图。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py.jpg" alt="更改路径"></p>
<p>更改路径后，打开cmd，使用下面指令安装numpy包。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>
<p>安装成功后，再使用下面指令查看numpy包的安装位置。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip show numpy</span><br></pre></td></tr></table></figure>
<p>我成功更改pip的安装路径，新下载的numpy包位于<code>D:\Pyhton\Lib\site-packages</code>。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py4.jpg" alt="更改路径后"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10下安装CUDA、TensorRT记录</title>
    <url>/2023/5/</url>
    <content><![CDATA[<p>GPU：NVIDIA GeFOrce GTX 1050</p>
<p>关键词：深度学习、YOLOv5、TensorRT、C++推演</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h2 id="下载cuda">下载CUDA</h2>
<h3 id="1-确定适配本机显卡驱动的cuda版本">1.确定适配本机显卡驱动的CUDA版本</h3>
<p>系统搜索打开NVIDIA控制面板，点击帮助，选择系统信息-&gt;组件，找到CUDA字样。此处我的CUDA适配版本为<code>12.0</code>。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/5_CUDA%E7%89%88%E6%9C%AC.jpg" alt="CUDA版本查看"></p>
<h3 id="2-下载对应版本的cuda">2.下载对应版本的CUDA</h3>
<p><a href="https://developer.nvidia.com/cuda-toolkit-archive">下载地址 - NVIDIA官网</a></p>
<h3 id="3-安装cuda">3.安装CUDA</h3>
<p>点击下载的安装exe文件，可以更改文件安装位置，记住文件安装位置。此处我的安装位置是<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>。</p>
<h2 id="下载cudnn包">下载cuDNN包</h2>
<h3 id="1-选择适配cuda的版本下载对应的cudnn包">1.选择适配CUDA的版本下载对应的cuDNN包</h3>
<p><a href="https://developer.nvidia.com/rdp/cudnn-archive">下载地址 - NVIDIA官网</a></p>
<h3 id="2-选择合适的位置解压cudnn压缩包">2.选择合适的位置解压cuDNN压缩包</h3>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/5_cuDNN.jpg" alt="解压cuDNN后的文件"></p>
<h3 id="3-复制文件">3.复制文件</h3>
<p>cuDNN属于是CUDA的一个补丁包，因此无需安装。需要将<code>bin</code>、<code>include</code>、<code>lib</code>文件夹中的相关文件拷贝到CUDA安装位置的<code>bin</code>、<code>include</code>、<code>lib的x64</code>文件夹中。</p>
<p>我的CUDA安装位置是：<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>。</p>
<h3 id="4-验证是否成功">4.验证是否成功</h3>
<p><code>Win + R</code>输入cmd打开cmd窗口。<br>
直接输入盘符如<code>F:</code>跳转到F盘，<code>cd</code>进入到具体地址。<br>
比如我的CUDA安装在<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>，<br>
那么进入到<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\extras\demo_suite</code></p>
<p>接着在cmd窗口输入下面的指令分别运行两个exe文件，结果出现PASS（如图）则验证成功。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bandwidthTest.exe</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/5_cuDNN%E9%AA%8C%E8%AF%81.jpg" alt="第一个exe运行结果"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">deviceQuery.exe</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/5_cuDNN%E9%AA%8C%E8%AF%812.jpg" alt="第二个exe运行结果"></p>
<h2 id="下载tensorrt包">下载TensorRT包</h2>
<h3 id="1-选择适配cuda版本的tensorrt包下载">1.选择适配CUDA版本的TensorRT包下载</h3>
<p>进入<a href="https://developer.nvidia.com/nvidia-tensorrt-download">官网</a>，选择较新的大版本，再选择适合自己安装的CUDA版本下载。</p>
<p>我在此处下载Windows的支持CUDA12.0的版本。</p>
<h3 id="2-选择合适的位置解压tensorrt压缩包">2.选择合适的位置解压TensorRT压缩包</h3>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/5_TensorRT.jpg" alt="解压TensorRT后的文件"></p>
<h3 id="3-安装tensorrt">3.安装TensorRT</h3>
<ul>
<li>将TensorRT的<code>include</code>文件夹中文件复制到CUDA安装位置的<code>include</code>文件夹。</li>
</ul>
<p>我的操作是：<code>copy \TensorRT-8.6.1.6\include → NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include</code></p>
<ul>
<li>
<p>将TensorRT的<code>lib</code>中所有lib文件复制到CUDA安装位置的<code>lib\x64</code>文件夹</p>
</li>
<li>
<p>将TensorRT的<code>lib</code>中所有dll文件复制到CUDA安装位置的<code>bin</code>文件夹</p>
</li>
</ul>
<h3 id="4-验证tensort">4.验证TensoRT</h3>
<p>检查系统环境变量中是否有包含了CUDA的bin文件夹，没有则添加。</p>
<p>使用Visual Studio打开sampleMNIST示例，即打开<code>../TensorRT-8.6.1.6\samples\sampleOnnxMNIST</code>文件夹中的sln文件，必要时对项目属性的常规、VC++目录、C/C++里面的环境进行配置，添加依赖。<a href="https://blog.csdn.net/shanglianlm/article/details/92847719">参考</a></p>
<p>右键项目，点击重新生成。可以点击不调试运行测试。</p>
<h2 id="参考">参考</h2>
<p><a href="https://blog.csdn.net/shanglianlm/article/details/92847719">TensorRT之安装与测试（Windows和Linux环境下安装TensorRT）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/305854081">Window下Python+CUDA+PyTorch安装</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>深度学习</tag>
        <tag>YOLOv5</tag>
        <tag>TensorRT</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 数据库学习记录</title>
    <url>/2024/MySQL/</url>
    <content><![CDATA[<p>关键词：MySQL、C++</p>
<hr>
<h2 id="一-认识-mysql">一、认识 MySQL</h2>
<h3 id="1-1-什么是-mysql">1.1 什么是 MySQL</h3>
<p>MySQL 是 <strong>关系型</strong> 数据库。</p>
<ul>
<li>关系型可以理解为表格的概念。
<ul>
<li>表格具有表头、行、列、键、值等。
<ul>
<li>表头：每一列的名称；</li>
<li>列：具有相同数据类型的集合；</li>
<li>行：每一行用来描述某个具体信息；</li>
<li>键：表中用来识别某个特定对象的方法，键的值在当前列中具有唯一性；</li>
<li>值：行的具体信息，每个值必须与该列的数据类型相同。</li>
</ul>
</li>
</ul>
</li>
<li>一个关系型数据库由一个或多个表格组成。</li>
</ul>
<p>如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">sex</th>
<th style="text-align:center">age</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">小明</td>
<td style="text-align:center">男</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">小红</td>
<td style="text-align:center">女</td>
<td style="text-align:center">17</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">小张</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">小李</td>
<td style="text-align:center">女</td>
<td style="text-align:center">16</td>
</tr>
</tbody>
</table>
<ul>
<li>表头为 id、name、sex、age；</li>
<li>id：作为一个键。</li>
</ul>
<h3 id="1-2-windows-下配置-mysql">1.2 Windows 下配置 MySQL</h3>
<p>此处为免安装版 MySQL-8.0.36，<a href="https://dev.mysql.com/downloads/mysql/5.1.html#downloads">下载地址 - ZIP文件</a></p>
<p>解压到目录：<code>E:\MySQL-8.0.36</code>。</p>
<p>接着在文件夹中创建配置文件 <code>my.ini</code>，内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=E:\\MySQL-<span class="number">8.0</span>.<span class="number">36</span></span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line"><span class="comment"># datadir=C:\\web\\sqldata</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">20</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></table></figure>
<p>然后配置环境变量：</p>
<ul>
<li>打开环境变量设置，新建变量名 <code>MYSQL_HOME</code>，变量值为 <code>E:\MySQL-8.0.36</code>。</li>
<li>系统变量 <code>PATH</code> 中添加 <code>E:\MySQL-8.0.36\bin</code>。</li>
</ul>
<p>最后启动命令提示符（cmd），执行命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysqld.exe --install MySQL --defaults-file=&quot;E:\MySQL-<span class="number">8</span>.<span class="number">0</span>.<span class="number">36</span>\my.ini&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果安装被拒绝，请使用管理员权限启动cmd。</li>
</ul>
<p>提示 <code>Service successfully installed.</code> 表示成功。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_installed.jpg" alt="安装成功"></p>
<h4 id="1-2-1-mysql-的启动-停止和卸载">1.2.1 MySQL 的启动、停止和卸载</h4>
<p>MySQL 服务的启动：<code>net start MySQL</code></p>
<p>MySQL 服务的停止：<code>net stop MySQL</code></p>
<p>MySQL 服务的卸载：<code>sc delete MySQL</code></p>
<h3 id="1-3-mysql-脚本的基本组成">1.3 MySQL 脚本的基本组成</h3>
<p>MySQL 通过执行 SQL 脚本来完成对数据库的操作。</p>
<ul>
<li>脚本由一条或多条 MySQL 语句（SQL 语句 + 扩展语句）组成，保存为脚本文件一般为 <code>.sql</code> 文件。</li>
<li>控制台可以进行单句脚本执行。</li>
</ul>
<p>标识符：</p>
<ul>
<li>命名对象，如数据库、表、列、变量等。由字母、数字、下划线组成，第一个字符不能为数字。
<ul>
<li>大小写是否敏感取决于操作系统，Windows 下是不敏感的，但大多数 Linux 下是敏感的。</li>
</ul>
</li>
</ul>
<p>关键字：</p>
<ul>
<li>关键字有特定的含义，避免作为标识符。（此处不列出，使用中学习）</li>
</ul>
<p>语句：</p>
<ul>
<li>是组成 MySQL 脚本的最小单位。每条语句可以完成特定操作，由 SQL 语句 + 扩展语句组成。</li>
</ul>
<p>函数：</p>
<ul>
<li>实现数据库操作的高级功能，大致分为：字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。</li>
</ul>
<h3 id="1-4-mysql-中的数据类型">1.4 MySQL 中的数据类型</h3>
<p>三大数据类型：数字、日期/时间、字符串。</p>
<p>数字：</p>
<ul>
<li>整型：
<ul>
<li><code>tinyint</code>：1个字节，带符号范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>128</mn><mo>∼</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">-128\sim127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span>；</li>
<li><code>smallint</code>：2个字节，带符号范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>32768</mn><mo>∼</mo><mn>32767</mn></mrow><annotation encoding="application/x-tex">-32768\sim32767</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">7</span></span></span></span>；</li>
<li><code>mediumint</code>：3个字节，带符号范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>8388608</mn><mo>∼</mo><mn>8388607</mn></mrow><annotation encoding="application/x-tex">-8388608\sim8388607</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">8</span><span class="mord">3</span><span class="mord">8</span><span class="mord">8</span><span class="mord">6</span><span class="mord">0</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">3</span><span class="mord">8</span><span class="mord">8</span><span class="mord">6</span><span class="mord">0</span><span class="mord">7</span></span></span></span>；</li>
<li><code>int</code>：4个字节，带符号范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>∼</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>2147483648</mn><mo>∼</mo><mn>2147483647</mn></mrow><annotation encoding="application/x-tex">-2^{31}\sim2^{31}-1,-2147483648\sim2147483647</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span></span></span></span>；</li>
<li><code>bigint</code>：8个字节，带符号范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>63</mn></msup><mo>∼</mo><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>±</mo><mn>9.22</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">-2^{63}\sim2^{63}-1,\pm9.22\times10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">±</span><span class="mord">9</span><span class="mord">.</span><span class="mord">2</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>；</li>
</ul>
</li>
<li>浮点型：
<ul>
<li><code>float(m,d)</code>：单精度浮点型，8位精度（4字节），总精度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，小数位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，以实际为准。</li>
<li><code>double</code>：双精度浮点型，16位精度（8字节），总精度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，小数位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，以实际为准。</li>
<li><code>real</code></li>
<li><code>decimal(m,d)</code>：定点数，存放精确的值。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">m&gt;d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 则大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 字节，否则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">d+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 字节。</li>
</ul>
</li>
</ul>
<p>日期和时间：</p>
<ul>
<li><code>date</code>：格式为 <code>YYYY-MM-DD</code>，大小3字节，范围<code>1000-01-01/9999-12-31</code>。</li>
<li><code>time</code>：格式为 <code>HH:MM:SS</code>，大小3字节，范围<code>-838:59:59/838:59:59</code>。</li>
<li><code>year</code>：格式为 <code>YYYY</code>，大小1字节，范围<code>1901/2155</code>。</li>
<li><code>datetime</code>：格式为 <code>YYYY-MM-DD HH:MM:SS</code>，大小8字节，范围<code>1000-01-01 00:00:00/9999-12-31 23:59:59</code>。</li>
<li><code>timestamp</code>：格式为 <code>YYYY-MM-DD HH:MM:SS</code>，大小4字节，范围<code>1970-01-01 00:00:00/2038-01-19 03:14:07</code>（结束时间为距离1970-01-01 00:00:00 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 秒，看时区）。
<ul>
<li>时间戳的数据会随其他字段修改时自动更新。</li>
</ul>
</li>
</ul>
<p>字符串类型：</p>
<ul>
<li>字符串：
<ul>
<li><code>char(n)</code>：定长字符串，0~255字节。</li>
<li><code>varchar(n)</code>：变长字符串，0~65535字符。</li>
<li><code>char(n)</code> 与 <code>varchar(n)</code>：两者的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 都表示字符个数，而不是字节个数。前者若存入字符数小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则用空格补在后面，查询时去掉空格；而后者没这个规定。</li>
</ul>
</li>
<li>文本：
<ul>
<li><code>tinytext</code>：短文本字符串，0~255字节。</li>
<li><code>text</code>：长文本数据，0~65535字节。</li>
<li><code>mediumtext</code>：中等长度文本数据，0~16777215字节。</li>
<li><code>longtext</code>：极大文本数据，0~4294967295字节。</li>
</ul>
</li>
<li><code>varchar</code> 与 <code>text</code>：
<ul>
<li>前者可以指定 <code>n</code>，后者不能指定；</li>
<li>后者不能有默认值；</li>
<li>前者可直接创建索引，后者创建索引需要指定前多少个字符。前者查询速度快于后者。</li>
</ul>
</li>
<li>二进制（存储图片、音乐等）：
<ul>
<li><code>tinyblob</code>：二进制字符串，0~255字节。</li>
<li><code>blob</code>：二进制长文本，0~65535字节。</li>
<li><code>mediumblob</code>：二进制中等长度文本，0~16777215字节。</li>
<li><code>longblob</code>：二进制极大文本，0~4294967295字节。</li>
</ul>
</li>
<li><code>_blob</code> 与 <code>_text</code>：
<ul>
<li>前者以二进制方式存储，英文不区分大小写，后者以文本方式存储，英文区分大小写；</li>
<li>前者存储的数据只能整体读出；</li>
<li>前者不用指定字符集，后者可以指定字符集。</li>
</ul>
</li>
</ul>
<p>数据类型的属性：</p>
<ul>
<li><code>NULL</code>：数据列可包含 <code>NULL</code> 值。</li>
<li><code>NOT NULL</code>：数据列不允许包含 <code>NULL</code> 值。</li>
<li><code>DEFAULT</code>：数据列的默认值。</li>
<li><code>PRIMARY KEY</code>：主键。</li>
<li><code>AUTO_INCREMENT</code>：自动递增。</li>
<li><code>UNSIGNED</code>：无符号。</li>
<li><code>CHARACTER SET name</code>：指定字符集。</li>
</ul>
<h2 id="二-使用-mysql">二、使用 MySQL</h2>
<h3 id="2-1-登录到-mysql">2.1 登录到 MySQL</h3>
<p>先启动 MySQL 服务（管理员权限cmd）：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysql</span><br></pre></td></tr></table></figure>
<p>然后使用自带的客户端工具登录，cmd输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-h</code>：表示登录到的主机名，当前机器可省略。</li>
<li><code>-u</code>：表示登录的用户名。</li>
<li><code>-p</code>：表示登录时需要输入密码，密码为空可忽略。</li>
<li>这里安装的 MySQL 默认 root 账号是无密码的。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_login.jpg" alt="登录"></p>
<hr>
<p>我的第一次安装出现了坑：“如何解决本地计算机上的mysql服务启动停止后,某些服务在未由其他服务或程序使用时将自动停止”</p>
<p>可能是因为之前不懂事弄着玩过，然后出了一堆错误。</p>
<p>解决办法：<a href="https://blog.csdn.net/u014555006/article/details/106025355">CSDN - 如何解决本地计算机上的mysql服务启动停止后,某些服务在未由其他服务或程序使用时将自动停止</a></p>
<hr>
<h3 id="2-2-创建一个数据库">2.2 创建一个数据库</h3>
<p>创建命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名 [options];</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_create.jpg" alt="创建数据库"></p>
<ul>
<li>MySQL 语句以分号作为结束。</li>
<li><code>show databases;</code> 可查看创建了的数据库。</li>
</ul>
<p>选择操作的数据库（必须先选择数据库，才能进行数据库的操作）。</p>
<ol>
<li>登录时指定数据库：</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -D 数据库名 -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>登陆后使用 <code>use 数据库名;</code> 语句选择数据库。</li>
</ol>
<h4 id="2-2-1-创建数据库表">2.2.1 创建数据库表</h4>
<p>比如创建一张表，存放学号、姓名、性别、年龄、电话号码。</p>
<p>使用命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名称;</span><br></pre></td></tr></table></figure>
<p>有时候表信息比较多，使用 <code>.sql</code> 脚本事先记录，然后执行 <code>.sql</code> 文件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tables students</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">not null</span> auto_increment <span class="keyword">primary key</span>,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not null</span>,</span><br><span class="line">    sex <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">not null</span>,</span><br><span class="line">    age tinyint unsigned <span class="keyword">not null</span>,</span><br><span class="line">    tel <span class="type">char</span>(<span class="number">13</span>) <span class="keyword">null</span> <span class="keyword">default</span> &quot;-&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>通过命令提示符下的文件重定向执行执行该脚本。打开命令提示符, 输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -D samp_db -u root -p &lt; createtable.sql</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>show tables;</code> 可以查看已创建的表。</li>
<li>使用 <code>describe 表名;</code> 可以查看已创建表的详细信息。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_showtables.jpg" alt="创建的表"></p>
<h3 id="2-3-操作-mysql-数据库">2.3 操作 MySQL 数据库</h3>
<h4 id="2-3-1-向表中插入数据">2.3.1 向表中插入数据</h4>
<p>使用 <code>insert</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> [<span class="keyword">into</span>] 表名 [(列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3</span>,...)] <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>,...);</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> students <span class="keyword">values</span> (<span class="keyword">NULL</span>,<span class="string">&#x27;ZhangSan&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;13800000000&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>也可以不按列的顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> students (name,sex,age) <span class="keyword">values</span> (<span class="string">&#x27;LiSi&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-查询表中的数据">2.3.2 查询表中的数据</h4>
<p>使用 <code>select</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名称 <span class="keyword">from</span> 表名称 [查询条件];</span><br></pre></td></tr></table></figure>
<p>如查询表中所有学生的名字和年龄：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_added.jpg" alt="查询"></p>
<p>通配符 <code>*</code>：表示所有内容。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_selectall.jpg" alt="通配符查询"></p>
<p>如果具有查询条件，使用 <code>where</code> 关键字：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名称 <span class="keyword">from</span> 表名称 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>
<p>如查找女性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_selectcondition.jpg" alt="带条件查询"></p>
<ul>
<li>查询前已添加了 LiSi 的数据。</li>
</ul>
<p><code>where</code> 支持 <code>=</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>in</code>、<code>not in</code>、<code>is [not] null</code>、<code>like</code> 等运算符，支持与 <code>or</code>、<code>and</code> 的组合。</p>
<p>如：</p>
<ul>
<li>查询名字中带有 “Wang” 字的所有人信息：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> name <span class="keyword">like</span> &quot;%Wang%&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询 <code>id</code> 小于5且年龄大于20的所有人信息：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">and</span> age<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-更新表中的数据">2.3.3 更新表中的数据</h4>
<p>使用 <code>update</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名称 <span class="keyword">set</span> 列名称<span class="operator">=</span>新值 <span class="keyword">where</span> 更新条件;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<ul>
<li>将 <code>id</code> 为5的手机号改为默认的&quot;-&quot;：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> tel<span class="operator">=</span><span class="keyword">default</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将所有人的年龄增加1：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-删除表中的数据">2.3.4 删除表中的数据</h4>
<p>使用 <code>delete</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名称 <span class="keyword">where</span> 删除条件;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<ul>
<li>删除所有年龄小于21岁的数据：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">&lt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除表中的所有数据：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-5-创建后表的修改">2.3.5 创建后表的修改</h4>
<p>使用 <code>alter table</code> 语句：</p>
<h5 id="添加列">添加列</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> 列名 列数据类型 [after 插入位置];</span><br></pre></td></tr></table></figure>
<p>如：</p>
<ul>
<li>在表后添加列 <code>address</code>：<code>alter table students add address char(20);</code></li>
<li>在 <code>age</code> 列后插入 <code>birthday</code>：<code>alter table students add birthday date after age;</code></li>
</ul>
<h5 id="修改列">修改列</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 change 列名 新列名 新列数据类型;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<ul>
<li>修改列 <code>age</code> 的数据类型：<code>alter table students change age age tinyint unsigned null;</code></li>
</ul>
<h5 id="删除列">删除列</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<ul>
<li>删除列 <code>birthday</code>：<code>alter table students drop birthday;</code></li>
</ul>
<h5 id="修改表名">修改表名</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 rename 新表名;</span><br></pre></td></tr></table></figure>
<h5 id="删除整张表">删除整张表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>
<h5 id="删除整个数据库">删除整个数据库</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-修改-root-用户密码">2.4 修改 root 用户密码</h3>
<p>其中一种方法：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password 新密码</span><br></pre></td></tr></table></figure>
<h2 id="三-在c-工程上使用mysql">三、在C++工程上使用MySQL</h2>
<h3 id="3-1-使用mysql-h">3.1 使用mysql.h</h3>
<p><em>IDE：Visual Studio 2022</em></p>
<h4 id="3-1-1-vs中配置mysql">3.1.1 VS中配置MySQL</h4>
<p>添加包含目录：<code>VC++目录</code> 中的 <code>包含目录</code> 添加上 MySQL 文件夹中的 <code>include</code> 目录。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_addinclude.jpg" alt="添加包含目录"></p>
<p>添加库目录：<code>VC++目录</code> 中的 <code>库目录</code> 添加上 MySQL 文件夹中的 <code>lib</code> 目录。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_addlib.jpg" alt="添加库目录"></p>
<p>添加附加依赖项：<code>链接器</code> 中的 <code>输入</code> → <code>附加依赖项</code> 添加上 <code>libmysql.lib</code>。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_adddepend.jpg" alt="添加附加依赖项"></p>
<p>复制动态库：将 <code>lib</code> 文件夹下的 <code>libmysql.dll</code> 复制到工程文件夹下。</p>
<h4 id="3-1-2-相关函数代码">3.1.2 相关函数代码</h4>
<p>头文件：<code>mysql.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接数据库：</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MYSQL *mysql, <span class="type">const</span> <span class="type">char</span> *host,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *passwd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *db, <span class="type">unsigned</span> <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *unix_socket,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">long</span> clientflag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行MySQL语句:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mysql_query</span><span class="params">(MYSQL *mysql, <span class="type">const</span> <span class="type">char</span> *q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一条MySQL语句执行结果：</span></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_store_result</span><span class="params">(MYSQL *mysql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一条MySQL语句执行结果行数：</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">mysql_affected_rows</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用类实现一个基础连接数据库，可以执行数据库语句、输出查询结果等功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DataBase.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> _state;					<span class="comment">// 连接状态</span></span><br><span class="line">	MYSQL *_conn;					<span class="comment">// 数据库连接</span></span><br><span class="line">	std::vector&lt;MYSQL_FIELD *&gt; fd;	<span class="comment">// 字段列数组</span></span><br><span class="line">	std::vector&lt;std::string&gt; _field;<span class="comment">// 字段名</span></span><br><span class="line">	MYSQL_RES *_res;				<span class="comment">// 返回行的查询结果集</span></span><br><span class="line">	MYSQL_ROW _column;				<span class="comment">// 一个行数据的类型安全的表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* @brief 构造函数，初始化参数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">DataBase</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* @brief 连接数据库</span></span><br><span class="line"><span class="comment">	* @param ip IP地址</span></span><br><span class="line"><span class="comment">	* @param name 用户名</span></span><br><span class="line"><span class="comment">	* @param pass 密码</span></span><br><span class="line"><span class="comment">	* @param dataBaseName 数据库名</span></span><br><span class="line"><span class="comment">	* @param port 端口</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(std::string <span class="type">const</span> &amp;ip, std::string <span class="type">const</span> &amp;name, std::string <span class="type">const</span> &amp;pass, std::string <span class="type">const</span> &amp;dataBaseName, <span class="type">int</span> <span class="type">const</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* @brief 获取表字段数</span></span><br><span class="line"><span class="comment">	* @param tableName 表名</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getTableField</span><span class="params">(std::string <span class="type">const</span> &amp;tableName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* @brief 查询表</span></span><br><span class="line"><span class="comment">	* @param tableName 表名</span></span><br><span class="line"><span class="comment">	* @return 查询结果</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function">std::string <span class="title">query</span><span class="params">(std::string <span class="type">const</span> &amp;tableName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* @brief 执行 sql 指令</span></span><br><span class="line"><span class="comment">	* @param sentence sql 命令</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">implement</span><span class="params">(std::string <span class="type">const</span> &amp;sentence)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DataBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DataBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DataBase::<span class="built_in">DataBase</span>() : _state(<span class="literal">false</span>), _res(<span class="literal">nullptr</span>), _column(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_conn = <span class="keyword">new</span> MYSQL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DataBase::connect</span><span class="params">(std::string <span class="type">const</span> &amp;ip, std::string <span class="type">const</span> &amp;name, std::string <span class="type">const</span> &amp;pass, std::string <span class="type">const</span> &amp;dataBaseName, <span class="type">int</span> <span class="type">const</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_state)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化数据库</span></span><br><span class="line">	<span class="built_in">mysql_init</span>(_conn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接数据库</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_real_connect</span>(_conn, ip.<span class="built_in">c_str</span>(), name.<span class="built_in">c_str</span>(), pass.<span class="built_in">c_str</span>(), dataBaseName.<span class="built_in">c_str</span>(), port, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		_state = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DataBase::getTableField</span><span class="params">(std::string <span class="type">const</span> &amp;tableName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_state)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串格式化为查询数组</span></span><br><span class="line">	<span class="type">char</span> query[<span class="number">150</span>];</span><br><span class="line">	<span class="built_in">sprintf_s</span>(query, <span class="string">&quot;show columns from %s&quot;</span>, tableName.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行查询</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, query))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取查询结果</span></span><br><span class="line">	_res = <span class="built_in">mysql_store_result</span>(_conn);</span><br><span class="line">	<span class="keyword">if</span> (_res == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mysql_affected_rows</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">DataBase::query</span><span class="params">(std::string <span class="type">const</span> &amp;tableName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_state)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取列数</span></span><br><span class="line">	<span class="type">int</span> field = <span class="built_in">getTableField</span>(tableName);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串格式化为查询数组</span></span><br><span class="line">	<span class="type">char</span> query[<span class="number">150</span>];</span><br><span class="line">	<span class="built_in">sprintf_s</span>(query, <span class="string">&quot;select * from %s&quot;</span>, tableName.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行查询</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, query))</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取查询结果</span></span><br><span class="line">	_res = <span class="built_in">mysql_store_result</span>(_conn);</span><br><span class="line">	<span class="keyword">if</span> (_res == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将查询结果转化为字符串输出</span></span><br><span class="line">	fd.<span class="built_in">reserve</span>(field);</span><br><span class="line">	fd.<span class="built_in">resize</span>(field);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; field; i ++)</span><br><span class="line">		fd[i] = <span class="built_in">mysql_fetch_field</span>(_res);</span><br><span class="line"></span><br><span class="line">	std::string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (_column = <span class="built_in">mysql_fetch_row</span>(_res))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; field; i ++)</span><br><span class="line">			res += _column[i], res += <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		res += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DataBase::implement</span><span class="params">(std::string <span class="type">const</span> &amp;sentence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_state)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字符串格式化</span></span><br><span class="line">	<span class="type">char</span> query[<span class="number">150</span>];</span><br><span class="line">	<span class="built_in">sprintf_s</span>(query, <span class="string">&quot;%s&quot;</span>, sentence.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行命令</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, query))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码见仓库：<a href="https://gitee.com/fingsinz/my-sql-cpp/tree/master/">Gitee - MySQL - C++</a></p>
<p>更多可参考：<a href="https://blog.csdn.net/cpp_learner/article/details/116171955">https://blog.csdn.net/cpp_learner/article/details/116171955</a></p>
<h3 id="3-2-使用qtsql">3.2 使用QtSQL</h3>
<p><em>Qt6.6.1_msvc2019_64</em></p>
<h4 id="3-2-1-qt的sql模块">3.2.1 Qt的SQL模块</h4>
<p>VS 中勾选上 SQL 模块：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_qtsqlmodule.jpg" alt="勾选SQL"></p>
<h4 id="3-2-2-数据库驱动">3.2.2 数据库驱动</h4>
<p>QtSQL 是 Qt 提供的一个访问数据库的接口。但需要数据库驱动才能使用不同类型的数据库。</p>
<table>
<thead>
<tr>
<th style="text-align:center">驱动名称</th>
<th style="text-align:center">对应数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>QDB2</code></td>
<td style="text-align:center">IBM DB2</td>
</tr>
<tr>
<td style="text-align:center"><code>QIBASE</code></td>
<td style="text-align:center">Borland Interbase</td>
</tr>
<tr>
<td style="text-align:center"><code>QMYSQL</code></td>
<td style="text-align:center">MySQL</td>
</tr>
<tr>
<td style="text-align:center"><code>QOCI</code></td>
<td style="text-align:center">Oracle Call Interface Driver</td>
</tr>
<tr>
<td style="text-align:center"><code>QODBC</code></td>
<td style="text-align:center">ODBC（包括MS SQL Server）</td>
</tr>
<tr>
<td style="text-align:center"><code>QPSQL</code></td>
<td style="text-align:center">PostgreSQL</td>
</tr>
<tr>
<td style="text-align:center"><code>QSQLITE</code></td>
<td style="text-align:center">SQLite v3</td>
</tr>
<tr>
<td style="text-align:center"><code>QSQLITE2</code></td>
<td style="text-align:center">SQLite v2</td>
</tr>
</tbody>
</table>
<p>很不幸，MySQL 需要额外下载驱动，可前往 <a href="https://github.com/thecodemonkey86/qt_mysql_driver/releases">Github - thecodemonkey86/qt_mysql_driver</a> 下载对应版本的编译后的文件。</p>
<ul>
<li>将下载到的压缩包解压后，把 <code>sqldrives</code> 文件夹中的文件复制到 Qt 目录下的 <code>sqldrives</code> 文件夹中。如此处我是： <code>..\Qt\6.6.1\msvc2019_64\plugins\sqldrivers</code></li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_adddrive.jpg" alt="添加驱动"></p>
<h4 id="3-2-3-连接数据库">3.2.3 连接数据库</h4>
<p>通过 <code>QSqlDatabase</code> 类，可以操作数据库。</p>
<p>连接数据库的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QtSql 连接数据库</span></span><br><span class="line">QSqlDatabase db;</span><br><span class="line">db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>, <span class="string">&quot;connection&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置主机名</span></span><br><span class="line">db.<span class="built_in">setHostName</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置数据库名</span></span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;students&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置用户名和密码</span></span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置端口</span></span><br><span class="line">db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开数据库</span></span><br><span class="line">db.<span class="built_in">open</span>();</span><br></pre></td></tr></table></figure>
<p>其中函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSqlDatabase <span class="title">addDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString&amp; type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString&amp; connectionName = QLatin1StringView(defaultConnection))</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个数据库连接，第一个参数指定数据库驱动，第二个参数指定连接名称，多线程访问数据库中每个线程都需要使用不同的连接名称。</p>
<h4 id="3-2-4-访问数据库">3.2.4 访问数据库</h4>
<p>通过 <code>QSqlQuery</code> 类，可以访问数据库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建查询对象</span></span><br><span class="line"><span class="function">QSqlQuery <span class="title">query</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询语句</span></span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>QSqlQuery::prepare()</code> 和 <code>QSqlQuery::bindValue()</code> 函数进行数据库语句的构造。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUser</span><span class="params">(QSqlDatabase db,<span class="type">const</span> <span class="type">int</span> &amp;id,<span class="type">const</span> QString &amp;username)</span> </span>&#123;</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造查询语句</span></span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;update newUser set username=:username WHERE id=:id&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定参数</span></span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:id&quot;</span>, id);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:username&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">    query.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-学生管理系统demo">3.3 学生管理系统demo</h3>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/MySQL_showinfo.jpg" alt="demo"></p>
<p>完整代码见仓库：<a href="https://gitee.com/fingsinz/my-sql-cpp/">Gitee - MySQL - C++</a></p>
<p>分支：</p>
<ul>
<li>master：mysql.h方式</li>
<li>QSQL：QtSql方式</li>
</ul>
<hr>
<p><strong>Reference：</strong></p>
<blockquote>
<p>21分钟 MySQL 入门教程 - <a href="https://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">https://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html</a><br>
C/C++ vs2017连接MySQL数据库 - 增删改查(详细步骤) - <a href="https://blog.csdn.net/qq_45698148/article/details/117136407">https://blog.csdn.net/qq_45698148/article/details/117136407</a><br>
MySQL 教程 - RUNOOB：<a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a><br>
Qt零基础系列10：使用Qt如何操作数据库：<a href="https://zhuanlan.zhihu.com/p/348174965">https://zhuanlan.zhihu.com/p/348174965</a></p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 服务器编程入门尝试 - C++</title>
    <url>/2024/LinuxServerCpp/</url>
    <content><![CDATA[<p>关键词：C++、Linux</p>
<span id="more"></span>
<hr>
<blockquote>
<p><strong>References：</strong></p>
<ul>
<li><a href="https://github.com/yuesong-feng/30dayMakeCppServer/">30天自制C++服务器</a></li>
<li><a href="https://github.com/yuesong-feng/pine">配套网络库 pine</a></li>
</ul>
<p><em>Linux下操作。</em></p>
</blockquote>
<h2 id="零-前言">零、前言</h2>
<p>这个项目原作者暂未更新，单凭我自己的话，还没能力续写下去。我的想法是有时间再重新组织一下语言，细化一下每一章的描述。这个项目作为一个 Linux 网络编程的入门项目还是相当不错的，能够了解到 Socket、线程池以及一系列抽象编程思想。如果想继续深入学习网络编程，那路还有很长很长……</p>
<p><em>——Fingsinz，2024.06.06留</em></p>
<p>碰巧看到一位大牛在原仓库的基础上专注于功能的实现。</p>
<p>Reference：<a href="https://github.com/Wlgls/30daysCppWebServer">https://github.com/Wlgls/30daysCppWebServer</a></p>
<p><em>——Fingsinz，2024.07.11留</em></p>
<h2 id="一-从socket开始">一、从socket开始</h2>
<p>socket，被翻译为套接字，它是计算机之间进行通信的一种约定或一种方式。套接字是双方通过网络进行通信的通道。Socket 连接的一边是客户端，另一边是服务器端。一个正常的服务器端能服务多个客户端。</p>
<ul>
<li>通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</li>
</ul>
<h3 id="1-1-服务端干了什么">1.1 服务端干了什么</h3>
<p>在服务器端，需要建立一个 socket 套接字，对外提供一个网络通信接口。</p>
<ul>
<li>在 Linux 系统中这个套接字仅仅是一个文件描述符，也就是一个int类型的值。</li>
<li>对套接字的所有操作（包括创建）都是最底层的系统调用。</li>
</ul>
<ol>
<li>创建套接字：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建一个 <code>sockaddr_in</code> 结构体并初始化（<code>bzero</code> 函数）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置地址族、IP 地址和端口号：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>将 socket 地址与文件描述符绑定：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用 <code>listen</code> 函数监听套接字：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd, SOMAXCONN);</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>服务端想要接受一个客户端连接，需要使用 <code>accept</code> 函数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line"><span class="type">socklen_t</span> clientAddrLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line"><span class="built_in">bzero</span>(&amp;clientAddr, <span class="built_in">sizeof</span>(clientAddr));</span><br><span class="line"><span class="type">int</span> clientSockfd = <span class="built_in">accept</span>(sockfd, (sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>输出 socket 连接信息：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client connected: %d!\tIP: %s\tPort: %d\n&quot;</span>, clientSockfd, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), <span class="built_in">ntohs</span>(clientAddr.sin_port));</span><br></pre></td></tr></table></figure>
<p>至此，客户端已经可以通过 IP 地址和端口号连接到这个 socket 端口了。</p>
<h3 id="1-2-客户端如何配合">1.2 客户端如何配合</h3>
<p>在客户端，也需要建立一个 socket 套接字。</p>
<p>对于客户端，服务器存在的唯一标识是 IP 地址和端口号。此时需要将套接字绑定到一个 IP 地址和端口上。</p>
<ol>
<li>创建套接字：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建一个 <code>sockaddr_in</code> 结构体，并绑定 IP 族、IP 地址和端口号：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用 <code>connect</code> 函数进行连接：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, (sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br></pre></td></tr></table></figure>
<p>注意，需要先 <code>./server</code> 运行服务端进行等待，再 <code>./client</code> 运行客户端进行连接请求。</p>
<h3 id="1-3-该节涉及函数及源代码">1.3 该节涉及函数及源代码</h3>
<ul>
<li>相关头文件：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// 创建 socket 所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// socket 地址结构体所需</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建 socket：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span> <span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __domain：IP 地址类型，AF_INET 表示 IPv4，AF_INET6 表示 IPv6。</span></span><br><span class="line"><span class="comment">* __type：数据传输方式，SOCK_STREAM 表示流格式、面向链接，多用于 TCP； SOCK_DGRAM 表示数据报格式、无连接，多用于 UDP。</span></span><br><span class="line"><span class="comment">* __protocol：协议，0 表示根据前面两个参数自动推导协议类型。设置为 IPPROTO_TCP 和 IPPROTO_UDP，分别表示 TCP 和 UDP。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>初始化：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bzero</span> <span class="params">(<span class="type">void</span> *__s, <span class="type">size_t</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __s：指向要清零的内存块的指针。</span></span><br><span class="line"><span class="comment">* __n：要清零的内存块的大小。</span></span><br><span class="line"><span class="comment">* 该函数在头文件 string.h 或 cstring 中。</span></span><br><span class="line"><span class="comment">* Effective C++ - 条款01：视 C++ 为一个语言联邦。写 C 就用 string.h，写 C++ 就用 cstring。</span></span><br><span class="line"><span class="comment">* Effective C++ - 条款04：确定对象被使用前已先被初始化。使用 bzero 进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>绑定函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __addr：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __len：sockaddr 参数的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>listen</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __n：最大监听队列长度，宏定义 SOMAXCONN 为最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>accept</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr, <span class="type">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：服务端的文件描述符。</span></span><br><span class="line"><span class="comment">* __addr`：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __addr_len`：指向 sockaddr 参数大小的指针。因为 accept 需要写入客户端 socket 长度，所以需要地址</span></span><br><span class="line"><span class="comment">* 另外，该函数会阻塞当前程序，直到有一个客户端 socket 被接受后程序才会往下执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>connect</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：客户端的文件描述符。</span></span><br><span class="line"><span class="comment">* __addr：sockaddr 参数。</span></span><br><span class="line"><span class="comment">* __len：sockaddr 参数大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>关于 Socket 的有些地址结构需要清楚：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 通用的套接字地址类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>   sa_family;     <span class="comment">// AF_INET 或 AF_INET6</span></span><br><span class="line">    <span class="type">char</span>             sa_data[<span class="number">14</span>];   <span class="comment">// 无关紧要</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际使用的套接字地址类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">short</span>           sin_family;     <span class="comment">// AF_INET</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  sin_port;       <span class="comment">// 端口号，大端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;       <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span>            sin_zero[<span class="number">8</span>];    <span class="comment">// 无关紧要</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span>        sin6_family;    <span class="comment">// AF_INET6</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin6_port;      <span class="comment">// 端口号，大端</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;      <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>     ss_family;      <span class="comment">// AF_INET 或 AF_INET6</span></span><br><span class="line">    <span class="comment">// 为IPv4和IPv6提供足够的空间</span></span><br><span class="line">    <span class="type">char</span>    __ss_pad1[_SS_PAD1SIZE];</span><br><span class="line">    <span class="type">int64_t</span> __ss_align;</span><br><span class="line">    <span class="type">char</span>    __ss_pad2[_SS_PAD2SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>struct sockaddr_storage</code> 对于IPv4和IPv6都足够大，可以在实际中使用它。</p>
</li>
<li>
<p><code>struct sockaddr_in</code> 和 <code>struct sockaddr_in6</code> 是IPv4和IPv6的具体结构。</p>
</li>
</ul>
<p><code>struct sockaddr *</code> 是 socket API 使用的类型，结构本身是无用的。程序员不应操作 <code>sockaddr</code>，<code>sockaddr</code> 是给操作系统用的。应使用 <code>sockaddr_in</code> 来表示地址，<code>sockaddr_in</code> 区分了地址和端口，将 <code>struct sockaddr_storage</code> 引用（指针）转换为 <code>struct sockaddr_in</code> 或 <code>struct sockaddr_in6</code> 以初始化/读取结构。</p>
<p>当在 Linux 上调用任何系统调用时，实际上是在调用 libc 中的一个瘦包装器，即一个稳定的 Linux 系统调用接口的包装器。在 Windows 上，套接字 API 遵循相同的 BSD API，但有许多不同的细节。接口来自 OS DLL 而不是系统调用。</p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day01">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day01">Gitee</a></p>
<h2 id="二-完善代码-数据读写">二、完善代码，数据读写</h2>
<p>上面的代码是基础版的，但要想真正运行使用，需要完善代码，并抓住错误。</p>
<ul>
<li>Effective C++ 中有提到：“别让异常逃离析构函数”（条款08）。</li>
</ul>
<h3 id="2-1-错误检查处理函数">2.1 错误检查处理函数</h3>
<p>对于 Linux 系统调用，常见的错误提示方式是使用返回值和设置错误码。</p>
<ul>
<li>当一个系统调用返回 <code>-1</code>，说明有错误发生。</li>
</ul>
<p>增加一个错误检查处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">errorif</span><span class="params">(<span class="type">bool</span> condition, <span class="type">const</span> <span class="type">char</span> *errmsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (condition)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(errmsg);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数为判断是否发生错误条件，调用 <code>iostream</code> 中的 <code>perror</code> 打印错误。</li>
<li>第二个参数为错误信息。</li>
<li>然后使用 <code>exit</code> 函数让程序退出并返回一个预定义常量 <code>EXIT_FAILURE</code>。</li>
</ul>
<p>使用就很方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">errorif</span>(sockfd == <span class="number">-1</span>, <span class="string">&quot;socket create error&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对所有函数都进行处理错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">errorif</span>(<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">-1</span>, <span class="string">&quot;socket bind error&quot;</span>);</span><br><span class="line"><span class="built_in">errorif</span>(<span class="built_in">listen</span>(sockfd, SOMAXCONN) == <span class="number">-1</span>, <span class="string">&quot;socket listen error&quot;</span>);</span><br><span class="line"><span class="built_in">errorif</span>(clientfd == <span class="number">-1</span>, <span class="string">&quot;socket accept error&quot;</span>);</span><br><span class="line"><span class="built_in">errorif</span>(<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">-1</span>, <span class="string">&quot;socket connect error&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><em>错误的处理是必须的，但处理函数不一定这样写。</em></li>
</ul>
<h3 id="2-2-数据读写">2.2 数据读写</h3>
<p>当建立 socket 连接后，就可以使用 <code>unistd.h</code> 中的 <code>read</code> 和 <code>write</code> 函数进行数据读写。（仅限于 TCP 连接。UDP 连接使用 <code>sendto</code> 和 <code>recvfrom</code> 函数。）</p>
<p>接下来做一个通信情况：客户端向服务端发送一定数据，然后服务端接收后转发回客户端，客户端将接收的转发数据再进行标准输出。</p>
<p>客户端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">// 持续通信</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];	<span class="comment">// 定义缓冲区</span></span><br><span class="line">	std::cin &gt;&gt; buffer;	<span class="comment">// 从标准输入读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向服务端发送数据</span></span><br><span class="line">	<span class="type">size_t</span> writeLen = <span class="built_in">write</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送失败处理</span></span><br><span class="line">	<span class="keyword">if</span> (writeLen == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Socket already disconnected!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(buffer, <span class="built_in">sizeof</span>(buffer));	<span class="comment">// 清空缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读回数据</span></span><br><span class="line">	<span class="type">size_t</span> readLen = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读数据问题判断</span></span><br><span class="line">	<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Server socket disconnected!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">close</span>(sockfd);</span><br><span class="line">		<span class="built_in">errorif</span>(<span class="literal">true</span>, <span class="string">&quot;socket read error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 定义并初始化缓冲区</span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">bzero</span>(buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从客户端读取数据</span></span><br><span class="line">	<span class="type">size_t</span> readLen = <span class="built_in">read</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取数据问题判断</span></span><br><span class="line">	<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Message from client:&quot;</span> &lt;&lt; clientfd &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="built_in">write</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer));	<span class="comment">// 读到后转回客户端</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Client &quot;</span> &lt;&lt; clientfd &lt;&lt; <span class="string">&quot; disconnected\n&quot;</span>;</span><br><span class="line">		<span class="built_in">close</span>(clientfd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">close</span>(clientfd);</span><br><span class="line">		<span class="built_in">errorif</span>(<span class="literal">true</span>, <span class="string">&quot;socket read error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>服务端和客户端都可以从对方中读写数据。</li>
<li>使用完一个 <code>fd</code>（文件描述符） 后，记得使用 <code>close</code> 函数进行关闭。</li>
</ul>
<h3 id="2-3-该节涉及函数及源代码">2.3 该节涉及函数及源代码</h3>
<ul>
<li>相关头文件：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>	<span class="comment">// 读写数据等需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span>  	<span class="comment">// 放置错误处理函数</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>write</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __buf：写入缓冲区。</span></span><br><span class="line"><span class="comment">* __n：写入缓冲区大小。</span></span><br><span class="line"><span class="comment">* 返回写入的大小，或-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>read</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __nbytes)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">* __buf：读取缓冲区。</span></span><br><span class="line"><span class="comment">* __nbytes：读取缓冲区大小。</span></span><br><span class="line"><span class="comment">* 返回读取的大小，-1表示错误，0表示EOF。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>close</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span> <span class="params">(<span class="type">int</span> __fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* __fd：文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day02">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day02">Gitee</a></p>
<h2 id="三-高并发使用epoll">三、高并发使用epoll</h2>
<p>之前只写了一个简单的服务器，只能同时处理一个客户端连接。事实上，所有的服务都是高并发的，可以同时为成千上万个客户端提供服务——IO复用。</p>
<ul>
<li>IO 复用和多线程相似，但不是一个概念。
<ul>
<li>IO 复用针对 IO 接口；</li>
<li>多线程针对 CPU。</li>
</ul>
</li>
</ul>
<p>IO 复用的基本思想是事件驱动，服务器同时保持多个客户端 IO 连接。</p>
<ul>
<li>当 IO 上有可读或可写事件发生，表示这个 IO 对应的客户端在请求服务器的服务，服务器应当响应。</li>
<li>Linux 中， IO 复用使用 select、poll 和 epoll 来实现。
<ul>
<li>epoll 相比 select、poll，表现性能更好，更加高效。</li>
</ul>
</li>
</ul>
<h3 id="3-1-从select-poll到epoll">3.1 从select、poll到epoll</h3>
<blockquote>
<p>从实现原理上来说，select 和 poll 采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。epoll_wait 则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插人内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此 epoll_wait 无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。详见《Linux高性能服务器编程-游双，第9章》</p>
</blockquote>
<ul>
<li>当活动连接比较多的时候，epoll_wait 的效率未必比 select 和 poll 高，因为此时回调函数被触发得过于频繁。所以 epoll_wait 适用于连接数量多，但活动连接较少的情况。</li>
</ul>
<p>epoll 是 Linux 特有的 IO 复用函数。</p>
<ul>
<li>使用一组函数完成任务。</li>
<li>把用户关心的文件描述符上的事件放到内核的一个事件表中。
<ul>
<li>而不像 select 和 poll 那样每次调用都重复传入文件描述符或事件集。</li>
</ul>
</li>
<li>需要额外的文件描述符来标识内核中的事件表。</li>
</ul>
<p>创建文件描述符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* size：内核事件表大小。</span></span><br><span class="line"><span class="comment">* 返回文件描述符，用作其他所有 epoll 系统调用的第一个参数，指定访问的内核事件表。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>操作 epoll 的内核事件表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* epfd：文件描述符。</span></span><br><span class="line"><span class="comment">* op：操作类型。有 EPOLL_CTL_ADD（往事件表中注册 fd 上的事件）、 </span></span><br><span class="line"><span class="comment">* 				EPOLL_CTL_DEL（修改 fd 上的注册事件）、</span></span><br><span class="line"><span class="comment">* 				EPOLL_CTL_MOD（删除 fd 上的注册事件） 三种。</span></span><br><span class="line"><span class="comment">* fd：文件描述符。</span></span><br><span class="line"><span class="comment">* event：指定事件，是 epoll_event 结构体指针。</span></span><br><span class="line"><span class="comment">* 返回值：成功返回 0，失败返回 -1 并设置错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>而关于 <code>epoll_event</code> 结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">__uint32_t</span> events;	<span class="comment">/*epoll事件*/</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;	<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ptr;		<span class="comment">// 指定与fd相关的用户数据</span></span><br><span class="line">	<span class="type">int</span> fd;			<span class="comment">// 指定事件所从属的目标文件描述符</span></span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>epoll 系列系统调用的主要接口是 <code>epoll_wait</code> 函数，它在一段超时时间内等待一组文件描述符上的事件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 该函数如果检测到事件，就将所有就绪的事件从内核事件表（epfd指定）中复制到events中。</span></span><br><span class="line"><span class="comment">* epfd：文件描述符。</span></span><br><span class="line"><span class="comment">* events：事件数组。</span></span><br><span class="line"><span class="comment">* maxevents：监听事件数组大小。</span></span><br><span class="line"><span class="comment">* timeout：超时时间，单位为毫秒。</span></span><br><span class="line"><span class="comment">* 返回值：成功返回就绪事件个数，失败返回 -1 并设置错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>epoll 对文件描述符的操作有两种：</p>
<ul>
<li>LT（Level Trigger，电平触发）模式
<ul>
<li>默认的工作模式，相当于效率较高的 poll。</li>
<li>对于采用 LT 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 epoll,_wait 时，epoll_wait 还会再次向应用程序通告此事件，直到该事件被处理。</li>
</ul>
</li>
<li>ET（Edge Trigger，边沿触发）模式
<ul>
<li>对于采用ET工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait 调用将不再向应用程序通知这一事件。可见，ET 模式在很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</li>
<li>ET 模式必须搭配非阻塞式 socket 使用。</li>
</ul>
</li>
</ul>
<p>epoll 的事件有：</p>
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符可读（包括对端 socket 正常关闭）；</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可写；</li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><code>EPOLLET</code>：将 epoll 设为边缘触发模式。</li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完事件后，如果还需要继续监听这个 socket 的情况下，需要再次把这个 socket 加到 epoll 队列里。</li>
</ul>
<h3 id="3-2-将服务器改写成epoll版本">3.2 将服务器改写成epoll版本</h3>
<p>在创建了服务器 socket fd 后，将这个 fd 添加到 epoll。</p>
<ul>
<li>epoll 监听事件的描述符会放在一棵红黑树上，将要监听的 IO 口放入 epoll 红黑树中，就可以监听该 IO 上的事件。</li>
<li>只要这个 fd 上发生可读事件，表示有一个新的客户端连接。</li>
<li>然后 accept 这个客户端并将客户端的 socket fd 添加到 epoll，epoll 会监听客户端 socket fd 是否有事件发生，如果发生则处理事件。</li>
</ul>
<p>所以服务器大概的步骤如下：</p>
<ol>
<li>创建 epoll，同时定义事件数组。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll</span></span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">errorif</span>(epfd == <span class="number">-1</span>, <span class="string">&quot;epoll create error&quot;</span>);</span><br><span class="line"><span class="comment">// 定义事件数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS], ev;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;events, <span class="built_in">sizeof</span>(events));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将要监听的 IO 口放入 epoll 中。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ev.data.fd = sockfd;			<span class="comment">// 该 IO 口为服务器 socket fd</span></span><br><span class="line">ev.events = EPOLLIN;			<span class="comment">// 可读</span></span><br><span class="line"><span class="built_in">setnonblocking</span>(sockfd);			<span class="comment">// 设置 sockfd 为非阻塞</span></span><br><span class="line"><span class="comment">// 将服务器 socket fd 注册到 epoll</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>不断监听 epoll 上的事件并处理。</p>
</li>
<li>
<p>如果监听发生的事件是服务器 socket fd 上的事件，表示有一个新的客户端连接。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (events[i].data.fd == sockfd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 接收客户端信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新增监听</span></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;ev, <span class="built_in">sizeof</span>(ev));</span><br><span class="line">	ev.data.fd = clientfd;			<span class="comment">// 该 IO 口为客户端 socket fd</span></span><br><span class="line">	ev.events = EPOLLIN | EPOLLET;	<span class="comment">// 客户端连接使用 ET 模式</span></span><br><span class="line">	<span class="built_in">setnonblocking</span>(clientfd);		<span class="comment">// ET 需要搭配非阻塞式 socket 使用</span></span><br><span class="line">	<span class="comment">// 将客户端 socket fd 注册到 epoll</span></span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clientfd, &amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>如果监听发生的事件是客户端，并且是可读事件，表示有客户端发送消息：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">// 非阻塞 IO，需要不断读取，直至完毕</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">ssize_t</span> bytesRead = <span class="built_in">read</span>(events[i].data.fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正常读取数据</span></span><br><span class="line">		<span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 客户端正常中断，继续读取</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> <span class="keyword">and</span> errno == EINTR)</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 非阻塞 IO，这个条件表示数据全部读取完毕</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> <span class="built_in">and</span> ((errno == EAGAIN) <span class="built_in">or</span> (errno == EWOULDBLOCK)))</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// EOF 事件，一般表示客户端断开连接</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day03">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day03">Gitee</a></p>
<h2 id="四-封装成类-程序模块化">四、封装成类，程序模块化</h2>
<h3 id="4-1-将socket和inetaddress封装成类">4.1 将socket和InetAddress封装成类</h3>
<p>当新建服务器 socket 时，需要完成绑定 IP 地址、监听、接受客户端连接等任务，这些任务都封装成 <code>Socket</code> 类来完成。希望简化成以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建服务器 socket</span></span><br><span class="line">Socket *serverSocket = <span class="keyword">new</span> <span class="built_in">Socket</span>();</span><br><span class="line"><span class="comment">// 实例化 IP 地址</span></span><br><span class="line">InetAddress *serverAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 IP 地址</span></span><br><span class="line">serverSocket-&gt;<span class="built_in">bind</span>(serverAddr);</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">serverSocket-&gt;<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个客户端地址</span></span><br><span class="line">InetAddress *clientAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>();</span><br><span class="line"><span class="comment">// 接受一个客户端连接</span></span><br><span class="line">Socket *clientSocket = <span class="keyword">new</span> <span class="built_in">Socket</span>(serverSocket-&gt;<span class="built_in">accept</span>(clientAddr));</span><br></pre></td></tr></table></figure>
<h3 id="4-2-将epoll封装成类">4.2 将epoll封装成类</h3>
<p>对于 epoll，希望简化操作，封装成类后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化 epoll</span></span><br><span class="line">Epoll *ep = <span class="keyword">new</span> <span class="built_in">Epoll</span>();</span><br><span class="line"><span class="comment">// 将要监听的 IO 口放入 epoll</span></span><br><span class="line">ep-&gt;<span class="built_in">epoll_add</span>(serverSocket-&gt;<span class="built_in">getFd</span>(), EPOLLIN | EPOLLET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::vector&lt;epoll_event&gt; events = ep-&gt;<span class="built_in">poll</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ev : events)</span><br><span class="line">		<span class="comment">// 处理事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-目录结构及源代码">4.3 目录结构及源代码</h3>
<p>目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client.cpp</span><br><span class="line">server.cpp</span><br><span class="line">util.h</span><br><span class="line">util.cpp</span><br><span class="line">Socket.h</span><br><span class="line">Socket.cpp</span><br><span class="line">InetAddress.h</span><br><span class="line">InetAddress.cpp</span><br><span class="line">Epoll.h</span><br><span class="line">Epoll.cpp</span><br></pre></td></tr></table></figure>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day04">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day04">Gitee</a></p>
<h2 id="五-向着reactor模式转变">五、向着Reactor模式转变</h2>
<h3 id="5-1-reactor和proactor">5.1 Reactor和Proactor</h3>
<blockquote>
<p>Reactor 翻译过来的意思是「反应堆」，这里的反应指的是「对事件反应」。</p>
<ul>
<li>当来了一个事件，Reactor 就有相对应的反应/响应。</li>
</ul>
<p>事实上，Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 I/O 多路复用监听事件。</p>
<ul>
<li>收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。</li>
</ul>
<p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成。</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ul>
<li>Reactor 的数量可以只有一个，也可以有多个；</li>
<li>处理资源池可以是单个进程 / 线程，也可以是多个进程 / 线程；</li>
</ul>
<p>有 3 个方案都是比较经典的，且都有应用在实际的项目中：</p>
<ul>
<li>单 Reactor 单进程 / 线程；</li>
<li>单 Reactor 多线程 / 进程；</li>
<li>多 Reactor 多进程 / 线程；</li>
</ul>
<p>方案具体使用进程还是线程，要看使用的编程语言以及平台有关：</p>
<ul>
<li>Java 语言一般使用线程，比如 Netty；</li>
<li>C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。</li>
</ul>
<p>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</p>
<p>Proactor 是异步网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p>
<p>因此，Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p>
<p>作者：小林coding<br>
链接：<a href="https://www.zhihu.com/question/26943938/answer/1856426252">https://www.zhihu.com/question/26943938/answer/1856426252</a><br>
来源：知乎著作权归作者所有。</p>
</blockquote>
<p><em>详细请参考游双《Linux高性能服务器编程》第八章第四节、陈硕《Linux多线程服务器编程》第六章第六节。</em></p>
<p>接下来要将服务器向着 Reactor 模式转变：</p>
<ol>
<li>首先将整个服务器抽象成一个 Server 类，这个类中有一个 main-Reactor，里面的核心是一个 EventLoop，这是一个事件循环；</li>
<li>添加需要监听的事务到这个事件循环内，每次有事件发生时就会通知，在程序中返回给 Channel（自封装的类），然后根据不同的描述符、事件类型以回调函数的方式进行处理。</li>
</ol>
<h3 id="5-2-加入channel类">5.2 加入Channel类</h3>
<p>面对服务器许多服务时，不同的连接类型也将决定不同的处理逻辑，仅仅通过一个文件描述符来区分显然会很麻烦。希望得到文件描述符的更多消息。</p>
<ul>
<li>epoll 的 <code>epoll_event</code> 结构体中，<code>data</code> 字段可以放一个 <code>void *</code> 类型的指针，用来保存更多信息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> events;		<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;	<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure>
<ul>
<li>epoll 中的 <code>data</code> 是一个联合类型：
<ul>
<li>可以存储一个指针，指向任何一个地址块的内容；</li>
<li>可以是一个类的对象，就此将一个文件描述符封装成一个 <code>Channel</code> 类，一个 <code>Channel</code> 类始终负责一个文件描述符。对不同的服务、不同的事件类型，都可以在类中进行处理。</li>
</ul>
</li>
</ul>
<p>设计 <code>Channel</code> 类，核心成员如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *loop;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> events;</span><br><span class="line">	<span class="type">uint32_t</span> revents;</span><br><span class="line">	<span class="type">bool</span> isEpoll;</span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>loop</code>：指向与之关联的事件循环的指针。</li>
<li><code>fd</code>：Channel 负责的文件描述符。</li>
<li><code>events</code>：表示希望监听这个文件描述符的哪些事件。</li>
<li><code>revents</code>：表示在 <code>epoll</code> 返回该 <code>Channel</code> 时文件描述符正在发生的事件。</li>
<li><code>isEpoll</code>：表示当前 <code>Channel</code> 是否已经添加到 <code>epoll</code> 红黑树中，区分使用 <code>EPOLL_CTL_ADD</code> 还是 <code>EPOLL_CTL_MOD</code>。</li>
<li><code>callback</code>：发生事件时执行的回调函数。</li>
</ul>
<p>添加 Channel 类可以更加方便简单、多样化地处理 epoll 中发生的事件。同时脱离了底层，将 epoll、文件描述符和事件进行了抽象，形成了事件分发的模型，这也是 Reactor 模式的核心。</p>
<h3 id="5-3-加入eventloop类">5.3 加入EventLoop类</h3>
<p>EventLoop 类的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Epoll *ep;</span><br><span class="line">    <span class="type">bool</span> quit;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel*)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ep</code>：指向Epoll类实例的指针；</li>
<li><code>quit</code>：指示程序是否应该退出；</li>
<li><code>loop()</code>：事件循环函数，调用开始事件驱动，即原来调用 <code>epoll_wait</code> 函数的死循环；</li>
<li><code>updateChannel()</code>：更新 Channel。</li>
</ul>
<p>将需要监听的事务加入到事件循环中，每次有事件发生就会通知，返回到 Channel，然后根据不同的描述符、事件类型以回调函数方式进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!quit)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 使用epoll实例轮询事件</span></span><br><span class="line">		std::vector&lt;Channel *&gt; channels = ep-&gt;<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理每个Channel的事件</span></span><br><span class="line">		<span class="keyword">for</span> (Channel *channel : channels)</span><br><span class="line">			channel-&gt;<span class="built_in">handleEvent</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-加入server类">5.4 加入Server类</h3>
<p>服务器类 <code>Server</code> 的核心成员如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *loop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(EventLoop*);</span><br><span class="line">    ~<span class="built_in">Server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleReadEvent</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(Socket *serv_sock)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>loop</code>：事件循环对象。</li>
<li><code>handleReadEvent()</code>：处理读事件。</li>
<li><code>newConnection()</code>：处理新连接。</li>
</ul>
<p>之后启动服务器的操作抽象为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EventLoop *loop = <span class="keyword">new</span> <span class="built_in">EventLoop</span>();</span><br><span class="line">Server *server = <span class="keyword">new</span> <span class="built_in">Server</span>(loop);</span><br><span class="line">loop-&gt;<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>
<p>这个版本服务器内只有一个 <code>EventLoop</code>，当其中有可读事件发生时，可以拿到该描述符对应的 <code>Channel</code>。</p>
<p>在新建 Channel 时，根据 Channel 描述符的不同分别绑定了两个回调函数：</p>
<ul>
<li><code>newConnection()</code> 函数被绑定到服务器socket上；
<ul>
<li>如果服务器 socket 有可读事件，Channel 里的 <code>handleEvent()</code> 函数实际上会调用 Server 类的 <code>newConnection()</code> 新建连接。</li>
</ul>
</li>
<li><code>handlrReadEvent()</code> 被绑定到新接受的客户端socket上。
<ul>
<li>如果客户端 socket 有可读事件，Channel 里的 <code>handleEvent()</code> 函数实际上会调用 Server 类的 <code>handleReadEvent()</code> 响应客户端请求。</li>
</ul>
</li>
</ul>
<p>至此，根据抽象出的 <code>EventLoop</code> 和 <code>Channel</code>，构成了事件驱动模型。这两个类和服务器核心 <code>Server</code> 已经没有任何关系，经过完善后可以被任何程序复用，达到了事件驱动的设计思想，现在的服务器也可以看成一个最简易的 Reactor 模式服务器。</p>
<p><em>需要注意的是，目前该服务器的内存管理一塌糊涂。</em></p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day05">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day05">Gitee</a></p>
<h2 id="六-把服务器的接受抽象化">六、把服务器的接受抽象化</h2>
<h3 id="6-1-抽象化接受">6.1 抽象化接受</h3>
<p>服务器中，对于每一个事件，首先都是调用 <code>accept()</code> 函数去接受一个 TCP 连接，然后把 Socket 文件描述符添加到 epoll。当这个 IO 口有事件发生时，对该连接提供相应的服务。</p>
<p>分离接受连接这个功能，添加 <code>Acceptor</code> 类。</p>
<h3 id="6-2-acceptor-类">6.2 Acceptor 类</h3>
<p>Acceptor 类应该有以下特点：</p>
<ul>
<li>类中有一个 Socket fd，就是服务器监听的 Socket fd，每一个<br>
Acceptor 对象都对应一个 Socket fd。</li>
<li>类存在于事件驱动 <code>EventLoop</code> 类中。</li>
<li>类也通过一个 <code>Channel</code> 负责分发到 epoll，该 <code>Channel</code> 的事件处理函数 <code>handleEvent()</code> 会调用 <code>Acceptor</code> 类中的连接函数进行新建一个 TCP 连接。</li>
</ul>
<p>将新建连接的逻辑就在 Acceptor 类中。但逻辑上新 Socket 建立后就和之前的监听的服务器 Socket 没有任何关系了。</p>
<p>新的 TCP 连接应该由 Server 类来创建并管理生命周期，而不是 Acceptor。并且将一部分代码放在 Server 类里也并没有打破服务器的通用性，因为对于所有的服务，都要使用 Acceptor 来建立连接。</p>
<ul>
<li><code>Acceptor</code> 类的新建连接功能是在 <code>Server</code> 类中实现的。</li>
</ul>
<p>可以使用 <code>std::function</code>、<code>std::bind</code>、右值引用、<code>std::move</code> 等实现函数回调。</p>
<p>定义该类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 用于事件处理的EventLoop指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于处理套接字操作的套接字指针</span></span><br><span class="line">	Socket *sock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于存储地址信息的指针</span></span><br><span class="line">	InetAddress *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于接受连接的 Channel 指针</span></span><br><span class="line">	Channel *acceptChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 定义一个新建连接的回调函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; newConnectionCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Acceptor</span>(EventLoop *_loop);</span><br><span class="line">	~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 接受新连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">acceptConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置新连接的回调函数。</span></span><br><span class="line"><span class="comment">	 * @param _callback 为新连接设置的回调函数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; _callback)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抽象后，Server类的变化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器套接字</span></span><br><span class="line">	Socket *serverSock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器地址</span></span><br><span class="line">	InetAddress *serverAddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器通道</span></span><br><span class="line">	Channel *serverChannel;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存客户端的套接字</span></span><br><span class="line">	std::vector&lt;std::pair&lt;Socket *, InetAddress *&gt;&gt; clients;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向Acceptor对象的指针</span></span><br><span class="line">	Acceptor *acceptor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day06">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day06">Gitee</a></p>
<h2 id="七-把tcp连接抽象化">七、把TCP连接抽象化</h2>
<h3 id="7-1-抽象化连接">7.1 抽象化连接</h3>
<p>对于 TCP 协议，在三次握手新建连接后，该连接会一直存在直至四次挥手断开连接。</p>
<p>那么把这个连接也抽象化，抽象成 <code>Connection</code> 类。</p>
<h3 id="7-2-connection-类">7.2 Connection 类</h3>
<p>Connection 类应该有以下特点：</p>
<ul>
<li>类存在于事件驱动类中；</li>
<li>类的 Socket fd 就是客户端的 Socket fd，每一个<br>
Connection 对象都对应一个 Socket fd。</li>
<li>类也通过一个 <code>Channel</code> 负责分发到 epoll，该 <code>Channel</code> 的事件处理函数 <code>handleEvent()</code> 会调用 <code>Connection</code> 类中的事件处理函数进行响应客户端请求。</li>
</ul>
<p><code>Connection</code> 类与 <code>Acceptor</code> 类十分相似，它们都由 <code>Server</code> 管理，由一个 <code>Channel</code> 分发到 epoll，通过回调函数处理响应事件。</p>
<p>一个高并发服务器一般只有一个 <code>Acceptor</code>（可以有多个），但会同时有成千上万个 TCP 连接，也就是 <code>Connection</code> 的实例。</p>
<p>对 <code>Connection</code> 类的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *loop;</span><br><span class="line">	Socket *sock;</span><br><span class="line">	Channel *channel;</span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; deleteConnectionCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(EventLoop *_loop, Socket *_sock);</span><br><span class="line">	~<span class="built_in">Connection</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 回显sockfd发来的数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 设置删除连接时要调用的回调函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; _callback)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-改写-server-类">7.3 改写 Server 类</h3>
<p><code>Server</code> 类的核心变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 指向EventLoop对象的指针</span></span><br><span class="line">	EventLoop *loop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向Acceptor对象的指针</span></span><br><span class="line">	Acceptor *acceptor;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">	std::map&lt;<span class="type">int</span>, Connection *&gt; connections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(EventLoop *_loop);</span><br><span class="line">	~<span class="built_in">Server</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 处理客户端请求，暂时没有</span></span><br><span class="line">	<span class="comment">// void handleReadEvent(int fd);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 处理与所提供套接字的新连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(Socket *_socket)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 断开与提供的套接字关联的连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteConnection</span><span class="params">(Socket *_socket)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>Map</code> 映射将众多连接保存起来，键为该连接客户端的 <code>socket fd</code>，值为指向该连接的指针。</li>
<li>该连接客户端的 <code>socket fd</code> 通过一个 <code>Channel</code> 类分发到 <code>epoll</code>，该 <code>Channel</code> 的事件处理回调函数 <code>handleEvent()</code> 绑定为 <code>Connection</code> 的处理函数，这样每当该连接的 <code>socket fd</code> 上发生事件，就会通过 <code>Channel</code> 调用具体连接类的处理函数。</li>
</ul>
<p>此处将新建连接的功能放回到 <code>Acceptor</code> 类中管理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::acceptConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个新的InetAddress对象来存储客户端地址信息</span></span><br><span class="line">	InetAddress *clientAddr = <span class="keyword">new</span> <span class="built_in">InetAddress</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过使用客户端地址接受来自服务器套接字的连接，创建一个新的Socket对象</span></span><br><span class="line">	Socket *clientSock = <span class="keyword">new</span> <span class="built_in">Socket</span>(sock-&gt;<span class="built_in">accept</span>(clientAddr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印有关新客户端连接的信息</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;New client &quot;</span> &lt;&lt; clientSock-&gt;<span class="built_in">getFd</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt;</span><br><span class="line">		<span class="built_in">inet_ntoa</span>(clientAddr-&gt;addr.sin_addr) &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(clientAddr-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	clientSock-&gt;<span class="built_in">setNonBlocking</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">newConnectionCallback</span>(clientSock);</span><br><span class="line">	<span class="keyword">delete</span> clientAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Server</code> 类变得只负责管理 <code>Acceptor</code> 和 <code>Connection</code> 类，其成员函数也集中在管理 <code>Acceptor</code> 和 <code>Connection</code> 类中。改写后的 <code>Server</code> 类代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::newConnection</span><span class="params">(Socket *_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(loop, _socket);</span><br><span class="line">	std::function&lt;<span class="type">void</span>(Socket *)&gt; cb = std::<span class="built_in">bind</span>(&amp;Server::deleteConnection, <span class="keyword">this</span>, std::placeholders::_1);</span><br><span class="line">	conn-&gt;<span class="built_in">setDeleteConnectionCallback</span>(cb);</span><br><span class="line">	connections[_socket-&gt;<span class="built_in">getFd</span>()] = conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::deleteConnection</span><span class="params">(Socket *_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Connection *conn = connections[_socket-&gt;<span class="built_in">getFd</span>()];</span><br><span class="line">	connections.<span class="built_in">erase</span>(_socket-&gt;<span class="built_in">getFd</span>());</span><br><span class="line">	<span class="keyword">delete</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当有新的 TCP 连接时，实例化一个 <code>Connection</code> 对象，设置其删除时的回调函数，并放置在 <code>connections</code> 中管理。
<ul>
<li>目前该服务器的唯一功能——接受客户端的信息并发回，封装成 <code>Connection</code> 类的 <code>echo</code> 函数，在 <code>Connection</code> 构造时绑定给 <code>Channel</code> 类的事件回调函数，由 <code>Channel</code> 实例遇到事件时触发。</li>
</ul>
</li>
<li>当有 TCP 连接断开时，从 <code>connections</code> 中删除该连接，并释放对象。
<ul>
<li>由于 <code>Connection</code> 的生命周期由 <code>Server</code> 进行管理，所以也应该由 <code>Server</code> 来删除连接</li>
</ul>
</li>
</ul>
<p>至此，服务器到了一个比较重要的阶段，服务器最核心的几个模块都已经抽象出来，一个完整的单线程服务器设计基本完成。</p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day07">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day07">Gitee</a></p>
<h2 id="八-闲来无事-整个缓冲区">八、闲来无事，整个缓冲区</h2>
<h3 id="8-1-引入缓冲区">8.1 引入缓冲区</h3>
<p>此节引入一个最简单、最基本的缓冲区，完善改进之前的服务器。</p>
<p>没有使用缓冲区时，服务器回送信息的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[READ_BUFFER];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">ssize_t</span> readLen = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; buf &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="built_in">write</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是非阻塞式 socket IO 的读取，缓冲区大小为 1024，表示每次 TCP 缓冲区读取 1024 大小的数据到缓冲区，然后发送到客户端。</li>
<li>只能以 1024 地读，当数据没有 1024，用空值补满。</li>
</ul>
<p>所以，封装一个缓冲区，为每一个 <code>Connection</code> 类分配一个读缓冲区和写缓冲区：</p>
<ul>
<li>从客户端读来的数据存放在都缓冲区。</li>
</ul>
<h3 id="8-2-buffer类">8.2 Buffer类</h3>
<p><code>Buffer</code> 类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 向当前字符串追加一个字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str, <span class="type">int</span> _size)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 返回当前缓冲区字符串大小</span></span><br><span class="line">	<span class="function"><span class="type">ssize_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief返回指向底层字符串数据的指针</span></span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="type">const</span> *<span class="title">c_str</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 清空当前缓冲区字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 从控制台获取输入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getline</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/Connection.cpp */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">ssize_t</span> readLen = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span> (readLen &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			readBuffer-&gt;<span class="built_in">append</span>(buf, readLen);	<span class="comment">// 缓冲区追加</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span> <span class="keyword">and</span> errno == EINTR)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span> <span class="built_in">and</span> ((errno == EAGAIN) <span class="built_in">or</span> (errno == EWOULDBLOCK)))</span><br><span class="line">		&#123;	<span class="comment">// 从缓冲区中读取数据，同时进行回写</span></span><br><span class="line">			std::cout &lt;&lt; readBuffer-&gt;<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="built_in">errorif</span>(<span class="built_in">write</span>(sockfd, readBuffer-&gt;<span class="built_in">c_str</span>(), readBuffer-&gt;<span class="built_in">size</span>()) == <span class="number">-1</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">			readBuffer-&gt;<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">deleteConnectionCallback</span>(sock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然仍有 <code>char buf[1024]</code> 这样的低级缓冲区，用于系统调用 <code>read()</code> 的读取，但这个缓冲区大小无所谓，设置为1到设备TCP缓冲区的大小都可以。</p>
<ul>
<li>太大导致资源浪费，单词读取速度低；</li>
<li>太小导致读取次数增多。</li>
</ul>
<p>以上代码会把 socket IO 上的可读数据全部读取到缓冲区，缓冲区大小就等于客户端发送的数据大小。全部读取完成之后，可以构造一个写缓冲区、填好数据发送给客户端。</p>
<ul>
<li>由于是echo服务器，所以这里使用了相同的缓冲区。</li>
</ul>
<h3 id="8-3-其他方面的改进">8.3 其他方面的改进</h3>
<ul>
<li>
<p>优化 InetAddress 类，将成员私有化，提供访问方法。（—— <code>src/InetAddress.h</code> 和 <code>src/InetAddress.cpp</code>）</p>
</li>
<li>
<p>Socket 类添加 <code>connect</code> 方法，方便 <code>client.cpp</code> 调用。（—— <code>src/Socket.h</code> 和 <code>src/Socket.cpp</code>）</p>
</li>
<li>
<p>结合现有的模块，改进 client 文件。（—— <code>client.cpp</code>）</p>
</li>
<li>
<p>整体改进了了输出信息提示。</p>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-1.jpg" alt="服务器端"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day8-2.jpg" alt="客户端"></p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day08">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day08">Gitee</a></p>
<h2 id="九-线程池啊线程池">九、线程池啊线程池</h2>
<h3 id="9-1-为什么加入线程池">9.1 为什么加入线程池</h3>
<p>当前的代码是单线程模式，所有 fd 上的事件都由一个线程（主线程，EventLoop线程）处理。</p>
<ul>
<li>假设响应一个事件需要 1s，那么如果有 1000 个事件，那么主线程就要等待很久。</li>
<li>这不现实。</li>
</ul>
<p>引入多线程，当发现 socket fd 有事件时，应该分发一个工作线程。</p>
<ul>
<li>由这个工作线程处理 fd 上的事件。</li>
</ul>
<p>再者，每一个 Reactor 只应该负责事件分发而不负责事件处理。</p>
<h3 id="9-2-如何设计线程池">9.2 如何设计线程池</h3>
<p>最简单的想法就是，每次遇到一个新的任务，就开一个新线程去执行。</p>
<ul>
<li>这种方式虽然简单，但是太粗暴了。</li>
<li>我们的机器是有上限的，不可能无限开新线程。</li>
</ul>
<p>那么，可以固定一个线程的数量。启动固定数量的工作线程，然后将任务添加到任务队列，工作线程不断取出任务队列的任务执行。</p>
<p>设计线程池还需要注意：</p>
<ol>
<li>多线程环境下任务队列的读写应该考虑互斥锁。</li>
<li>当任务队列为空时，CPU 不应该一直轮询耗费 CPU 资源。</li>
</ol>
<p>此处解决方法如下：</p>
<ol>
<li><code>std::mutex</code> 对任务队列进行加锁解锁。</li>
<li><code>std::condition_variable</code> 使用条件变量。</li>
</ol>
<h3 id="9-3-线程池用到的语法知识">9.3 线程池用到的语法知识</h3>
<p><strong>关于互斥锁：<a href="https://zh.cppreference.com/w/cpp/header/mutex">mutex头文件 - cppreference</a></strong></p>
<ul>
<li><code>mutex</code> 类是能用于保护共享数据免受从多个线程同时访问的同步原语。</li>
<li><code>lock()</code>：成员函数，锁定互斥体，若互斥体不可用则阻塞。位于头文件 <code>&lt;mutex&gt;</code>。
<ul>
<li>通常不直接调用 <code>lock()</code>。</li>
<li>用 <code>std::unique_lock</code> 与 <code>std::lock_guard</code> 管理排他性锁定。</li>
<li><code>unique_lock</code> 类是一种通用互斥包装器，允许延迟锁定、有时限的锁定尝试、递归锁定、所有权转移和与条件变量一同使用。</li>
<li>构造函数：<code>explicit unique_lock( mutex_type&amp; m );</code>，通过调用 <code>m.lock()</code> 锁定关联互斥体。</li>
<li>析构函数：若拥有关联互斥体且获得了其所有权，则解锁互斥体。</li>
</ul>
</li>
<li><code>try_lock()</code>：成员函数，尝试锁定互斥体，若互斥体不可用则返回 <code>false</code>。位于头文件 <code>&lt;mutex&gt;</code>。</li>
<li><code>unlock()</code>：成员函数，解锁互斥体。位于头文件 <code>&lt;mutex&gt;</code>。</li>
</ul>
<p><strong>关于线程等待条件：<a href="https://zh.cppreference.com/w/cpp/header/condition_variable">condition_variable头文件 - cppreference</a></strong></p>
<ul>
<li><code>std::condition_variable</code>（线程等待条件） 是与 <code>std::mutex</code> 一起使用的同步原语。</li>
<li>它能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 <code>std::condition_variable</code>。</li>
<li>有意修改变量的线程必须：
<ol>
<li>获得 <code>std::mutex</code>（常通过 <code>std::lock_guard</code>）</li>
<li>在保有锁时进行修改</li>
<li>在 <code>std::condition_variable</code> 上执行 <code>notify_one</code> 或 <code>notify_all</code>（可以释放锁后再通知）</li>
</ol>
</li>
<li>任何有意在 <code>std::condition_variable</code> 上等待的线程必须：
<ol>
<li>在用于保护共享变量的互斥体上获得 <code>std::unique_lock&lt;std::mutex&gt;</code>。</li>
<li>执行下列之一：
<ul>
<li>检查条件，是否为已更新且已提醒的情况。</li>
<li>调用 <code>std::condition_variable</code> 的 <code>wait</code>、<code>wait_for</code> 或 <code>wait_until</code>（原子地释放互斥体并暂停线程的执行，直到条件变量被通知，时限过期，或发生虚假唤醒，然后在返回前自动获得互斥体）。</li>
<li>检查条件，并在未满足的情况下继续等待。</li>
</ul>
</li>
</ol>
</li>
<li><code>wait()</code>：成员函数，阻塞当前进程，直至条件变量被唤醒。位于头文件 <code>&lt;condition_variable&gt;</code>。
<ul>
<li>类似还有<code>wait_for</code>、<code>wait_until</code>。不多说，自行查阅。</li>
</ul>
</li>
<li><code>notify_one()</code>：成员函数，通知一个等待的线程。位于头文件 <code>&lt;condition_variable&gt;</code>。</li>
<li><code>notify_all()</code>：成员函数，通知所有等待的线程。位于头文件 <code>&lt;condition_variable&gt;</code>。</li>
</ul>
<h3 id="9-4-线程池类">9.4 线程池类</h3>
<p>线程池类代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 线程池中的线程</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">// 要执行的函数</span></span><br><span class="line">	std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line">	<span class="comment">// 声明互斥锁以同步对任务队列的访问</span></span><br><span class="line">	std::mutex tasksMtx;</span><br><span class="line">	<span class="comment">// 声明在线程之间进行协调的条件变量</span></span><br><span class="line">	std::condition_variable cv;</span><br><span class="line">	<span class="comment">// 指示线程停止的标志</span></span><br><span class="line">	<span class="type">bool</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadPool</span>(<span class="type">int</span> size = <span class="number">10</span>);</span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @brief 加入任务到任务队列中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>线程池的构造函数设计为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> size) : <span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">thread</span>([<span class="keyword">this</span>] ()</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">					&#123;<span class="comment">// 使用作用域生命期解锁 std::mutex，而不调用unlock()</span></span><br><span class="line">						std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(tasksMtx);</span><br><span class="line">						<span class="comment">// 当任务队列不为空或线程池停止时停止等待（阻塞）</span></span><br><span class="line">						cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] ()&#123;</span><br><span class="line">								<span class="keyword">return</span> stop <span class="keyword">or</span> !tasks.<span class="built_in">empty</span>();</span><br><span class="line">							&#125;);</span><br><span class="line">						<span class="keyword">if</span> (stop <span class="keyword">and</span> tasks.<span class="built_in">empty</span>())	<span class="comment">// 任务队列为空且线程池停止，退出循环</span></span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						task = tasks.<span class="built_in">front</span>();</span><br><span class="line">						tasks.<span class="built_in">pop</span>();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">task</span>();	<span class="comment">// 执行任务</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始线程池大小为 <code>size</code>，创建线程并让每个线程等待将任务添加到任务队列中。</li>
<li>使用 <code>std::unique_lock</code> 锁定任务互斥锁以防止并发访问，并将其置于局部作用域，当离开作用域时，它将自动解锁互斥锁。</li>
<li>当添加任务时，线程从队列中获取任务并执行它。线程将继续执行任务，直到线程池停止。</li>
</ol>
<p>析构函数设计为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(tasksMtx)</span></span>;</span><br><span class="line">		stop = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cv.<span class="built_in">notify_all</span>();	<span class="comment">// 通知所有等待的线程线程池正在停止</span></span><br><span class="line">	<span class="keyword">for</span> (std::thread &amp;th : threads)</span><br><span class="line">	&#123;	<span class="comment">// 检查线程是否可接合</span></span><br><span class="line">		<span class="keyword">if</span> (th.<span class="built_in">joinable</span>())</span><br><span class="line">			th.<span class="built_in">join</span>();	<span class="comment">// 阻塞当前线程，直到指定线程完成其执行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在线程池析构时，需要注意将已经添加的所有任务执行完，最好不采用外部的暴力kill、而是让每个线程从内部自动退出，具体实现参考源代码。</li>
</ul>
<ol>
<li>在上锁的情况下，把线程池的停止状态设置为<code>true</code>，然后通知所有等待的线程线程池正在停止。</li>
<li>然后，等待所有线程完成其执行。</li>
</ol>
<p>加入线程池后，当 <code>Channel</code> 类有事件需要处理时，将这个事件处理添加到线程池，主线程 <code>EventLoop</code> 就可以继续进行事件循环，而不在乎某个 <code>socket fd</code> 上的事件处理。</p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day09">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day09">Gitee</a></p>
<h2 id="十-有了线程池之后的考虑">十、有了线程池之后的考虑</h2>
<h3 id="10-1-完善线程池">10.1 完善线程池</h3>
<p>上一节添加的线程池是最简单的线程池，还存在许多问题，比如：</p>
<ul>
<li>任务队列的添加、取出都会有不必要的拷贝操作；</li>
<li>线程池只接受 <code>std::function&lt;void&gt;</code> 类型的参数，所有函数参数都要事先使用 <code>std::bind()</code>，并且无法得到返回值。</li>
</ul>
<p>解决方法一一对应：</p>
<ul>
<li>使用右值移动去避免拷贝操作。</li>
<li>改写 <code>add()</code> 函数，希望使用前不需要手动绑定参数，直接传递并且可以得到任务的返回值。</li>
</ul>
<h3 id="10-2-完善线程池用到的语法知识">10.2 完善线程池用到的语法知识</h3>
<p><strong>关于模板编程：<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/templates-cpp?view=msvc-170">模板 - MSLearn</a>、<a href="https://zhuanlan.zhihu.com/p/655902377">理解C++模板 - 知乎</a></strong></p>
<ul>
<li>简单来说，模板编程就是提供了一套模具，对于不同的数据类型都可以适用于这套模具。</li>
<li>函数模板的结构一般如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 返回类型 函数名(参数列表)&#123; <span class="comment">/*函数的主体*/</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类模板结构一般如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> 类名 &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/394184676">变长参数模板</a>：参数个数和类型都可能发生变化的模板。
<ul>
<li>使用模板形参包实现。</li>
<li>模板形参包是可以接受 0 个或者 n 个模板实参的模板形参，至少有一个模板形参包的模板就可以称作变参数模板。</li>
<li>模板形参包有：非类型模板形参包、类型模板形参包、模板模板形参包三种。</li>
<li>此节使用类型模板形参包：表示该可变形参包可以接受无限个不同的实参类型。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span>... Args 或 <span class="keyword">class</span> ... Args</span><br></pre></td></tr></table></figure>
<p><strong>关于右值和移动 <code>std::move</code>：<a href="https://blog.csdn.net/reyas/article/details/137735522">C++引用和右值引用 - CSDN</a>、<a href="https://cloud.tencent.com/developer/article/2341672">【C++】C++11——左右值|右值引用|移动语义|完美转发</a>、<a href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move - 知乎</a></strong></p>
<ul>
<li>C++11 后增加了移动语义，出现了移动构造、移动赋值等。</li>
<li>简单来说，移动语义的出现，可以把旧对象所拥有的资源交给新对象，而旧对象什么都没有了。</li>
<li>右值引用的出现也是为了移动语义。</li>
</ul>
<p><strong>关于完美转发 <code>std::forward</code>：</strong></p>
<ul>
<li>和 <code>std::move</code> 类似，与 <code>std::move</code>相比，它更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</li>
<li><code>std::forward&lt;T&gt;(u)</code> 有两个参数：<code>T</code> 与 <code>u</code>。
<ul>
<li>当 <code>T</code> 为左值引用类型时，<code>u</code> 将被转换为 <code>T</code> 类型的左值；</li>
<li>否则 <code>u</code> 将被转换为 <code>T</code> 类型右值。</li>
</ul>
</li>
</ul>
<p><strong>关于 <code>std::future</code>：<a href="https://zh.cppreference.com/w/cpp/header/future">future - cppreference</a></strong></p>
<ul>
<li>类模板 <code>std::packaged_task</code> 可以包装任何可调用 (Callable) 目标（函数、lambda 表达式、bind 表达式或其他函数对象），使得能异步调用它。其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。
<ul>
<li>成员函数 <code>get_future()</code>，返回与 <code>*this</code> 共享同一共享状态的 <code>future</code>，每个 <code>packaged_task</code> 对象只能调用一次。</li>
</ul>
</li>
<li>类模板 <code>std::future</code>：<code>future</code> 对象提供访问异步操作结果的机制，从异步任务中返回结果。</li>
<li>类模板 <code>std::future</code> 提供访问异步操作结果的机制：
<ul>
<li>（通过 <code>std::async</code>、<code>std::packaged_task</code> 或 <code>std::promise</code> 创建的）异步操作能提供一个 <code>std::future</code> 对象给该异步操作的创建者。</li>
<li>然后，异步操作的创建者可以使用多个方法查询、等待或从 <code>std::future</code> 提取值。若异步操作尚未提供值，则这些方法可能阻塞。</li>
<li>当异步操作准备好发送结果给创建者时，它可以修改与创建者的 <code>std::future</code> 相链接的共享状态（例如 <code>std::promise::set_value</code>）。</li>
</ul>
</li>
</ul>
<h3 id="10-3-再修修补补">10.3 再修修补补</h3>
<p>除了上面线程池的部分有修改，以下部分也有修改：</p>
<p>Channel 部分：</p>
<ul>
<li>新增标记位和是否使用线程池的函数；</li>
<li>对于处理事件区分了读事件和写事件分别的回调函数；</li>
<li>新增可选择性 epoll ET 模式或 epoll LT 模式；</li>
</ul>
<p>Acceptor 部分：因为接受连接处理时间短、报文数据小，也不会有同时到达的新连接，所以</p>
<ul>
<li>Acceptor 的 socket fd （服务器监听 socket）使用阻塞式：</li>
<li>Acceptor 从 epoll ET 模式改为 epoll LT 模式，建立好连接后处理事件 fd 读写用 ET 模式。</li>
<li>Acceptor 的连接建立不适用线程池，建立好连接后处理事件使用线程池。</li>
</ul>
<p>Connection 部分：</p>
<ul>
<li>新增 <code>send()</code> 函数，独立发送数据。</li>
<li>修改 <code>deleteConnectionCallback()</code> 函数，参数类型改为 <code>int</code>。</li>
</ul>
<p>Epoll 部分：</p>
<ul>
<li>新增 <code>deleteChannel()</code> 函数，用于删除 Channel。</li>
</ul>
<p>Server 部分：</p>
<ul>
<li>新增 <code>deleteConnection()</code> 函数。</li>
</ul>
<p>更多细节上的变化（可能有部分错误处理、变量变化）可比较前一天的文件。</p>
<p><em>服务器中还可能有潜在的bug。</em></p>
<p>最后，添加测试连接的程序 <code>test.cpp</code>，使用命令 <code>make t</code> 编译，使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./test -t 1000 -m 10 -w 100</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code> 表示线程数量，此处为 1000 个线程进行服务器连接；</li>
<li><code>-m</code> 表示每个线程的回显次数，此处为每个线程回显 10 次；</li>
<li><code>-w</code> 表示每个线程的等待时间，可以测试最大连接数，可以不设置。</li>
</ul>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day10">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day10">Gitee</a></p>
<h2 id="十一-改写成主从reactor多线程模式">十一、改写成主从Reactor多线程模式</h2>
<h3 id="11-1-什么是主从reactor多线程模式">11.1 什么是主从Reactor多线程模式</h3>
<p>现在实现的服务器多线程 Reactor 模式，是给每一个 Channel 的任务分配一个线程执行。但目前的线程池对象置于 EventLoop 中，而不是由服务器类 Server 类管理。</p>
<p>主从 Reactor 多线程模式是大多数高性能服务器采用的模式。</p>
<blockquote>
<p>陈硕《Linux多线程服务器编程》书中的 one loop per thread 模式。</p>
</blockquote>
<p>该模式的特点有：</p>
<ul>
<li>服务器一般只有一个 main Reactor，有多个 sub Reactor。</li>
<li>服务器管理一个线程池，每一个 sub Reactor 由一个线程来负责 Connection 上的事件循环，事件执行也在这个线程中完成。</li>
<li>main Reactor 只负责 Acceptor 建立新连接，然后将这个连接分配给一个 sub Reactor。</li>
</ul>
<h3 id="11-2-代码上的变化">11.2 代码上的变化</h3>
<p>根据主从 Reactor 多线程模式的特点，将服务器类重写如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *mainReactor;						<span class="comment">// 只负责接受连接，然后分发给一个subReactor</span></span><br><span class="line">	Acceptor *acceptor;							<span class="comment">// 连接接受器</span></span><br><span class="line">	std::vector&lt;EventLoop *&gt; subReactors;		<span class="comment">// 负责处理事件循环</span></span><br><span class="line">	std::map&lt;<span class="type">int</span>, Connection *&gt; connections;	<span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">	ThreadPool *threadPool;						<span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有一个新连接到来时，采用随机调度策略分配给一个 subReactor：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> random = _socket-&gt;<span class="built_in">getFd</span>() % subReactors.<span class="built_in">size</span>();</span><br><span class="line">Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(subReactors[random], _socket);</span><br></pre></td></tr></table></figure>
<ul>
<li>这种调度算法适用于每个socket上的任务处理时间基本相同，可以让每个线程均匀负载。但事实上，不同的业务传输的数据极有可能不一样，也可能受到网络条件等因素的影响，极有可能会造成一些 subReactor 线程十分繁忙，而另一些 subReactor 线程空空如也。此时需要使用更高级的调度算法，如根据繁忙度分配，或支持动态转移连接到另一个空闲 subReactor 等。</li>
</ul>
<p><em>调度问题是个很有趣的问题，会直接影响服务器的效率和性能。</em></p>
<p>代码上，还将原来在 EventLoop 的线程池去掉，Channel 也不再区分是否使用线程池。</p>
<p>现在，服务器以事件驱动为核心，服务器线程只负责 mainReactor 的新建连接任务，同时维护一个线程池，每一个线程是一个事件循环，新连接建立后分发给一个 subReactor 开始事件监听，有事件发生则在当前线程处理。</p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day11">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day11">Gitee</a></p>
<h2 id="十二-项目工程化">十二、项目工程化</h2>
<p>目前服务器的结构是主从 Reactor 多线程模式，是比较主流的模式。所以大体上的方向已经确定，接下来对细节进行优化，把项目工程化。</p>
<h3 id="12-1-认识cmake">12.1 认识Cmake</h3>
<p>首先，CMake是一个跨平台的编译工具，可以用简单的语句进行编译。</p>
<p>一个项目使用 CMake 维护一个 <code>CMakeLists.txt</code> 配置文件来描述一个项目的编译过程。利用这个文件，就可以搭建起来这个项目。</p>
<p>目前将所有文件都放在一个文件夹，并且没有分类。随着项目越来越复杂、模块越来越多，开发者需要考虑这座屎山的可读性，如将模块拆分到不同文件夹，将头文件统一放在一起等。</p>
<p>对于这样复杂的项目，如果手写复杂的Makefile来编译链接，那么将会相当负责繁琐。我们应当使用 CMake 来管理我们的项目，CMake 的使用非常简单、功能强大，会帮我们自动生成 Makefile 文件，使项目的编译链接更加容易，程序员可以将更多的精力放在写代码上。</p>
<p>这是 <code>CmakeLists.txt</code> 基本结构：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xxx：本 CMakeLists.txt 的 project 名称</span></span><br><span class="line"><span class="comment"># 会自动创建两个变量，PROJECT_SOURCE_DIR 和 PROJECT_NAME</span></span><br><span class="line"><span class="comment"># $&#123;PROJECT_SOURCE_DIR&#125;：本 CMakeLists.txt 所在的文件夹路径</span></span><br><span class="line"><span class="comment"># $&#123;PROJECT_NAME&#125;：本CMakeLists.txt 的 project 名称</span></span><br><span class="line"><span class="keyword">project</span>(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取路径下所有的.cpp/.c/.cc文件，并赋值给变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(路径 变量)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给文件名/路径名或其他字符串起别名，用$&#123;变量&#125;获取变量内容</span></span><br><span class="line"><span class="keyword">set</span>(变量 文件名/路径/...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加编译选项</span></span><br><span class="line"><span class="keyword">add_definitions</span>(编译选项)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印消息</span></span><br><span class="line"><span class="keyword">message</span>(消息)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译子文件夹的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(子文件夹名称)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp/.c/.cc文件生成.a静态库</span></span><br><span class="line"><span class="comment"># 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可</span></span><br><span class="line"><span class="keyword">add_library</span>(库文件名称 STATIC 文件)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp/.c/.cc文件生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名称 文件)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定.h头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定.so/.a库文件路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对add_library或add_executable生成的文件进行链接操作</span></span><br><span class="line"><span class="comment"># 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(库文件名称/可执行文件名称 链接的库文件名称)</span><br></pre></td></tr></table></figure>
<h3 id="12-2-工程化的实际操作">12.2 工程化的实际操作</h3>
<p>首先规范化目录的意义：</p>
<ul>
<li><code>src</code> 目录（即source），用于存放核心的代码；
<ul>
<li><code>include</code> 目录，用于存放源代码中的头文件；</li>
</ul>
</li>
<li><code>test</code> 目录，用于存放测试的代码；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">projiect/</span><br><span class="line">├─src/</span><br><span class="line">│ ├─include/</span><br><span class="line">│ │ ├─*.h</span><br><span class="line">│ ├─*.cpp</span><br><span class="line">├─test/</span><br><span class="line">│ ├─*.cpp</span><br></pre></td></tr></table></figure>
<p>在这一章，我们使用的是一个 CMake 工程，所以 Visual Studio 创建的是 CMake 项目。接下来就是 CMake 的配置工作。（<em>有关 CMake 的安装使用可参考附 2</em>）</p>
<p>构建上述文件目录，将对应的文件分类进去。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-1.jpg" alt="文件结构"></p>
<p>接着，开始编写项目的根 <code>CMakeLists.txt</code> 文件（即根目录下的 <code>CMakeLists.txt</code> ）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)    <span class="comment"># CMake运行的最小版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)   <span class="comment"># 启用编译命令的导出，常与代码分析工具配合使用</span></span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)               <span class="comment"># 构建共享（动态）库</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)              <span class="comment"># 设置C++标准为17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)     <span class="comment"># 要求编译器支持C++17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译器</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;clang&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;clang++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Day12           <span class="comment"># 项目名称</span></span><br><span class="line">        LANGUAGES CXX   <span class="comment"># 项目语言</span></span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为源代码和测试添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># set(TEST_INCLUDE_DIR $&#123;PROJECT_SOURCE_DIR&#125;/test/include)</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SRC_INCLUDE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译和链接选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fPIC -Wall -Wextra -std=c++17 -pthread&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -O0 -ggdb -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS  <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -fPIC&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -fPIC&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_STATIC_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_STATIC_LINKER_FLAGS&#125; -fPIC&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(GCC_COVERAGE_LINK_FLAGS <span class="string">&quot;-fPIC&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示编译器和链接器标志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_FLAGS: $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_FLAGS_DEBUG: $&#123;CMAKE_CXX_FLAGS_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_EXE_LINKER_FLAGS: $&#123;CMAKE_EXE_LINKER_FLAGS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_SHARED_LINKER_FLAGS: $&#123;CMAKE_SHARED_LINKER_FLAGS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次接触 CMake 命令可以参考注释理解。</li>
</ul>
<p>接着，尝试把我们关于服务器的设计打包成一个库，即编写 <code>src/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SRC_INCLUDE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索/src目录中的所有.cpp文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE day12_sources <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置共享库链接选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125;  -fPIC -pthread&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用源文件创建一个名为day12_shared的共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(day12_shared SHARED <span class="variable">$&#123;day12_sources&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>然后，把测试文件的 <code>CMakeLists.txt</code>（即 <code>test/CMakeLists.txt</code>）也编写一下，用于管理测试文件的编译：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置包含目录</span></span><br><span class="line"><span class="keyword">set</span>(SRC_INCLUDE_DIR <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SRC_INCLUDE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置变量TEST_SOURCES，将所有.cpp文件存储在测试目录中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB TEST_SOURCES <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/test/*.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为“build-tests”的自定义目标以仅显示测试</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(build-tests <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_CTEST_COMMAND&#125;</span> --show-only)</span><br><span class="line"><span class="comment"># 创建名为“check-tests”的自定义目标以在详细模式下运行测试</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(check-tests <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_CTEST_COMMAND&#125;</span> --verbose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历TEST_SOURCES中的每个测试源文件</span></span><br><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br><span class="line">    <span class="comment"># 组合为可读的名称，使得每个Cpp都可以make</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(test_filename <span class="variable">$&#123;test_source&#125;</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">&quot;.cpp&quot;</span> <span class="string">&quot;&quot;</span> test_name <span class="variable">$&#123;test_filename&#125;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为测试添加可执行目标，默认情况下将其从所有生成中排除</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;test_name&#125;</span> EXCLUDE_FROM_ALL <span class="variable">$&#123;test_source&#125;</span>)</span><br><span class="line">    <span class="comment"># 添加对生成测试和检查测试的依赖项</span></span><br><span class="line">    <span class="keyword">add_dependencies</span>(build-tests <span class="variable">$&#123;test_name&#125;</span>)</span><br><span class="line">    <span class="keyword">add_dependencies</span>(check-tests <span class="variable">$&#123;test_name&#125;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将“day12_shared”库链接到可执行测试文件</span></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;test_name&#125;</span> day12_shared)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置测试目标的属性，指定输出目录和运行测试的命令</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(<span class="variable">$&#123;test_name&#125;</span></span><br><span class="line">        PROPERTIES</span><br><span class="line">        RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span></span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;test_name&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endforeach</span>(test_source <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>当然，这章在代码上也有些许修改，比如函数参数做了 <code>const &amp;</code>，类也禁止了拷贝和移动操作。</p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day12">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day12">Gitee</a></p>
<p>接着只需要把项目部署到远程 Linux 服务器，使用以下命令编译即可：</p>
<ul>
<li><code>make server</code>：编译服务端代码</li>
<li><code>make SingleClient</code>：编译单个客户端连接代码</li>
<li><code>make MultipleClients</code>：编译多个客户端连接代码</li>
<li><code>make clean</code>：清理生成</li>
</ul>
<p>运行只需要：</p>
<ul>
<li><code>./bin/server</code>：启动服务端</li>
<li><code>./bin/SingleClient</code>：启动单个客户端连接</li>
<li><code>./bin/MultipleClients -t 线程数 -m 回显消息数 -w 延时发送信息</code>：启动多个客户端连接</li>
</ul>
<blockquote>
<p>原作者还进行了代码静态分析和代码格式化，详见地址：<a href="https://github.com/yuesong-feng/30dayMakeCppServer/blob/main/day13-C%2B%2B%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md">Github</a></p>
</blockquote>
<h2 id="十三-业务逻辑自定义化">十三、业务逻辑自定义化</h2>
<h3 id="13-1-业务逻辑思想">13.1 业务逻辑思想</h3>
<p>首先回顾之前的思想，我们目前服务器只有一个功能，就是进行回声（Echo）：把客户端发来的消息再发送回去。而这个功能，或者说业务逻辑，就固定在 <code>Connection</code> 类。</p>
<p>而通过第十二章的设计，我们把网络方面的代码整合为一个链接库。很明显，作为一个库，并不能就这样把业务逻辑固定了，应该支持业务逻辑自定义。</p>
<p>业务逻辑由用户自定义，然后使用网络库进行服务器与客户端间的交互。</p>
<blockquote>
<p>怎样事件触发、读取数据、异常处理等流程应该是网络库提供的基本功能，用户只应当关注怎样处理业务即可，所以业务逻辑的进入点应该是服务器读取完客户端的所有数据之后。这时，客户端传来的请求在 <code>Connection</code> 类的读缓冲区里，只需要根据请求来分发、处理业务即可。</p>
</blockquote>
<p>总体上，服务器端提出这样的设计：</p>
<ul>
<li>具有一个 <code>Server</code> 类和一个事件循环类。</li>
<li>通过回调函数的方式编写业务逻辑，传给 <code>Server</code> 类的实例。
<ul>
<li>只需关心服务器的处理方法，比如一个 Echo 服务器只需要把对方发来的信息发回去。通过设置 <code>onMessage</code> 回调函数来自定义自己的业务逻辑，在服务器完全接收到客户端的数据之后，该函数触发。</li>
<li>可以设置连接时的业务逻辑和整个服务端的业务逻辑。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Server *server = <span class="keyword">new</span> <span class="built_in">Server</span>(loop);</span><br><span class="line"></span><br><span class="line">server-&gt;<span class="built_in">newConnect</span>([] (Connection *conn) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 服务器对有新连接时的操作函数</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">server-&gt;<span class="built_in">onMessage</span>([] (Connection *conn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 服务器对客户端消息的操作函数</span></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>另外，希望客户端的代码也可以通过我们的网络库进行实现：将 <code>Connection</code> 类进行完善，使得其满足服务端（Server → Client）和客户端（Client → Server）的使用：</p>
<ul>
<li>服务端和客户端的传输数据方向是相反的：对于服务端，它从客户端中读取数据，或者写入数据到客户端；对于客户端，它从服务端中读取数据，或者写入数据到服务端。</li>
<li>在发回数据时，应该考虑对方是否已经关闭了链接。所以还需要设计 <code>Connection</code> 的状态。</li>
</ul>
<p>总体上，客户端要使用 Connection 类，提出这样的设计：</p>
<ul>
<li>提供 <code>write()</code> 和 <code>read()</code> 函数。
<ul>
<li><code>write()</code> 函数表示将写缓冲区里的内容发送到该 <code>Connection</code> 的 socket，发送后会清空写缓冲区；</li>
<li><code>read()</code> 函数表示清空读缓冲区，然后将 TCP 缓冲区内的数据读取到读缓冲区。</li>
</ul>
</li>
<li>考虑 <code>Connection</code> 的状态 <code>State</code>。</li>
</ul>
<h3 id="13-2-操刀动代码">13.2 操刀动代码</h3>
<p>根据上面的分析，<code>Server</code> 进行改动如下：</p>
<ol>
<li>将 <code>Server</code> 类进行改写：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Connection *)&gt; onConnectionCallback;	<span class="comment">// 连接的业务逻辑</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Connection *)&gt; onMessageCallback;	<span class="comment">// 消息的业务逻辑</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>(Connection *)&gt; newConnectCallback;	<span class="comment">// 新连接的业务逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置服务器的业务逻辑</span></span><br><span class="line"><span class="comment">	 * @param fn 业务逻辑函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">onConnect</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置接收消息时调用的回调函数</span></span><br><span class="line"><span class="comment">	 * @param fn 回调函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @brief 设置在建立新连接时调用的回调函数。</span></span><br><span class="line"><span class="comment">	 * @param fn 回调函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">newConnect</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们不能急，修改 <code>Server</code> 必须还得对 <code>Connection</code> 类的完善。因为服务器的一些操作是通过连接类完成，改动如下：</p>
<ol>
<li>添加连接状态（此处其实只关注是否连接建立即可）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">	Invalid = <span class="number">1</span>, <span class="comment">// 初始无效状态</span></span><br><span class="line">	Handshaking, <span class="comment">// 握手过程中的状态</span></span><br><span class="line">	Connected,   <span class="comment">// 连接建立</span></span><br><span class="line">	Closed,      <span class="comment">// 连接关闭</span></span><br><span class="line">	Failed,      <span class="comment">// 连接失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>提供读写函数（详细见章末 Gitee 或 Github 链接）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 判断连接状态</span></span><br><span class="line">	<span class="comment">// 清空读缓冲区</span></span><br><span class="line">	<span class="comment">// 读操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 判断连接状态</span></span><br><span class="line">	<span class="comment">// 写操作</span></span><br><span class="line">	<span class="comment">// 清空写缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于服务器程序回发消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string msg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>读操作和写操作区分是否阻塞：对于客户端，使用阻塞读写；对于服务端，使用非阻塞读写。在判断 Socket 是否阻塞时，需要添加个函数（之前没有）。</em></p>
<ol start="3">
<li>
<p>将原来成员属性 <code>int fd</code> 变成 <code>Socket *mSocket</code>。</p>
</li>
<li>
<p>添加上对应的回调函数及其 <code>Set</code> 函数：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(Socket *)&gt; mDeleteConnectionCallback;	<span class="comment">// 删除连接的回调函数</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(Connection *)&gt; mOnConnectCallback;		<span class="comment">// 连接建立时的回调函数</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(Connection *)&gt; mOnMessageCallback;		<span class="comment">// 业务逻辑回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置连接时的业务逻辑回调函数</span></span><br><span class="line"><span class="comment"> * @param callback 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOnConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将回调函数设置为在收到消息时调用</span></span><br><span class="line"><span class="comment"> * @param callback 接收到消息时调用的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOnMessageCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置删除连接时要调用的回调函数</span></span><br><span class="line"><span class="comment"> * @param _callback 删除连接时要调用的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Socket *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>编写业务函数。在构建服务器时指定对客户端消息的响应，然后通过对 <code>Server</code> 类的设置，传递到 <code>Connection</code> 类，最后传递到 <code>Channel</code> 类的 <code>handleEvent()</code> 进行调用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该函数表示业务逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">business</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 大概操作有：</span></span><br><span class="line">	<span class="comment">// - 接受客户端信息</span></span><br><span class="line">	<span class="comment">// - 做出响应，即 mOnMessageCallback()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在也差不多了，但是可以完善（重构）一下 <code>Channel</code> 类，让其意义更明确，更规范一些：</p>
<ol>
<li>规范私有成员变量：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop *mLoop;					<span class="comment">// 指向与之关联的事件循环</span></span><br><span class="line">	Socket *mSocket;					<span class="comment">// 与之关联的Socket</span></span><br><span class="line">	<span class="type">uint32_t</span> mListenEvents&#123; <span class="number">0</span> &#125;;		<span class="comment">// 监听的事件</span></span><br><span class="line">	<span class="type">uint32_t</span> mReadyEvents&#123; <span class="number">0</span> &#125;;			<span class="comment">// 就绪事件</span></span><br><span class="line">	<span class="type">bool</span> exist&#123; <span class="literal">false</span> &#125;;				<span class="comment">// 指示该Channel是否存在有效</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; readCallback;	<span class="comment">// 读回调</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; writeCallback;<span class="comment">// 写回调</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写相关成员函数（函数名修改后记得在对应调用处修改）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开启读操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableRead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开启写操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableWrite</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 使用ET</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useET</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取Socket</span></span><br><span class="line"><span class="function">Socket *<span class="title">getSocket</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取监听事件</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">getListenEvents</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取就绪事件</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">getReadyEvents</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置就绪事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadyEvents</span><span class="params">(<span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"><span class="comment">// 检查有效性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getExist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置有效性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setExist</span><span class="params">(<span class="type">bool</span> _exist)</span></span>;</span><br><span class="line"><span class="comment">// 设置回调函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改 <code>Channel</code> 类的析构函数，其析构为 <code>loop</code> 调用 <code>deleteChannel()</code>（需要添加函数）（实际上还是相关联的 <code>Epoll</code> 封装类去 <code>deleteChannel()</code>）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Channel::~<span class="built_in">Channel</span>()</span><br><span class="line">&#123;</span><br><span class="line">	mLoop-&gt;<span class="built_in">deleteChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::deleteChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ep-&gt;<span class="built_in">deleteChannel</span>(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在修改了 Channel 类后，其相关联的 <code>Epoll</code> 封装类也需要修改：</p>
<ol>
<li>修改 <code>Epoll::deleteChannel(Channel *channel)</code>，需要把当前的 <code>Channel</code> 对象从 epoll 中删除，然后设置有效性为 <code>false</code>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Epoll::deleteChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd = channel-&gt;<span class="built_in">getSocket</span>()-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">	<span class="built_in">errorif</span>(<span class="built_in">epoll_ctl</span>(mEpFd, EPOLL_CTL_DEL, fd, <span class="literal">nullptr</span>) == <span class="number">-1</span>, <span class="string">&quot;epoll delete error&quot;</span>);</span><br><span class="line">	channel-&gt;<span class="built_in">setExist</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>完善 <code>Epoll::updateChannel(Channel *channel)</code>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Epoll::updateChannel</span><span class="params">(Channel *channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 更新事件event，读写事件区分开</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!channel-&gt;<span class="built_in">getExist</span>())	<span class="comment">// 如果不存在，则添加</span></span><br><span class="line">		<span class="comment">// 添加到epoll</span></span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">// 存在，只需要修改</span></span><br><span class="line">		<span class="comment">// 修改epoll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>完善 <code>Epoll::poll(int timeout)</code>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Channel *&gt; <span class="title">Epoll::poll</span><span class="params">(<span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// epoll_wait</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 遍历事件 events</span></span><br><span class="line">		<span class="keyword">if</span>(events &amp; EPOLLIN)</span><br><span class="line">			<span class="comment">// 读</span></span><br><span class="line">		<span class="keyword">if</span> (events &amp; EPOLLOUT)</span><br><span class="line">			<span class="comment">// 写</span></span><br><span class="line">		<span class="keyword">if</span>(events &amp; EPOLLET)</span><br><span class="line">			<span class="comment">// ET 模式</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回事件（Channel数组）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>最后检查各个文件无报错后，根据需要修改 CMakeLists.txt 文件。</em></p>
<p><em>之后，如果想创建不一样功能的服务器，可以通用我们这样的一个网络库。</em></p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day13">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day13">Gitee</a></p>
<h2 id="十四-再次重构-告一段落">十四、再次重构，告一段落</h2>
<h3 id="14-1-重构思想">14.1 重构思想</h3>
<ol>
<li>
<p>使用智能指针进行内存管理。在之前的开发中，使用的都是原始的指针，但是原始的指针对内存管理而言是困难的，极易产生内存泄漏、悬垂引用、野指针等问题。从 C++11 标准后，可以使用智能指针来管理内存，让程序员无需过多考虑内存资源的使用。</p>
<ul>
<li><code>std::unique_ptr</code></li>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>
</li>
<li>
<p>避免资源的复制操作，尽量使用移动语义来进行所有权的转移，这对提升程序的性能有十分显著的帮助。</p>
</li>
<li>
<p>对错误、异常的处理。在项目上线后，我们不能因为某些错误就直接让程序崩溃或者终止。而且，绝大部分错误都是可恢复的：</p>
<ul>
<li>如创建 socket 失败可能是文件描述符超过操作系统限制，稍后再次尝试即可。</li>
<li>监听 socket 失败可能是端口被占用，切换端口或提示并等待用户处理即可。</li>
<li>打开文件失败可能是文件不存在或没有权限，此时只需创建文件或赋予权限即可。</li>
<li>所以在底层的编码上，对于部分错误需要进行可恢复处理，避免一个模块或资源发生的小错误影响整个服务器的运行。</li>
</ul>
</li>
</ol>
<h3 id="14-2-加入-clang-fromat">14.2 加入.clang-fromat</h3>
<p>Clang 本身是一个 C++ 的编译器。而 Clang-Format 是其中的一个格式化工具，可用于格式化（排版）多种不同语言的代码。在 Linux 中安装一下 <code>clang-format</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y clang-format</span><br></pre></td></tr></table></figure>
<p>如果使用 VSCode 进行编程的话，需要安装插件 Clang-Format，格式化快捷键：<code>shift + alt + f</code>。</p>
<p>详见：<a href="https://www.fingsinz.space/2024/22/">使用clang-format给你代码格式化</a></p>
<p><em>纯靠手动控制格式太麻烦了，还是使用工具吧</em></p>
<h3 id="14-3-设计宏定义-common-h">14.3 设计宏定义（Common.h）</h3>
<p>显式将拷贝和移动函数删除，避免拷贝和移动操作：</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY(className) \</span></span><br><span class="line"><span class="meta">	className(const className &amp;) = delete; \</span></span><br><span class="line"><span class="meta">	className &amp;operator = (const className &amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_MOVE(className) \</span></span><br><span class="line"><span class="meta">	className(className &amp;&amp;) = delete; \</span></span><br><span class="line"><span class="meta">	className &amp;operator = (className &amp;&amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_MOVE(className) \</span></span><br><span class="line"><span class="meta">	DISALLOW_COPY(className);             \</span></span><br><span class="line"><span class="meta">	DISALLOW_MOVE(className);</span></span><br></pre></td></tr></table></figure>
<p>新增 <code>FLAG</code> 标记，统一标记函数的返回：</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FLAG</span> &#123;</span></span><br><span class="line">	FL_UNDIFINED,</span><br><span class="line">	FL_SUCCESS,</span><br><span class="line">	FL_SOCKET_ERROR,</span><br><span class="line">	FL_EPOLL_ERROR,</span><br><span class="line">	FL_CONNECTION_ERROR,</span><br><span class="line">	FL_ACCEPTOR_ERROR,</span><br><span class="line">	FL_UNIMPLEMENTED</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>记得修改包含的头文件。</em></p>
<h3 id="14-4-重构socket类">14.4 重构Socket类</h3>
<p><code>Socket</code> 类主要是对 socket 操作进行了封装，并主要应用在 <code>Acceptor</code> 类中和 <code>Connection</code> 类中。对 <code>Socket</code> 类的函数进行重构，同时删去 InetAddress 类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Socket);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Socket</span>();</span><br><span class="line">    ~<span class="built_in">Socket</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getAddr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketCreate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketBind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketListen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketAccept</span><span class="params">(<span class="type">int</span> &amp;clientFd)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">socketConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">setNonBlocking</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNonBlocking</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">recvBufSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mFd&#123;<span class="number">-1</span>&#125;; <span class="comment">// socket 文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Socket</code>的创建、绑定、监听、接受等操作进行错误、异常的处理，在函数中大概如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FLAG <span class="title">xxx</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断言 fd 是否合法</span></span><br><span class="line">	<span class="comment">// 进行创建、绑定、监听、接受等操作</span></span><br><span class="line">	<span class="comment">// 判断上述操作是否出现异常</span></span><br><span class="line">	<span class="comment">// 出现异常则输出并返回错误标记，无异常则返回成功标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Socket 的连接操作，是将 Socket 连接到某个 IP 地址，在函数中如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FLAG <span class="title">Socket::socketConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">uint16_t</span> port)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构建地址结构体</span></span><br><span class="line">	<span class="comment">// 连接</span></span><br><span class="line">	<span class="comment">// 判断上述操作是否出现异常</span></span><br><span class="line">	<span class="comment">// 出现异常则输出并返回错误标记，无异常则返回成功标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有其他的 Get、Set 函数可详见代码。</p>
<h3 id="14-4-小改channel类和epoll类">14.4 小改Channel类和Epoll类</h3>
<p>修改完 <code>Socket</code> 类后，比较底层的还有 <code>Channel</code> 类。<code>Channel</code> 类是网络库的核心组建之一，其对 <code>socket</code> 进行了更深度的封装，保存了需要对 <code>socket</code> 监听的事件和当前 <code>socket</code> 已经准备好的事件，并进行处理。此外，为了更新和获取在 <code>epoll</code> 中的状态，需要使用<code>EventLoop</code>进行管理。</p>
<p>对于 Channel 类的改动并不多，类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Channel);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(EventLoop *loop, <span class="type">int</span> fd)</span></span>;</span><br><span class="line">    ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableRead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useET</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getListenEvents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getReadyEvents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadyEvents</span><span class="params">(<span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getExist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setExist</span><span class="params">(<span class="type">bool</span> _exist = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *mLoop;                    <span class="comment">// 指向与之关联的事件循环</span></span><br><span class="line">    <span class="type">int</span> mFd;                             <span class="comment">// 与之关联的Socket fd</span></span><br><span class="line">    <span class="type">uint32_t</span> mListenEvents&#123;<span class="number">0</span>&#125;;           <span class="comment">// 监听的事件</span></span><br><span class="line">    <span class="type">uint32_t</span> mReadyEvents&#123;<span class="number">0</span>&#125;;            <span class="comment">// 就绪事件</span></span><br><span class="line">    <span class="type">bool</span> exist&#123;<span class="literal">false</span>&#125;;                   <span class="comment">// 指示该Channel是否存在有效</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; readCallback;  <span class="comment">// 读回调</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; writeCallback; <span class="comment">// 写回调</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大部分代码没什么特别的，可以见代码。但是需要注意的是，设置回调函数时，使用 <code>std::move()</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setxxxCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; <span class="type">const</span> &amp;callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	xxxCallback = std::<span class="built_in">move</span>(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Epoll</code> 类主要是进行 IO 多路复用，保证高并发。在 <code>Epoll</code> 类主要是对 epoll 中 channel 的监听与处理。声明改为如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Epoll</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 禁用拷贝和移动</span></span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Epoll);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Epoll</span>();</span><br><span class="line">    ~<span class="built_in">Epoll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">deleteChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Channel *&gt; <span class="title">poll</span><span class="params">(<span class="type">int</span> timeout = <span class="number">-1</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mEpFd&#123;<span class="number">-1</span>&#125;;                        <span class="comment">// epoll文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *mEvents&#123;<span class="literal">nullptr</span>&#125;; <span class="comment">// epoll事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数方面也是小改。</p>
<h3 id="14-5-小改eventloop类">14.5 小改EventLoop类</h3>
<p><code>EventLoop</code> 类用于对事件的轮询和处理。每一个 <code>EventLoop</code> 不断地调用 <code>epoll_wait</code> 来获取激活的事件，并处理。原本的 <code>EventLoop</code> 类中有一个普通的指针 <code>Epoll*</code>，现改为 <code>std::unique_ptr</code>。顺便再把函数声明为 <code>const</code>，使其更安全。</p>
<p>EventLoop 类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(EventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Epoll&gt; ep; <span class="comment">// 指向Epoll类实例的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于使用了智能指针，所以其构造函数和析构函数也简化了不少。</p>
<h3 id="14-6-小改acceptor类">14.6 小改Acceptor类</h3>
<p><code>Acceptor</code> 主要用于服务器接受连接，并在接受连接之后进行相应的处理。这个类需要独属于自己的 <code>Channel</code>，因此采用了智能指针管理。</p>
<p>Acceptor 类的重构类似。</p>
<ul>
<li>将一些指针变成智能指针；</li>
<li>使用之前定义的 <code>FLAG</code> 标记。</li>
</ul>
<p>Acceptor 类声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Acceptor);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Acceptor</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line">    ~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">acceptConnection</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Socket&gt; mSocket;   <span class="comment">// 用于处理套接字操作的套接字指针</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; mChannel; <span class="comment">// 用于接受连接的 Channel 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个新建连接的回调函数</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; mNewConnectionCallback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-7-小改connection类">14.7 小改Connection类</h3>
<p>对于每个 TCP 连接，都可以使用一个类进行管理，在这个类中，将注意力转移到对客户端 socket 的读写上，除此之外，他还需要绑定几个回调函数，例如当接收到信息时，或者需要关闭时进行的操作。</p>
<p>对于 <code>Connection</code> 类中的指针改用智能指针，同时按需求简化了部分函数，声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        Invalid = <span class="number">0</span>, <span class="comment">// 初始无效状态</span></span><br><span class="line">        Handshaking, <span class="comment">// 握手过程中的状态</span></span><br><span class="line">        Connected,   <span class="comment">// 连接建立</span></span><br><span class="line">        Closed,      <span class="comment">// 连接关闭</span></span><br><span class="line">        Failed,      <span class="comment">// 连接失败</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Connection</span><span class="params">(EventLoop *loop, <span class="type">int</span> fd)</span></span>;</span><br><span class="line">    ~<span class="built_in">Connection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Connection);</span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">send</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setOnMessageCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeleteConnectionCallback</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; <span class="type">const</span> &amp;callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">business</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">State <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSentBuffer</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str)</span></span>;</span><br><span class="line">    <span class="function">Buffer *<span class="title">getReadBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Buffer *<span class="title">getSendBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Socket *<span class="title">getSocket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// EventLoop *mLoop;							// EventLoop指针</span></span><br><span class="line">    std::unique_ptr&lt;Socket&gt; mSocket;              <span class="comment">// Socket指针</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; mChannel&#123;<span class="literal">nullptr</span>&#125;;   <span class="comment">// Channel指针</span></span><br><span class="line">    std::unique_ptr&lt;Buffer&gt; mReadBuffer&#123;<span class="literal">nullptr</span>&#125;; <span class="comment">// 读缓冲区</span></span><br><span class="line">    std::unique_ptr&lt;Buffer&gt; mSendBuffer&#123;<span class="literal">nullptr</span>&#125;; <span class="comment">// 写缓冲区</span></span><br><span class="line"></span><br><span class="line">    State mState&#123;Invalid&#125;;                                <span class="comment">// 连接状态</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; mDeleteConnectionCallback;   <span class="comment">// 删除连接的回调函数</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Connection *)&gt; mOnMessageCallback; <span class="comment">// 业务逻辑回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">FLAG <span class="title">readNonBlocking</span><span class="params">()</span></span>;  <span class="comment">// 非阻塞读</span></span><br><span class="line">    <span class="function">FLAG <span class="title">writeNonBlocking</span><span class="params">()</span></span>; <span class="comment">// 非阻塞写</span></span><br><span class="line">    <span class="function">FLAG <span class="title">readBlocking</span><span class="params">()</span></span>;     <span class="comment">// 阻塞读</span></span><br><span class="line">    <span class="function">FLAG <span class="title">writeBlocking</span><span class="params">()</span></span>;    <span class="comment">// 阻塞写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="14-8-重头戏server类">14.8 重头戏Server类</h3>
<p><code>Server</code> 类是对整个服务器的管理，他通过创建 <code>acceptor</code> 来接收连接。并管理 <code>Connection</code> 的添加。</p>
<p>对 Server 类的众多指针都改为智能指针，声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>();</span><br><span class="line">    ~<span class="built_in">Server</span>();</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(Server);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnect</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(std::function&lt;<span class="type">void</span>(Connection *)&gt; fn)</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">newConnection</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">    <span class="function">FLAG <span class="title">deleteConnection</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;EventLoop&gt; mainReactor;              <span class="comment">// 只负责接受连接，然后分发给一个subReactor</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EventLoop&gt;&gt; subReactors; <span class="comment">// 处理事件循环</span></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor;                  <span class="comment">// 连接接受器</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Connection&gt;&gt; connections; <span class="comment">// 存储连接及其相应的文件描述符</span></span><br><span class="line">    std::unique_ptr&lt;ThreadPool&gt; threadPool;                           <span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Connection *)&gt; onConnectionCallback; <span class="comment">// 连接的业务逻辑</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Connection *)&gt; onMessageCallback;    <span class="comment">// 接收消息后的业务逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改完这么多类后，记得查看代码修改一下测试的 <code>server.cpp</code>、<code>SingleClient.cpp</code>、<code>MultipleClients.cpp</code> 等文件，然后编译即可。</p>
<p>该节代码：<a href="https://github.com/Fingsinz/MakeServerInLinux/tree/master/Day14">Github</a>，<a href="https://gitee.com/fingsinz/make-server-in-linux/tree/master/Day14">Gitee</a></p>
<hr>
<h2 id="附录">附录</h2>
<h3 id="附-1-代码运行环境">附 1 - 代码运行环境</h3>
<p>前十四章：</p>
<ul>
<li>代码编写：Windows 下 Visual Studio 2022</li>
<li>代码编译及执行：阿里云 ECS，Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-169-generic x86_64)</li>
</ul>
<p>在 Visual Studio 2022 中编写代码，接着连接远程服务器，将代码部署到服务器上。</p>
<ul>
<li>前期在服务器使用 <code>make</code> 编译代码。<a href="https://developer.aliyun.com/article/798104">Ubuntu之make：make命令行工具的简介、安装、使用方法之详细攻略</a>
<ul>
<li>编译命令见每个 Day 中的 Makefile 文件。
<ul>
<li><code>make</code> 命令为：<code>make build</code> 或 <code>make</code>。</li>
<li>清理编译结果命令为：<code>make clean</code>。</li>
</ul>
</li>
<li>若没有 <code>make</code>，可以手动输入（Makefile中的） <code>g++</code> 命令编译。</li>
</ul>
</li>
<li>后期考虑使用 CMake 将项目工程化，详情看附录 2。</li>
</ul>
<p>剩下章节：</p>
<ul>
<li>代码编写：Windows 下 Visual Studio Code</li>
<li>代码编译及执行：WSL2 - Ubuntu 18.04</li>
</ul>
<p>用 Visual Studio Code 远程连接 WSL 进行编写代码，使用 cmake 进行项目管理。</p>
<h3 id="附-2-cmake的安装和使用">附 2 - CMake的安装和使用</h3>
<p>此处的环境是：<strong>Visual Studio 2022 远程连接 Ubuntu 20.04.6 LTS</strong></p>
<ul>
<li><em>当然 Windows 也有 CMake，此处主要是在 Linux 下的使用。</em></li>
</ul>
<h4 id="附-2-1-检查远程的cmake环境和编译环境">附 2.1 检查远程的CMake环境和编译环境</h4>
<p><em>可能需要先 <code>apt-get update</code> 更新一下 apt。</em></p>
<ol>
<li>安装 CMake 工具</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install cmake</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可选择安装使用 clang 编译器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install clang</span><br></pre></td></tr></table></figure>
<h4 id="附-2-2-visual-studio-2022中使用cmake进行远程linux服务器开发">附 2.2 Visual Studio 2022中使用CMake进行远程Linux服务器开发</h4>
<ol>
<li>创建选择 CMake 项目，我此处构建演示项目 <code>CMakeTestProject</code>。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-2.jpg" alt="选择CMake项目"></p>
<ol start="2">
<li>选择远程的 Linux 计算机，管理配置，新建一个配置。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-3.jpg" alt="管理配置"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-4.jpg" alt="新建配置"></p>
<ol start="3">
<li>编辑配置，具体看下图，主要修改部分已经框选。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-5.jpg" alt="编辑配置"></p>
<ol start="4">
<li>
<p>正常编写代码，此处我用 Day12（第十二章）的代码作为演示。编写代码后，可以点进去根目录的 <code>CMakeLists.txt</code> 文件，保存一下（<code>ctrl + s</code>），就会自动复制到远程。</p>
</li>
<li>
<p>进行项目生成和编译，项目生成有两种方式：</p>
</li>
</ol>
<ul>
<li>可以选择右键项目名，选择以 CMake 视图查看。再进行生成或清理，最后使用编译命令进行编译。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-6.jpg" alt="选择CMake视图"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-7.jpg" alt="生成和清理"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-8.jpg" alt="生成成功1"></p>
<ul>
<li>可以在 Linux 的终端上执行以下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake ../src/ &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-9.jpg" alt="生成成功2"></p>
<p><em>可以在 CMakeLists.txt 中的项目信息之前设置编译器为Clang。</em></p>
<ol start="6">
<li>生成成功后就可以在 <code>CMakeLists.txt</code> 中指定的输出文件夹中找到可执行文件或其他。</li>
</ol>
<h4 id="附-2-2-visual-studio-2022中使用cmake进行wsl开发">附 2.2 Visual Studio 2022中使用CMake进行WSL开发</h4>
<p><em>有的人可能没有Linux服务器，但是WSL可以有的。如何安装WSL可以查看<a href="https://www.fingsinz.space/2024/20/">这里</a></em></p>
<p>基本步骤同上，但在新建配置和编辑时，需要做一些修改：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-10.jpg" alt="新建关于WSL的配置"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/LinuxServer_Day12-11.jpg" alt="编辑关于WSL的配置"></p>
<h4 id="附-2-3-cmake相关资料">附 2.3 CMake相关资料</h4>
<ul>
<li><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/</a></li>
</ul>
<h3 id="附-3-可能出现的问题">附 3 - 可能出现的问题</h3>
<ul>
<li>
<p>在 Ubuntu 中安装 <code>make</code> 时，出现 <font color="red">“dpkg: error processing package ***”</font> 的问题，可以参考 <a href="https://blog.csdn.net/dou3516/article/details/105120221">CSDN</a>。</p>
</li>
<li>
<p>在线程池部分中，直接使用 <code>g++</code> 命令会出现 <font color="red">“对‘pthread_create’未定义的引用”</font> 的问题，需要加上 <code>-lpthread</code> 参数，详见 <a href="https://blog.csdn.net/Dontla/article/details/122637407">CSDN</a> 或 <code>Makefile</code> 中的做法。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门学习教程</title>
    <url>/2023/c-language-learning/</url>
    <content><![CDATA[<p>个人整理面向入门基础级别的C语言学习教程。</p>
<p>关键词：C语言</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h2 id="ⅰ-基础知识介绍">Ⅰ —— 基础知识介绍</h2>
<p>此教程会用一些注记符号，表示某种格式。</p>
<h3 id="1-1-c语言背景知识">1.1 C语言背景知识</h3>
<p>C语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。</p>
<p>C语言标准有C89、C99、C11、C17、C2x ……等，后面的数字是标准发布的年份。如果想了解每个标准有什么差异，自行必应搜索。本教程的完整代码在GNU C17下成功运行。</p>
<h3 id="1-2-用什么写c语言">1.2 用什么写C语言</h3>
<p>编写C语言，就连基本的文本编辑器——记事本也可以完成。但我们并不会只想着使用那么奇奇怪怪的记事本，去编写十来行代码甚至上千行代码，至少是真的不习惯。</p>
<p>接触C语言，会有很多人推荐你用那个什么什么写啊，一点一动就行；但如果在大学学习，教师可能会让你使用Visual C++ 6.0（下简称VC 6.0）去写。</p>
<p>感受过VC 6.0软件界面的人都知道，很不舒服，甚至降低自己的效率。VC 6.0甚至比我的年龄还大，算是老古董了。但是目前教材用的是VC 6.0，实验室配置的是VC 6.0，乃至你的考试，甚至计算机二级，都是VC 6.0，所以用VC 6.0而不是别的软件，更加容易应付教学。</p>
<p>所以在此，我推荐使用的C语言编辑器是：</p>
<ul>
<li>
<p>基础小白或图方便可使用<a href="https://sourceforge.net/projects/dev-cpp-2020/">Dev-C++</a></p>
</li>
<li>
<p>非基础小白可使用Visual Studio或Visual Studio Code</p>
</li>
</ul>
<p>此教程的代码使用Dev-C++，均在Dev-C++下成功运行。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_devcpp.jpg" alt="Dev-C++界面"></p>
<p>按 <code>Ctrl</code> + <code>N</code> 可以新建文件，或者点击左上角文件新建文件。</p>
<p>在 工具 → 编译选项 → 代码生成/优化 → 代码生成 处可以找到语言标准。</p>
<h3 id="1-3-从代码到执行程序">1.3 从代码到执行程序</h3>
<p>在上一节我提到了用什么写C语言，这是关于编辑器（Editor）的事情。字面意思，它只负责编辑，也就是敲上一个个的字母数字，就像写英语日记、写英语文章一样。</p>
<p>事实上，你在编辑器上写的内容，还不能完全算是程序，这个内容称为 <strong>源代码（Source Code）</strong> 。存放源代码的文件称为 <strong>源文件</strong> 。</p>
<p>我们还需要经过一些步骤，使得源代码变成 <strong>可执行文件（Executable file）</strong> ，也就是你计算机里面那些.exe文件。把这些步骤称之为 <strong>编译（Build）</strong> 和 <strong>链接（Link）</strong> 。</p>
<ul>
<li>
<p>编译：编译需要 <strong>编译器</strong> 完成。编译器把一个源代码翻译成可执行文件的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。常见的编译器有：MinGW、MSVC等。</p>
</li>
<li>
<p>链接：链接需要 <strong>链接器</strong> 完成。链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。链接的意义在于我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
</li>
</ul>
<p>这些只是一些知识补充，想详细了解可参阅编译原理。另外，如果你选择了Dev-C++或者Visual Studio这样的集成软件，编译器和链接器的配置会相对简单。</p>
<h3 id="1-4-认识最基础的c语言代码">1.4 认识最基础的C语言代码</h3>
<p>学习C语言的开始，从输出一个“Hello World！”开始，这似乎是所有编程语言一开始都经历的事情。</p>
<p>我在此直接给出完整代码，心急的可以复制到Dev-C++运行试试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello World.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来逐行认识基本的C语言代码结构。</p>
<ul>
<li>
<p><code>//</code> 表示当前整行被编译器忽略，又称注释，供程序员理解语句。</p>
</li>
<li>
<p><code>#include&lt;stdio.h&gt;</code>中的 <code>#</code>（井号）表示预处理命令，即在程序编译前进行提前处理的部分。若是头文件，可用 <code>&lt;&gt;</code>（单书名号）括起来，也可用 <code>&quot; &quot;</code>（引号）包含起来。 <strong>其中由 <code>&lt;&gt;</code> 括起来的头文件表示在系统头文件的文件夹中查找，由 <code>&quot;&quot;</code> 括起来的头文件表示在源文件当前文件夹查找。</strong></p>
</li>
<li>
<p><code>int main()</code> 是一个函数的开头，再加以 <code>&#123;&#125;</code>（大括号）包含主函数内容。此处是主函数，主函数是一个程序最重要的函数，程序从此开始编译。</p>
</li>
<li>
<p><code>printf(&quot;Hello World!&quot;);</code> 为程序工作语句，其作用是输出“Hello World！”。</p>
</li>
<li>
<p>C语言中以 <code>;</code>（分号）作为一条语句的结束标志。</p>
</li>
<li>
<p><code>return 0;</code>是函数的结构之一，在函数一节介绍。</p>
</li>
</ul>
<p>一般情况下， <strong>一个C语言程序包含预处理器指令、函数、变量、语句（表达式和注释）等</strong> 。函数是一个进行某种功能操作的模块，目前认识到的是主函数，还可以自定义函数。变量即程序运行时其值可以改变的量，变量的功能就是存储数据。</p>
<p>C语言代码按 <strong>顺序结构</strong> ，由上到下顺序执行代码。</p>
<p>还有一件比较重要的事情，养成良好的代码风格，即令人舒适的缩进、空格位置等；千万不要所有代码都挤到一块或者全都左对齐。</p>
<h3 id="1-5-头文件">1.5 头文件</h3>
<p>在上一节提到了预处理命令包含的头文件，那么头文件是什么？</p>
<p>头文件是扩展名为.h的文件，包含了C语言一些函数甚至几乎所有函数的提前 <strong>声明（Statement）</strong> 和 <strong>定义（Definition）</strong> ，没有这些声明和定义，编译器不会认识这些函数，故而不能运行。</p>
<p>有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用预处理指令 #include 来引用它，引用头文件相当于复制头文件的内容。如stdio.h头文件，它包含了<code>printf()</code>这一函数。</p>
<h3 id="1-6-关键字">1.6 关键字</h3>
<p>C语言的关键字是C语言的基本构成要素，共有32个，根据关键字的作用，可分其为数据类型关键字、控制语句关键字、存储类型关键字和其它关键字四类。</p>
<p><strong>1 数据类型关键字（12个）：</strong><br>
(1)  <code>char</code> ：声明字符型变量或函数<br>
(2) <code>double</code> ：声明双精度变量或函数<br>
(3) <code>enum</code> ：声明枚举类型<br>
(4) <code>float</code> ：声明浮点型变量或函数<br>
(5) <code>int</code> ：声明整型变量或函数<br>
(6) <code>long</code> ：声明长整型变量或函数<br>
(7) <code>short</code> ：声明短整型变量或函数<br>
(8) <code>signed</code> ：声明有符号类型变量或函数<br>
(9) <code>struct</code> ：声明结构体变量或函数<br>
(10) <code>union</code> ：声明共用体（联合）数据类型<br>
(11) <code>unsigned</code> ：声明无符号类型变量或函数<br>
(12) <code>void</code> ：声明函数无返回值或无参数，声明无类型指针</p>
<p><strong>2 控制语句关键字（12个）：</strong><br>
A循环语句<br>
(1) <code>for</code> ：一种循环语句(可意会不可言传）<br>
(2) <code>do</code> ：循环语句的循环体<br>
(3) <code>while</code> ：循环语句的循环条件<br>
(4) <code>break</code> ：跳出当前循环<br>
(5) <code>continue</code> ：结束当前循环，开始下一轮循环<br>
B条件语句<br>
(1) <code>if</code> : 条件语句<br>
(2) <code>else</code> ：条件语句否定分支（与 if 连用）<br>
(3) <code>goto</code> ：无条件跳转语句<br>
C开关语句<br>
(1) <code>switch</code> :用于开关语句<br>
(2) <code>case</code>：开关语句分支<br>
(3) <code>default</code>：开关语句中的“其他”分支<br>
D返回语句<br>
<code>return</code> ：函数返回语句（可以带参数，也可不带参数）</p>
<p><strong>3 存储类型关键字（4个）</strong><br>
(1) <code>auto</code> ：声明自动变量 一般不使用<br>
(2) <code>extern</code> ：声明变量是在其他文件正声明（也可以看做是引用变量）<br>
(3) <code>register</code>：声明积存器变量<br>
(4) <code>static</code> ：声明静态变量</p>
<p><strong>4 其它关键字（4个）：</strong><br>
(1) <code>const</code> ：声明只读变量<br>
(2) <code>sizeof</code> ：计算数据类型长度<br>
(3) <code>typedef</code> ：用以给数据类型取别名<br>
(4) <code>volatile</code> ：说明变量在程序执行中可被隐含地改变</p>
<p>你可能不明白这些关键字什么意思怎么用，但你只需要知道这些关键字不能随便用，它们被C语言内部定义占用了。</p>
<p></br></br></br></p>
<h2 id="ⅱ-函数">Ⅱ —— 函数</h2>
<p>函数是用来完成特定任务的一组语句。在C语言中，每个程序至少有一个主函数 <code>main()</code> 。此外，C语言还提供了许多内置函数，可以在相应的头文件中找到。有时候，我们也可以称函数为方法。</p>
<p>当我们编写代码时，我们可以将其分割成不同的函数。划分代码到不同的函数中是我们自己决定的。但是从逻辑上来说，我们通常会根据每个函数执行特定的任务来进行划分。例如，如果我们正在编写一个计算器程序，我们可以使用四个函数分别处理加法、减法、乘法和除法。这样的划分可以让代码更有组织性，并且更易于理解和维护。</p>
<h3 id="2-1-函数的基本结构">2.1 函数的基本结构</h3>
<p>函数的结构应当如下，包括 <strong>函数返回类型return_type</strong> ， <strong>函数名字function_name</strong> 、 <strong>参数arguments</strong> 和 <strong>函数主体Body</strong> 等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">(arguments)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>函数返回类型</strong>：一个函数可以返回一个值，return_type是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <code>void</code> 。</p>
</li>
<li>
<p><strong>函数名字</strong>：这是函数的实际名称。函数名和参数列表一起构成了 <strong>函数签名（Function signature）</strong> 。</p>
</li>
<li>
<p><strong>参数列表</strong>：当函数被调用时，可以向参数传递值。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</p>
</li>
<li>
<p><strong>函数主体</strong>：函数主体包含一组定义函数执行任务的语句。若有返回值的函数使用 <code>return</code> 返回。函数主体中遇到返回表示结束函数。</p>
</li>
</ul>
<h3 id="2-2-函数声明和定义">2.2 函数声明和定义</h3>
<p>函数的产生有两个概念： <strong>函数声明（Function Statement）</strong> 和 <strong>函数定义（Function Definition）</strong> 。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 <strong>使用函数之前必须先声明（也可以直接声明并定义）。</strong><br>
开玩笑地说，声明就是你骗机器有这么一个函数，但是当机器要找这个函数用的时候，你最好是有个定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明并定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C语言从上到下运行，如果是先写了 main 函数，再写 sub 函数，而在 main 函数调用了 sub 函数的情况下，需要有一个声明在 main 函数的前面，告知编译器有这个函数，否则按从上到下的顺序，此时并未出现 sub 函数；</p>
<p>如果是先写了 sub 函数，再写 main 函数，而在 main 函数调用了 sub 函数的情况下，在 main 函数之前的 sub 函数就相当于函数声明并定义，main 函数调用 sub 函数也自然成功。</p>
<p>函数声明中的参数列表可以不具体写变量名，但函数定义中的参数列表必须写变量名。如上述代码的声明可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-调用函数">2.3 调用函数</h3>
<p>当我们写完我们的函数，使用时直接称呼 <strong>函数签名</strong>（函数名字+参数列表）即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并定义函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">add(c, d);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-函数参数传递">2.4 函数参数传递</h3>
<p>如果函数要使用参数，接受参数值的变量称为函数的 <strong>形式参数</strong> 。如上面 <code>int add(int a, int b)</code> 中的 <code>a</code> 和 <code>b</code>。</p>
<p>如果调用函数时，传递进入的参数称为 <strong>实际参数</strong>。如上面 <code>add(1, 2)</code>中的 <code>c</code> 和 <code>d</code> 。</p>
<p>参数传递有两种方式： <strong>值传递</strong> 和 <strong>地址传递</strong> 。</p>
<ul>
<li>
<p><strong>值传递</strong>：把参数的数值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</p>
</li>
<li>
<p><strong>地址（引用）传递</strong>：把参数的地址复制给函数的形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 <em>对于地址传递，经过指针的学习可能更清晰。</em></p>
</li>
</ul>
<p></br></br></br></p>
<h2 id="ⅲ-数据-运算符及语句">Ⅲ —— 数据、运算符及语句</h2>
<h3 id="3-1-数据的表现形式">3.1 数据的表现形式</h3>
<p>数据以常量、变量、常变量或标识符的形式出现。</p>
<p>变量、常变量的出现包括 <strong>声明</strong> 、 <strong>定义</strong> 、 <strong>初始化</strong> 三个步骤。 <strong>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。</strong></p>
<p>变量定义：用于为变量分配存储空间，还可为变量指定初始值，程序中，变量有且仅有一个定义。</p>
<p>变量声明：用于向程序表明变量的类型和名字。</p>
<p>定义也是声明：当定义变量时我们声明了它的类型和名字。</p>
<p><strong>所有变量使用之前需要有声明或定义。</strong></p>
<ul>
<li>
<p><strong>常量</strong> ，其值不能改变的量。其分为 <strong>整型常量</strong> （即整数，如1，2，1000，666）、 <strong>实型常量</strong> 、 <strong>字符常量</strong> 。</p>
</li>
<li>
<p><strong>实型常量</strong> ，包括十进制小数形式（由数字和小数点组成）和指数形式，指数形式以E或e代表以10为底的指数，如1e6，注意：e或E之前必须有数字，且e或E之后必须为整数；</p>
</li>
<li>
<p><strong>字符常量之字符常量</strong> ，由 <code>‘’</code> （单引号）包括的一个字符，如 <code>‘a’</code> 、 <code>‘A’</code> 等。普通字符，详见ASCII字符集；转义字符，特殊形式的字符，以 <code>\</code> 开头。  <em>引号在此充当界限符，字符常量和字符串常量不包括引号。</em></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">字符值</th>
<th style="text-align:center">输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\'</code></td>
<td style="text-align:center">一个单引号</td>
<td style="text-align:center"><code>'</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\&quot;</code></td>
<td style="text-align:center">一个双引号</td>
<td style="text-align:center"><code>&quot;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\?</code></td>
<td style="text-align:center">一个问号</td>
<td style="text-align:center"><code>?</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">一个反斜杠</td>
<td style="text-align:center"><code>\</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\a</code></td>
<td style="text-align:center">警告alert</td>
<td style="text-align:center">产生声音或视觉信号</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">退格backspace</td>
<td style="text-align:center">将光标后退一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页form feed</td>
<td style="text-align:center">将光标移到下一页</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行</td>
<td style="text-align:center">将光标移到下一行</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车carriage return</td>
<td style="text-align:center">将光标移到本行开头</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">水平制表符</td>
<td style="text-align:center">将光标移到下一个Tab位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表符</td>
<td style="text-align:center">将光标移到下一个垂直制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\o</code></td>
<td style="text-align:center">与该八进制码对应的ASCII字符</td>
<td style="text-align:center">与该八进制码对应的ASCII字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\xh[h…]</code></td>
<td style="text-align:center">与该十六进制码对应的ASCII字符</td>
<td style="text-align:center">与该十六进制码对应的ASCII字符</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>字符常量之字符串常量</strong> ，由 <code>“ ”</code> （双引号）包括的一个字符串，可以超过一个字符，如 <code>“boy”</code> 。</p>
</li>
<li>
<p><strong>字符常量之符号常量</strong> ，用 <code>#define</code> 指令指定一个符号名称代表一个常量。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Pi 3.14 <span class="comment">//符号常量，之后所有语句中所有Pi用3.14替换</span></span></span><br></pre></td></tr></table></figure>
<p><em>#define宏定义与常变量const的区别是，#define宏定义的值为实型常量，且#define为预处理命令，不分配内存，但常变量具有使程序稳定性提高的优点，使用方便。</em></p>
<ul>
<li><strong>变量</strong> ，在运行期间可以改变的量。变量必须先定义后使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;  <span class="comment">//定义整型变量 a</span></span><br><span class="line">a = <span class="number">3</span>;  <span class="comment">//把3赋值给变量 a</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常变量</strong> ，在变量存在期间不可改变的量。也必须先定义后使用。用法是在定义变量前加上“const”。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">3</span>;  <span class="comment">//定义一个整数常变量 a，后续不可修改。 </span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>标识符</strong> ，简单来说就是一个对象的名字，遵守命名规则。</li>
</ul>
<p>变量的命名规则：</p>
<ol>
<li>
<p>变量名的开头必须是字母或下划线，不能是数字。实际编程中最常用的是以字母开头，而以下划线开头的变量名是系统专用的。</p>
</li>
<li>
<p>变量名中的字母是区分大小写的。比如 a 和 A 是不同的变量名，num 和 Num 也是不同的变量名。</p>
</li>
<li>
<p>变量名绝对不可以是C语言关键字。</p>
</li>
<li>
<p>变量名中不能有空格。这个可以这样理解：因为上面我们说过，变量名是字母、数字、下划线的组合，没有空格这一项。</p>
</li>
</ol>
<h3 id="3-2-数据的类型">3.2 数据的类型</h3>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_type.jpg" alt="数据类型"></p>
<h4 id="3-2-1-整型数据">3.2.1 整型数据</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">存储大小</th>
<th style="text-align:center">表示值范围（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned char</code></td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">0~255</td>
</tr>
<tr>
<td style="text-align:center"><code>signed char</code></td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ）~2147483647（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">0~4294967295（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">-32768~32767</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned short</code></td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">0~65535</td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ）~2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">0~4294967295（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>long int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ）~2147483648（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long int</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">0~4294967295（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>long long int</code></td>
<td style="text-align:center">8字节</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">-2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long int</code></td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">0~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主，下同。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 <code>sizeof(type)</code> 得到对象或类型的存储字节大小。</p>
<p>上述只讨论十进制，实际上C语言还可以表示八进制(<code>int a = 010</code>)和十六进制(<code>int a = 0x10</code>)。</p>
<p>特别指出，unsigned表示无符号数据，即非负数，但只有整型和字符型数据可以加unsigned修饰符。</p>
<p>由于ASCII码的存在， <code>char</code> 类型的数据范围恰好最小完整表达字符，所以 <code>char</code> 类型又称为字符类型。</p>
<h4 id="3-2-2-浮点型数据">3.2.2 浮点型数据</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">存储大小</th>
<th style="text-align:center">表示值范围</th>
<th style="text-align:center">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">1.2E-38~3.4E+38</td>
<td style="text-align:center">6位有效数字</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">2.3E-308~1.7E+308</td>
<td style="text-align:center">15位有效数字</td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">16字节</td>
<td style="text-align:center">3.4E-4932~1.1E+4932</td>
<td style="text-align:center">19位有效数字</td>
</tr>
</tbody>
</table>
<p>需要注意，计算机对于浮点数的存储并不完全精准。</p>
<p>若我们声明定义的变量超过数据类型的数据范围时，编译会警告我们，我们可在数据末尾加专用字符进行类型转换。如在 <code>float</code> 类型数据后加“f”，指定为 <code>float</code> 类型，如在实型变量后加“L”，指定为 <code>long double</code> 型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">//在某些系统中，会发出警告超出float类型，系统自动转化会影响精度</span></span><br><span class="line"><span class="type">float</span> a = <span class="number">3.14159f</span>;</span><br><span class="line"><span class="comment">//在数字后面加“f”，指定为float型，编译时不发出警告</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-void类型">3.2.3 Void类型</h4>
<p><code>void</code> 它通常用于以下三种情况下：</p>
<ol>
<li>函数返回为空：C中有各种函数都不返回值，或者可以说它们返回空。不返回值的函数的返回类型为空。</li>
<li>函数参数为空：C中有各种函数不接受任何参数。不带参数的函数可以接受一个 <code>void</code> 。</li>
<li>指针指向 <code>void</code> ：类型为 <code>void *</code> 的指针代表对象的地址，而不是类型。返回指向 <code>void</code> 的指针，可以转换为任何数据类型。</li>
</ol>
<h4 id="3-2-4-类型转换">3.2.4 类型转换</h4>
<p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p>
<p>C 语言中有两种类型转换：</p>
<ul>
<li><strong>隐式类型转换</strong>：隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d = i + f; <span class="comment">// 隐式将int类型转换为double类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>显式类型转换</strong>：显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)d; <span class="comment">// 显式将double类型转换为int类型</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-运算符">3.3 运算符</h3>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_cop.jpg" alt="运算符"></p>
<h4 id="3-3-1-算术运算符">3.3.1 算术运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">左操作数和右操作数相加</td>
<td style="text-align:center"><code>A + B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">左操作数减去右操作数</td>
<td style="text-align:center"><code>A - B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">左操作数和右操作数相乘</td>
<td style="text-align:center"><code>A * B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">左操作数除以右操作数</td>
<td style="text-align:center"><code>A / B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">左操作数除以右操作数后的余数</td>
<td style="text-align:center"><code>A % B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>++</code></td>
<td style="text-align:center">操作数整数值自增1</td>
<td style="text-align:center"><code>A ++</code></td>
</tr>
<tr>
<td style="text-align:center"><code>--</code></td>
<td style="text-align:center">操作数整数值自减1</td>
<td style="text-align:center"><code>A --</code></td>
</tr>
</tbody>
</table>
<p><code>%</code> 运算符的操作数只可以是整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b, ans1;</span><br><span class="line">	<span class="type">int</span> c, d, ans2;</span><br><span class="line">	ans1 = a + b; <span class="comment">//两个整型变量相加的结果仍为整型。</span></span><br><span class="line">	ans1 = a - b; <span class="comment">//两个整型变量相减的结果仍为整型。</span></span><br><span class="line">	ans1 = a * b; <span class="comment">//两个整型变量相乘的结果仍为整型。</span></span><br><span class="line">	ans1 = a / b; <span class="comment">//两个整型变量相除的结果仍为整型，多数为除不尽向零取整。</span></span><br><span class="line">	<span class="comment">//如 5/3=1，-5/3=-1；</span></span><br><span class="line">	ans2 = c % d; <span class="comment">// 取余运算要求运算对象均为整数，即整型。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应当注意， <code>++i</code> 和 <code>i++</code> ， <code>--i</code> 和 <code>i--</code> 是两回事。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test2.c</span></span><br><span class="line"><span class="comment">//以下例子可能理解更加深刻</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">  </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	i++;    <span class="comment">//i使用后，使i的值加一,此时 i=1；</span></span><br><span class="line">	j = i;    <span class="comment">// j=i=2;</span></span><br><span class="line">    </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	++i;    <span class="comment">//i使用前，使i的值加一,此时 i=2；</span></span><br><span class="line">	j = i;    <span class="comment">// j=i=2;</span></span><br><span class="line">    </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	i--;    <span class="comment">//j使用后，使i的值减一，此时 i=1；</span></span><br><span class="line">	j = i;    <span class="comment">//j=i=0;</span></span><br><span class="line">    </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	--i;    <span class="comment">//j使用前，使i的值减一，此时 i=0；</span></span><br><span class="line">	j = i;    <span class="comment">//j=i=0;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-关系运算符">3.3.2 关系运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">检查两个操作数的值是否相等，如果相等则条件为真</td>
<td style="text-align:center"><code>A == B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">检查两个操作数的值是否相等，如果不相等则条件为真</td>
<td style="text-align:center"><code>A != B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">检查左操作数的值是否大于右操作数的值，如果是则条件为真</td>
<td style="text-align:center"><code>A &gt; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td style="text-align:center"><code>A &lt; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td>
<td style="text-align:center"><code>A &gt;= B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td>
<td style="text-align:center"><code>A &lt;= B</code></td>
</tr>
</tbody>
</table>
<h4 id="3-3-3-逻辑运算符">3.3.3 逻辑运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">逻辑与运算符，如果两个操作数都非零，则条件为真。</td>
<td style="text-align:center"><code>A &amp;&amp; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|\|</code></td>
<td style="text-align:center">逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真</td>
<td style="text-align:center"><code>A \|\| B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td style="text-align:center"><code>!A</code></td>
</tr>
</tbody>
</table>
<h4 id="3-3-4-位运算符">3.3.4 位运算符</h4>
<p>位运算符是对数据转化为二进制，再逐位进行运算。如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><msub><mn>0</mn><mn>10</mn></msub><mo>=</mo><mn>0011110</mn><msub><mn>0</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">60_{10} = 00111100_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">6</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，再对每一位进行逻辑运算。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">按位与运算符，对两个操作数的每一位执行逻辑与操作</td>
<td style="text-align:center"><code>A &amp; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center">按位或运算符，对两个操作数的每一位执行逻辑或操作</td>
<td style="text-align:center"><code>A \| B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">按位异或运算符，对两个操作数的每一位执行逻辑异或操作</td>
<td style="text-align:center"><code>A ^ B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">按位取反运算符，对两个操作数的每一位执行逻辑取反操作</td>
<td style="text-align:center"><code>~A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">将操作数的所有位向左移动指定的位数。左移n位相当于乘以2的n次方</td>
<td style="text-align:center"><code>A &lt;&lt; n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">将操作数的所有位向右移动指定的位数。右移n位相当于除以2的n次方</td>
<td style="text-align:center"><code>A &gt;&gt; n</code></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bit.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;    <span class="comment">/* 60 = 0011 1100 */</span>  </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;    <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;           </span><br><span class="line"> </span><br><span class="line">	c = a &amp; b;       <span class="comment">/* 12 = 0000 1100 */</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c ); <span class="comment">// 一个输出的函数</span></span><br><span class="line"> </span><br><span class="line">	c = a | b;       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = a ^ b;       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = ~a;          <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = a &lt;&lt; <span class="number">2</span>;     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = a &gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-赋值运算符">3.3.5 赋值运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">把右操作数的值赋给左操作数</td>
<td style="text-align:center"><code>C = A + B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center">把右边操作数加上左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C += A</code> 相当于 <code>C = C + A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center">把右边操作数减去左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C -= A</code> 相当于 <code>C = C - A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center">把右边操作数乘以左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C *= A</code> 相当于 <code>C = C * A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center">把右边操作数除以左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C /= A</code> 相当于 <code>C = C / A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center">把右边操作数取余左边操作数的结果赋给左边操作数</td>
<td style="text-align:center"><code>C %= A</code> 相当于 <code>C = C % A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;=</code></td>
<td style="text-align:center">左移且赋值运算符</td>
<td style="text-align:center"><code>C &lt;&lt;= A</code> 相当于 <code>C = C &lt;&lt; A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;=</code></td>
<td style="text-align:center">右移且赋值运算符</td>
<td style="text-align:center"><code>C &gt;&gt;= A</code> 相当于 <code>C = C &gt;&gt; A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;=</code></td>
<td style="text-align:center">按位与且赋值运算符</td>
<td style="text-align:center"><code>C &amp;= A</code> 相当于 <code>C = C &amp; A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>^=</code></td>
<td style="text-align:center">按位异或且赋值运算符</td>
<td style="text-align:center"><code>C ^= A</code> 相当于 <code>C = C ^ A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|=</code></td>
<td style="text-align:center">按位或且赋值运算符</td>
<td style="text-align:center"><code>C \|= A</code> 相当于 <code>C = C \| A</code></td>
</tr>
</tbody>
</table>
<p>赋值运算符参与的表达式中，赋值表达式返回赋值符号右边的值。</p>
<h4 id="3-3-6-其他运算符">3.3.6 其他运算符</h4>
<ul>
<li><strong>条件运算符</strong> <code>（? : ）</code> ：其形式为 <code>(表达式1)? 表达式2 : 表达式3</code> ，先求解表达式1，若其值为真（非0）则将表达式2的值作为整个表达式的取值，否则（表达式1的值为0）将表达式3的值作为整个表达式的取值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">9</span>, o = <span class="number">6</span>, q;</span><br><span class="line">	i &gt; o ? i : o;</span><br><span class="line">	<span class="comment">// i大于o吗，大于（真）则返回i的值，小于（假）则返回o的值。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>逗号运算符</strong> <code>,</code> ：其形式为 <code>表达式1,表达式2</code> ，逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果，而左操作数只是当作副作用被计算，其值和类型不会被返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">9</span>, o = <span class="number">6</span>, q;</span><br><span class="line">	q = (i + o, i - o);</span><br><span class="line">	<span class="comment">// q = 3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>指针运算符</strong> <code>&amp;</code> 和 <code>*</code> 。 <code>*</code> ：取值符，指向一个变量； <code>&amp;</code> ：取地址符，取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象。</p>
</li>
<li>
<p><strong>成员运算符</strong> <code>.</code> 和 <code>-&gt;</code> 。用于返回复杂数据类型的子成员。</p>
</li>
<li>
<p><strong>下标运算符</strong> <code>[]</code> 。用于访问下标，在数组中用到。</p>
</li>
<li>
<p><strong>求字节运算符</strong> <code>sizeof()</code> 。返回变量的大小，将需要求字节内存的变量或其他数据结构放于括号中。</p>
</li>
<li>
<p><strong>强制类型转换运算符</strong> <code>(类型名)(表达式)</code> 。 如 <code>(float)(a + b)</code> 。</p>
</li>
</ul>
<h4 id="3-3-7-运算符优先级">3.3.7 运算符优先级</h4>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pre.jpg" alt="运算符优先级"></p>
<h3 id="3-4-语句">3.4 语句</h3>
<ol>
<li><strong>控制语句</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件语句</span></span><br><span class="line"><span class="keyword">if</span>(条件)  <span class="comment">//如果小括号里面的条件为真，则运行大括号的语句。</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环语句</span></span><br><span class="line"><span class="keyword">for</span>(语句<span class="number">1</span>;语句<span class="number">2</span>;语句<span class="number">3</span>)  <span class="comment">//语句2为条件，为真则运行大括号的语句，直至条件为假</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，小括号内必须得有两个分号，即使没有语句</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环语句</span></span><br><span class="line"><span class="keyword">while</span>(条件)  <span class="comment">//如果小括号的条件为真，则运行大括号的语句，直至条件为假</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;<span class="keyword">while</span>(条件);  <span class="comment">//如果小括号的条件为真，则运行大括号的语句，直至条件为假</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，while(…)&#123;…&#125;和do&#123;…&#125;while;的区别是，do-while至少循环一次，无视条件真或假。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//用于循环语句</span></span><br><span class="line"><span class="comment">//作用是结束该次循环，转至下一次循环，不改变总循环次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//用于循环语句或者switch语句</span></span><br><span class="line"><span class="comment">//作用是结束整个循环，改变总循环次数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件语句</span></span><br><span class="line"><span class="keyword">switch</span> (对象)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span> </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    语句<span class="number">2</span> </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:  <span class="comment">//default表示除以上case之外的情况</span></span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该语句每个case中的break不可省略。</span></span><br><span class="line"><span class="comment">//若省略break则系统会一直往下读语句，直至结束或者break，可自行上机作死</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ……;</span><br><span class="line"><span class="comment">//从函数中返回语句，一般情况下返回语句也是函数结束的地方</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转向语句</span></span><br><span class="line"><span class="keyword">goto</span> a;</span><br><span class="line">  number = <span class="number">0</span>;</span><br><span class="line">a:</span><br><span class="line">  number = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//结果number为1;  </span></span><br><span class="line"><span class="comment">//声明一处标记为a，使用goto语句使程序转向a处；</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><strong>函数调用语句</strong>：右一个函数调用加分号构成。</p>
</li>
<li>
<p><strong>复合语句</strong>：用 <code>&#123;&#125;</code> 括起来的语句，也称语句块。</p>
</li>
<li>
<p><strong>空语句</strong>：只有一个分号。</p>
</li>
<li>
<p><strong>表达式语句</strong>：一个表达式加上一个分号构成。用C语言运算符将运算对象连接起来的式子称为表达式。</p>
</li>
</ol>
<h3 id="3-5-变量的作用范围">3.5 变量的作用范围</h3>
<p>任何一种编程中， <strong>作用域</strong> 是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。</p>
<p>C语言中有三个地方可以声明变量：</p>
<ol>
<li>
<p>在函数或块（由花括号包括起来的称为代码块）内部的局部变量</p>
</li>
<li>
<p>在所有函数外部的全局变量</p>
</li>
<li>
<p>在形式参数的函数参数定义中</p>
</li>
</ol>
<p>变量按作用范围可分为 <strong>局部变量</strong> 、 <strong>全局变量</strong> 、 <strong>形式参数</strong> 。</p>
<ul>
<li><strong>局部变量</strong></li>
</ul>
<p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 局部变量声明</span></span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 实际初始化 </span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	c = a + b;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>全局变量</strong></li>
</ul>
<p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。也就是说，全局变量在声明后整个程序中都是可用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 局部变量声明</span></span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 实际初始化</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	g = a + b;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>形式参数</strong></li>
</ul>
<p>函数的参数就是形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用，同样如果局部变量与全局变量同名时优先使用当前区域的局部变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在主函数中的局部变量声明</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;主函数中的 a = %d\n&quot;</span>, a);</span><br><span class="line">	c = sum(a, b);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;主函数中的 c = %d\n&quot;</span>, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加两个整数的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;sum函数中的 a = %d\n&quot;</span>,  a);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;sum函数中的 b = %d\n&quot;</span>,  b);</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">主函数中的 a = 10</span><br><span class="line">sum函数中的 a = 10</span><br><span class="line">sum函数中的 b = 20</span><br><span class="line">主函数中的 c = 30</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>全局变量与局部变量在内存中的区别</strong></li>
</ul>
<ol>
<li>
<p>全局变量保存在内存的全局存储区中，占用静态的存储单元；</p>
</li>
<li>
<p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
</li>
</ol>
<ul>
<li><strong>局部变量和全局变量的初始化</strong></li>
</ul>
<p>当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">初始化默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>\0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pointer</code>（指针）</td>
<td style="text-align:center"><code>NULL</code></td>
</tr>
</tbody>
</table>
<h2 id="ⅳ-格式化输入输出">Ⅳ —— 格式化输入输出</h2>
<p>格式化的输入输出函数位于 <code>stdio.h</code> 头文件中。</p>
<h3 id="4-1-格式化的输出">4.1 格式化的输出</h3>
<ul>
<li><code>printf()</code>函数进行格式化的输出，其函数定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"><span class="comment">// fmt：为常量字符串,存储在内存的常量字段，fmt为该字符串首地址；</span></span><br><span class="line"><span class="comment">// ...表示存在可变形参</span></span><br><span class="line"><span class="comment">// 输出正确返回输出的字符总数，输出错误返回负值</span></span><br></pre></td></tr></table></figure>
<p>也可以参考这样的格式： <code>printf(格式控制,输出表列)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, b, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p><strong>格式控制</strong>，是使用双引号括起来的一个字符串，称为格式控制字符串，包括格式声明和普通字符。</p>
<ol>
<li>
<p><strong>格式声明</strong>，由 <code>%</code>（百分号）和格式字符组成，其作用是将输出的数据转换为指定的格式后输出。格式声明总是由 <code>%</code> 字符开始。</p>
</li>
<li>
<p><strong>普通字符</strong>，即原样输出的字符，包括逗号、空格等。</p>
</li>
</ol>
<p>应当注意的是：</p>
<ol>
<li>
<p>当我们想在显示器输出一个 <code>%</code> 时，我们需要在格式控制字符串中连续使用两个 <code>%</code> 表示一个 <code>%</code> 。</p>
</li>
<li>
<p>当我们想在显示器输出一个 <code>\</code> 时，我们需要在格式控制字符串中连续使用两个 <code>\</code> 表示一个 <code>\</code> 。</p>
</li>
</ol>
<p>对于格式字符，有如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>d</code> 或 <code>i</code></td>
<td style="text-align:center">以带符号的十进制输出整数（正数不带符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>ld</code> 或 <code>lld</code></td>
<td style="text-align:center">数据类型为 <code>long int</code> 或 <code>long long int</code> 的输出</td>
</tr>
<tr>
<td style="text-align:center"><code>o</code></td>
<td style="text-align:center">以无符号的八进制输出整数（不输出前导 <code>0</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>x</code> 或 <code>X</code></td>
<td style="text-align:center">以无符号的十六进制输出整数（不输出前导符 <code>0x</code> ）</td>
</tr>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center">以无符号的十进制输出整数</td>
</tr>
<tr>
<td style="text-align:center"><code>c</code></td>
<td style="text-align:center">以字符形式输出一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>s</code></td>
<td style="text-align:center">输出一整个字符串，直至遇到 <code>\0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>f</code></td>
<td style="text-align:center">以小数形式输出单精度数，默认输出6位小数</td>
</tr>
<tr>
<td style="text-align:center"><code>lf</code></td>
<td style="text-align:center">以小数形式输出双精度数，默认输出6位小数</td>
</tr>
<tr>
<td style="text-align:center"><code>e</code> 或 <code>E</code></td>
<td style="text-align:center">以指数形式输出实数</td>
</tr>
<tr>
<td style="text-align:center"><code>g</code> 或 <code>G</code></td>
<td style="text-align:center">选用 <code>%f</code> 或 <code>%e</code> 中宽度较短的格式，不输出无意义 <code>0</code></td>
</tr>
</tbody>
</table>
<ul>
<li>PS：正常来说，一个数字的前面加 <code>0</code> ，表示该数字为八进制。上述中不输出前导 <code>0</code> ，但当格式为 <code>%#o</code> 时，输出前导 <code>0</code> ；一个数字的前面加 <code>0x</code> ，表示该数字为十六进制。上述中不输出前导符，但当格式为 <code>%#x</code> 时，输出前导 <code>0x</code> 。</li>
</ul>
<p>输入下面的代码可以直观感受输出的格式问题：会因为格式字符与输出的数据类型不匹配而导致输出乱码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">float</span> b = <span class="number">3.1415926535</span>; </span><br><span class="line">	<span class="type">double</span> c = <span class="number">3.1415926535</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">int</span> d = <span class="number">1e9</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> e=<span class="number">1e18</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%ld\t\t%lld\t\t%f\t%lf\n&quot;</span>, a, a, a, a, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%.8f\t%.8lf\n&quot;</span>, b, b, b, b, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%.8f\t%.8lf\n&quot;</span>, c, c, c, c, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%f\t%lf\n&quot;</span>, d, d, d, d, d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%f\t%lf\n&quot;</span>, e, e, e, e, e);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">1               1               4294967297              0.000000        0.000000</span><br><span class="line">1610612736      1074340347      4614256656748904448     3.14159274      3.14159274</span><br><span class="line">1413551940      1074340347      4614256656551843652     3.14159265      3.14159265</span><br><span class="line">1000000000      1000000000      4294967297000000000     3.141592        3.141593</span><br><span class="line">-1486618624     232830643       1000000000000000000     0.000000        0.000000</span><br></pre></td></tr></table></figure>
<p>应该清晰格式字符，不乱用不混用。 <strong>输出表列的数量需与%d（或其他格式声明）的数量一致。</strong></p>
<p><code>%f</code> 默认保留6位小数，而 <code>%m.nf</code> 可以自定义小数位，m指输出宽度，n指保留小数位。如果想用 <code>0</code> 控制宽度，在宽度控制数字前加 <code>0</code> 可以这么使用 <code>%06d</code> 、<code>%07.2f</code> ，但只能补前导 <code>0</code> 。而单独的 <code>%.nf</code> 就可以控制输出的小数位。</p>
<p>当m前面添加 <code>-</code> ，则输出数据向左对齐，再补空格或 <code>0</code> 。当m前面无 <code>-</code> ，则输出数据向右对齐，再补空格或 <code>0</code> ，此时称前导空格或前导 <code>0</code> 。</p>
<p>如 <code>%7.2f</code> ，表示输出数据占7列（小数点也占一列），保留2位小数。运行以下代码可深刻理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a = <span class="number">3.141592</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;|%07.2f|\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;|%-07.2f|\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">|0003.14|</span><br><span class="line">|3.14   |</span><br></pre></td></tr></table></figure>
<p>由 <code>%f</code> 拓展， <code>%d</code> 等格式声明都可在 <code>%</code> 和格式字符之间加一个数字（正或负），表示控制整个输出所占宽度，如 <code>%7d</code> 、 <code>%4c</code> 等。</p>
<p>如果事先并不知道保留多少小数位，而是后续输入的情况，可以使用占位符 <code>%.*f</code> 解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a = <span class="number">3.1415926</span>;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k); <span class="comment">// 根据输入的k决定保留多少位小数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.*f&quot;</span>, k, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外， <code>printf()</code> 函数在运行时的形参是 <strong>从右到左</strong> 处理，具体效果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, b = a + <span class="number">1</span>, a += <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure>
<p>由于是 <strong>从右到左</strong> 的顺序处理，所以先是 <code>a += 1</code> ，a变成6，再接着 <code>b = a + 1</code>，b变成7。</p>
<ul>
<li>putchar()：输出一个字符</li>
</ul>
<p>函数原型： <code>int putchar(int _Character)</code> ，函数定义在 <code>stdio.h</code> 中。</p>
<ul>
<li>puts()：输出一个字符串，并换行</li>
</ul>
<p>函数原型： <code>int puts(const char *s);</code> ，函数定义在 <code>stdio.h</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(a);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">!aHello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-2-格式化的输入">4.2 格式化的输入</h3>
<ul>
<li>用 <code>scanf()</code> 函数进行格式化的输入，其函数定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,...)</span>;</span><br><span class="line"><span class="comment">// 第一参数为输入格式字符串，省略号表示存在可变形参</span></span><br><span class="line"><span class="comment">// 输入成功返回成功读入的数据项数，输入数据时遇到了结束则返回EOF（End Of File）。</span></span><br></pre></td></tr></table></figure>
<p>也可以参考这样的格式： <code>scanf(格式控制，地址表列)；</code>。格式控制字符串同输入的规则。在使用 <code>scanf()</code> 的时候，我们应当注意， <code>scanf()</code> 函数的地址表列是需要输入的变量地址，而不是变量名，因此，我们要在变量名前加 <code>&amp;</code> 取地址符。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, a, b, c);    <span class="comment">//此写法错误</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">//此写法正确</span></span><br></pre></td></tr></table></figure>
<p>当我们不加取地址符的时候，程序会因为储存内存溢出（输入的内容没有正确的地方存放）而终止程序。因此，当我们的程序莫名中断崩掉时，我们可以优先考虑是否在输入时加取地址符。</p>
<p>从另一个角度理解，对于函数而言，我们希望输入一个值，也就是修改变量里面的值，应当传入其地址，而不是直接传入值。</p>
<p>还需要注意的是， <code>scanf()</code> 的格式控制字符串应与我们输入的格式严格一致，即格式控制字符串中有逗号或空格等的时候，我们输入也需加上逗号或空格等。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);<span class="comment">//此时应当输入 1 2 3</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;a, &amp;b, &amp;c);<span class="comment">//此时应当输入 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>如果没有留意到这个问题，那么当我们输入数据的时候，可能会出现数据吞没的情况，因为输入的跟字符串规定的不匹配，不读入。</p>
<p>该函数还有自动处理的地方，如</p>
<ol>
<li>
<p>当我们的输入格式控制为 <code>%d%d%d</code> 时，系统会自动把空格或者换行（回车）作为分隔两个数据的标志。</p>
</li>
<li>
<p>当我们的输入格式控制为 <code>%f%f%f</code> 时，系统会自动把小数点、空格或者换行（回车）作为分隔两个数据的标志。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f%f&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f %f\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行窗口：</span><br><span class="line">3.142.77                              //输入</span><br><span class="line">3.142000 0.770000                     //输出</span><br></pre></td></tr></table></figure>
<p>虽然系统会自动把空格作为分隔两个数据的标志而不读入空格，但是总有办法可以使得 <code>scanf()</code> 函数输入带空格，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getstring.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">20</span>]; <span class="comment">// 存放字符串</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, a); <span class="comment">// 可输入带空格的字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上， <code>scanf()</code> 函数的注意点与其的键盘缓冲区和输入流有关。该函数会从输入流中选择数据放入键盘缓冲区中。在未输入满前忽略掉空白字符（空格、制表符和新行符），在输入满时把空白字符当作中断的标志。所以要注意反思输入流和键盘缓冲区里面的内容是什么，是否有键盘缓冲区遗留问题导致提前终止输入，是否有数据仍在输入流中没有进入键盘缓冲区而丢弃等。</p>
<ul>
<li><code>getchar()</code>：输入一个字符</li>
</ul>
<p>函数原型： <code>int getchar(void);</code> ，返回值则是输入的字符的ASCII码，若读取失败返回EOF或-1，函数定义在 <code>stdio.h</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	b = getchar();</span><br><span class="line">	<span class="built_in">putchar</span>(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行窗口：</span><br><span class="line">h	// 输入</span><br><span class="line">h	// 输出</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gets()</code>：输入一个字符串，一般使用 <code>scanf()</code> 输入字符串的时候不能输入含空格的字符串，而使用 <code>gets()</code> 则可以输入含空格的字符串。</li>
</ul>
<p>由于 <code>gets()</code> 函数的不安全性，在C99标准中，已经不再建议使用该函数，而在C11中更是直接抛弃了这个函数。</p>
<p></br></br></br></p>
<h2 id="ⅴ-条件结构">Ⅴ —— 条件结构</h2>
<p>实际上，在很多情况下，需要根据某个条件是否满足来决定是否执行指定操作任务，或者从给定的两种或多种操作选择其一。这就是选择结构需要解决的问题。再举个详细的例子，当我们处于岔路时，做出方向的选择；比如数学上的分段函数，条件不同对应函数关系不同。</p>
<p>通过条件结构，可以完成一些简单的语法题，如交换两个数，输出两数最大值和最小值，由键盘输入三个数输出最大值，判断闰年……</p>
<p>条件的真假如果对应到数字上，0为假，非0为真，即正负数都为真。</p>
<h3 id="5-1-if构成的条件结构">5.1 if构成的条件结构</h3>
<p><code>if</code> 语句的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( condition is <span class="literal">true</span> ) </span><br><span class="line">&#123;</span><br><span class="line">  sentence1;</span><br><span class="line">  sentence2;</span><br><span class="line">  …………</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先简单地翻译一遍以上代码：如果（ 某个条件成立 ），则运行花括号中的内容。</span></span><br></pre></td></tr></table></figure>
<p>需要注意， <code>if</code> 语句在没有花括号的情况下，只连带其后的一句语句。即 <code>if(condition)</code> 后只能跟一个语句，其可以是单个简单语句，也可以是由花括号包含起来的复合语句。</p>
<p>再加之 <code>else</code> （另外，否则），可以组成以下三种形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一，无else子句部分，只有单个if语句</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence;</span><br><span class="line">&#125;   </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 情况二，有else子句部分</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	sentence2;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 情况三，在else部分又嵌套多层if语句</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( condition1 )</span><br><span class="line">&#123;</span><br><span class="line">	sentence2;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	sentence3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三还可以写成下面的形式</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( condition1 )</span><br><span class="line">	&#123;</span><br><span class="line">		sentence2;</span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		sentence3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if</code> 语句无论写几行，都是一个整体，属于同一个语句，只是将其分成 <code>if</code> 部分和 <code>else</code> 部分。在 <code>if</code> 语句中要对给定的条件进行检查，判定所给定的条件是否成立。判断的结果是一个逻辑值“是”或“否”。</p>
<p><code>if</code> 语句小括号中的 <code>condition</code> ，应该是由关系运算符与逻辑运算符构成的表达式，运算符号详见运算符。如表达x大于1时写成 <code>x&gt;1</code> ，表达x在10到20之间时写成 <code>x &gt;=10 &amp;&amp; x &lt;= 20</code> ，表达x不等于4时写成 <code>x != 4</code> ，表达x等于4时写成 <code>x == 4</code> 。可以试着巧妙应用 <code>? :</code> 三目运算符转化繁琐的if结构。</p>
<p>下面结合一个例子剖析 <code>if-else</code> 语句，在数学中有阶跃函数（分段函数），当x＞0时，y＝1；当x＝0时，y＝0；当x＜0时，y＝-1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y; <span class="comment">//定义x和y变量</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">//输入x</span></span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">0</span>) <span class="comment">//第一个判断，做x＞0的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( x == <span class="number">0</span> ) <span class="comment">//排除第一个判断后的另外一个判断，做x＝0的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( x &lt; <span class="number">0</span> ) <span class="comment">//排除以上两种情况后的另一种情况，做x＜0的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//其实这种情况下，排除以上两种情况，剩下唯一的可能，可以写成else部分</span></span><br><span class="line">	<span class="comment">//如：</span></span><br><span class="line">	<span class="comment">//  else</span></span><br><span class="line">	<span class="comment">//  &#123;</span></span><br><span class="line">	<span class="comment">//     y = -1;</span></span><br><span class="line">	<span class="comment">//  &#125;</span></span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y); <span class="comment">//输出y</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if</code> 语句可以多个嵌套， <code>if</code> 中又带有 <code>if-else</code> 等情况，请注意辨识。应当注意 <code>if</code> 与 <code>else</code> 的配对关系。 <code>else</code> 总是与它上面最近的未配对的 <code>if</code> 配对， <code>else</code> 一般不能单独出现，上面必须先有 <code>if</code> 部分。上面的例子用 <code>if</code> 语句嵌套可如下表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y; <span class="comment">//定义x和y变量</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">//输入x</span></span><br><span class="line">	<span class="keyword">if</span>(x &gt;= <span class="number">0</span>)  <span class="comment">//将大于等于零归为一类</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">0</span>)<span class="comment">//再判断大于0的情况</span></span><br><span class="line">			y = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//在x大于等于零的情况下，再排除x大于零，即x等于零</span></span><br><span class="line">			y = ;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//排除x大于等于零的情况下，即x小于零 </span></span><br><span class="line">		y = <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y); <span class="comment">//输出y</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-switch构成的条件结构">5.2 switch构成的条件结构</h3>
<p><code>switch</code> 语句的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (object) <span class="comment">//对于某个变量或表达式进行switch</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> constant1: <span class="comment">//对于常量1的情况，进行语句</span></span><br><span class="line">		<span class="comment">//操作部分语句</span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//注意break必须存在</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> constant2: <span class="comment">//对于常量2的情况，进行语句</span></span><br><span class="line">		<span class="comment">//操作部分语句</span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//注意break必须存在</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">//对于默认情况，即排除上述情况，进行语句</span></span><br><span class="line">		<span class="comment">//操作部分语句</span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//注意break不必存在，建议存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此强调， <code>switch</code> 语句中 <code>case</code> 情况部分的 <code>break</code> 语句必须存在，此为语法规定。当去掉 <code>break</code> 语句时，系统将逐句往下运行。更具体地说，如果 <code>switch</code> 时 <code>case</code> 情况1的话，你想运行情况1部分的语句，但因为缺少 <code>break</code> 语句，系统还会运行下面 <code>case</code> 情况的语句，造成逻辑表达上的错误。可以对下面的代码中每个 <code>break</code> 试着取消注释，让其运行，观察系统运行语句输出区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> object = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span>(object) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span> : </span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span> : </span><br><span class="line">			sum = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//brea;</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">			sum = <span class="number">2</span>;</span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">		<span class="keyword">default</span> :</span><br><span class="line">			sum = <span class="number">-1</span>;</span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code> 语句的对象应该是 <strong>整型和字符类型的变量或变量表达式</strong> ，如 <code>int</code> 变量 <code>number</code> 、 <code>char</code> 变量 <code>ch</code>  、 <code>number%10</code> 、 <code>ch+32</code> ……相对于的 <code>case</code> 情况应该是整型常量或者是字符常量。如整数1、2、3……和字符’A’、‘B’、‘c’……</p>
<p>对于 <code>switch</code> 语句，还有以下规则说明。操作部分语句可以不止一个语句，其一直运行到 <code>break</code> 语句为止。可以没有 <code>default</code> 的情况，但此时如果没有与 <code>switch</code> 表达式相匹配的 <code>case</code> 常量时，不执行任何语句。 <code>case</code> 情况出现的次序不影响执行结果，每个 <code>case</code> 情况常量必须互不相同，不能存在一个值有多种执行情况。</p>
<p>这里有一个例子，对于输入分数，输出分数评级，可以辅助理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score ; <span class="comment">//输入分数score，此处人为规定输入值在0到100之间 </span></span><br><span class="line">	<span class="type">char</span> grade ; <span class="comment">//输出分数评级，由&#x27;A&#x27;到&#x27;E&#x27; </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;score ) ; <span class="comment">//输入分数 </span></span><br><span class="line">	<span class="keyword">switch</span>( score / <span class="number">10</span> ) </span><br><span class="line">	<span class="comment">//对分数除以十，即判断十位的情况，如80分到90，除以十为8 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>: </span><br><span class="line">			grade = <span class="string">&#x27;A&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>: </span><br><span class="line">			grade = <span class="string">&#x27;A&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;    </span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>: </span><br><span class="line">			grade = <span class="string">&#x27;B&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">			grade = <span class="string">&#x27;C&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">			grade = <span class="string">&#x27;D&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			grade = <span class="string">&#x27;E&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;      </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your grade is %c .\n&quot;</span> , grade ) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code> 语句也是可以嵌套的，但结构上比较繁琐。</p>
<p></br></br></br></p>
<h2 id="ⅵ-循环结构">Ⅵ —— 循环结构</h2>
<p>有时候用条件结构还是不能简便解决问题，还需要使用循环结构，如处理求多个整数的和、处理多个判断。</p>
<p>再如在输入的时候，我希望输入50个数字，我们可以复制粘贴50句 <code>scanf()</code> 来实现这个要求。学了循环之后，至少，不再需要50句语句。</p>
<p>需要注意的是， <strong>循环语句一定要设置终止条件，否则将进入死循环，无法得出结果！！！</strong></p>
<p>通过循环结构，可以完成一些简单的语法题，如判断一个数是否为素数，计算斐波那契数列，计算阶乘……</p>
<h3 id="6-1-while构成的循环结构">6.1 while构成的循环结构</h3>
<p><code>while</code> 语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( condition is <span class="literal">true</span> ) </span><br><span class="line">&#123;</span><br><span class="line">	sentences;</span><br><span class="line">	……………………</span><br><span class="line">	<span class="comment">//花括号内的内容总称为循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 <code>condition</code> 为表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。循环体可以是一条语句，也可以是一个语句块（用花括号包起来）。 <code>while</code> 循环的特点是先判断条件表达式，后执行循环体语句。</p>
<p><code>while</code> 语句的运行顺序是：从上至下，先判断条件表达式是否为真，为真则执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p>这里给出一个例子，求1到100的和，希望通过例子更好理解 <code>while</code> 循环：</p>
<p>分析此问题，将100个数相加，要重复进行100次加法，显然是需要循环结构介入。有兴趣的可以尝试画画流程图（此处不做介绍）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add-100-number.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//初始化循环变量，从1开始 </span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//用来存求和的值 </span></span><br><span class="line">	<span class="keyword">while</span>(i &lt;= <span class="number">100</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i; <span class="comment">//相当于sum=sum+i，求和 </span></span><br><span class="line">		i ++; <span class="comment">//i自增，实现从1到2到3到……100 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum); <span class="comment">//输出求和的值 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<h3 id="6-2-do-while构成的循环结构">6.2 do-while构成的循环结构</h3>
<p><code>do-while</code> 语句。其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">	sentences;</span><br><span class="line">	……………………</span><br><span class="line">	<span class="comment">//花括号内的内容总称为循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span>(condition is <span class="literal">true</span>); <span class="comment">//注意这有一个分号</span></span><br></pre></td></tr></table></figure>
<p>此处 <code>condition</code> 为表达式，道理同上。 <code>do-while</code> 循环的特点是先无条件执行循环体，然后判断循环条件是否成立。即 <code>do-while</code> 循环至少进行一次循环，注意与 <code>while</code> 语句区分。</p>
<p><code>do-while</code> 语句的运行顺序是：从上至下，先无条件执行一次循环体，再判断条件表达式是否为真，为真则回到循环体开始重新执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p>此处同样解决上面的问题，从1加到100求和。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add-100-number.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//初始化循环变量，从1开始 </span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//用来存求和的值 </span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		sum += i; <span class="comment">//相当于sum=sum+i，求和 </span></span><br><span class="line">		i ++; <span class="comment">//i自增，实现从1到2到3到……100 </span></span><br><span class="line">	&#125; <span class="keyword">while</span>(i &lt;= <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum); <span class="comment">//输出求和的值 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<h3 id="6-3-for构成的循环结构">6.3 for构成的循环结构</h3>
<p><code>for</code> 语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( sentence1; condition; sentence2 )</span><br><span class="line">&#123;</span><br><span class="line">	sentences3</span><br><span class="line">	…………………………</span><br><span class="line">	<span class="comment">//花括号内的内容总称为循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 <code>sentence1</code> 和 <code>sentence2</code> 为普通表达式， <code>sentence1</code> 只执行一次，而 <code>sentence2</code> 在每次执行完循环体后都会运行一次。 <code>condition</code> 为条件控制表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。</p>
<p><code>for</code> 语句的运行顺序是：先进行一次 <code>sentence1</code> ，接着判断 <code>condition</code> 是否为真，为真则执行循环体。循环体运行完后执行 <code>sentence2</code> 。然后再次判断 <code>condition</code> ，一直循环直至条件为假。</p>
<p>所以延展出常用的 <code>for</code> 语句使用格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量赋值初始化; 循环条件; 循环变量变化)</span><br><span class="line">&#123;</span><br><span class="line">  循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做个补充，在老版本的C语言中， <code>sentence1</code> 不支持声明变量并同时初始化，如： <code>for(int i = 1; i &lt;= 100; i ++)</code> 。但是在C99版本后是允许的。</p>
<p>事实上， <code>for</code> 语句中的 <code>sentence1</code> 语句、 <code>sentence2</code> 语句和 <code>condition</code> 语句并非必要。即这三句语句可以省略，省略 <code>condition</code> 语句默认为真，写成 <code>for( ; ; )</code> ，但是两个分号绝不可少。在省略掉这三句语句时，我们仍要思考如何终止循环。例如在 <code>for</code> 语句上面就把变量初始化，在循环体中设置判断 <code>if</code> 什么条件就终止循环，在循环体中处理条件变化……</p>
<h3 id="6-4-循环的终止与继续">6.4 循环的终止与继续</h3>
<ul>
<li>使用 <code>break</code> 语句终止循环。</li>
</ul>
<p>之前使用 <code>break</code> 语句，可能是条件结构中跳出 <code>switch</code> 语句。实际上， <code>break</code> 语句还可以用来跳出循环体，即终止循环。</p>
<p>以求1到100和的例子，假如我希望在和刚好大于等于2500的时候结束，并想知道此时是多少个数的和，那怎么实现呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use-break.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">		<span class="keyword">if</span>(sum &gt;= <span class="number">2500</span>) <span class="comment">//当sum大于等于2500 </span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//终止所在的一层for循环 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d, and now i is %d\n&quot;</span>, sum, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以这样解决：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use-for.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; sum &lt; <span class="number">2500</span>; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d, and now i is %d\n&quot;</span>, sum, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中我写到，终止 <code>break</code> 所在的一层 <code>for</code> 循环，因为当有多个循环嵌套时， <code>break</code> 不会终止所有的循环，而是一层循环。（可以自己做实验研究）</p>
<ul>
<li>使用 <code>continue</code> 语句跳过本次循环。</li>
</ul>
<p>有时候不希望终止整个循环，而是想结束这一次循环，还得执行下次循环。这时可以使用 <code>continue</code> 语句。</p>
<p>还是求1到100和的例子，但我希望求1到100中是偶数的和，那么奇数就没必要加进去，此时可以使用 <code>continue</code> 语句跳过本次循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find-the-sum-of-even-numbers-from-1-to-100.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>) <span class="comment">//当i为奇数，即除于2余数为1 </span></span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">//结束本次循环 </span></span><br><span class="line">		sum += i; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，结束本次循环并不是完全不进入循环，而是不执行 <code>continue</code> 下面的循环体部分。上面的代码，如果 <code>sum += i</code> 在 <code>continue</code> 的上面，结果还是会加上奇数的部分。</p>
<p></br></br></br></p>
<h2 id="ⅶ-枚举">Ⅶ —— 枚举</h2>
<p>枚举是C语言中的一种基本数据类型，用于定义一组具有离散值的常量。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p>
<p>定义一个枚举类型，需要使用 <code>enum</code> 关键字，后面跟着枚举类型的名称，以及用大括号 <code>&#123;&#125;</code> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从0开始递增。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子，一周有7天，如果想将星期一映射为数字1，星期天映射为数字7，我们可以使用枚举。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MON映射到1，后面的会自动递增</span></span><br><span class="line"><span class="comment">// 效果跟#define MON 1 等一样</span></span><br></pre></td></tr></table></figure>
<p>如果想让星期三之后特殊一些，星期三映射到8，星期天映射到12，只需在中间添加赋值即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED=<span class="number">8</span>, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MON映射到1，TUE映射到2，WED映射到8，后面的会自动递增</span></span><br></pre></td></tr></table></figure>
<p>使用时直接输出即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, MON);</span><br></pre></td></tr></table></figure>
<p>然而上面是对枚举类型的使用，下面介绍枚举变量的定义和使用。</p>
<p>枚举类型是一种数据类型，可以对标 <code>int</code> 理解；枚举变量是一个变量，可以对标 <code>int number</code> 中的 <code>number</code> 理解。</p>
<p>可以通过三种方式定义枚举变量：</p>
<ol>
<li>先定义枚举类型，再定义枚举变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义枚举类型的同时定义枚举变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>省略枚举名称，直接定义枚举变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>
<p>给出使用枚举变量的情形：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br><span class="line">    day = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <strong>枚举类型值连续</strong> 的情况下还可以进行循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将将整数转换为现有枚举值，只需强制类型转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        saturday, sunday, monday, tuesday, wednesday, thursday, friday</span><br><span class="line">    &#125; workday;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">weekend</span>;</span></span><br><span class="line">    weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br><span class="line">    <span class="comment">//weekend = a; //错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,weekend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="ⅷ-数组">Ⅷ —— 数组</h2>
<p>数组是一种可以存储固定大小的相同类型元素的顺序集合。简单来说，数组可以存放一串相同的数据类型。</p>
<h3 id="8-1-数组结构">8.1 数组结构</h3>
<p>数组的结构如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_array.png" alt="数组的结构"></p>
<p>数组的每一个单体称作 <strong>元素</strong> ，每个元素有它的 <strong>索引号</strong> ，用于访问该元素。 <strong>索引号从0开始。</strong></p>
<h3 id="8-2-数组的定义和访问">8.2 数组的定义和访问</h3>
<p>数组的定义十分简单，其定义格式是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [arraySize];</span><br></pre></td></tr></table></figure>
<p>如 <code>int array[5];</code> 就定义了一个大小为5的整型数组，数组名为array，它可以存放5个整型数据，索引号从0到4。</p>
<p>访问数组时直接使用 <code>arrayName[index]</code> 的方式进行，如 <code>array[0]</code> 就是array数组的第一个元素的值。使用循环还可以将数组的内容输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 访问数组并赋值</span></span><br><span class="line">   	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">   		<span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">   	</span><br><span class="line">   	<span class="comment">// 访问数组并输出</span></span><br><span class="line">   	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>补充个冷知识，我们比较经常使用 <code>array[0]</code> 访问元素，实际上还能以 <code>0[array]</code> 的方式访问元素。</p>
<h3 id="8-3-数组的初始化">8.3 数组的初始化</h3>
<p>通过上面的例子，我们可以通过循环给数组中的每个元素赋值。但是还可以通过声明时的初始化语句进行相同的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>大括号 <code>&#123; &#125;</code> 之间的值的数目不能大于我们在数组声明时在方括号 <code>[ ]</code> 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。即等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-多维数组">8.4 多维数组</h3>
<p>C 语言支持多维数组。多维数组声明的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure>
<p>下面以二维数组作为示例。一个二维数组，在本质上，是一个元素为一维数组的数组。定义形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [x][y];</span><br></pre></td></tr></table></figure>
<p>如一个二维数组初始化如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_array2.png" alt="二维数组"></p>
<p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 一个带有 5 行 2 列的数组</span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 输出数组中每个元素的值</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = %d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-数组的使用">8.5 数组的使用</h3>
<ul>
<li>求数组长度：使用 <code>sizeof</code> 关键字，将整个数组占的内存大小除以每个元素占的内存大小，得到的就是元素个数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numbers[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(numbers[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li>将数组作为函数参数传入</li>
</ul>
<ol>
<li>形式参数是一个已定义大小的数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> param[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>形式参数是一个未定义大小的数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> param[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了函数的通用性，通常使用未定义大小的数组，再将数组大小作为第二参数传入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getAverage</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> <span class="comment">// 求数组的平均值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> avg;</span><br><span class="line">	<span class="type">double</span> sum;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	avg = sum / size;</span><br><span class="line">	<span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们传入的是数组，在函数内部中如若有对数组元素的修改，也会同步对外部的数组进行修改。因为此处形式参数是以地址传递的形式传入。</p>
<p>为什么传递数组名字会是以地址传递的形式传入呢？那是因为 <strong>数组名实际上是一个指针</strong> ，它存放数组中首元素的地址。至于什么是指针，可查阅下一节。</p>
<p></br></br></br></p>
<h2 id="ⅸ-指针">Ⅸ —— 指针</h2>
<p>指针是C语言很重要的一环。</p>
<p>数据都有一个内存空间，内存空间都有一个地址，我们形象地把这个地址称为指针。指针也就是内存地址，指针变量是用来存放内存地址的变量。</p>
<h3 id="9-1-指针变量的定义">9.1 指针变量的定义</h3>
<p>指针变量定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *var_name;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 是指针的基类型，它必须是一个有效的数据类型， <code>var_name</code> 是指针变量的名称。用来声明指针的星号 <code>*</code> 与乘法中使用的星号是相同的，但在此处的意义是标记改变量是指针变量，称为指针运算符。一个指针对应一个 <code>*</code> 。</p>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个 <strong>代表内存地址的长的十六进制数</strong> 。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<p>当我们需要取一个变量的地址时，我们需要加 <code>&amp;</code> （取地址符）；当我们需要取一个指针的数据时，我们需要加 <code>*</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure>
<p>之前使用 <code>scanf()</code> 函数时所加的 <code>&amp;</code> ，表明我们是把数据放到某变量名所处的地址，而不是塞到变量名里面。</p>
<p>如果想输出地址的话，可以使用 <code>%p</code> 或 <code>%x</code> 输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;a);</span><br></pre></td></tr></table></figure>
<p>指针使用前必须有初始化值，即定义时必须赋值，若无值则指向NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用前没有初始化值时，该指针会变成 <strong>野指针</strong> ，指针指向了一块随机的空间，不受程序控制。有可能是系统重要软件的地址，贸然使用可能使得系统崩溃。</p>
<h3 id="9-2-指针的运算">9.2 指针的运算</h3>
<ul>
<li>
<p>指针之间不能进行 <code>+</code> 运算，无意义。</p>
</li>
<li>
<p>指针进行 <code>&lt;</code> 运算时，表示实际内存高低位的比较；</p>
</li>
<li>
<p>指针进行 <code>=</code> 运算时，表示把右边的地址赋值给左边；</p>
</li>
<li>
<p>指针进行 <code>-</code> 运算时，表示在两指针之间相隔相同类型元素的个数。</p>
</li>
<li>
<p>指针进行 <code>++</code> 运算时，表示在指针递增，会指向下一个元素的存储单元。指针在递增时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p>
</li>
<li>
<p>指针进行 <code>--</code> 运算时，表示在指针递减，会指向上一个元素的存储单元。指针在递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p>
</li>
</ul>
<h3 id="9-3-指针的使用">9.3 指针的使用</h3>
<ul>
<li>指针间接访问变量</li>
</ul>
<p>通过指针输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *pointer1, *pointer2;</span><br><span class="line">	pointer1 = &amp;a;</span><br><span class="line">	pointer2 = &amp;b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>, a, b); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pointer1=%d,pointer2=%d\n&quot;</span>, pointer1, pointer2); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pointer1=%d,pointer2=%d\n&quot;</span>, *pointer1, *pointer2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">a=100,b=10</span><br><span class="line">pointer1=6422216,pointer2=6422220</span><br><span class="line">pointer1=100,pointer2=10</span><br></pre></td></tr></table></figure>
<p>通过指针将两个变量存放的值交换，用地址传递实现存储空间上的交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap-ab.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>, x, y);</span><br><span class="line">	swap(&amp;x, &amp;y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">x=1,y=2</span><br><span class="line">x=2,y=1</span><br></pre></td></tr></table></figure>
<ul>
<li>指针引用一维数组</li>
</ul>
<p>数组名即是该数组首元素（即序号为0的元素）的地址。所以我们可以直接用指针指向数组名，无需取地址符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure>
<p>同时，我们可以对数组首元素进行取地址，即下代码等价：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = a;      <span class="comment">//p指向数组首元素的地址，即a[0]的地址；</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];  <span class="comment">//p指向a[0]的地址</span></span><br></pre></td></tr></table></figure>
<p>当我们正确把指针指向一个数组的时候，可以对指针进行以下运算： <code>p++</code> , <code>++p</code> , <code>p--</code> , <code>--p</code> , <code>p = p + 1</code> , <code>p = p - 1</code> 等。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pointer.png" alt="指针访问数组"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>,<span class="number">105</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(p+<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br></pre></td></tr></table></figure>
<p>因为数组名也有地址的属性，所以输出语句还可以改成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(a+<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>但数组名不能进行自增自减，如不能 <code>a++</code> 或 <code>a--</code> 等。</p>
<p>指针还可以引用字符串（字符数组），字符串的本质是一个字符数组。我们可以类似指针引用一维数组那样引用字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[] = <span class="string">&quot;computer!&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p);  <span class="comment">//%c，取*时，具体到某个元素，此处是首元素</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *(p + <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);  <span class="comment">//%s，不取*，从首元素输出所有字符</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p + <span class="number">2</span>);  <span class="comment">// 从a[2]开始输出所有字符</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">输出结果：</span><br><span class="line">c</span><br><span class="line">m</span><br><span class="line">computer!</span><br><span class="line">mputer!</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上也可用字符指针变量表示，如下所示：</span></span><br><span class="line"><span class="type">char</span> *p=<span class="string">&quot;computer!&quot;</span>;<span class="comment">//此处可能会出现warning，但无关紧要</span></span><br><span class="line"><span class="comment">//上句等价于char *p; p=&quot;computer!&quot;;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p);<span class="comment">//此处无需*p，注意对比</span></span><br></pre></td></tr></table></figure>
<p><code>char *p=&quot;computer!&quot;</code> 的意思是将字符指针变量 <code>p</code> 指到&quot;computer!&quot;的首地址即&quot;c&quot;的地址。</p>
<p>之前，我们用字符数组也能实现打印字符串，而使用字符指针的不同是：</p>
<p>①可以对字符指针变量赋值，但不能对数组名赋值，初始化不等于赋值，如不能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>] = &#123;<span class="string">&quot;computer!&quot;</span>&#125;; <span class="comment">//此句合法</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>]; </span><br><span class="line">a = <span class="string">&quot;computer!&quot;</span>; <span class="comment">//此句不合法</span></span><br></pre></td></tr></table></figure>
<p>②储存内容不同，字符数组把每一个元素的值都存放，而字符指针只存放第一个元素的地址。</p>
<ul>
<li>指针指向二维数组</li>
</ul>
<p>二维数组有两个下标，那么一个指针怎么指，我们将指针分为 <strong>行指针</strong> 和 <strong>列指针</strong> 。行指针，即指向某一行元素的指针；列指针，即指向某一列元素的指针。</p>
<p>下有二维数组 <code>a[4][5]</code> ：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pointer2.png" alt="指针指向二维数组"></p>
<ul>
<li>动态数组</li>
</ul>
<p>像 <code>int a[5];</code> 这样的定义数组，我们称之为 <strong>静态数组</strong> 。在程序编译时，静态数组的内存空间就被分配好了，存储在栈上或者全局数据区。静态数组的大小在声明时确定且无法在运行时改变。静态数组的生命周期与其作用域相关。如果在函数内部声明静态数组，其生命周期为整个函数执行期间；如果在函数外部声明静态数组，其生命周期为整个程序的执行期间。</p>
<p><strong>动态数组</strong> 是在运行时通过动态内存分配函数（如 <code>malloc</code> 和 <code>calloc</code> ）手动分配内存的数组。动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 <code>malloc</code> 、 <code>calloc</code>  等函数来申请内存，并使用 <code>free</code> 函数来释放内存。动态数组的大小在运行时可以根据需要进行调整。可以使用 <code>realloc</code> 函数来重新分配内存，并改变数组的大小。动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *dynamicArray = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态数组内存分配</span></span><br><span class="line"><span class="comment">// 使用动态数组</span></span><br><span class="line"><span class="built_in">free</span>(dynamicArray); <span class="comment">// 动态数组内存释放</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组指针</li>
</ul>
<p>数组指针，其本质是指针，指向一个一维数组的指针。所以定义时，由运算符优先级，我们需要带上小括号</p>
<p>定义数组指针： <code>类型名 (*指针变量名)[长度];</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">4</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">		<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">		<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,</span><br><span class="line">		<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,</span><br><span class="line">		<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;;</span><br><span class="line">	<span class="type">int</span> (*p)[<span class="number">5</span>];</span><br><span class="line">	p = a+<span class="number">1</span>; <span class="comment">// 指向第2行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(*p)[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">6 7 8 9 10</span><br></pre></td></tr></table></figure>
<ul>
<li>指针数组</li>
</ul>
<p>指针数组，其本质是数组，是一个元素均为指针类型的数组。</p>
<p>定义指针数组： <code>类型名 *数组名[长度];</code></p>
<p>举例：（将数字转化为对应的英文月份）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p[<span class="number">13</span>];</span><br><span class="line">	p[<span class="number">1</span>]=<span class="string">&quot;Januray&quot;</span>;  p[<span class="number">2</span>]=<span class="string">&quot;February&quot;</span>;  p[<span class="number">3</span>]=<span class="string">&quot;March&quot;</span>; </span><br><span class="line">	p[<span class="number">4</span>]=<span class="string">&quot;April&quot;</span>;  p[<span class="number">5</span>]=<span class="string">&quot;May&quot;</span>;      p[<span class="number">6</span>]=<span class="string">&quot;June&quot;</span>;</span><br><span class="line">	p[<span class="number">7</span>]=<span class="string">&quot;July&quot;</span>;  p[<span class="number">8</span>]=<span class="string">&quot;August&quot;</span>;    p[<span class="number">9</span>]=<span class="string">&quot;September&quot;</span>;</span><br><span class="line">	p[<span class="number">10</span>]=<span class="string">&quot;October&quot;</span>;p[<span class="number">11</span>]=<span class="string">&quot;November&quot;</span>;  p[<span class="number">12</span>]=<span class="string">&quot;December&quot;</span>;</span><br><span class="line">	<span class="comment">//可能会警告，但无关紧要</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">3 	// 输入</span><br><span class="line">March 	// 输出</span><br></pre></td></tr></table></figure>
<ul>
<li>指向函数的指针</li>
</ul>
<p>函数名也代表函数的起始地址。</p>
<p>此内容直接看以下例子——比较两个数字的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y ? x : y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">50</span>, b = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=%d&quot;</span>, max(a, b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上代码等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y ? x : y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">50</span>, b = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">	p = max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=%d&quot;</span>, (*p)(a,b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>int (*p)(int,int)</code>；定义指向函数的指针变量： <code>类型名 (* 指针变量名)(函数参数表列);</code></p>
<p>指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数，下附一个使用函数指针的例子；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ans;</span><br><span class="line">	ans = (*p)(x,y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;min=&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">34</span>, b = <span class="number">-21</span>, n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的选择(1-求最大值，2-求最小值)：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)  fun(a, b, max);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>)  fun(a, b, min);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回指针类型的函数</li>
</ul>
<p>定义返回指针值得函数形式为： <code>类型名* 函数名(参数表列);</code></p>
<p>依然是使用一个例子：对若干学生成绩，找出不合格得课程得学生及其学生号，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span>* <span class="title function_">search</span><span class="params">(<span class="type">float</span> (*pointer)[<span class="number">4</span>])</span><span class="comment">//定义函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> *pt;</span><br><span class="line">	pt = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//切记初始化指针，无则指向NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*(*pointer+i)&lt;<span class="number">60</span>)  pt = *pointer;</span><br><span class="line">		<span class="comment">//如有不及格，使pt指向score[i][0]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> score[][<span class="number">4</span>] = &#123;&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;,&#123;<span class="number">56</span>,<span class="number">89</span>,<span class="number">67</span>,<span class="number">88</span>&#125;,&#123;<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">66</span>&#125;&#125;;</span><br><span class="line">	<span class="comment">//定义数组，初始化成绩，有3名学生，每名学生有4门成绩</span></span><br><span class="line">	<span class="type">float</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = search(score + i);</span><br><span class="line">		<span class="comment">//调用search函数，如不及格则返回score[i][0]的地址</span></span><br><span class="line">		<span class="comment">//否则返回NULL</span></span><br><span class="line">		<span class="keyword">if</span>(p == *(score+i))  <span class="comment">//若返回的不是NULL，则输出学生成绩</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No.%d score:&quot;</span>,i);</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%5.2f &quot;</span>, *(p+j));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指向指针数据的指针变量</li>
</ul>
<p>指向指针数据的指针，可以嵌套，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	<span class="type">int</span> **q;</span><br><span class="line">	q = &amp;p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, **q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="ⅹ-共用体与结构体">Ⅹ —— 共用体与结构体</h2>
<h3 id="10-1-共用体">10.1 共用体</h3>
<p><strong>共用体（Union）</strong> 是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。</p>
<p>为了定义共用体，必须使用 <code>union</code> 语句。 <code>union</code> 语句定义了一个新的数据类型，带有多个成员。定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>]</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员定义;</span><br><span class="line">	成员定义;</span><br><span class="line">	...</span><br><span class="line">	成员定义;</span><br><span class="line">&#125; 共用体变量;</span><br></pre></td></tr></table></figure>
<p><code>union tag</code> 是可选的，每个 <code>成员定义</code> 是标准的变量定义，比如 <code>int i;</code> 或者 <code>float f;</code> 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。</p>
<p>下面定义一个名为 <code>Data</code> 的共用体类型，有三个成员 <code>i</code> 、 <code>f</code> 和 <code>str</code> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span>  str[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以像枚举类型定义枚举类型的同时定义枚举变量一样，定义共用体类型的同时定义共用体变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span>  str[<span class="number">10</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>
<p><code>Data</code> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>
<p><strong>共用体占用的内存应足够存储共用体中最大的成员。</strong> 例如，在上面的实例中，<code>Data</code> 将占用10个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。</p>
<p>使用共用体时，我们需要先创建共用体类型变量，再根据变量访问成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure>
<p>为了访问共用体的成员，使用成员访问运算符 <code>.</code> ，如 <code>data.i</code> 、 <code>data.f</code> 、 <code>data.str</code> ，但是在同一时间只能使用一个成员。</p>
<h3 id="10-2-结构体">10.2 结构体</h3>
<p><strong>结构体</strong> 与共用体类似，不同的是结构体的成员并列存在，可同时使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员定义;</span><br><span class="line">	成员定义;</span><br><span class="line">	...</span><br><span class="line">	成员定义;</span><br><span class="line">&#125; 结构体变量;</span><br></pre></td></tr></table></figure>
<p><code>tag</code> 是结构体标签，每个 <code>成员定义</code> 是标准的变量定义，比如 <code>int i;</code> 或者 <code>float f;</code> 或者其他有效的变量定义。在结构体定义的末尾，最后一个分号之前，可以指定一个或多个结构体变量，这是可选的。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">double</span> c;</span><br><span class="line">&#125; s1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用typedef创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">double</span> c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure>
<p>第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 <code>t3=&amp;s1</code> ，则是非法的。</p>
<p>如果将结构体与基本数据类型做对比的话，举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span> <span class="title">b</span>；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">&#125; Tag2;</span><br><span class="line">Tag2 c;</span><br></pre></td></tr></table></figure>
<p>那么 <code>int</code> 、 <code>struct Tag</code> 、 <code>Tag2</code> 是对等的，都是数据类型；而 <code>a</code> 、 <code>b</code> 和 <code>c</code> 是同级的，都是变量。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针。如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了访问结构的成员，使用成员访问运算符 <code>.</code> 。对于结构体的初始化，可以使用 <code>&#123;&#125;</code> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//book.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   	<span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   	<span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   	<span class="type">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语言&quot;</span>, <span class="string">&quot;RUNOOB&quot;</span>, <span class="string">&quot;编程语言&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体作为函数的参数传入时，传参方式与其他类型的变量或指针类似，如： <code>void printBooks(struct Books b);</code> ，之后在函数里访问成员即可。</p>
<p>可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br><span class="line">struct_pointer = &amp;Book1;</span><br><span class="line">struct_pointer-&gt;title; <span class="comment">// 指针访问成员时</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用指向该结构的指针访问结构的成员时，必须使用 <code>-&gt;</code> 运算符。</p>
<p>使用 <code>sizeof</code> 运算符来计算结构体的大小，这在使用链表时有帮助。</p>
<p></br></br></br></p>
<h2 id="ⅺ-链表">Ⅺ —— 链表</h2>
<h3 id="11-1-链表及其构成">11.1 链表及其构成</h3>
<p><strong>链表</strong>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。而这些储存单元需要及时开辟，此时需要使用动态储存分配函数。</p>
<p><strong>链表</strong>由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的 <strong>数据域</strong> ，另一个是存储下一个结点地址的 <strong>指针域</strong> 。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> num;		<span class="comment">// 数据域</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">5</span>];		<span class="comment">// 数据域</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span> 	<span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链表还可分为动态链表和静态链表，此处不讨论静态链表，均为动态链表。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_arrayandlist.png" alt="链表与数组"></p>
<h3 id="11-2-内存管理的函数">11.2 内存管理的函数</h3>
<p>关于动态储存分配函数有 <code>calloc()</code> 、 <code>malloc()</code> 、 <code>free()</code> 、 <code>realloc()</code> 。他们都存在于 <code>stdlib.h</code> 头文件中。</p>
<p>有的编译系统要求用 <code>malloc.h</code> 头文件而不是 <code>stdlib.h</code> 头文件，实际上这两个头文件都包含以上的动态储存分配函数。</p>
<p>除 <code>free()</code> 函数，其他函数都会返回一定的地址，需要对地址进行强制类型转换，转换为我们所需的数据类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">函数原型</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>calloc()</code></td>
<td style="text-align:center"><code>void *calloc(unsigned n, unsign size)</code></td>
<td style="text-align:center">分配n个大小为size的内存连续空间</td>
<td style="text-align:center">成功时返回分配内存的起始地址，不成功返回0</td>
</tr>
<tr>
<td style="text-align:center"><code>malloc()</code></td>
<td style="text-align:center"><code>void *calloc(unsigned size)</code></td>
<td style="text-align:center">分配1个大小为size的储存区</td>
<td style="text-align:center">成功时返回分配内存起始地址，内存不足返回0</td>
</tr>
<tr>
<td style="text-align:center"><code>free()</code></td>
<td style="text-align:center"><code>void free(void *p)</code></td>
<td style="text-align:center">释放p所指的内存区</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center"><code>realloc()</code></td>
<td style="text-align:center"><code>void *calloc(viod *p, unsigned isze)</code></td>
<td style="text-align:center">将p所指的已分配内存区大小改为size，size可大于或小于原来大小</td>
<td style="text-align:center">返回指向该内存的指针</td>
</tr>
</tbody>
</table>
<h3 id="11-3-单向链表">11.3 单向链表</h3>
<p><strong>单向链表</strong>，指针指向单向，连接方向单向，优点是简单，缺点是效率略低。</p>
<p>单向链表是由结点构成，所讨论的单向链表结点如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表创建，返回一个表头head</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">creat</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	p1 = p2 = (<span class="keyword">struct</span> test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test));  <span class="comment">//开辟一个内存单元</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p1-&gt;num);  <span class="comment">//输入第一个信息</span></span><br><span class="line">	head = <span class="literal">NULL</span>;  <span class="comment">//指针必须初始化，无地址则指向NULL</span></span><br><span class="line">	<span class="keyword">while</span>(p1-&gt;num != <span class="number">0</span>) <span class="comment">// 设计当输入0时停止创建链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		n += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>)  head = p1; <span class="comment">// 当链表为空，即创建的是第一个结点，则使头结点指向p1的地址</span></span><br><span class="line">		<span class="keyword">else</span>  p2-&gt;next = p1;	<span class="comment">// 当链表非空，用next指针连接</span></span><br><span class="line">		p2 = p1; <span class="comment">// p2指向p1所指的地址，p2为当前链表末尾</span></span><br><span class="line">		p1 = (<span class="keyword">struct</span> test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test));  <span class="comment">//再开辟内存单元，并将起始地址赋值给p1</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p1-&gt;num);   <span class="comment">//循环输入信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p1); <span class="comment">// 释放最后一个结点，即释放输入为0的结点</span></span><br><span class="line">	p2-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 链表的末尾指向NULL</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上述代码，演示过程如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_create.png" alt="链表创建过程"></p>
<ul>
<li>链表的插入</li>
</ul>
<p>链表的插入思路如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_insert.png" alt="链表的插入"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在某链表中插入一个新的由指针引用的结构体</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">add</span><span class="params">(<span class="keyword">struct</span> test *head, <span class="keyword">struct</span> test *insert)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p0</span>, *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	p0 = insert;  <span class="comment">//将新的由指针引用的结构体赋值给p0</span></span><br><span class="line">	p1 = head;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="comment">//判断是否为空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		head = p0;  <span class="comment">//是空链表则从头插入，头指针为p0</span></span><br><span class="line">		p0-&gt;next = <span class="literal">NULL</span>;<span class="comment">//后面无新的数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>    <span class="comment">//链表非空，按num排序，找到适合的位置或者到链表末端停下</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((p0-&gt;num &gt; p1-&gt;num) &amp;&amp; (p1-&gt;next != <span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			p2=p1;</span><br><span class="line">			p1=p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(p0-&gt;num &lt;= p1-&gt;num) <span class="comment">// 找到合适的位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(head == p1) head = p0;</span><br><span class="line">			<span class="keyword">else</span>  p2-&gt;next = p0;</span><br><span class="line">			p0-&gt;next = p1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 找不到合适位置，插入到链表末尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			p1-&gt;next = p0;</span><br><span class="line">			p0-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="keyword">return</span> head; <span class="comment">// 返回更新后的链表表头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的删除</li>
</ul>
<p>链表的删除思路如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_delete.png" alt="链表的删除"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在某链表中查找num并删除该结构体，返回更新后的表头</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">del</span><span class="params">(<span class="keyword">struct</span> test *head, <span class="type">int</span> num)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)  <span class="comment">// 判断是否为空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是一个空链表\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	p1 = head;</span><br><span class="line">	<span class="comment">// 链表非空，将创建好的链表头指针head赋值给p1</span></span><br><span class="line">	<span class="comment">// 不能直接对表头进行操作，否则变动完之后找不到表头</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当没匹配到元素或者已经到链表末端，停止循环</span></span><br><span class="line">	<span class="keyword">while</span>(p1-&gt;num != num &amp;&amp; p1-&gt;next != <span class="literal">NULL</span>)  </span><br><span class="line">	&#123;</span><br><span class="line">		p2 = p1;		<span class="comment">// p2指向的是p1的前一个结点</span></span><br><span class="line">		p1 = p1-&gt;next;		<span class="comment">// p1指针遍历链表</span></span><br><span class="line">	&#125; <span class="comment">// 此处寻找元素</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(p1-&gt;num == num)  <span class="comment">// 如果是找到了元素而停止循环的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p1 == head)</span><br><span class="line">		&#123;</span><br><span class="line">			head = p1-&gt;next;<span class="comment">// 如果删除的是头指针，则将头指针指向下一个，修改表头</span></span><br><span class="line">			<span class="built_in">free</span>(p1);</span><br><span class="line">		&#125;  </span><br><span class="line">			</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p2-&gt;next = p1-&gt;next;  <span class="comment">// 删除节点，即跳过某结构体直接连向下一个</span></span><br><span class="line">			<span class="built_in">free</span>(p1);</span><br><span class="line">		&#125;  </span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Not found!&quot;</span>);   <span class="comment">// 到链表末端而停止循环的情况，也就是没找到</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head;	<span class="comment">// 返回修改后的表头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的查找</li>
</ul>
<p>思路简单，自行理解代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表中查找值为obj的结构体，找到返回该结构体的指针，找不到返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">find</span><span class="params">(<span class="keyword">struct</span> test *head, <span class="type">int</span> obj)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p</span>, *<span class="title">res</span> =</span> <span class="literal">NULL</span>; <span class="comment">// res作为返回的结构体</span></span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表为空返回空</span></span><br><span class="line">	</span><br><span class="line">	p = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">// 遍历链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;num == obj) <span class="comment">// 找到目标</span></span><br><span class="line">		&#123;</span><br><span class="line">			res = p;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next; <span class="comment">// 往下顺延</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的输出</li>
</ul>
<p>思路简单，自行理解代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while循环输出链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> test *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p</span>;</span></span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;num);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-4-双向链表">11.4 双向链表</h3>
<p><strong>双向链表</strong>，指针指向双向，连接方向双向。</p>
<p>双向链表是由结点构成，所讨论的双向链表结点如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span>	<span class="comment">// 指向后一个结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">pre</span>;</span>	<span class="comment">// 指向前一个结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>双向链表结构如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_dlist.png" alt="双向链表"></p>
<p>至于双向链表的创建，插入，删除，查找，不详细介绍。多一个方向的指针使得该链表可以往前遍历，提高其方便性。</p>
<h3 id="11-5-循环链表">11.5 循环链表</h3>
<p>循环链表的首位是相接的，构成一个环。所以还可以分成单向循环链表和双向循环链表。</p>
<ul>
<li>循环单向链表</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_clist.png" alt="循环单向链表"></p>
<ul>
<li>循环双向链表</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_cdlist.png" alt="循环双向链表"></p>
<p></br></br></br></p>
<h2 id="ⅻ-对文件的读写">Ⅻ —— 对文件的读写</h2>
<h3 id="12-1-打开文件">12.1 打开文件</h3>
<p>可以使用 <code>fopen()</code> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <code>FILE</code> 的一个对象，类型 <code>FILE</code> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>
<p>函数的第一参数是打开的文件名，常量字符指针类型，也能看成字符串类型；第二参数是打开文件的模式，有如下模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">打开一个已有的文本文件，允许读取文件</td>
</tr>
<tr>
<td style="text-align:center"><code>r+</code></td>
<td style="text-align:center">打开一个已有的文本文件，允许读写文件</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code></td>
<td style="text-align:center">打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入</td>
</tr>
<tr>
<td style="text-align:center"><code>w+</code></td>
<td style="text-align:center">打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入</td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center">打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则在原有内容上追加写入</td>
</tr>
<tr>
<td style="text-align:center"><code>a+</code></td>
<td style="text-align:center">打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则在原有内容上追加写入</td>
</tr>
</tbody>
</table>
<p>如果是处理二进制文件的情况，则在原来的基础上加上 <code>b</code> ，如： <code>rb</code> ， <code>wb</code> ， <code>ab</code> ， <code>rb+</code> ， <code>r+b</code> ， <code>wb+</code> ， <code>w+b</code> ， <code>ab+</code> ， <code>a+b</code> 。</p>
<p><strong>打开文件处理完成之后记得关闭文件</strong>，使用 <code>fclose()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<p>如果成功关闭文件， <code>fclose()</code> 函数返回零，如果关闭文件时发生错误，函数返回  <code>EOF</code> 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。 <code>EOF</code> 是一个定义在头文件 <code>stdio.h</code> 中的常量，上述打开文件函数和关闭文件函数也都在 <code>stdio.h</code> 头文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;	<span class="comment">// 文件对象</span></span><br><span class="line">	fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>); <span class="comment">// 打开文件并把文件指针绑定到该文件</span></span><br><span class="line">	fclose(fp); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-2-写入文件">12.2 写入文件</h3>
<ul>
<li>函数 <code>fputc()</code> ：把参数 <code>c</code> 的字符值写入到 <code>fp</code> 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <code>EOF</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>fputs()</code> ：把字符串 <code>s</code> 写入到 <code>fp</code> 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <code>EOF</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>fprintf</code> ：把一个字符串写入到文件中。该函数形式与 <code>printf</code> 函数类似，参考 <code>printf</code> 函数使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp,<span class="type">const</span> <span class="type">char</span> *format, ...)</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两函数比较</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%d&quot;</span>, a, b);</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d %d&quot;</span>, a, b);</span><br></pre></td></tr></table></figure>
<h3 id="12-3-读取文件">12.3 读取文件</h3>
<ul>
<li>函数 <code>fgetc()</code> ：从 <code>fp</code> 所指向的输入文件中读取一个字符，返回值是读取的字符，发生错误时返回 <code>EOF</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>fgets()</code> ：从 <code>fp</code> 所指向的输入文件中读取n-1个字符，并把字符串复制到 <code>buf</code> 中，最后追加 <code>NULL</code> 终止字符串。该函数如果在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 <code>EOF</code> ，则只会返回读取到的字符，包括换行符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>fscanf()</code> ：从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。该函数形式与 <code>scanf</code> 函数类似，参考 <code>scanf</code> 函数使用，记得添加取地址符 <code>&amp;</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两函数比较</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - C++</title>
    <url>/2024/cpp-patterns/</url>
    <content><![CDATA[<p>关键词：C++、设计模式</p>
<span id="more"></span>
<hr>
<blockquote>
<p>Reference：<a href="https://kamacoder.com/designpattern.php">卡码网KamaCoder - 设计模式精讲 - https://kamacoder.com/designpattern.php</a></p>
</blockquote>
<h2 id="创建型设计模式">创建型设计模式</h2>
<h3 id="单例模式">单例模式</h3>
<p>单例模式是<strong>创建型设计模式</strong>，保证一个类只有一个实例，并提供全局访问方法实现这个实例。</p>
<h4 id="单例模式的使用情形">单例模式的使用情形</h4>
<ol>
<li>资源共享：多个模块共享某个资源的时候，比如需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。</li>
<li>只有一个实例。</li>
<li>懒加载：对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用。</li>
</ol>
<h4 id="单例模式的优点">单例模式的优点</h4>
<ol>
<li>全局控制：保证只有一个实例，这样就可以严格的控制怎样访问它以及何时访问它。</li>
<li>节省资源：避免多次创建了相同的对象，从⽽节省了系统资源，⽽且多个模块还可以通过单例实例共享数据。</li>
<li>懒加载：可以实现懒加载，需要时才实例化。</li>
</ol>
<h4 id="单例模式的基本原则">单例模式的基本原则</h4>
<ol>
<li>不允许外部代码创建实例。</li>
<li>唯一实例保存在私有静态变量中。</li>
<li>通过公有静态方法获取唯一实例。</li>
</ol>
<h4 id="单例模式的实现">单例模式的实现</h4>
<ol>
<li>饿汉式：类加载时就完成了实例创建。</li>
<li>懒汉式：需要使用实例时在创建。
<ul>
<li>多个线程同时获取实例时，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建。这个时候需要使用同步机制。</li>
</ul>
</li>
</ol>
<p>单例模式参考代码：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Singleton.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span> &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton <span class="type">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton <span class="type">const</span> &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式设计题">单例模式设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1074">【设计模式专题之单例模式】1.小明的购物车 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。</p>
<p>输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。</p>
<p>输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 “商品名称 购买数量”。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Singleton/main.cpp">Singleton/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Singleton/main.cpp">Singleton/main.cpp (gitee.com)</a></p>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p>简单工厂模式：将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。</p>
<ul>
<li>三个主要角色，工厂类、抽象产品、具体产品。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_SimpleFactory.png" alt=""></p>
<p>工厂方法模式是<strong>创建型设计模式</strong>。</p>
<ul>
<li>简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。</li>
<li>工厂方法模式引⼊了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码。</li>
</ul>
<p>工厂方法模式的角色：</p>
<ul>
<li>抽象工厂：一个接口，包含一个抽象的工厂方法。</li>
<li>具体工厂：创建具体产品。</li>
<li>抽象产品：产品的接口。</li>
<li>具体产品：实现抽象产品接口，是工厂创建的对象。</li>
</ul>
<h4 id="工厂方法模式的使用情形">工厂方法模式的使用情形</h4>
<p>工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品。当创建对象涉及一系列复杂的初始化逻 辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。</p>
<h4 id="工厂方法模式的实现">工厂方法模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_FactoryMethod.png" alt=""></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteProductA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ConcreteProductA\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteProductB</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ConcreteProductB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactoryA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactoryA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactoryB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactoryB</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式设计题">工厂方法模式设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1076">【设计模式专题之工厂方法模式】2.积木工厂 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。</p>
<p>接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 “Circle” 和 “Square” 两种。整数表示该积木生产的数量。</p>
<p>对于每个积木，输出一行字符串表示该积木的信息。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/FactoryMethod/main.cpp">FactoryMethod/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/FactoryMethod/main.cpp">FactoryMethod/main.cpp(gitee.com)</a></p>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<p>抽象工厂模式是<strong>创建型设计模式</strong>。抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用。</p>
<p>在工厂方法模式中，每个具体工厂只负责创建单一的产品。但是如果有多类产品呢，比如说“手机”，一个品牌的手机有高端机、中低端机之分，这些具体的产品都需要建立一个单独的工厂类，但是它们都是相互关联的，都共同属于同一个品牌，这就可以使用到抽象工厂模式。</p>
<p>抽象工厂模式包括多个抽象产品、多个具体产品、一个抽象工厂和多个具体工厂，每个具体工厂负责创建一组相关产品。</p>
<h4 id="简单工厂-工厂方法-抽象工厂的区别">简单工厂、工厂方法、抽象工厂的区别</h4>
<ul>
<li>
<p>简单工厂模式：一个工厂方法创建<strong>所有</strong>具体产品；</p>
</li>
<li>
<p>工厂方法模式：一个工厂方法创建<strong>一个</strong>具体产品；</p>
</li>
<li>
<p>抽象工厂模式：一个工厂方法可以创建<strong>一类</strong>具体产品。</p>
</li>
</ul>
<h4 id="工厂方法模式的使用情形">工厂方法模式的使用情形</h4>
<p>抽象工厂模式能够保证一系列相关的产品一起使⽤，并且在不修改客户端代码的情况下，可以方便地替换整个产品系列。但是当需要增加新的产品类时，除了要增加新的具体产品类，还需要修改抽象工厂及其所有的具体工厂类，扩展性相对较差。</p>
<p>典型的应用场景是使用抽象工厂模式来创建与不同数据库的连接对象。</p>
<h4 id="抽象工厂模式的实现">抽象工厂模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_AbstractFactory.png" alt=""></p>
<p>遵循以下步骤：</p>
<ul>
<li>定义（一个或多个）抽象产品，声明产品的公共方法。</li>
<li>实现具体产品类。</li>
<li>定义抽象工厂，声明一组可用于创建产品的方法。</li>
<li>实现具体工厂。</li>
<li>客户端中使用抽象工厂和抽象产品。</li>
</ul>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">AbstractProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA1</span> : <span class="keyword">public</span> ::AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductA1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ProductA1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA2</span> : <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductA2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;use ProductA2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB1</span> : <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductB1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eat ProductB1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB2</span> : <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductB2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;eat ProductB2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactory1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactory1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactory2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactory2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂模式设计题">抽象工厂模式设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1077">【设计模式专题之抽象工厂模式】3. 家具工厂 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家新开了两个工厂用来生产家具，一个生产现代风格的沙发和椅子，一个生产古典风格的沙发和椅子，现在工厂收到了一笔订单，请你帮他设计一个系统，描述订单需要生产家具的信息。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。</p>
<p>接下来的 N 行，每行输入一个字符串，字符串表示家具的类型。家具类型分为 “modern” 和 “classical” 两种。</p>
<p>对于每笔订单，输出字符串表示该订单需要生产家具的信息。</p>
<p>modern订单会输出下面两行字符串</p>
<p>modern chair</p>
<p>modern sofa</p>
<p>classical订单会输出下面两行字符串</p>
<p>classical chair</p>
<p>classical soft</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/AbstractFactory/main.cpp">AbstractFactory/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/AbstractFactory/main.cpp">AbstractFactory/main.cpp(gitee.com)</a></p>
<h3 id="建造者模式">建造者模式</h3>
<p>建造者（生成器）模式是<strong>创建型设计模式</strong>。主要思想是将对象的构建过程分为多个步骤，每个步骤定义一个抽象接口，具体构建过程有具体建造者类完成，同时有一个指导者类负责协调建造者的工作。</p>
<p>建造者模式有以下角色：</p>
<ul>
<li>产品：被构建的负责对象，包含多个组成部分。</li>
<li>抽象建造者：定义构建产品各部分的抽象类和一个返回复杂产品的方法。</li>
<li>具体建造者：实现抽象类的方法，构建产品各部分。</li>
<li>指导者：调用具体建造者的方法，按照一定顺序或逻辑构建。</li>
</ul>
<h4 id="建造者模式的使用情形">建造者模式的使用情形</h4>
<p>比如 Junit 中的测试构建器 TestBuilder，构建测试对象。</p>
<h4 id="建造者模式的优点和缺点">建造者模式的优点和缺点</h4>
<ul>
<li>将一个复杂对象的构建与其表示分离。</li>
<li>同样的构建过程可以创建不同的表示。</li>
<li>适用于复杂对象的创建。</li>
<li>当产品的构建过程发⽣变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难。</li>
</ul>
<h4 id="建造者模式的实现">建造者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Builder.png" alt=""></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPart1</span><span class="params">(<span class="type">const</span> std::string&amp; part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPart2</span><span class="params">(<span class="type">const</span> std::string&amp; part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getProduct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="string">&quot; &quot;</span> + part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string part1;</span><br><span class="line">    std::string part2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">getProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> : <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildPart1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        product-&gt;<span class="built_in">setPart1</span>(<span class="string">&quot;Part1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildPart2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        product-&gt;<span class="built_in">setPart2</span>(<span class="string">&quot;Part2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product* <span class="title">getProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product* product = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(Builder* builder)</span> </span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildPart1</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildPart2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="建造者模式设计题">建造者模式设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1084">【设计模式专题之建造者模式】4. 自行车加工 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家新开了一家自行车工厂，用于使用自行车配件（车架 frame 和车轮 tires ）进行组装定制不同的自行车，包括山地车和公路车。</p>
<p>山地车使用的是Aluminum Frame（铝制车架）和 Knobby Tires（可抓地轮胎），公路车使用的是 Carbon Frame （碳车架）和 Slim Tries。</p>
<p>现在它收到了一笔订单，要求定制一批自行车，请你使用【建造者模式】告诉小明这笔订单需要使用那些自行车配置吧。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。</p>
<p>接下来的 N 行，每行输入一个字符串，字符串表示客户的自行车需求。</p>
<p>字符串可以包含关键词 “mountain” 或 “road”，表示客户需要山地自行车或公路自行车。</p>
<p>对于每笔订单，输出该订单定制的自行车配置。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Builder/main.cpp">Builder/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Builder/main.cpp">Builder/main.cpp(gitee.com)</a></p>
<h3 id="原型模式">原型模式</h3>
<p>原型模式是<strong>创建型设计模式</strong>。核心思想是基于现有的对象创建新的对象。</p>
<p>原型模式包含两个重点模块：</p>
<ol>
<li>抽象原型类，且具有克隆自身的方法。</li>
<li>具体原型类，实现克隆方法，复制当前对象并返回一个新对象。</li>
</ol>
<h4 id="原型模式的使用情形">原型模式的使用情形</h4>
<p>通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。</p>
<p>当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式。</p>
<p>在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。</p>
<p>原型模式的例子：</p>
<ul>
<li>Java 提供了 Object 类的  <code>clone()</code> 方法，可以实现对象的浅拷贝。类需要实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法。</li>
<li>在 .NET 中，ICloneable 接口提供了 Cloneable 接口并重写 <code>Clone</code> 方法，可以用于实现对象的克隆。</li>
<li>Spring 框架中的 Bean 的作用域之一是原型作用域（Prototype Scope），在这个作用域下，Spring 框架会为每次请求创建⼀个新的 Bean 实例，类似于原型模式。</li>
</ul>
<h4 id="原型模式的实现">原型模式的实现</h4>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Prototype</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Prototype *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> Prototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcretePrototype</span>(std::string <span class="type">const</span> &amp;data) : <span class="built_in">m_data</span>(data) &#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ConcretePrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Prototype *<span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(<span class="keyword">this</span>-&gt;m_data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原型模式设计题">原型模式设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1083">【设计模式专题之原型模式】5. 矩形原型 (kamacoder.com)</a>：</p>
<blockquote>
<p>公司正在开发一个图形设计软件，其中有一个常用的图形元素是矩形。设计师在工作时可能需要频繁地创建相似的矩形，而这些矩形的基本属性是相同的（颜色、宽度、高度），为了提高设计师的工作效率，请你使用原型模式设计一个矩形对象的原型。使用该原型可以快速克隆生成新的矩形对象。</p>
<p>首先输入一个字符串，表示矩形的基本属性信息，包括颜色、长度和宽度，用空格分隔，例如 “Red 10 5”。</p>
<p>然后输入一个整数 N（1 ≤ N ≤ 100），表示使用原型创建的矩形数量。</p>
<p>对于每个矩形，输出一行字符串表示矩形的详细信息，如 “Color: Red, Width: 10,Height: 5”。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Prototype/main.cpp">Prototype/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Prototype/main.cpp">Prototype/main.cpp(gitee.com)</a></p>
<h2 id="结构型设计模式">结构型设计模式</h2>
<h3 id="适配器模式">适配器模式</h3>
<p>适配器模式是<strong>结构型设计模式</strong>。它将一个类的接口转换成客户希望的另一个接口，充当两个不同接口的桥梁，让不兼容的类一起工作。</p>
<p>适配器模式的基本角色有：</p>
<ul>
<li>目标接口：客户端希望使用的接口。</li>
<li>适配器类：实现客户端使用的接口，包含一个需要适配的类实例，起到转接扩展的作用。</li>
<li>被适配者：需要被适配的类。</li>
</ul>
<h4 id="适配器模式的使用情形">适配器模式的使用情形</h4>
<p>扮演着补救和扩展角色。</p>
<p>不同的项目和库可能使用不同的日志框架，不同的日志框架提供的 API 也不同，因此引⼊了适配器模式使得不同的 API 适配为统一接口。</p>
<p>Spring MVC 中，<code>HandlerAdapter</code> 接口就是适配器模式，将处理器适配到框架中，使得不同类型的处理器能够统一处理请求。</p>
<h4 id="适配器模式的实现">适配器模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Adapter.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;specificRequest&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> : <span class="keyword">public</span> Target &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Adapter</span>(Adaptee *adaptee) &#123;</span><br><span class="line">		m_adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		m_adaptee-&gt;<span class="built_in">specificRequest</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Adaptee *m_adaptee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="适配器模式设计题">适配器模式设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1085">【设计模式专题之适配器模式】6. 扩展坞 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明购买了一台新电脑，该电脑使用 TypeC 接口，为了确保新电脑可以使用现有的USB接口充电器和数据线，他购买了一个TypeC到USB的扩展坞。</p>
<p>请你使用适配器模式设计并实现这个扩展坞系统，确保小明的新电脑既可以通过扩展坞使用现有的USB接口充电线和数据线，也可以使用TypeC接口充电。</p>
<p>题目包含多行输入，第一行输入一个数字 N （1 &lt; N &lt;= 20)，表示后面有N组测试数据。</p>
<p>之后N行都是一个整数，1表示使用电脑本身的TypeC接口，2表示使用扩展坞的USB接口充电。</p>
<p>根据每行输入，输出相应的充电信息。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Adapter/main.cpp">Adapter/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Adapter/main.cpp">Adapter/main.cpp(gitee.com)</a></p>
<h3 id="代理模式">代理模式</h3>
<p>代理模式是<strong>结构型设计模式</strong>，用于控制对其他对象的访问。</p>
<p>代理模式允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。</p>
<ul>
<li>通常用于在访问某对象时引入间接层（中介作用），可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。</li>
</ul>
<p>比如进行文件加载，为了避免直接访问“文件&quot;对象，可以新增一个代理对象，代理对象中有一个对“文件对象&quot;的引用，在代理对象的 <code>1oad</code> 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查，<br>
然后调用真实文件对象的 <code>1oad</code> 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。</p>
<p>代理模式的角色有：</p>
<ul>
<li>抽象主题：抽象类，声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题：定义了代理类所代表的真实对象。</li>
<li>代理类。</li>
</ul>
<h4 id="代理模式的使用情形">代理模式的使用情形</h4>
<p>代理模式可以在实际操作的前后添加一些额外的操作，但在多个对象交互之间可能会增加复杂性且降低性能。</p>
<p>代理模式在许多工具和库中也有应用：</p>
<ul>
<li>Spring 框架的 AOP 模块；</li>
<li>Java 提供动态代理机制；</li>
<li>Android 的 Glide 框架 使用代理模式实现图片的延迟加载。</li>
</ul>
<h4 id="代理模式的实现">代理模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Proxy.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;RealSubject: Handling request.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		realSubject.<span class="built_in">request</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	RealSubject realSubject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代理模式目的是控制对对象的访问，同时还可以加入一些额外的逻辑；</p>
<p>适配器模式目的是使不兼容的对象能够协同工作，将一个类的接口转换成另一个类的接口。</p>
<h4 id="代理模式的设计题">代理模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1088">【设计模式专题之代理模式】7-小明买房子 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明想要购买一套房子，他决定寻求一家房屋中介来帮助他找到一个面积超过100平方米的房子，只有符合条件的房子才会被传递给小明查看。</p>
<p>第一行是一个整数 N（1 ≤ N ≤ 100），表示可供查看的房子的数量。</p>
<p>接下来的 N 行，每行包含一个整数，表示对应房子的房屋面积。</p>
<p>对于每个房子，输出一行，表示是否符合购房条件。如果房屋面积超过100平方米，输出 “YES”；否则输出 “NO”。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Proxy/main.cpp">Proxy/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Proxy/main.cpp">Proxy/main.cpp(gitee.com)</a></p>
<h3 id="装饰模式">装饰模式</h3>
<p>装饰模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>在不定义子类的情况下动态的给对象添加⼀些额外的功能。</li>
</ul>
<p>举个例子，假设有一个基础的图形类，想要为图形类添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类。这时就可以考虑使用装饰模式来动态地添加，而不需要修改图形类本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。</p>
<p>装饰模式包含四个角色：</p>
<ul>
<li>组件：抽象类，是具体组件和装饰者的父类，定义了具体组件需要实现的方法。</li>
<li>具体组件：实现组件的具体方法，是被装饰的对象。</li>
<li>装饰类：一个抽象类，给具体组件添加功能，但具体功能由具体装饰者完成，包含一个组件对象引用。</li>
<li>具体装饰类：扩展实现装饰类，负责向组件对象添加新的行为。</li>
</ul>
<h4 id="装饰模式的使用情形">装饰模式的使用情形</h4>
<ul>
<li>不希望使用继承生成子类，给现有的类添加附加功能时；</li>
<li>动态的添加和覆盖功能。</li>
</ul>
<p>Java 的 I/O 库 中，装饰模式用于增强 I/O 的功能。</p>
<h4 id="装饰模式的实现">装饰模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Decorator.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Component</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ConcreteComponent operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Decorator</span>(Component *component) : <span class="built_in">m_component</span>(component) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		m_component-&gt;<span class="built_in">operation</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Component *m_component;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator</span>(Component *component) : <span class="built_in">Decorator</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		Decorator::<span class="built_in">operation</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ConcreteDecorator operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="装饰模式的设计题">装饰模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1086">【设计模式专题装饰模式】8-咖啡加糖 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明喜欢品尝不同口味的咖啡，他发现每种咖啡都可以加入不同的调料，比如牛奶、糖和巧克力。他决定使用装饰者模式制作自己喜欢的咖啡。</p>
<p>请设计一个简单的咖啡制作系统，使用装饰者模式为咖啡添加不同的调料。系统支持两种咖啡类型：黑咖啡（Black Coffee）和拿铁（Latte）。</p>
<p>多行输入，每行包含两个数字。第一个数字表示咖啡的选择（1 表示黑咖啡，2 表示拿铁），第二个数字表示要添加的调料类型（1 表示牛奶，2 表示糖）。</p>
<p>根据每行输入，输出制作咖啡的过程，包括咖啡类型和添加的调料。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Decorator/main.cpp">Decorator/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Decorator/main.cpp">Decorator/main.cpp(gitee.com)</a></p>
<h3 id="外观模式">外观模式</h3>
<p>外观模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>定义一个高层接口，使得子系统更容易使用，同时也隐藏了子系统。</li>
</ul>
<p>外观模式的角色有：</p>
<ul>
<li>外观类：对外的一个统一的高层接口。</li>
<li>子系统类：实现子系统的功能，处理外观类指派的任务。</li>
</ul>
<h4 id="外观模式的使用情形">外观模式的使用情形</h4>
<p>外观模式隐藏了系统的复杂性，使得客户端不需要直接与子系统交互，只需与外观接口交互即可。</p>
<p>但是如果要添加子系统或者修改子系统的行为，那么需要修改外观类，违背“开闭原则”。</p>
<p>使用外观模式的例子：</p>
<ul>
<li>Spring 框架的 <code>ApplicationContext</code> 可以看作是外观。</li>
<li>JDBC 提供了一个用于数据库交互的接口，<code>DriverManager</code> 类。</li>
<li>Android 系统的 API。</li>
</ul>
<h4 id="外观模式的实现">外观模式的实现</h4>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;operationA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;operationB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;operationC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		subSystemA.<span class="built_in">operationA</span>();</span><br><span class="line">		subSystemB.<span class="built_in">operationB</span>();</span><br><span class="line">		subSystemC.<span class="built_in">operationC</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SubSystemA subSystemA;</span><br><span class="line">	SubSystemB subSystemB;</span><br><span class="line">	SubSystemC subSystemC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="外观模式的设计题">外观模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1089">【设计模式专题之外观模式】9-电源开关 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家的电源总开关控制了家里的三个设备：空调、台灯和电视机。每个设备都有独立的开关密码，分别用数字1、2和3表示。即输入1时，空调关闭，输入2时，台灯关闭，输入3时，电视机关闭，当输入为4时，表示要关闭所有设备。请你使用外观模式编写程序来描述电源总开关的操作。</p>
<p>第一行是一个整数 N（1 &lt;= N &lt;= 100），表示后面有 N 行输入。</p>
<p>接下来的 N 行，每行包含一个数字，表示对应设备的开关操作（1表示关闭空调，2表示关闭台灯，3表示关闭电视机，4表示关闭所有设备）。</p>
<p>输出关闭所有设备后的状态，当输入的数字不在1-4范围内时，输出Invalid device code.</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Facade/main.cpp">Facade/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Facade/main.cpp">Facade/main.cpp(gitee.com)</a></p>
<h3 id="桥接模式">桥接模式</h3>
<p>桥接模式是<strong>结构型设计模式</strong>。其 UML 图很像一座桥。</p>
<ul>
<li>将抽象部分与实现部分分离，通过组合建立两个类之间的联系，而不是继承。</li>
</ul>
<p>桥接模式的角色有：</p>
<ul>
<li>抽象：抽象类，定义抽象部分的接口，维护一个对实现的引用。</li>
<li>修正抽象：对抽象类进行扩展。</li>
<li>实现：定义实现的接口，抽象化接口的实现。</li>
<li>具体实现：实现接口的具体类，实现具体操作。</li>
</ul>
<p>举个例子，图形编辑器中，每一种图形都需要蓝色、红色、黄色不同的颜色。</p>
<ul>
<li>不使用桥接模式，可能需要为每一种图形类型和每一种颜色都创建一个具体的子类；</li>
<li>使用桥接模式可以将图形和颜色两个维度分离，两个维度都可以独立进行变化和扩展，如果要新增其他颜色，只需添加新的 Co1or 子类，不影响图形类；反之亦然。</li>
</ul>
<h4 id="桥接模式的使用情形">桥接模式的使用情形</h4>
<p>使用情况：</p>
<ul>
<li>一个类存在两个独立变化的维度，且两个维度都需要扩展时；</li>
<li>不希望使用继承时。</li>
</ul>
<p>适用于多个独立变化维度，需要灵活扩展的系统。</p>
<h4 id="桥接模式的实现">桥接模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Bridge.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationA</span> : <span class="keyword">public</span> Implementation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationB</span> : <span class="keyword">public</span> Implementation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Abstraction</span>(Implementation *impl) : <span class="built_in">impl</span>(impl) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Implementation *impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> : <span class="keyword">public</span> Abstraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RefinedAbstraction</span>(Implementation *impl) : <span class="built_in">Abstraction</span>(impl) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		impl-&gt;<span class="built_in">operationImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="桥接模式的设计题">桥接模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1092">【设计模式专题之桥接模式】10-万能遥控器 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有一个万能遥控器，能够支持多个品牌的电视。每个电视可以执行开机、关机和切换频道的操作，请你使用桥接模式模拟这个操作。</p>
<p>第一行是一个整数 N（1 &lt;= N &lt;= 100），表示后面有 N 行输入。</p>
<p>接下来的 N 行，每行包含两个数字。第一个数字表示创建某个品牌的遥控和电视，第二个数字表示执行的操作。</p>
<p>其中，0 表示创建 Sony 品牌的电视，1 表示创建 TCL 品牌的遥控和电视；</p>
<p>2 表示开启电视、3表示关闭电视，4表示切换频道。</p>
<p>对于每个操作，输出相应的执行结果。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Bridge/main.cpp">Bridge/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Bridge/main.cpp">Bridge/main.cpp(gitee.com)</a></p>
<h3 id="组合模式">组合模式</h3>
<p>组合模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>将对象组合成树状结构来表示部分和整体的层次关系。</li>
</ul>
<p>组合模式使得客户端可以统一处理单个对象和对象的集合。</p>
<p>组合模式的角色有：</p>
<ul>
<li>组件：根节点，定义组合中所有对象的通用接口，定义共性内容。</li>
<li>叶子：实现组件的内容，表示组合中的叶子对象。</li>
<li>合成：存储子部件，实现对子部件的相关操作，比如添加、删除、获取子组件等。</li>
</ul>
<p>比如，省份中包含了多个城市，如果比喻成一个树形结构，城市就是叶子节点，它是省份的组成部分，而省份就是合成节点，可以包含其他城市。省份和城市都是组件，它们都有一些共同的操作，比如获取信息。</p>
<p>通过组合模式，整个省份的获取信息操作可以一次性执行，无需关心省份中的具体城市。</p>
<h4 id="组合模式的使用情形">组合模式的使用情形</h4>
<p>可以使得客户端统一处理单个对象和组合对象。适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。</p>
<h4 id="组合模式的实现">组合模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Combination.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Component</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Leaf operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点：包含叶子节点的操作行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component *component)</span> </span>&#123;</span><br><span class="line">		m_component.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Component&gt;(component));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component *component)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Composite operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;component : m_component) &#123;</span><br><span class="line">			component-&gt;<span class="built_in">operation</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;Component&gt;&gt; m_component;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合模式的设计题">组合模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1090">【设计模式专题之组合模式】11-公司组织架构 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明所在的公司内部有多个部门，每个部门下可能有不同的子部门或者员工。</p>
<p>请你设计一个组合模式来管理这些部门和员工，实现对公司组织结构的统一操作。部门和员工都具有一个通用的接口，可以获取他们的名称以及展示公司组织结构。</p>
<p>第一行是一个整数 N（1 &lt;= N &lt;= 100），表示后面有 N 行输入。</p>
<p>接下来的 N 行，每行描述一个部门或员工的信息。部门的信息格式为 D 部门名称，员工的信息格式为 E 员工名称，其中 D 或 E 表示部门或员工。</p>
<p>输出公司的组织结构，展示每个部门下的子部门和员工</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Combination/main.cpp">Combination/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Combination/main.cpp">Combination/main.cpp(gitee.com)</a></p>
<h3 id="享元模式">享元模式</h3>
<p>享元模式是<strong>结构型设计模式</strong>。</p>
<ul>
<li>对象被设计为可共享的，可被多个上下文使用。</li>
</ul>
<p>认识并区分内部状态和外部状态：</p>
<ul>
<li>内部状态：指那些可以被多个对象共享的状态，存储在享元对象内部，对于所有享元对象都是相同的，这部分状态通常是不变的。</li>
<li>外部状态：享元对象依赖的、可变的部分，这部分状态不存储在享元对象内部，而是使用享元对象时通过参数传递给对象。</li>
</ul>
<p>享元模式的角色有：</p>
<ul>
<li>抽象享元类：所以具体享元类的共享接口，包含对外部状态的操作。</li>
<li>具体享元类：继承实现享元接口，包含内部状态。</li>
<li>享元工厂类：创建并管理享元对象，当用户请求时，提供实例。</li>
<li>客户端：维护外部状态，在使用享元对象时，将外部状态传递给享元对象。</li>
</ul>
<h4 id="享元模式的使用情形">享元模式的使用情形</h4>
<p>享元模式适用于包含大量相似对象，并且这些对象的内部状态可以共享。</p>
<p>具体的应用场景包括文本编辑器，图形编辑器，游戏中的角色创建，这些对象的内部状态比较固定（外观，技能，形状），但是外部状态变化比较大时，可以使用。</p>
<h4 id="享元模式的实现">享元模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_FlyWeight.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyWeight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FlyWeight</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">(std::string externalState)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyWeight</span> : <span class="keyword">public</span> FlyWeight &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyWeight</span>(std::string <span class="type">const</span>&amp; state)</span><br><span class="line">            : <span class="built_in">m_state</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(std::string externalState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteFlyWeight: &quot;</span> &lt;&lt; m_state &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; externalState &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_state; <span class="comment">// 内部状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyWeightFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FlyWeight* <span class="title">getFlyWeight</span><span class="params">(std::string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_flyweights.<span class="built_in">find</span>(key) == m_flyweights.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            FlyWeight* flyweight = <span class="keyword">new</span> <span class="built_in">ConcreteFlyWeight</span>(key);</span><br><span class="line">            m_flyweights[key] = flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_flyweights[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, FlyWeight*&gt; m_flyweights;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="享元模式的设计题">享元模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1091">【设计模式专题之享元模式】12-图形编辑器 (kamacoder.com)</a>：</p>
<blockquote>
<p>在一个图形编辑器中，用户可以绘制不同类型的图形，包括圆形（CIRCLE）、矩形（RECTANGLE）、三角形（TRIANGLE）等。现在，请你实现一个图形绘制程序，要求能够共享相同类型的图形对象，以减少内存占用。</p>
<p>输入包含多行，每行表示一个绘制命令。每个命令包括两部分：</p>
<p>图形类型（Circle、Rectangle 或 Triangle）</p>
<p>绘制的坐标位置（两个整数，分别表示 x 和 y）</p>
<p>对于每个绘制命令，输出相应图形被绘制的位置信息。如果图形是首次绘制，输出 “drawn at”，否则输出 “shared at”。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/FlyWeight/main.cpp">FlyWeight/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/FlyWeight/main.cpp">FlyWeight/main.cpp(gitee.com)</a></p>
<h2 id="行为型设计模式">行为型设计模式</h2>
<h3 id="观察者模式">观察者模式</h3>
<p>观察者模式（发布-订阅模式）是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义了一种一对多的依赖关系，多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。</li>
</ul>
<p>观察者模式有两个角色：</p>
<ul>
<li>主题：被观察的对象，维护一组观察者，自身变化时通知观察者。</li>
<li>观察者：观察主题的对象，当主题发生变化，会得到通知。</li>
</ul>
<p>具体可以设计为四个角色：</p>
<ul>
<li>抽象主题：抽象类，提供注册、删除和通知观察者的方法，通常包含一个状态。</li>
<li>抽象观察者：抽象类，包含一个更新方法。</li>
<li>具体主题：主题的具体实现，维护一个观察者列表，实现抽象类的方法。</li>
<li>具体观察者：观察者的具体实现，每个具体观察者都注册到具体主题中，实现抽象类方法。</li>
</ul>
<p>观察者模式可以将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。</p>
<h4 id="观察者模式的使用情形">观察者模式的使用情形</h4>
<p>观察者模式特别适用于一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。</p>
<ul>
<li>图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于 GUl 框架，比如 Java 的 Swing 框架。</li>
<li>前端开发中，比较典型的例子是前端框架 Vue，当数据发生变化时，视图会自动更新。</li>
<li>分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。</li>
</ul>
<h4 id="观察者模式的实现">观察者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Observer.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer *observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer *observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ConcreteSubject</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer *observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">emplace_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer *observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer), observers.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObserver</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::string state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">        <span class="built_in">notifyObserver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer *&gt; observers;</span><br><span class="line">    std::string state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ConcreteObserver</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteObserver: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="观察者模式的设计题">观察者模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1075">【设计模式专题之观察者模式】13. 时间观察者 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明所在的学校有一个时钟（主题），每到整点时，它就会通知所有的学生（观察者）当前的时间，请你使用观察者模式实现这个时钟通知系统。</p>
<p>注意点：时间从 0 开始，并每隔一个小时更新一次。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示学生的数量。</p>
<p>接下来的 N 行，每行包含一个字符串，表示学生的姓名。</p>
<p>最后一行是一个整数，表示时钟更新的次数。</p>
<p>对于每一次时钟更新，输出每个学生的姓名和当前的时间。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Observer/main.cpp">Observer/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Observer/main.cpp">Observer/main.cpp(gitee.com)</a></p>
<h3 id="策略模式">策略模式</h3>
<p>策略模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义一系列算法（完成相同工作，实现不同），并将每个算法封装起来，可以相互替换，算法的变化不会影响使用算法的客户。</li>
</ul>
<p>策略模式的角色有：</p>
<ul>
<li>策略类：抽象类，定义所有支持的算法。</li>
<li>具体策略类：实现策略类的方法。</li>
<li>上下文类：包含一个策略实例，并在需要时调用策略对象方法。</li>
</ul>
<p>举个例子，电商网站对于商品的折扣策略有不同的算法，比如新用户满减优惠，不同等级会员的打折情况不同。</p>
<ul>
<li>
<p>一般情况下，产生大量的 if-e1se 语句，并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。</p>
</li>
<li>
<p>可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。</p>
</li>
</ul>
<h4 id="策略模式的使用情形">策略模式的使用情形</h4>
<p>使用策略模式的情形：</p>
<ul>
<li>
<p>当一个系统根据业务场景需要动态地在几种算法中选择一种时，例如，根据用户的行为选择不同的计费策略。</p>
</li>
<li>
<p>当代码中存在大量条件判断，条件判断的区别仅仅在于行为。</p>
</li>
</ul>
<p>在已有的工具库中，Java 标准库中的 Comparator 接口就使用了策略模式，通过实现这个接口，可以创建不同的比较器（指定不同的排序策略）来满足不同的排序需求。</p>
<h4 id="策略模式的实现">策略模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Strategy.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Called ConcreteStrategyA&#x27;s AlgorithmInterface&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Called ConcreteStrategyB&#x27;s AlgorithmInterface&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy)</span><br><span class="line">            : <span class="built_in">m_strategy</span>(strategy) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ContextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_strategy-&gt;<span class="built_in">AlgorithmInterface</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* m_strategy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="策略模式的设计题">策略模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1082">【设计模式专题之策略模式】14. 超市打折 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家的超市推出了不同的购物优惠策略，你可以根据自己的需求选择不同的优惠方式。其中，有两种主要的优惠策略：</p>
<ol>
<li>九折优惠策略：原价的90%。</li>
<li>满减优惠策略：购物满一定金额时，可以享受相应的减免优惠。</li>
</ol>
<p>具体的满减规则如下：</p>
<p>满100元减5元</p>
<p>满150元减15元</p>
<p>满200元减25元</p>
<p>满300元减40元</p>
<p>请你设计一个购物优惠系统，用户输入商品的原价和选择的优惠策略编号，系统输出计算后的价格。</p>
<p>输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示需要计算优惠的次数。</p>
<p>接下来的 N 行，每行输入两个整数，第一个整数M( 0 &lt; M &lt; 400) 表示商品的价格, 第二个整数表示优惠策略，1表示九折优惠策略，2表示满减优惠策略</p>
<p>每行输出一个数字，表示优惠后商品的价格</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Strategy/main.cpp">Strategy/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Strategy/main.cpp">Strategy/main.cpp(gitee.com)</a></p>
<h3 id="命令模式">命令模式</h3>
<p>命令模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>允许将请求封装成一个对象（命令对象，包含执行操作所需的所有信息），并将命令对象按照一定顺序存储在队列中，再逐一调用执行，命令支持反向操作、撤消重做。</li>
</ul>
<p>命令模式的角色有：</p>
<ul>
<li>抽象命令类：抽象类，定义执行操作的接口。</li>
<li>具体命令类：实现命令，执行具体操作。</li>
<li>接收者类：接受并执行命令的对象。</li>
<li>调用者：发起请求的对象。不关心命令的具体实现。</li>
</ul>
<p>使用时创建具体的命令对象和接收者对象，将其组装起来。</p>
<h4 id="命令模式的使用情形">命令模式的使用情形</h4>
<p>命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。</p>
<ul>
<li>
<p>撤销操作：需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。</p>
</li>
<li>
<p>队列请求：命令模式可以将请求排队，形成一个命令队列，依次执行命令。</p>
</li>
<li>
<p>可扩展性：可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。</p>
</li>
<li>
<p>但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。</p>
</li>
</ul>
<p>命令模式同样有着很多现实场景的应用：</p>
<ul>
<li>比如 Git 中的很多操作，如提交（commit）、合并（merge）等，都可以看作是命令模式的应用，用户通过执行相应的命令来操作版本库。</li>
<li>Java 的 GUI 编程中，很多事件处理机制也都使用了命令模式。例如，每个按钮都有一个关联的Action，它代表一个命令，按钮的点击触发 Action 的执行。</li>
</ul>
<h4 id="命令模式的实现">命令模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Receiver::action()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invoker</span>(Command *command)</span><br><span class="line">            : <span class="built_in">m_command</span>(command) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_command-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_command;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>(Receiver receiver)</span><br><span class="line">            : <span class="built_in">m_receiver</span>(receiver) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_receiver.<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver m_receiver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="命令模式的设计题">命令模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1093">【设计模式专题之命令模式】15-自助点餐机 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明去奶茶店买奶茶，他可以通过在自助点餐机上来点不同的饮品，请你使用命令模式设计一个程序，模拟这个自助点餐系统的功能。</p>
<p>输入第一行是一个整数 n（1 ≤ n ≤ 100），表示点单的数量。接下来的 n 行，每行包含一个字符串，表示点餐的饮品名称。</p>
<p>输出执行完所有点单后的制作情况，每行输出一种饮品的制作情况。如果制作完成，输出 “XXX is ready!”，其中 XXX 表示饮品名称。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Command/main.cpp">Command/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Command/main.cpp">Command/main.cpp(gitee.com)</a></p>
<h3 id="中介者模式">中介者模式</h3>
<p>中介者模式也称为调停者模式，是<strong>行为型设计模式</strong>。</p>
<ul>
<li>通过一个中介对象来封装一组对象之间的交互，从而使得这些对象之间不需要相互引用。</li>
</ul>
<p>中介者模式的角色有：</p>
<ul>
<li>抽象中介者：抽象类，定义中介者接口，用于各个具体同事对象之间的通信。</li>
<li>具体中介者：实现抽象类方法，协调各个具体同事对象的交互关系。</li>
<li>抽象同事类：抽象类，定义同事类接口，维护一个对中介者对象的引用，用于通信。</li>
<li>具体同事类：实现抽象类方法，每个具体同事类只知道自己的行为，不了解其他同事类的情况。</li>
</ul>
<h4 id="与代理模式区别">与代理模式区别</h4>
<p>中介者模式与代理模式在表述上类似，但是解决不同类型的问题：</p>
<ul>
<li>中介者模式通过一个中介者对象，使得系统中的<strong>其他对象通过中介者进行通信交互</strong>，降低了系统各个对象间的直接耦合。</li>
<li>代理模式通过一个代理类，使得客户端可以与目标对象进行通信，且可以在<strong>调用实际目标对象方法前后进行额外的操作</strong>，控制对象的访问。</li>
</ul>
<h4 id="中介者模式的使用情形">中介者模式的使用情形</h4>
<p>中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。</p>
<p>中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化，</p>
<h4 id="中介者模式的实现">中介者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Mediator.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(Colleague *colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">(std::string <span class="type">const</span> &amp;message, Colleague *colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Register</span><span class="params">(Colleague *colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_colleagues.<span class="built_in">push_back</span>(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string <span class="type">const</span> &amp;message, Colleague *colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;c : m_colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != colleague) &#123;</span><br><span class="line">                c-&gt;<span class="built_in">receive</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Colleague *&gt; m_colleagues;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Colleague</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Mediator *m_mediator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueA</span>(Mediator *mediator) &#123;</span><br><span class="line">        m_mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_mediator-&gt;<span class="built_in">Send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ColleagueA received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueB</span>(Mediator *mediator) &#123;</span><br><span class="line">        m_mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_mediator-&gt;<span class="built_in">Send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(std::string <span class="type">const</span> &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ColleagueB received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="中介者模式的设计题">中介者模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1094">【设计模式专题之中介者模式】16-简易聊天室 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明正在设计一个简单的多人聊天室系统，有多个用户和一个聊天室中介者，用户通过中介者进行聊天，请你帮他完成这个系统的设计。</p>
<p>第一行包括一个整数N,表示用户的数量（1 &lt;= N &lt;= 100) 第二行是N个用户，比如User1 User2 User3，用空格分隔。第三行开始，每行包含两个字符串，表示消息的发出者和消息内容，用空格分隔。</p>
<p>对于每个用户，输出一行，包含该用户收到的所有消息内容。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Mediator/main.cpp">Mediator/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Mediator/main.cpp">Mediator/main.cpp(gitee.com)</a></p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>备忘录模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>允许在不暴露对象实现的情况下捕获对象的内部状态并在对象之外保存这个状态，以便可以还原状态。</li>
</ul>
<p>备忘录的角色有：</p>
<ul>
<li>发起人：需要还原状态的对象，负责创建备忘录，使用备忘录记录。</li>
<li>备忘录：存储发起人对象的内部状态，包含发起人部分或全部状态信息，但对外不可见，仅发起人可见。</li>
<li>管理者：负责（一个或多个）存储备忘录对象，但不了解其内部结构。</li>
</ul>
<h4 id="备忘录模式的使用情形">备忘录模式的使用情形</h4>
<p>备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过备份对象往往会消耗较多的内存，资源消耗增加。</p>
<p>备忘录模式常常用来实现撤销和重做功能，比如在 Java Swing GUI 编程中，<code>javax.swing.undo</code> 包中的撤销（undo）和重做（redo）机制使用了备忘录模式。<code>UndoManager</code> 和 <code>UndoableEdit</code> 接口是与备忘录模式相关的主要类和接口。</p>
<h4 id="备忘录模式的实现">备忘录模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(std::string state)</span><br><span class="line">            : <span class="built_in">m_state</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::string state)</span> </span>&#123;</span><br><span class="line">        m_state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento *<span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Memento</span>(m_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restoreFromMemento</span><span class="params">(Memento *memento)</span> </span>&#123;</span><br><span class="line">        m_state = memento-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMemento</span><span class="params">(Memento *memento)</span> </span>&#123;</span><br><span class="line">        m_mementos.<span class="built_in">emplace_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento *<span class="title">getMemento</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt; m_mementos.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> m_mementos[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Memento *&gt; m_mementos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="备忘录模式的设计题">备忘录模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1095">【设计模式专题之备忘录模式】17-redo计数器应用 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明正在设计一个简单的计数器应用，支持增加（Increment）和减少（Decrement）操作，以及撤销（Undo）和重做（Redo）操作，请你使用备忘录模式帮他实现。</p>
<p>输入包含若干行，每行包含一个字符串，表示计数器应用的操作，操作包括 “Increment”、“Decrement”、“Undo” 和 “Redo”。</p>
<p>对于每个 “Increment” 和 “Decrement” 操作，输出当前计数器的值，计数器数值从0开始 对于每个 “Undo” 操作，输出撤销后的计数器值。 对于每个 “Redo” 操作，输出重做后的计数器值。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Memento/main.cpp">Memento/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Memento/main.cpp">Memento/main.cpp(gitee.com)</a></p>
<h3 id="模板方法模式">模板方法模式</h3>
<p>模板方法模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义一个算法骨架，将一些步骤的实现延迟到子类。</li>
</ul>
<p>模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>举个简单的例子，做一道菜通常都需要包含至少三步：准备食材；亨饪过程；上菜。</p>
<p>不同菜品的亨饪过程是不一样的，但是可以先定义一个“骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。</p>
<p>模板方法模式的角色有：</p>
<ul>
<li>模板类：一个模板方法和若干个基本方法构成。
<ul>
<li>模板方法定义逻辑的骨架，按照顺序调用包含的基本方法。</li>
<li>基本方法通常是抽象方法，由子类实现。</li>
<li>基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，可以在具体子类中继承或重写。</li>
</ul>
</li>
<li>具体类：继承自模板类，实现在模板类中定义的抽象方法。</li>
</ul>
<h4 id="模板方法模式的使用情形">模板方法模式的使用情形</h4>
<p>模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。</p>
<p>总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板方法模式来处理。如：</p>
<ul>
<li>Spring 框架中的 <code>JdbcTemplate</code> 类使用了模板方法模式，其中定义了一些执行数据库操作的模板方法，具体的数据库操作由回调函数提供。</li>
<li>Java 的 JDK 源码中，<code>AbstractList</code> 类也使用了模板方法模式，它提供了一些通用的方法，其中包括一些模板方法。具体的列表操作由子类实现。</li>
</ul>
<h4 id="模板方法模式的实现">模板方法模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">step1</span>();</span><br><span class="line">        <span class="built_in">step2</span>();</span><br><span class="line">        <span class="built_in">step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step3</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 3\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="模板方法模式的设计题">模板方法模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1087">【设计模式专题之模板方法模式】18-咖啡馆 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。</p>
<p>咖啡制作过程包括以下步骤：</p>
<ol>
<li>研磨咖啡豆 Grinding coffee beans</li>
<li>冲泡咖啡 Brewing coffee</li>
<li>添加调料 Adding condiments</li>
</ol>
<p>其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk。</p>
<p>多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。</p>
<p>根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/TemplateMethod/main.cpp">TemplateMethod/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/TemplateMethod/main.cpp">TemplateMethod/main.cpp(gitee.com)</a></p>
<h3 id="迭代器模式">迭代器模式</h3>
<p>迭代器模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>提供一种统一的方式访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。</li>
</ul>
<p>迭代器模式的角色有：</p>
<ul>
<li>迭代器抽象类：定义访问和遍历元素的接口。</li>
<li>具体迭代器：实现抽象迭代器。</li>
<li>抽象聚合类：定义创建迭代器接口，创建迭代器对象。</li>
<li>具体聚合类：实现抽象聚合类方法。</li>
</ul>
<h4 id="迭代器模式的使用情形">迭代器模式的使用情形</h4>
<p>迭代器模式使用很广泛。客户端不需要知道集合的内部结构，只需要关心迭代器和迭代器接口就可以完成元素的访问。如：</p>
<ul>
<li>Java 的集合类，<code>ArrayList</code>、<code>LinkedList</code>。</li>
<li>Python 的 <code>iter()</code> 、 <code>next()</code>。</li>
<li>C++ 中 STL 的迭代器，<code>begin()</code>、<code>end()</code>。</li>
</ul>
<h4 id="迭代器模式的实现">迭代器模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterator</span>(std::vector&lt;T&gt; elements)</span><br><span class="line">            : <span class="built_in">m_elements</span>(elements)</span><br><span class="line">            , m_idx = <span class="number">0</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="type">bool</span> <span class="built_in">hasNext</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_idx &lt; m_elements.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_elements[m_idx++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_idx;</span><br><span class="line">    std::vector&lt;T&gt; m_elements;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象聚合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator&lt;T&gt; *<span class="title">createIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体聚合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterable</span> : <span class="keyword">public</span> Iterable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterable</span>(std::vector&lt;T&gt; elements)</span><br><span class="line">            : <span class="built_in">m_elements</span>(elements) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; *<span class="title">createIterator</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>(m_elements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; m_elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器模式的设计题">迭代器模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1099">【设计模式专题之迭代器模式】19-学生名单 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明是一位老师，在进行班级点名时，希望有一个学生名单系统，请你实现迭代器模式提供一个迭代器使得可以按顺序遍历学生列表。</p>
<p>第一行是一个整数 N （1 &lt;= N &lt;= 100), 表示学生的数量。</p>
<p>接下来的 N 行，每行包含一个学生的信息，格式为 姓名 学号</p>
<p>输出班级点名的结果，即按顺序遍历学生列表，输出学生的姓名和学号</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Iterator/main.cpp">Iterator/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Iterator/main.cpp">Iterator/main.cpp(gitee.com)</a></p>
<h3 id="状态模式">状态模式</h3>
<p>状态模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>将对象每个状态的行为封装在一个具体类中，使得每个状态类相互独立，对象从而可以在运行时动态改变。</li>
</ul>
<p>状态模式的角色有：</p>
<ul>
<li>抽象状态类：抽象类，封装 Context 的一个特定状态相关的行为。</li>
<li>具体状态类：为每一个具体状态实现一个行为。</li>
<li>Context 类：维护一个具体状态的子类实例，实例定义当前状态。</li>
</ul>
<h4 id="状态模式的使用情形">状态模式的使用情形</h4>
<p>适用于一个对象在不同状态下有不同的行为。</p>
<p>适用于有限状态机的场景，其中对象的行为在运行时可以根据内部状态的改变而改变。</p>
<p>在游戏开发中，Unity 3D 的 Animator 控制器就是一个状态机。它允许开发人员定义不同的状态（动画状态），并通过状态转换来实现角色的动画控制和行为切换。</p>
<h4 id="状态模式的实现">状态模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;状态A下的操作\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;状态B下的操作\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(State *state)</span> </span>&#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">handle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *currentState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="状态模式的设计题">状态模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1097">【设计模式专题之状态模式】20-开关台灯 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（“ON”）、关闭（“OFF”）和闪烁（“blink”）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。</p>
<p>第一行是一个整数 n（1 &lt;= n &lt;= 1000），表示接收的命令数量。</p>
<p>接下来的 n 行，每行包含一个字符串 s，表示一个命令（“ON”、“OFF&quot;或&quot;blink”）。</p>
<p>对于每个命令，输出一行，表示执行该命令后灯泡的状态。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/State/main.cpp">State/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/State/main.cpp">State/main.cpp(gitee.com)</a></p>
<h3 id="责任链模式">责任链模式</h3>
<p>责任链模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>允许构建一个对象链，请求从链的一端进入，沿着链上的对象依次处理，直至链上某个对象能够处理该请求。</li>
</ul>
<p>责任链模式的角色有：</p>
<ul>
<li>处理者：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一处理者的链接。</li>
<li>具体处理者：实现处理请求的方法，判断能否处理，能处理则处理，否则传递下一处理者。</li>
</ul>
<h4 id="责任链模式的使用情形">责任链模式的使用情形</h4>
<p>责任链模式优点有：</p>
<ul>
<li>
<p>降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与自己相关的请求，客户端不需要知道具体是哪个处理者处理请求。</p>
</li>
<li>
<p>增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满足不同需求。</p>
</li>
</ul>
<p>但是由于一个请求可能会经过多个处理者，这可能会导致一些性能问题，并且如果整个链上也没有合适的处理者来处理请求，就会导致请求无法被处理。</p>
<p>实际使用有 Java 开发中过滤器的链式处理，以及 Spring 框架中的拦截器，都组装成一个处理链对请求、响应进行处理。</p>
<h4 id="责任链模式的实现">责任链模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> requestId)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(Handler *next)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Handler *m_nextHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandle</span>(requestId)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ConcreteHandler::handleRequest() &quot;</span> &lt;&lt; requestId &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_nextHandler-&gt;<span class="built_in">handleRequest</span>(requestId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无法处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="built_in">setNextHandler</span>(Handler *next) &#123;</span><br><span class="line">        m_nextHandler = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">int</span> requestId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据具体情况判断是否能处理请求</span></span><br><span class="line">        <span class="keyword">return</span> requestId &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="责任链模式的设计题">责任链模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1100">【设计模式专题之责任链模式】21-请假审批 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。</p>
<p>审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。</p>
<p>第一行是一个整数N（1 &lt;= N &lt;= 100), 表示请求申请的数量。</p>
<p>接下来的N行，每行包括一个请求申请的信息，格式为&quot;姓名 请假天数&quot;</p>
<p>对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/ResponsibilityChain/main.cpp">ResponsibilityChain/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/ResponsibilityChain/main.cpp">ResponsibilityChain/main.cpp(gitee.com)</a></p>
<h3 id="解释器模式">解释器模式</h3>
<p>解释器模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>定义了语言的文法，并且建立一个解释器解释句子。</li>
</ul>
<p>解释器模式的角色有：</p>
<ul>
<li>抽象表达式：定义了解释器抽象类，包含解释器方法。</li>
<li>终结符表达式：语法中不能再分解为更小单元的符号。</li>
<li>非终结符表达式：复杂表达式，由终结符和其他非终结符组成。</li>
<li>上下文：解释器之外的全局信息，存储解释器中间结果，也可以向解释器传递信息。</li>
</ul>
<p>比如表达式 <code>1+1</code>，数字 <code>1</code> 是终结符，而运算符 <code>+</code> 需要两个操作数，属于非终结符。</p>
<h4 id="解释器模式的使用情形">解释器模式的使用情形</h4>
<p>当需要解释和执行特定领域或业务规则的语言时，可以使用解释器模式。例如：</p>
<ul>
<li>SQL 解释器;</li>
<li>正则表达式解释器。</li>
</ul>
<p>但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使用要慎重。</p>
<h4 id="解释器模式的实现">解释器模式的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TerminalExpression</span>(<span class="type">int</span> value)</span><br><span class="line">            : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式，此处举例为加法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(Expression *left, Expression *right)</span><br><span class="line">            : <span class="built_in">m_left</span>(left)</span><br><span class="line">            , <span class="built_in">m_right</span>(right) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_left-&gt;<span class="built_in">interpret</span>() + m_right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Expression *m_left;</span><br><span class="line">    Expression *m_right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 存储一些全局信息或状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解释器模式的设计题">解释器模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1096">【设计模式专题之解释器模式】22-数学表达式 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明正在设计一个计算器，用于解释用户输入的简单数学表达式，每个表达式都是由整数、加法操作符+、乘法操作符组成的，表达式中的元素之间用空格分隔，请你使用解释器模式帮他实现这个系统。</p>
<p>每行包含一个数学表达式，表达式中包含整数、加法操作符（+）和乘法操作符（*）。 表达式中的元素之间用空格分隔。</p>
<p>对于每个输入的数学表达式，每行输出一个整数，表示对应表达式的计算结果。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Interpreter/main.cpp">Interpreter/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Interpreter/main.cpp">Interpreter/main.cpp(gitee.com)</a></p>
<h3 id="访问者模式">访问者模式</h3>
<p>访问者模式是<strong>行为型设计模式</strong>。</p>
<ul>
<li>在不改变对象结构的前提下，对对象中的元素进行新的操作。</li>
</ul>
<p>访问者模式的角色有：</p>
<ul>
<li>抽象访问者：抽象类，声明访问者可以访问的元素，以及声明访问方法。</li>
<li>具体访问者：实现了抽象类的方法。</li>
<li>抽象元素：定义方法接受访问者的访问。</li>
<li>具体元素：实现抽象元素的方法。</li>
<li>对象结构：元素的集合，负责遍历元素，并调用元素的接受方法。</li>
</ul>
<h4 id="访问者模式的使用情形">访问者模式的使用情形</h4>
<p>访问者模式结构较为复杂，但是访问者模式将同一类操作封装在一个访问者中，使得相关的操作彼此集中，提高了代码的可读性和维护性。</p>
<p>常用于对象结构比较稳定，但经常需要在此对象结构上定义新的操作，这样就无需修改现有的元素类，只需要定义新的访问者来添加新的操作。</p>
<h4 id="访问者模式的实现">访问者模式的实现</h4>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/designpattern_Visitor.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象元素类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA *element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB *element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorA</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorA visit ConcreElementA\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorA visit ConcreElementB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorB</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorB visit ConcreElementA\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB *element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorB visit ConcreElementB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Element *element)</span> </span>&#123;</span><br><span class="line">        m_elements.<span class="built_in">emplace_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Element *element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(m_elements.<span class="built_in">begin</span>(), m_elements.<span class="built_in">end</span>(), element);</span><br><span class="line">        <span class="keyword">if</span> (it != m_elements.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            m_elements.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element *element : m_elements) &#123;</span><br><span class="line">            element-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Element *&gt; m_elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="访问者模式的设计题">访问者模式的设计题</h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1098">【设计模式专题之访问者模式】23-图形的面积 (kamacoder.com)</a>：</p>
<blockquote>
<p>小明家有一些圆形和长方形面积的土地，请你帮他实现一个访问者模式，使得可以通过访问者计算每块土地的面积。</p>
<p>图形的面积计算规则如下：</p>
<ul>
<li>圆形的面积计算公式为：3.14 * 半径 * 半径</li>
<li>矩形的面积计算公式为：长 * 宽</li>
</ul>
<p>第一行是一个整数 n（1 &lt;= n &lt;= 1000），表示图形的数量。</p>
<p>接下来的 n 行，每行描述一个图形，格式为 “Circle r” 或 “Rectangle width height”，其中 r、width、height 是正整数。</p>
<p>对于每个图形，输出一行，表示该图形的面积。</p>
</blockquote>
<p>参考代码：</p>
<p><a href="https://github.com/Fingsinz/Patterns/blob/master/Visitor/main.cpp">Visitor/main.cpp(github.com)</a></p>
<p><a href="https://gitee.com/fingsinz/design-patterns-in-cpp/blob/master/Visitor/main.cpp">Visitor/main.cpp(gitee.com)</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>个人整理的C++学习路线</title>
    <url>/2023/cpproad/</url>
    <content><![CDATA[<p>个人整理的C++大概学习路线</p>
<p>关键词：C++</p>
<span id="more"></span>
<hr>
<p><em>by：Fingsinz，Reference：<a href="https://roadmap.sh/cpp">C++ Developer Roadmap</a></em></p>
<h2 id="c-语言介绍">C++ 语言介绍</h2>
<h3 id="什么是c">什么是C++</h3>
<ul>
<li>
<p>C++作为C编程语言的扩展，提供了类和继承等面向对象的特性。</p>
</li>
<li>
<p>C++被广泛应用于游戏开发、系统编程、嵌入式系统和高性能计算等各种应用中。</p>
</li>
<li>
<p>C++是一种静态类型语言，这意味着变量的类型是在编译过程中确定的，并且C++有一个称为C++标准库的扩展库，它为各种任务提供了一组丰富的函数、算法和数据结构。</p>
</li>
</ul>
<h3 id="为什么使用c">为什么使用C++</h3>
<ul>
<li>
<p>高性能：C++旨在提供高性能和高效率。它提供了对系统资源的细粒度控制，使优化软件变得更容易。</p>
</li>
<li>
<p>可移植性：不同的计算机体系结构和操作系统都支持C++，允许您编写在各种平台上运行的可移植代码，而无需进行重大修改。</p>
</li>
<li>
<p>面向对象编程：C++支持面向对象编程(OOP)——一种允许您使用类和对象设计程序的范例，从而实现更好的代码组织和可重用性。</p>
</li>
<li>
<p>支持低级和高级编程：C++允许您编写低级代码，如内存操作，以及高级抽象，如创建类和使用标准模板库(STL)。</p>
</li>
<li>
<p>丰富的库支持：C++提供了大量的库和工具，如标准模板库(STL)、Boost和Qt等，它们可以帮助您开发项目并使其更高效。</p>
</li>
<li>
<p>兼容C语言：C++可以与C结合使用，提供两种语言的功能，并允许您重用现有的C代码。通过合并C++特性，您可以增强代码并改进其功能。</p>
</li>
<li>
<p>活跃的社区支持：C++已经存在了很长一段时间，并且拥有一个庞大而活跃的用户社区，他们为语言的发展做出了贡献，表达了新的想法，并参与了有助于语言进一步发展的讨论。这让你更容易找到解决问题的方法。</p>
</li>
</ul>
<h3 id="c和c-的区别">C和C++的区别</h3>
<ul>
<li>语法语义区别、代码可重用性和模块化、错误处理</li>
</ul>
<h3 id="c-版本">C++版本</h3>
<ul>
<li>
<p>C++0x：指的是C++ 11的工作名称，在其最终发布之前，它以前被称为C++ 0x。C++ 11是2011年发布的C++语言标准的主要修订版，它为该语言带来了几个新特性和改进。</p>
<ul>
<li><code>auto</code>、基于范围的循环：<code>for(int i : array)</code>、匿名Lambda函数、<code>nullptr</code>、右值引用和移动语义、可变模板、静态判断<code>assert</code>、支持线程</li>
</ul>
</li>
<li>
<p>C++14：指的是2014年发布的C++版本。</p>
<ul>
<li>范式Lambda、<code>decltype</code>关键字、可变模板</li>
</ul>
</li>
<li>
<p>C++17：也称为C++ 1z，是2017年12月发布的C++编程语言版本。</p>
<ul>
<li>if中的初始化：<code>if(auto x = map.find(key); x != map.end())</code>、结构化绑定声明、<code>inline</code>变量、折叠表达式、<code>constexpr if </code>语句、改进Lambda表达式、标准文件系统库、<code>string_view</code>标准库、对标准库算法支持并行运算</li>
</ul>
</li>
<li>
<p>C++20：C++ 20是2020年发布的C++版本。</p>
<ul>
<li><code>concept</code>关键字；基于范围的处理序列；协同程序；<code>constexpr</code>和<code>consteval</code>关键字：带有<code>constexpr</code>标记的函数可以在编译时或运行时执行，而带有<code>consteval</code>标记的函数只能在编译时执行；最新C++</li>
</ul>
</li>
</ul>
<h2 id="配置c-开发环境">配置C++开发环境</h2>
<h3 id="安装c">安装C++</h3>
<ul>
<li>在开始用C++编程之前，您需要在系统上安装一个编译器。编译器是一个将你写的C++代码转换成计算机可以运行的可执行文件的程序。</li>
</ul>
<h3 id="编译器">编译器</h3>
<ul>
<li>
<p>编译器是一种计算机程序，它将用一种编程语言编写的源代码翻译成另一种语言，通常是机器代码或汇编代码，可以由计算机处理器直接执行。在c++环境中，编译器将您编写的c++源代码转换为可执行程序。</p>
</li>
<li>
<p>常见编译器</p>
<ul>
<li>GNU Compiler Collection（GCC）、Clang、Microsoft Visual C++（MSVC）、Intel C++ Compiler（ICC）</li>
</ul>
</li>
<li>
<p>编译器状态：C++的编译过程可以分为四个主要阶段：预处理、编译、汇编和链接。每个阶段执行一个特定的任务，最终将源代码转换为可执行程序。</p>
<ul>
<li>
<p>预处理（Preprocessing）：第一个阶段是源代码的预处理。预处理器在实际编译过程之前修改源代码。在这个阶段，将展开包含的头文件，替换宏，并处理条件编译语句。</p>
</li>
<li>
<p>编译（Compilation）：第二阶段是实际编译经过预处理的源代码。编译器将修改后的源代码转换为中间表示形式，通常特定于目标处理器体系结构。此步骤还包括执行语法检查、语义分析，并为源代码中遇到的任何问题生成错误消息。</p>
</li>
<li>
<p>汇编（Assembly）：第三阶段是将编译器的中间表示转换成汇编语言。此阶段使用特定于目标处理器体系结构的助记符和语法生成汇编代码。然后，汇编程序将该汇编代码转换为目标代码(机器代码)。</p>
</li>
<li>
<p>链接（Link）：第四阶段是将目标代码与必要的库和其他目标文件链接起来。在此阶段，链接器合并多个目标文件和库，解析来自其他模块或库的外部引用，为函数和变量分配内存地址，并生成可在目标平台上运行的可执行文件。</p>
</li>
</ul>
</li>
</ul>
<h3 id="编辑器-集成开发环境-ide">编辑器、集成开发环境（IDE）</h3>
<ul>
<li>
<p>代码编辑器是专门为编辑、管理和编写源代码而设计的程序。它们提供了广泛的功能，使开发过程更容易和更快。</p>
</li>
<li>
<p>Visual Studio、Visual Studio Code、CLion、Sublime Text、CodeBlock</p>
</li>
</ul>
<h3 id="运行第一个c-程序">运行第一个C++程序</h3>
<ul>
<li>Hello_World.cpp</li>
</ul>
<h2 id="基础语法">基础语法</h2>
<h3 id="基础操作">基础操作</h3>
<ul>
<li>
<p>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>++</code>、<code>--</code></p>
</li>
<li>
<p>逻辑运算符：<code>and</code>（<code>&amp;&amp;</code>）、<code>or</code>（<code>||</code>）、<code>not</code>（<code>!</code>）</p>
</li>
<li>
<p>位运算符：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>~</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code></p>
</li>
<li>
<p>条件：<code>if</code>/<code>switch</code></p>
</li>
<li>
<p>循环：<code>for</code>/<code>while</code></p>
</li>
</ul>
<h3 id="函数">函数</h3>
<ul>
<li>
<p>函数声明：仅有返回类型、函数名称和参数。</p>
</li>
<li>
<p>函数定义：具有详细的函数体。</p>
</li>
<li>
<p>函数原型：函数原型是没有函数体的函数声明，它告诉编译器函数的名称、返回类型和参数。</p>
</li>
<li>
<p>普通函数：函数是执行特定任务的一组语句，在程序中组织为一个单独的单元。</p>
<ul>
<li>标准库函数、自定义函数</li>
</ul>
</li>
<li>
<p>运算符函数</p>
<ul>
<li>
<p>C++中的运算符是对数据执行各种操作的符号，如算术、比较和逻辑操作。它们用于操作和计算表达式和变量。</p>
</li>
<li>
<p>赋值运算符；逻辑运算符；关系运算符；算术运算符</p>
</li>
</ul>
</li>
<li>
<p>Lamda匿名函数</p>
</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>
<p>静态数据类型</p>
<ul>
<li>意味着变量的数据类型是在编译时，在程序执行之前确定的。</li>
</ul>
</li>
<li>
<p>动态数据类型</p>
<ul>
<li>
<p>意味着在运行时确定变量的数据类型。</p>
</li>
<li>
<p><code>void*</code>指针：<code>void*</code>指针是一种泛型指针，可以指向任何数据类型的对象。它们可以用于存储对任何类型对象的引用，而无需知道对象的特定类型。</p>
</li>
<li>
<p><code>std::any</code>（C++17）：<code>std::any</code>类，它代表了任何类型的单个值的广义类型安全容器。</p>
</li>
<li>
<p><code>void*</code>指针和<code>std::any</code>都有性能影响，因为在运行时进行了额外的类型检查和类型转换。它们应该谨慎使用，只有在绝对必要的时候才使用。</p>
</li>
</ul>
</li>
<li>
<p>运行时类型标识RTTI</p>
<ul>
<li>
<p>允许在程序执行期间获取对象的类型信息。这在使用动态类型时非常有用，因为对象的类型可以在运行时更改。</p>
</li>
<li>
<p><code>typeid</code>操作符、<code>dynamic_cast</code>操作符</p>
</li>
<li>
<p>使用RTTI可能会有一些性能开销，因为它需要在运行时存储和处理编译器生成的额外信息。</p>
</li>
</ul>
</li>
</ul>
<h3 id="指针和引用">指针和引用</h3>
<ul>
<li>
<p>普通指针：字符指针、整型指针、浮点型指针、结构体指针、函数指针……</p>
</li>
<li>
<p>原始指针</p>
<ul>
<li>
<p>原始指针是直接保存内存地址的低级结构。它们可以用于手动分配内存、创建动态数组和有效地传递值等。</p>
</li>
<li>
<p><code>new</code>/<code>delete</code>操作符</p>
</li>
<li>
<p>内存泄漏</p>
</li>
</ul>
</li>
<li>
<p>智能指针</p>
<ul>
<li><code>unique_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code></li>
</ul>
</li>
<li>
<p>内存模型</p>
<ul>
<li>栈内存、堆内存、数据段、代码段</li>
</ul>
</li>
<li>
<p>对象生存期</p>
<ul>
<li>静态存储持续期、线程存储持续期、自动存储持续期、动态存储持续期</li>
</ul>
</li>
<li>
<p>引用</p>
</li>
</ul>
<h3 id="结构体和类">结构体和类</h3>
<ul>
<li>
<p>面向对象编程：类、封装、继承多态</p>
</li>
<li>
<p>静态多态</p>
<ul>
<li>
<p>静态多态性，也称为编译时多态性，是一种在编译时而不是在运行时解析类型和方法调用的多态性。这通常是通过使用C++中的函数重载和模板来实现的。</p>
</li>
<li>
<p>函数重载：一种创建具有相同名称但不同参数列表的多个函数的方法。编译器根据调用函数时使用的参数类型和数量确定要调用的正确函数。</p>
</li>
<li>
<p>模板：允许创建泛型函数或类。特定类型的实际代码是在编译时生成的，这避免了运行时多态的开销。模板的使用是c++中实现静态多态性的主要技术。</p>
</li>
</ul>
</li>
<li>
<p>动态多态</p>
<ul>
<li>
<p>动态多态性是通过虚函数实现的，虚函数是用virtual关键字标记的基类的成员函数。在基类中指定虚函数时，可以在任何派生类中重写虚函数，以提供不同的实现。</p>
</li>
<li>
<p>虚函数：在基类的方法声明中使用virtual关键字。这告诉编译器该方法应该被视为虚方法，允许它被派生类覆盖。</p>
</li>
<li>
<p>虚表：虚表(或Vtable)是C++编译器用来支持动态多态性的一种机制。在动态多态性中，根据实际的对象类型，在运行时调用适当的函数。</p>
</li>
</ul>
</li>
<li>
<p>多继承：一个类可以从多个父类继承特征（数据成员和成员函数），一个类可以有多个基类。</p>
</li>
<li>
<p>菱形继承：一个类派生自两个或多个类，而这些类又派生自一个公共基类</p>
</li>
</ul>
<h3 id="构建代码库">构建代码库</h3>
<ul>
<li>
<p>代码分割、代码风格、头文件和Cpp文件、头文件警卫、命名空间</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>全局作用域、局部作用域、名称空间作用域、类作用域</li>
</ul>
</li>
<li>
<p>前向声明：类前向声明、函数前向声明、枚举和<code>typedef</code>前向声明</p>
</li>
</ul>
<h2 id="语言概念">语言概念</h2>
<h3 id="习惯术语">习惯术语</h3>
<ul>
<li>
<p>auto关键字：用于自动类型推导。</p>
</li>
<li>
<p>类型转换：<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code></p>
</li>
<li>
<p>未定义行为：指由于违反语言规则而无法预测程序行为的情况。</p>
</li>
<li>
<p>参数依赖查找、命名修饰、宏定义、定义并初始化（资源获取即初始化RAII）、指针到实现（Pimpl）、奇异递归模板模式（CRTP）、不可复制/不可移动、擦除、复制和交换、惰性复制</p>
</li>
</ul>
<h3 id="调试器">调试器</h3>
<ul>
<li>
<p>理解调试信息：错误、警告、通知</p>
</li>
<li>
<p>调试器符号：内部调试符号、外部调试符号。</p>
</li>
<li>
<p>WinDbg：一个功能强大的Windows应用程序调试器。</p>
</li>
<li>
<p>GDB：GNU Project Debugger，一个功能强大的命令行调试器。</p>
</li>
</ul>
<h3 id="构建系统">构建系统</h3>
<ul>
<li>Cmake、Makefile、Ninja</li>
</ul>
<h2 id="异常处理">异常处理</h2>
<h3 id="异常">异常</h3>
<ul>
<li>
<p><code>try</code>关键字：定义应该监视异常的代码块</p>
</li>
<li>
<p><code>catch</code>关键字：指定要捕获的异常类型以及异常发生时应执行的代码块。</p>
</li>
<li>
<p><code>throw</code>关键字：抛出一个异常，该异常将被捕获并由适当的捕获块处理</p>
</li>
<li>
<p><code>noexcept</code>关键字：指定一个函数，该函数不会抛出异常，也不会在其作用域中抛出异常时终止程序。</p>
</li>
</ul>
<h3 id="标准异常">标准异常</h3>
<ul>
<li>
<p><code>std::exception</code>：所有标准异常的基类。</p>
</li>
<li>
<p><code>std::logic_error</code>：表示程序可以静态检测到的错误。</p>
</li>
<li>
<p><code>std::runtime_error</code>：表示程序执行期间发生的错误。</p>
</li>
</ul>
<h3 id="退出代码">退出代码</h3>
<ul>
<li>
<p>退出码，也称为“返回码”或“状态码”，是程序完成执行后返回给调用环境(通常是操作系统)的数值。这些代码用于指示程序执行的成功或失败。</p>
</li>
<li>
<p>0是成功执行的标准退出代码，而非零退出代码通常表示错误或其他异常情况。非零退出码的实际含义在不同的应用程序或系统之间可能有所不同。</p>
</li>
<li>
<p>在C++中，您可以使用<code>return</code>语句从<code>main</code>函数返回退出代码，也可以使用<code>exit()</code>函数，它是C++标准库的一部分。</p>
</li>
</ul>
<h3 id="访问冲突">访问冲突</h3>
<ul>
<li>
<p>访问冲突是程序试图访问非法内存位置时发生的一种特定类型的错误。</p>
</li>
<li>
<p>可能引起原因：取消引用空指针或无效指针；访问数组越界；对由用户或操作系统释放的内存进行阅读或写。</p>
</li>
</ul>
<h2 id="标准模板库stl">标准模板库STL</h2>
<h3 id="标准输入输出流">标准输入输出流</h3>
<ul>
<li><code>iostream</code>是C++标准库中的一个头文件，它提供了基本输入和输出(I/O)操作的功能。I/O流促进了程序与各种源(如控制台、文件或其他程序)之间的通信。</li>
</ul>
<h3 id="处理日期和时间">处理日期和时间</h3>
<ul>
<li>使用<code>chrono</code>库来处理日期和时间，它是标准库(Standard library, STL)的一部分。<code>chrono</code>库提供了各种数据类型和函数来表示和操作时间持续时间、时间点和时钟。</li>
</ul>
<h3 id="算法">算法</h3>
<ul>
<li>C++中的标准模板库(Standard Template Library, STL)提供了一组泛型算法，用于处理各种容器类。这些算法是作为函数实现的，可以应用于不同的数据结构，如数组、向量、列表等。算法的主要头文件是<code>&lt;algorithm&gt;</code></li>
</ul>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>
<p>迭代器是C++标准库(STL)中的对象，帮助我们遍历数组、列表和向量等容器。本质上，它们充当容器类和算法之间的桥梁。迭代器的行为类似于指针，但提供了一种更通用和抽象的方式来访问容器中的元素。</p>
</li>
<li>
<p>输入迭代器、输出迭代器、前向迭代器、反向迭代器、双向迭代器、随机访问迭代器</p>
</li>
</ul>
<h3 id="容器">容器</h3>
<ul>
<li>Pair对、Vector向量、List列表、String字符串、Stack栈、Queue队列、Deque双向队列、Priority_queue优先队列、Set集合（unordered_set、multiset、unordered_multiset）、Map映射（unordered_map、multimap、unordered_multimap）、Bitset压位</li>
</ul>
<h3 id="多线程">多线程</h3>
<ul>
<li>
<p>多线程是指在单个进程或程序中并发执行多个线程。它允许并行执行多个任务，从而提高了应用程序的性能和效率。</p>
</li>
<li>
<p>线程创建、带参数线程、互斥锁和锁</p>
</li>
</ul>
<h2 id="模板编程">模板编程</h2>
<h3 id="可变模板">可变模板</h3>
<ul>
<li>可变模板是C++ 11中的一个特性，它允许定义具有可变数量参数的模板。当您需要编写一个可以接受不同数量和类型参数的函数或类时，这尤其有用。</li>
</ul>
<h3 id="模板专门化">模板专门化</h3>
<ul>
<li>
<p>全模板专门化：完全模板专门化允许在与特定类型参数集一起使用时为模板提供特定的实现或行为。</p>
</li>
<li>
<p>部分模板专门化：允许为可能的类型参数的子集专门化模板。当希望为特定类型组提供自定义实现，而不必为该组中的所有类型定义单独的专门化时，它特别有用。</p>
</li>
</ul>
<h3 id="类型特征">类型特征</h3>
<ul>
<li>类型特征是C++中的一组模板类，可以帮助获取有关类型属性、行为或特征的信息。它们可以在<code>&lt;type_traits&gt;</code>头文件中找到。通过使用Type Traits，可以根据给定类型的属性来调整代码，甚至可以在模板代码中为类型参数强制执行特定的属性。</li>
</ul>
<h3 id="替换失败不是错误-sfinae">替换失败不是错误（SFINAE）</h3>
<ul>
<li>
<p>SFINAE是C++模板元编程中的一个原则，它允许编译器在替换过程中特定模板特化失败时选择适当的函数或类。术语“替换失败”是指编译器试图将模板参数替换为函数模板或类模板的过程。如果替换导致错误，编译器不会将特定的专门化视为候选专门化，而是继续搜索有效的专门化。</p>
</li>
<li>
<p>SFINAE背后的关键思想是，如果发生替换错误，它将被静默地忽略，编译器将继续探索其他模板专门化或重载。这允许编写更灵活和通用的代码，因为它使能够针对不同的场景拥有多个专门化。</p>
</li>
</ul>
<h2 id="包管理">包管理</h2>
<ul>
<li>
<p>包管理器是自动化安装、升级和管理编程语言(如C++)软件(库、框架和其他依赖项)过程的工具</p>
</li>
<li>
<p>vcpkg、Spack、Conan、NuGet</p>
</li>
</ul>
<h2 id="库和框架编程">库和框架编程</h2>
<ul>
<li>
<p>在使用C++时，可能需要使用外部库来协助完成各种任务。库是预编译的代码片段，可以在程序中重用，以执行特定任务或提供特定功能。在C++中，库可以是静态库(.lib)或动态库(Windows中的.dll, Unix/Linux中的.so)。</p>
</li>
<li>
<p>静态库：在编译时被合并到程序中。它们与代码链接，创建更大的可执行文件，但在运行时不需要任何外部文件。</p>
</li>
<li>
<p>动态库：动态库是在运行时加载的，这意味着可执行文件只包含对这些库的引用。这些库需要在运行程序的系统上可用。</p>
</li>
</ul>
<h3 id="c-库">C++库</h3>
<ul>
<li>OpenCV、POCO、protobuf、gRPC、Tensorflow、pybind11、spdlog、OpenCL、ranges_v3、fmt、Boost</li>
</ul>
<h3 id="框架">框架</h3>
<ul>
<li>gtest/gmock、Qt、Catch2、Orbit Profiler、PyTorch C++</li>
</ul>
<embed src="TheRoadOfCPP.pdf" width="100%" height="750" type="application/pdf">
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验之谈</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Qt的音频播放器程序设计记录</title>
    <url>/2023/fmusicplayer/</url>
    <content><![CDATA[<p>使用Qt的工具完成一个音频播放器——FMusicPlayer</p>
<hr>
<h2 id="一-前言">一、前言</h2>
<p>利用Qt的工具开发一个音乐播放器，界面如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/fmusicplayer_ui.jpg" alt="界面截图"></p>
<p>Qt版本5.12.12。该项目十分简单，适合用于练手。</p>
<h2 id="二-模块构思">二、模块构思</h2>
<p>根据市场上现有的音乐播放器思考，一个基本的音乐播放器应该具有以下功能：</p>
<ul>
<li>
<p>播放/暂停</p>
</li>
<li>
<p>停止</p>
</li>
<li>
<p>控制音频播放进度</p>
</li>
<li>
<p>管理音乐列表</p>
</li>
<li>
<p>音量控制</p>
</li>
<li>
<p>信息显示</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<p>此软件仅实现了上述功能。</p>
<h2 id="三-模块实现">三、模块实现</h2>
<p>此音乐播放器主要使用Qt现成的QMediaPlayer类和QMediaPlaylist类进行维护。</p>
<h3 id="3-1-界面设计">3.1 界面设计</h3>
<p>整体界面设计如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/fmusicplayer_uidesign.jpg" alt="界面设计"></p>
<ul>
<li>
<p>9个按钮QPushButton，对应各种功能；</p>
</li>
<li>
<p>3个标签文字QLabel，用于说明；</p>
</li>
<li>
<p>2个文本框QLineEdit，用于显示信息；</p>
</li>
<li>
<p>1个列表QListWidget，用于存放播放列表；</p>
</li>
<li>
<p>2个滑条QSlider，一个用于控制和显示进度，一个用于控制和显示音量。</p>
</li>
<li>
<p>若干个弹簧用于调整布局。</p>
</li>
</ul>
<p>完成后的程序界面：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/fmusicplayer_ui2.jpg" alt="期望的UI"></p>
<h3 id="3-2-初始化工程">3.2 初始化工程</h3>
<p>此程序使用了Qt的multimedia部件，所以首先在Qt的.pro工程文件中包含multimedia。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">QT  += multimedia</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>接着项目中应该有以下文件：</p>
<blockquote>
<p>mainwindow.h<br>
mainwindow.cpp<br>
mainwindow.ui<br>
main.cpp</p>
</blockquote>
<ul>
<li>
<p>mainwindow.h：主要存放主窗口的一些声明</p>
</li>
<li>
<p>mainwindow.cpp：记录主窗口的实现</p>
</li>
<li>
<p>mainwindow.ui：界面的设计文件</p>
</li>
<li>
<p>main.cpp：程序入口</p>
</li>
</ul>
<p>首先在mainwindow.h中将我们实现的模块添加槽函数声明和成员变量的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMediaPlayer *musicplayer; <span class="comment">// 播放器</span></span><br><span class="line">QMediaPlaylist *musicplayList; <span class="comment">// 播放列表</span></span><br><span class="line"></span><br><span class="line">QString durationTime;<span class="comment">// 音频总长度</span></span><br><span class="line">QString  positionTime;<span class="comment">// 当前播放到位置</span></span><br><span class="line"><span class="comment">// 槽函数声明略，见源代码</span></span><br></pre></td></tr></table></figure>
<p>接着在主窗口构造函数中做一些初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line">musicplayer = <span class="keyword">new</span> <span class="built_in">QMediaPlayer</span>(<span class="keyword">this</span>);</span><br><span class="line">musicplayList = <span class="keyword">new</span> <span class="built_in">QMediaPlaylist</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环播放</span></span><br><span class="line">musicplayList-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::Loop);</span><br><span class="line">musicplayer-&gt;<span class="built_in">setPlaylist</span>(musicplayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认音量，同步音量显示</span></span><br><span class="line">ui-&gt;volume-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);	</span><br><span class="line"><span class="built_in">changedVolume</span>(<span class="number">50</span>);			</span><br></pre></td></tr></table></figure>
<h3 id="3-3-播放-暂停模块">3.3 播放/暂停模块</h3>
<p>当点击播放键时播放音乐，为播放按钮play绑定单击事件，触发playMusic()函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放音乐</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;play, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">playMusic</span>()));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::playMusic</span><span class="params">()</span><span class="comment">//播放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 维护播放列表，使其索引正常，正常播放</span></span><br><span class="line">    <span class="keyword">if</span>(musicplayList-&gt;<span class="built_in">currentIndex</span>()&lt;<span class="number">0</span>)</span><br><span class="line">        musicplayList-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    musicplayer-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当点击暂停键时暂停音乐，支持记录位置，从上次暂停的位置播放。为暂停按钮绑定单击事件，触发pauseMusic()函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停音乐</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;pause, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pauseMusic</span>()));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pauseMusic</span><span class="params">()</span><span class="comment">//暂停播放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    musicplayer-&gt;<span class="built_in">pause</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-停止模块">3.4 停止模块</h3>
<p>当点击停止键时，停止音乐，音乐播放位置归零。为停止按钮绑定单击事件，触发stopMusic()函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 停止音乐</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;stop, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">stopMusic</span>()));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::stopMusic</span><span class="params">()</span><span class="comment">//停止播放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    musicplayer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-控制音频进度模块">3.5 控制音频进度模块</h3>
<p>播放时，音频进度条应当可以被拖动，并且更新播放的位置。为进度条绑定值修改事件，触发changedPosition()函数，函数参数为进度条传入的位置参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进度条控制</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;timebar, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">changedPosition</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::changedPosition</span><span class="params">(<span class="type">int</span> pos)</span>   <span class="comment">// 修改播放位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    musicplayer-&gt;<span class="built_in">setPosition</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-管理音乐列表模块">3.6 管理音乐列表模块</h3>
<p>播放器应该可以输入多个文件，接着顺序播放，所以需要维护一个音乐列表。</p>
<p>首先可以向音乐列表添加音乐，为添加音乐按钮绑定单击事件，绑定addMusic()函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加文件</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;addMusic, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">addMusictoList</span>()));</span><br></pre></td></tr></table></figure>
<p>读取文件时，wav文件是支持的，而mp3文件需要外置解码器的支持，处理mp3文件方法见文章最后。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::addMusictoList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString curPath = QDir::<span class="built_in">currentPath</span>();</span><br><span class="line">    QString title = <span class="string">&quot;选择音频文件&quot;</span>;</span><br><span class="line">    QString filter = <span class="string">&quot;音频文件(*.wav *.mp3)&quot;</span>;</span><br><span class="line">    QStringList fileList = QFileDialog::<span class="built_in">getOpenFileNames</span>(<span class="keyword">this</span>, title, curPath, filter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加文件少于1个时退出函数</span></span><br><span class="line">    <span class="keyword">if</span>(filter.<span class="built_in">count</span>() &lt; <span class="number">1</span>)  <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 将读取的文件放入musicplayList里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; fileList.<span class="built_in">count</span>(); ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        QString aFile = fileList.<span class="built_in">at</span>(i);</span><br><span class="line">        musicplayList-&gt;<span class="built_in">addMedia</span>(QUrl::<span class="built_in">fromLocalFile</span>(aFile));</span><br><span class="line"></span><br><span class="line">        <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(aFile)</span></span>;</span><br><span class="line">        ui-&gt;playList-&gt;<span class="built_in">addItem</span>(fileinfo.<span class="built_in">fileName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 将音乐列表的第一首音频作为待播放音频</span></span><br><span class="line">    <span class="keyword">if</span>(musicplayer-&gt;<span class="built_in">state</span>() != QMediaPlayer::PlayingState)</span><br><span class="line">        musicplayList-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样还应支持移除音频文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除文件</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;delMusic, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">delMusic</span>()));</span><br></pre></td></tr></table></figure>
<p>移除文件时还应判断移除的是否为当前播放音乐，进行相应处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::delMusic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = ui-&gt;playList-&gt;<span class="built_in">currentRow</span>(); <span class="comment">// 获取选中行</span></span><br><span class="line">    QListWidgetItem *item = ui-&gt;playList-&gt;<span class="built_in">takeItem</span>(pos);</span><br><span class="line">    <span class="keyword">delete</span>  item;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(musicplayList-&gt;<span class="built_in">currentIndex</span>() == pos)<span class="comment">// 删除是当前播放的音乐时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nextPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= <span class="number">1</span>)    nextPos = pos - <span class="number">1</span>;</span><br><span class="line">        musicplayList-&gt;<span class="built_in">removeMedia</span>(pos);</span><br><span class="line">        <span class="keyword">if</span>(ui-&gt;playList-&gt;<span class="built_in">count</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            musicplayList-&gt;<span class="built_in">setCurrentIndex</span>(nextPos);</span><br><span class="line">            <span class="built_in">onPlayListChanged</span>(nextPos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            musicplayer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            ui-&gt;playmusic-&gt;<span class="built_in">setText</span>(<span class="string">&quot;无文件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        musicplayList-&gt;<span class="built_in">removeMedia</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空文件则是移除文件的简化版，直接将播放列表清空即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空文件列表</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;clearList, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">clearList</span>()));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::clearList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    musicplayList-&gt;<span class="built_in">clear</span>();	<span class="comment">// 清空列表</span></span><br><span class="line">    ui-&gt;playList-&gt;<span class="built_in">clear</span>();	<span class="comment">// 更新UI</span></span><br><span class="line">    ui-&gt;playmusic-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    ui-&gt;time-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    ui-&gt;timebar-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>);</span><br><span class="line">    musicplayer-&gt;<span class="built_in">stop</span>();	<span class="comment">// 停止播放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还可以添加上一首和下一首的功能，只需简单绑定一下点击事件和调用musicplayList的函数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">musicplayList-&gt;<span class="built_in">previous</span>();	<span class="comment">// 上一首</span></span><br><span class="line">musicplayList-&gt;<span class="built_in">next</span>();		<span class="comment">// 下一首</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-音量控制模块">3.7 音量控制模块</h3>
<p>一个播放器还应该支持音量的调节，而QMediaPlayer支持音量调节，所以绑定滑条值改变事件且调用函数即可，事件返回一个滑条的位置参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制音量</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;volume, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">changedVolume</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::changedVolume</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    musicplayer-&gt;<span class="built_in">setVolume</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-信息显示与同步模块">3.8 信息显示与同步模块</h3>
<p>根据UI的设计，显示的信息有：当前播放的音频名字、播放时间/完整时间。当播放音频进行切换时，需要更新音频名字、播放时间和音频完整时间等信息。</p>
<p>为播放列表musicplayList的当前索引变化事件绑定onPlayListChanged()函数，事件返回新的索引号，用此更新播放的音频名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放音乐变化</span></span><br><span class="line"><span class="built_in">connect</span>(musicplayList, <span class="built_in">SIGNAL</span>(<span class="built_in">currentIndexChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onPlayListChanged</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::onPlayListChanged</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;playList-&gt;<span class="built_in">setCurrentRow</span>(pos);</span><br><span class="line">    <span class="comment">// 使用QListWidgetItem类取出QListWidget的某一行</span></span><br><span class="line">    QListWidgetItem *item = ui-&gt;playList-&gt;<span class="built_in">currentItem</span>();</span><br><span class="line">    <span class="keyword">if</span>(item)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 更新UI的音频名字</span></span><br><span class="line">        ui-&gt;playmusic-&gt;<span class="built_in">setText</span>(item-&gt;<span class="built_in">text</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换音频时，其总时长也应该变化，需要为播放器musicplayer的播放位置变化durationChanged事件绑定onDurationChanged()函数。函数为计算音频总的时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时长变化</span></span><br><span class="line"><span class="built_in">connect</span>(musicplayer, <span class="built_in">SIGNAL</span>(<span class="built_in">durationChanged</span>(qint64)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onDurationChanged</span>(qint64)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::onDurationChanged</span><span class="params">(qint64 dur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;timebar-&gt;<span class="built_in">setMaximum</span>(dur);	<span class="comment">// 设置进度条的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> secs = <span class="built_in">int</span>(dur / <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span> mins = secs / <span class="number">60</span>;</span><br><span class="line">    secs %= <span class="number">60</span>;</span><br><span class="line">    durationTime = QString::<span class="built_in">asprintf</span>(<span class="string">&quot; %d : %d &quot;</span>, mins, secs);</span><br><span class="line">    <span class="comment">// UI刷新时间</span></span><br><span class="line">    ui-&gt;time-&gt;<span class="built_in">setText</span>(positionTime + <span class="string">&quot; / &quot;</span> + durationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于音频随着播放而位置和进度的刷新，则需要为播放器musicplayer的播放位置变化positionChanged事件绑定onPositionChanged()函数。函数为计算播放的时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放位置变化</span></span><br><span class="line"><span class="built_in">connect</span>(musicplayer, <span class="built_in">SIGNAL</span>(<span class="built_in">positionChanged</span>(qint64)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onPositionChanged</span>(qint64)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::onPositionChanged</span><span class="params">(qint64 pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 进度条滑动到尽头，退出函数</span></span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;timebar-&gt;<span class="built_in">isSliderDown</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ui-&gt;timebar-&gt;<span class="built_in">setSliderPosition</span>(pos);</span><br><span class="line">    <span class="comment">// 计算分和秒</span></span><br><span class="line">    <span class="type">int</span> secs = <span class="built_in">int</span> (pos / <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span> mins = secs / <span class="number">60</span>;</span><br><span class="line">    secs %= <span class="number">60</span>;</span><br><span class="line">    positionTime = QString::<span class="built_in">asprintf</span>(<span class="string">&quot; %d : %d &quot;</span>, mins, secs);</span><br><span class="line">    <span class="comment">// UI刷新时间</span></span><br><span class="line">    ui-&gt;time-&gt;<span class="built_in">setText</span>(positionTime + <span class="string">&quot; / &quot;</span> + durationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-总结">四、总结</h2>
<p>该程序源代码放在<a href="https://gitee.com/fingsinz/fmusicplayer/">Gitee - https://gitee.com/fingsinz/fmusicplayer/</a></p>
<p>该项目只是一个简单的播放器实现，希望能够帮助萌新认识Qt，提高自己的能力。</p>
<p>不支持直接加载mp3文件，需要先下载相关解码器。此处附上解码器链接：</p>
<p><a href="https://www.codecguide.com/download_kl.htm">K-lite_codec_pack</a></p>
<p><a href="https://www.codecguide.com/download_k-lite_codec_pack_basic.htm">K-lite_codec_pack_basic（基础版）</a></p>
<p><a href="https://www.codecguide.com/download_k-lite_codec_pack_standard.htm">K-lite_codec_pack_standard（标准版）</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础语法杂记</title>
    <url>/2024/cppbasic/</url>
    <content><![CDATA[<p>关键词：C++</p>
<hr>
<p><em>假定读者有一定的 C 语言基础</em></p>
<p><em>Reference：<a href="https://hackingcpp.com/cpp/beginners_guide.html">https://hackingcpp.com/cpp/beginners_guide.html</a></em></p>
<h2 id="从c语言到c">从C语言到C++</h2>
<h3 id="c-开发设置">C++开发设置</h3>
<h4 id="编辑器-集成开发环境ide">编辑器 &amp; 集成开发环境IDE</h4>
<ul>
<li>
<p>Visual Studio Code</p>
</li>
<li>
<p>Visual Studio</p>
</li>
<li>
<p>VIM</p>
</li>
<li>
<p>Qt Creator</p>
</li>
<li>
<p>CLion</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<h4 id="编译器">编译器</h4>
<ul>
<li>
<p>gcc/g++</p>
</li>
<li>
<p>clang/clang++</p>
</li>
<li>
<p>Microsoft Visual Studio（msvc）</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<h3 id="第一个程序hello-world">第一个程序Hello World</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 注释</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>#include &lt;iostream&gt;</code></p>
<ul>
<li>包含头文件，这行将会被头文件 iostream 所替换；</li>
<li>iostream 是编译器目录中的一个头文件，其提供了基本的输入和输出方法。</li>
<li><code>#include &quot;filename&quot;</code> 可以引入头文件；</li>
<li><code>#include &lt;filename&gt;</code> 同上，但在包含目录中查找。</li>
<li>发生在编译之前，编译器只能看到已经预处理的文件。</li>
</ul>
</li>
<li>
<p>注释</p>
<ul>
<li><code>//</code> 表示单行注释；</li>
<li><code>/* */</code> 表示多行注释。</li>
</ul>
</li>
<li>
<p><code>int main()</code></p>
<ul>
<li>定义了主函数；</li>
<li>主函数是每个程序的入口；</li>
<li><code>int</code> 表明主函数的返回类型是整型；</li>
<li><code>()</code> 表示主函数的参数列表，此处为空。</li>
</ul>
</li>
<li>
<p><code>&#123;&#125;</code></p>
<ul>
<li>表示语句块</li>
</ul>
</li>
<li>
<p><code>std::cout &lt;&lt; &quot;Hello World!\n&quot;;</code></p>
<ul>
<li>在控制台输出 Hello World。</li>
<li><code>std</code> 是标准库的命名空间；</li>
<li><code>cout</code> 表示控制台标准输出，是“character out”的缩写。</li>
<li><code>Hello World</code> 是一个字符串，即字符组成的串。</li>
<li><code>\n</code> 表示换行。</li>
</ul>
</li>
<li>
<p><code>return 0;</code></p>
<ul>
<li>函数出口，返回值0。</li>
</ul>
</li>
</ul>
<hr>
<p><em>注：少用甚至不用 <code>using namespace std;</code></em></p>
<p><em>可能大多数的代码都会附带上 <code>using namespace std;</code></em></p>
<p><em>但使用名称空间将该名称空间中的所有符号拖放到全局名称空间中。这可能会导致名称冲突和歧义，在某些情况下甚至会导致只在运行时才会出现并且很难检测到的bug。</em></p>
<p><em>使用来自其他名称空间的所有符号污染全局名称空间在任何生产代码库中都是一个严重的问题，应该从一开始就避免使用这种模式。</em></p>
<hr>
<h4 id="编译hello-cpp">编译hello.cpp</h4>
<ol>
<li>
<p>预处理，在源代码中处理头文件等；</p>
</li>
<li>
<p>编译：将源代码转化成机器码；</p>
</li>
<li>
<p>链接：结合多个二进制机器码文件，生成可执行文件。</p>
</li>
</ol>
<p>编译术语：</p>
<ul>
<li>
<p>编译错误（Compiler Error，CE）： 编译器无法正确处理源代码，一般为语法错误；</p>
</li>
<li>
<p>编译警告（Compiler Warning）：程序可编译，编译器将继续，但有一段有问题的代码可能导致运行时错误；</p>
</li>
<li>
<p>静态（static）：在编译时固定（固定到可执行文件中，在运行时不可更改）；</p>
</li>
<li>
<p>动态（dynamic）：在运行时可更改（可能由用户输入）。</p>
</li>
</ul>
<h4 id="编译器参数标记">编译器参数标记</h4>
<p>使用 g++ 进行编译时，有一些可选的选项。下面是一条编译指令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">g++ -std=c++<span class="number">20</span> -Wall -Wextra -Wpedantic -Wshadow input.cpp -o output</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>-std=c++20</code> 表示使用 C++20 标准。</p>
</li>
<li>
<p><code>-Wall -Wextra -Wpedantic -Wshadow</code> 表示额外的警告信息。</p>
</li>
<li>
<p><code>-o output</code> 表示输出可执行文件名。</p>
</li>
</ul>
<hr>
<p><em>都这个年代了，尽量使用高版本 C++</em></p>
<hr>
<h3 id="c-的i-o">C++的I/O</h3>
<h4 id="i-o流">I/O流</h4>
<p>对于数据而言，其可以从程序中产生并输出到显示终端，也可以从输入设备中输入到程序中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IO流.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::cin &gt;&gt; i;  <span class="comment">// 输入 i</span></span><br><span class="line">    std::cout &lt;&lt; i; <span class="comment">// 输出 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>std::cin</code>：表示从输入流中读取字符，从外界（缓冲区）读入字符；</p>
</li>
<li>
<p><code>std::cout</code>：表示把字符放入输出流，首先写入缓冲区，缓冲区满时输出到控制台；</p>
</li>
<li>
<p><code>std::clog</code>：表示把字符放入错误流，首先写入缓冲区，缓冲区满时输出到控制台；</p>
</li>
<li>
<p><code>std::cerr</code>：表示把字符放入错误流，但立刻输出到控制台。</p>
</li>
<li>
<p><code>&gt;&gt;</code> 和 <code>&lt;&lt;</code>：流符号，尖端表示数据的流向，如 <code>源 &gt;&gt; 目标</code>。</p>
<ul>
<li>支持基本类型和字符串(可以添加对其他类型的支持)；</li>
<li><code>&gt;&gt;</code> 读取直到下一个空白字符(空格，制表符，换行符，…)</li>
<li>可以连续使用，如 <code>std::cin &gt;&gt; i &gt;&gt; j;</code></li>
</ul>
</li>
</ul>
<hr>
<p><em>注：在必要的时候才用 <code>std::endl</code></em></p>
<p><em>也许会见到代码中出现 <code>std::endl</code>，其也是流处理中的操作，但是每次调用 <code>std::endl</code> 都会刷新输出缓冲区并立即写入输出。C++的I/O流使用缓冲区来减轻系统输入或输出操作对性能的影响。将收集输出，直到可以写入最小数量的字符为止。</em></p>
<p><em>如果经常这样做，可能会导致严重的性能下降。过度使用 <code>std::endl</code> 会干扰这一机制。</em></p>
<p><em>使用 <code>\n</code> 代替或只有一次对操作符 <code>&lt;&lt;</code> 的调用（每次额外的调用会产生很小的开销）</em></p>
<hr>
<h3 id="基本类型">基本类型</h3>
<h4 id="变量声明">变量声明</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type variable = value;</span><br><span class="line">type variable &#123;value&#125;; <span class="comment">// C++11后的初始化</span></span><br></pre></td></tr></table></figure>
<p>但基本类型的变量默认情况下不会初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// i未被初始化，值不可知</span></span><br></pre></td></tr></table></figure>
<h4 id="变量类型">变量类型</h4>
<ol>
<li>
<p>布尔类型：值只有真（<code>true</code>）和假（<code>false</code>）。</p>
</li>
<li>
<p>字符类型：一个字节大小，通常范围在-128~127。</p>
</li>
<li>
<p>整型类型：一般的整数，<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>。</p>
<ul>
<li>带符号整型</li>
<li>无符号整型</li>
<li>C++14中可支持数字分隔符，如 <code>long num = 512'232'697'499;</code></li>
</ul>
</li>
<li>
<p>浮点类型：一般的小数</p>
<ul>
<li><code>float</code>：32位，4字节</li>
<li><code>double</code>：64位，8字节</li>
<li><code>long double</code>：80位，10字节</li>
<li>C++11支持强制转换为 <code>long double</code>，如 <code>long double num = 3.5e38L</code></li>
<li>C++14中也支持数字分隔符</li>
</ul>
</li>
</ol>
<ul>
<li><code>std::numeric_limits&lt;type&gt;</code> 查看变量可表示范围。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lowest:  &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// lowest:  -1.79769e+308</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;min:     &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="comment">// min:     2.22507e-308</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;max:     &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="comment">// max:     1.79769e+308</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;epsilon: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">epsilon</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="comment">// epsilon: 2.22045e-16</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类型窄化">类型窄化</h5>
<p>从可以表示更多值的类型转换为可以表示更少值的类型，可能导致信息丢失。</p>
<h5 id="类型提升">类型提升</h5>
<p>涉及浮点类型的提升：</p>
<ul>
<li>小类型转换成大类型</li>
</ul>
<p>两种整数类型的操作：</p>
<ol>
<li>
<p>整数提升:</p>
<ul>
<li>基本上任何小于int的值都会被提升为int或unsigned int（取决于哪一种类型可以表示未提升类型的所有值）</li>
</ul>
</li>
<li>
<p>如果两个操作数类型不同，则应用整数转换</p>
<ul>
<li>两种符号：小类型转换成大类型</li>
<li>都是无符号的：将较小的类型转换为较大的类型</li>
<li>有符号⊕无符号:
<ul>
<li>如果两者宽度相同，则有符号转换为无符号</li>
<li>否则，如果可以表示所有值，则将无符号转换为有符号</li>
<li>否则都转换为无符号</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="const修饰符">const修饰符</h5>
<p>使用 <code>const</code> 限定变量为常量。</p>
<ul>
<li>值一旦赋值就不能更改。</li>
<li>如果不需要在初始赋值后改变变量的值，总是将变量声明为 <code>const</code> 。
<ul>
<li>避免错误:如果稍后不小心更改值，则不会编译</li>
<li>帮助更好地理解你的代码：清楚地传达值将在代码中保持不变</li>
<li>可以提高性能(可能进行更多编译器优化)</li>
</ul>
</li>
</ul>
<h5 id="constexpr常量表达式">constexpr常量表达式</h5>
<p>C++11支持，常量表达式必须在编译时可计算</p>
<p>如果未在constexpr上下文中调用，则可以在运行时进行计算</p>
<p>constexpr上下文中的所有表达式必须是constexpr本身</p>
<p>Constexpr函数可能包含：</p>
<ul>
<li>C++ 11：只有一条返回语句</li>
<li>C++ 14：多个语句</li>
</ul>
<h5 id="auto关键字">auto关键字</h5>
<p>使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable = expression;</span><br></pre></td></tr></table></figure>
<ul>
<li>从赋值的右侧推导出变量类型</li>
<li>往往更方便、更安全、更经得起未来考验</li>
<li>对于泛型（与类型无关）编程也很重要</li>
</ul>
<h5 id="类型别名">类型别名</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11支持</span></span><br><span class="line"><span class="keyword">using</span> NewType = OldType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++98支持</span></span><br><span class="line"><span class="keyword">typedef</span> OldType NewType;</span><br></pre></td></tr></table></figure>
<h4 id="算术运算符">算术运算符</h4>
<ul>
<li>
<p><code>+</code>、<code>+=</code>：算术加</p>
</li>
<li>
<p><code>-</code>、<code>-=</code>：算术减</p>
</li>
<li>
<p><code>*</code>、<code>*=</code>：算术乘</p>
</li>
<li>
<p><code>/</code>、<code>/=</code>：算术除</p>
</li>
<li>
<p><code>%</code>、<code>%=</code>：算术取余</p>
</li>
</ul>
<h4 id="自增自减符">自增自减符</h4>
<ul>
<li>作用：将值更改+/- 1
<ul>
<li>前缀表达式 <code>++x</code> / <code>--x</code> 返回新的（递增/递减）值；</li>
<li>后缀表达式 <code>x++</code> / <code>x--</code> 增加/减少值，但返回旧值。</li>
</ul>
</li>
</ul>
<h4 id="比较运算符">比较运算符</h4>
<ul>
<li>
<p>返回值只有真（<code>true</code>）和假（<code>false</code>）。</p>
</li>
<li>
<p><code>==</code>：判断相等</p>
</li>
<li>
<p><code>!=</code>：判断不相等</p>
</li>
<li>
<p><code>&lt;</code>：小于</p>
</li>
<li>
<p><code>&gt;</code>：大于</p>
</li>
<li>
<p><code>&lt;=</code>：小于或等于</p>
</li>
<li>
<p><code>&gt;=</code>：大于或等于</p>
</li>
<li>
<p>C++20引入 <code>&lt;=&gt;</code></p>
<ul>
<li>当 a &lt; b 时， <code>(a &lt;=&gt; b) &lt; 0</code></li>
<li>当 a &gt; b 时， <code>(a &lt;=&gt; b) &gt; 0</code></li>
<li>当 a = b 时， <code>(a &lt;=&gt; b) == 0</code></li>
</ul>
</li>
</ul>
<h4 id="逻辑运算符">逻辑运算符</h4>
<ul>
<li>
<p>返回值只有真（<code>true</code>）和假（<code>false</code>）。</p>
</li>
<li>
<p><code>0</code> 永远是假，其他值都是真。</p>
</li>
<li>
<p><code>&amp;&amp;</code> 或 <code>and</code>：逻辑与</p>
</li>
<li>
<p><code>||</code> 或 <code>or</code>：逻辑或</p>
</li>
<li>
<p><code>!</code> 或 <code>not</code>：逻辑非</p>
</li>
<li>
<p>短路评估：如果布尔比较的第二个操作数在计算第一个操作数后已经知道结果，则不计算第二个操作数。</p>
</li>
</ul>
<h4 id="位运算符">位运算符</h4>
<ul>
<li>
<p><code>&amp;</code>：按位与</p>
</li>
<li>
<p><code>|</code>：按位或</p>
</li>
<li>
<p><code>^</code>：按位异或</p>
</li>
<li>
<p><code>~</code>：按位取非</p>
</li>
<li>
<p><code>&lt;&lt;</code>、<code>&lt;&lt;=</code>：左移</p>
</li>
<li>
<p><code>&gt;&gt;</code>、<code>&gt;&gt;=</code>：右移</p>
</li>
</ul>
<p><em>将类型为N位的对象的位移位 N 位或 N 位以上是未定义的行为！</em></p>
<h3 id="控制流">控制流</h3>
<h4 id="条件结构">条件结构</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 条件1为真则执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 条件2为真则执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 否则执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++17支持以下语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即在条件判断前可执行一句语句</span></span><br><span class="line"><span class="keyword">if</span>(statement; condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有 <code>switch</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(variable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++17同样支持多执行一句语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(statement; variable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三元运算符 <code>condition ? statement1 : statement2</code> 同样可用于分支结构。</p>
<h4 id="循环结构">循环结构</h4>
<p><code>for</code> 循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++11支持针对可迭代对象的迭代循环，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(variable : range)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code> 循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do-while</code> 循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3>
<p>普通枚举： <code>enum　枚举名 &#123;枚举元素1,枚举元素2,……&#125;;</code></p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">day</span> &#123;mon, tue, wed, thu, fri, sat, sun&#125;;</span><br><span class="line">day d;</span><br><span class="line">d = mon; <span class="comment">// 正确</span></span><br><span class="line">d = tue; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>但 C++11 中允许带有作用域的枚举： <code>enum class 枚举名 &#123;枚举元素1,枚举元素2,……&#125;;</code></p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">day</span> &#123;mon, tue, wed, thu, fri, sat, sun&#125;;</span><br><span class="line">day d;</span><br><span class="line">d = day::mon;   <span class="comment">// 正确</span></span><br><span class="line">d = tue;        <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>枚举的内在类型：必须是整型类型，默认情况下枚举是 <code>int</code> 类型。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举只有7个值，使用char类型足够</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">day</span> : <span class="type">char</span> &#123;mon, tue, wed, thu, fri, sat, sun&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举可以自定义映射值，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">day</span> : <span class="type">char</span> &#123;mon = <span class="number">1</span>, tue = <span class="number">2</span>, wed = <span class="number">3</span>, thu = <span class="number">4</span>, fri = <span class="number">5</span>, sat = <span class="number">6</span>, sun = <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举可以与基本数据类型进行转换，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">day</span> : <span class="type">char</span> &#123;mon = <span class="number">1</span>, tue = <span class="number">2</span>, wed = <span class="number">3</span>, thu = <span class="number">4</span>, fri = <span class="number">5</span>, sat = <span class="number">6</span>, sun = <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(month::tue);   <span class="comment">// i = 2</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">day d = <span class="built_in">static_cast</span>&lt;day&gt;(j);            <span class="comment">// d = tue</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型聚合">数据类型聚合</h3>
<p>基础数据类型： <code>void</code>、<code>bool</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<p>聚合的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>为什么要自定义类型/数据聚合？</p>
<ul>
<li>接口变得更容易正确使用</li>
<li>语义数据分组:点、日期、…</li>
<li>避免了许多函数参数，因此，混淆</li>
<li>可以从一个专用类型的函数返回多个值，而不是多个非const引用输出参数</li>
</ul>
<p>聚合后的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type &#123;arg1 arg2 ... argn&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">point p&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>可以多重聚合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span></span><br><span class="line">&#123;</span><br><span class="line">    point _begin;</span><br><span class="line">    point _end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用">引用</h3>
<p>使用引用：定义一个变量的引用，引用相对于一个变量的别名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i; <span class="comment">// 定义 i 的引用 r</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// i 与 r 是一样的值</span></span><br><span class="line"><span class="comment">// 2 2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">10</span>；</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// i 与 r 是一样的值</span></span><br><span class="line"><span class="comment">// 10 10</span></span><br><span class="line"></span><br><span class="line">r = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// i 与 r 是一样的值</span></span><br><span class="line"><span class="comment">// 20 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用必须总是指向一个对象</li>
<li>变量的一个引用总是指向与变量相同的内存位置</li>
<li>引用类型必须与被引用对象的类型一致</li>
</ul>
<p><code>const</code> 引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i; <span class="comment">// 定义 i 的常量引用 r</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">10</span>; <span class="comment">// 不报错</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// i 与 r 是一样的值</span></span><br><span class="line"><span class="comment">// 10 10</span></span><br><span class="line"></span><br><span class="line">r = <span class="number">20</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>引用可应用于：</p>
<ul>
<li>基于范围的循环，改变值</li>
<li>函数参数传入，不会进行复制减少开销，且改变值，还能达到返回值的效果
<ul>
<li>当只想减少开销，但不想改变值，可以考虑 <code>const</code> 的引用</li>
</ul>
</li>
<li>等等</li>
</ul>
<p>引用的绑定：</p>
<ul>
<li><code>&amp;</code> ：只能绑在左值上；</li>
<li><code>const &amp;</code>：能绑定在左值和右值上。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_palindrome</span> <span class="params">(std::string <span class="type">const</span>&amp; s)</span> </span>&#123; … &#125;</span><br><span class="line">std::string s = <span class="string">&quot;uhu&quot;</span>; </span><br><span class="line">cout &lt;&lt; <span class="built_in">is_palindrome</span>(s) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">is_palindrome</span>(<span class="string">&quot;otto&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">// 左值变量 s 和 右值 &quot;otto&quot; 都可以执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(<span class="type">int</span>&amp; i, <span class="type">int</span>&amp; j)</span> </span>&#123; … &#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">swap</span>(i, <span class="number">5</span>); <span class="comment">// 5 是右值，不能绑定引用，编译错误</span></span><br></pre></td></tr></table></figure>
<p>使用引用的陷阱：</p>
<ul>
<li>不要返回对函数局部对象的引用：函数局部对象函数结束时会被销毁，返回的引用也会变得无效。</li>
<li>引用 <code>std::vector</code> 要小心：在任何改变vector中元素数量的操作之后，对std::vector中元素的引用都可能失效。
<ul>
<li>在一些vector操作期间，<code>std::vector</code> 存储元素的内部内存缓冲区可以被交换为一个新的，因此对旧缓冲区的任何引用都可能是悬空的。</li>
</ul>
</li>
<li>引用能延长临时变量（或右值）的生存期：如 <code>const auto&amp; r = vector&lt;int&gt;&#123;1, 2, 3&#125;</code>，引用r存在，右边vector则一直存在。
<ul>
<li>不要通过引用去延长变量生存期，请使用合适的变量。</li>
<li>但当对临时的vector成员进行引用时，则生存期不会延长。如：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">foo</span> <span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line"><span class="type">const</span> std::string &amp;s = <span class="built_in">foo</span>()[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 对函数返回的临时 vector 的成员进行引用，并不会延长生存期</span></span><br><span class="line">std::cout &lt;&lt; s;     <span class="comment">// 未定义的行为</span></span><br></pre></td></tr></table></figure>
<p><em>悬空引用：引用不再有效的内存位置的引用。</em></p>
<h3 id="c-的默认动态数组-std-vector">C++的默认动态数组 std::vector</h3>
<ul>
<li>数组：可以存放多个相同类型的值；</li>
<li>动态：长度可以动态变化。</li>
</ul>
<p><strong>std::vector</strong> 的使用需要包含头文件：<code>#include &lt;vector&gt;</code></p>
<h4 id="std-vector的使用">std::vector的使用</h4>
<p><code>std::vector</code> 的定义和初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;                 <span class="comment">// 定义一个空，元素类型为int的vector</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">// 定义一个vector并初始化</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;       <span class="comment">// 定义一个vector并C++11的初始化</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>)</span></span>;            <span class="comment">// 定义一个长度为10，未初始化的vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;         <span class="comment">// 定义一个长度为10，且都初始化为0的vector</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v5&#123;v1&#125;;            <span class="comment">// 定义vector，并用v1的值和长度初始化</span></span><br></pre></td></tr></table></figure>
<p>遍历 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">1.</span><span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 下标访问</span></span><br><span class="line">    std::cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : v1)    <span class="comment">// 此时 x 只能从 v1 中读，并不能修改值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基于范围for循环</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : v1)    <span class="comment">// 此时 x 附加了引用，可以修改值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基于范围for循环</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于x的变量类型很复杂时的只读，减少开销</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; x : v1) </span><br><span class="line">&#123; </span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .front()首元素，.back()尾元素</span></span><br><span class="line">std::cout &lt;&lt; v<span class="number">1.f</span>ront() &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>添加元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);     <span class="comment">// 向v的后面添加一个元素</span></span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">pop_back</span>();       <span class="comment">// 删除v的最后一个元素</span></span><br><span class="line">v.<span class="built_in">clear</span>();          <span class="comment">// 清空v中的所有元素</span></span><br></pre></td></tr></table></figure>
<p><code>std::vector</code> 的长度调整：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>);        <span class="comment">// 将v的长度调整为5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>示例代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">6</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x : v)	std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// 1 2 3 0 0 0</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x : v)	std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// 1 2 3 0 0 0 7</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::vector</code> 中的复制都是深复制。</p>
<ul>
<li>深度复制：创建一个新的对象并复制源的所有包含对象；</li>
<li>深度赋值：将所有包含的对象从源复制到赋值目标；</li>
<li>深度比较：比较两个向量，比较所包含对象的值；</li>
<li>深层所有权：销毁vector将销毁所有包含的对象。</li>
</ul>
<p><em>深复制和浅复制（深拷贝和浅拷贝）：简单来说，深拷贝在内存上独立，复制内容在新的内存空间上。浅拷贝在内存上共享。比如把A复制到B，如果是深复制，则A和B独立互不影响；如果是浅复制，在修改A，B也会改变。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; b = a; <span class="comment">// 深度赋值，a和b独立，互不影响</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">9</span>;   <span class="comment">// a：9 2 3；b：1 2 3</span></span><br></pre></td></tr></table></figure>
<p>另外，C++对 <code>std::vector</code> 进行了一系列的运算符重载，即可以对 <code>std::vector</code> 使用 <code>==</code> （判断相等）、<code>!=</code>（判断不相等）、<code>&gt;</code>（判断大小）等运算符。</p>
<ul>
<li><code>std::vector</code> 的判断大小：比较两个vector上每个位置上的元素，当发现不同的且字典序小的，拥有该元素的vector判定为小。</li>
</ul>
<p><code>std::vector</code> 的大小和容量：</p>
<ul>
<li>大小：指元素个数，函数 <code>.size()</code> 可以获取，同时函数 <code>.resize(newSize)</code> 可以改变大小。</li>
<li>容量：指能容纳的元素个数，函数 <code>.capacity()</code> 可以获取，同时函数 <code>.resize(newCapacity)</code> 可以改变最大容纳元素个数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// 4 6</span></span><br></pre></td></tr></table></figure>
<h4 id="std-vector迭代器">std::vector迭代器</h4>
<p><strong>优先使用迭代器而不是索引器。</strong></p>
<ul>
<li><code>begin(vector)</code>：指向vector的第一个元素</li>
<li><code>end(vector)</code>：指向vector的最后一个元素的后面，只能用作位置指示符，不能用于访问元素。</li>
</ul>
<p><em>迭代器：类似一个指针，指向容器的某个位置，便于迭代循环</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator p = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">for</span>(p; p != <span class="built_in">end</span>(a); p ++)</span><br><span class="line">	std::cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>所以迭代器也可以进行自增自减，加法减法运算。</p>
<p>除了正向迭代器，还有反向迭代器，其作用与正向迭代器类似：</p>
<ul>
<li><code>rbegin(vector)</code>：指向vector的最后一个元素</li>
<li><code>rend(vector)</code>：指向vector的第一个元素的前面，只能用作位置指示符，不能用于访问元素。</li>
</ul>
<p>用迭代器表示范围的 <code>std::vector</code> 初始化和赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; u&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="built_in">begin</span>(u), <span class="built_in">begin</span>(u) + <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; w;</span><br><span class="line">w.<span class="built_in">assign</span>(<span class="built_in">begin</span>(u) + <span class="number">1</span>, <span class="built_in">end</span>(u));</span><br></pre></td></tr></table></figure>
<p>通过迭代器在 <code>std::vector</code> 中插入元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数结构1</span></span><br><span class="line"><span class="comment">//.insert(插入位置, 插入元素)</span></span><br><span class="line"><span class="comment">//.insert(插入位置, &#123;插入元素1, 插入元素2, ……&#125;)</span></span><br><span class="line"></span><br><span class="line">v.<span class="built_in">insert</span>(<span class="built_in">begin</span>(v), <span class="number">0</span>);      <span class="comment">// 在v的第一个位置前插入0</span></span><br><span class="line"><span class="comment">// 0 1 2 3</span></span><br><span class="line">v.<span class="built_in">insert</span>(<span class="built_in">end</span>(v), &#123;<span class="number">4</span>, <span class="number">5</span>&#125;);   <span class="comment">// 在v的最后一个位置后插入&#123;4, 5&#125;</span></span><br><span class="line"><span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数结构2</span></span><br><span class="line"><span class="comment">//.insert(插入位置, 起始位置, 结束位置)，范围左闭右开</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 在v的第一个位置前插入v1的所有元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(<span class="built_in">begin</span>(v), <span class="built_in">begin</span>(v1), <span class="built_in">end</span>(v1));</span><br><span class="line"><span class="comment">// 7 8 9 0 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>通过迭代器在 <code>std::vector</code> 中删除元素：（从vector中擦除元素不会改变容量，因此不会释放任何内存。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数结构</span></span><br><span class="line"><span class="comment">//.erase(位置)</span></span><br><span class="line"><span class="comment">//.erase(起始位置, 结束位置)，范围左闭右开</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">begin</span>(v) + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">begin</span>(v), <span class="built_in">begin</span>(v) + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>在使用迭代器进行元素操作后，如添加删除，原迭代器并未更新，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">auto</span> i = <span class="built_in">begin</span>(v) + <span class="number">3</span>;  <span class="comment">// auto 表示编译器自动推导类型</span></span><br><span class="line">v.<span class="built_in">insert</span>(i, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 输出 *i 为 4，是原来vector的第3个元素，不计刚刚插入的8，因为当前 i 已经失效了</span></span><br><span class="line"><span class="comment">// 使用 i = v.insert(i, 8); 更新迭代器，输出 *i 才为 8</span></span><br></pre></td></tr></table></figure>
<p>同时，经过增删元素后，<code>std::vector</code> 的长度可能变短或者变长。当长度变短时，其容量并不会变小，仍保持之前操作中的最大值，此时可能需要“刷新”一下容量，减少空间消耗：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 一系列增删改操作后</span></span><br><span class="line">v = std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v);    <span class="comment">// C++11~20支持</span></span><br><span class="line">v.<span class="built_in">swap</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v)); <span class="comment">// C++98~20支持</span></span><br></pre></td></tr></table></figure>
<p>做一个临时的副本，通过交换内存缓冲区更新容量，临时变量自动销毁。</p>
<h4 id="std-vector-的工作原理">std::vector 的工作原理</h4>
<p><strong>vector 的数据总是在堆上的，但对象的地址根据定义的方式不同可能在堆上，也可能在栈上。</strong></p>
<p>vector元素保证驻留在一个连续的内存块中。</p>
<ul>
<li>大小：指元素个数。</li>
<li>容量：指能容纳的元素个数。</li>
</ul>
<p>内存块一旦分配后不能调整大小。</p>
<p>动态数组增长方式:</p>
<ol>
<li>动态分配新的（≈1.1-2倍）更大的内存块</li>
<li>复制/移动旧值到新块</li>
<li>摧毁旧的内存块</li>
</ol>
<p>当在某位置擦除（删除）元素时，方式如下：</p>
<ol>
<li>析构（销毁）元素</li>
<li>剩下的元素前移</li>
<li>长度减少，但容量不变</li>
</ol>
<p>当在某位置添加（插入）元素时，方式如下：</p>
<ol>
<li>判断容量大小是否允许，允许则不需再开辟空间增长，不允许则进行增长。</li>
<li>将插入位置及后面的元素后移</li>
<li>在插入位置复制上新元素</li>
</ol>
<h3 id="字符串std-string">字符串std::string</h3>
<p>基本特性：</p>
<ul>
<li>是动态的 <code>char</code> 数组（类似于 <code>vector&lt;char&gt;</code> ）</li>
<li>支持 <code>+</code> 或 <code>+=</code> 进行字符串之间的连接</li>
<li>支持使用 <code>[下标]</code> 进行单字符访问</li>
<li>深复制</li>
<li>支持 <code>==</code> 和 <code>!=</code> 进行比较</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 字符串操作的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    std::string hw = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string s = hw;     <span class="comment">// 复制 hw 到 s</span></span><br><span class="line">    hw += <span class="string">&quot; World!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; hw &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;     <span class="comment">// Hello World!</span></span><br><span class="line">    cout &lt;&lt; hw[<span class="number">4</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// o</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;      <span class="comment">// Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串的操作，对于 <code>std::string s = &quot;Hello World&quot;;</code></p>
<ul>
<li><code>s.insert(5, &quot;,&quot;)</code>：在下标为 5 的位置插入字符串 “,”，变成 “Hello, World”</li>
<li><code>s.erase(6, 7)</code>：删除下标为 5 的位置后的 7 个字符，变成“Hello,”</li>
<li><code>s.replace(5, 3, &quot; C++&quot;)</code>：将下标为 5 的位置的后 3 个字符替换为 “C++”，变成“Hello C++”</li>
<li><code>s.resize(5)</code>：调整字符串长度为5，即变成“Hello”</li>
<li><code>s.resize(8, '!')</code>：调整字符串长度为8，多出来的部分用 <code>!</code> 代替，变成“Hello!!!”</li>
<li><code>s.find(&quot;l&quot;)</code>：字符串中从头到尾寻找“l”，返回 l 所在的下标 2 ，找不到返回 <code>string::npos</code></li>
<li><code>s.rfind(&quot;l&quot;)</code>：字符串中从尾到头寻找“l，返回 l 所在的下标 3 ，找不到返回 <code>string::npos</code></li>
<li><code>s.find('e', 5)</code>：字符串从第5个位置往后寻找“e”。</li>
<li><code>s.substr(0, 2)</code>：在字符串 s 中从下标为0到2（左闭右开）截取子字符串，返回“He”</li>
<li><code>s.ends_with(&quot;&quot;)</code>:判断字符串是否以 “” 结尾，返回 true 或者 false</li>
<li><code>s.starts_with(&quot;&quot;)</code>:判断字符串是否以 “” 开头，返回 true 或者 false</li>
</ul>
<p>在定义并初始化时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string a = <span class="string">&quot;hello&quot;</span>;    <span class="comment">// std::string 类型</span></span><br><span class="line"><span class="comment">// 使用 auto：</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 此时 b 会被推导为 const char[] 类型，而不是std::string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C++14及以后</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&quot;hello&quot;</span>s;</span><br><span class="line"><span class="comment">// 此时 c 是 std::string 类型</span></span><br></pre></td></tr></table></figure>
<p>另外，仅用空格分隔的字符串字面值将被连接起来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;hello&quot;</span> <span class="string">&quot; world&quot;</span>;</span><br><span class="line"><span class="comment">// s 现在是 &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果想让字符串的转义字符失效：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line"><span class="keyword">auto</span> s = <span class="string">R&quot;(\n)&quot;</span>s;  <span class="comment">// C++14及之后支持，类型为 std::string</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="string">R&quot;(\\n)&quot;</span>;  <span class="comment">// C++11支持，类型为 const char[]</span></span><br></pre></td></tr></table></figure>
<p>函数 <code>std::getline()</code> ：该函数需要包含头文件<string></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s;</span><br><span class="line"><span class="comment">// 从标准输入中读取一行</span></span><br><span class="line">std::<span class="built_in">getline</span>(std::cin, s);</span><br><span class="line"><span class="comment">// 从标准输入中读取一行，直到下一个制表符</span></span><br><span class="line">std::<span class="built_in">getline</span>(std::cin, s, <span class="string">&#x27;\t&#x27;</span>); </span><br><span class="line"><span class="comment">// 从标准输入中读取一行，直到下一个 &#x27;a&#x27;</span></span><br><span class="line">std::<span class="built_in">getline</span>(std::cin, s, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当需要把 <code>std::string</code> 作为函数参数传入时，有以下选择：</p>
<table>
<thead>
<tr>
<th style="text-align:center">要求</th>
<th style="text-align:center">使用形式</th>
<th style="text-align:center">优势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">总是需要复制值时</td>
<td style="text-align:center"><code>std::string</code></td>
<td style="text-align:center">值传参</td>
</tr>
<tr>
<td style="text-align:center">在C++17/20下只读</td>
<td style="text-align:center"><code>std::string_view</code>(<code>#include &lt;string_view&gt;</code>)</td>
<td style="text-align:center">省去大部分复制</td>
</tr>
<tr>
<td style="text-align:center">在C++98/11/14下只读</td>
<td style="text-align:center"><code>const std::string &amp;</code></td>
<td style="text-align:center">引用传递，省去大部分复制</td>
</tr>
<tr>
<td style="text-align:center">原地修改输入字符串</td>
<td style="text-align:center"><code>std::string &amp;</code></td>
<td style="text-align:center">非const的引用传递</td>
</tr>
</tbody>
</table>
<p><em>const表示把变量常量化，不允许改变值</em></p>
<hr>
<p><em>C++还提供了关于 <code>std::string</code> 与基本类型转换的函数：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">std::<span class="built_in">to_string</span>(<span class="number">5</span>);  <span class="comment">// 数字（整型和浮点型）转字符串</span></span><br><span class="line"></span><br><span class="line">std::string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = std::<span class="built_in">stoi</span>(s); <span class="comment">// 字符串转整型</span></span><br><span class="line"><span class="comment">// 类似的还有 std::stol, std::stoll, std::stof, std::stod</span></span><br><span class="line"><span class="comment">// 分别是字符串转long，转long long，转float，转double</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="函数">函数</h3>
<p>与C语言类似，函数实现细节的封装；通过将问题分解为单独的函数，更容易对正确性和测试进行推理；避免为常见任务重复代码。</p>
<p>函数结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">返回类型 函数名 (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数的默认值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a 默认值为0，b 默认值为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1 = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// num1 = 3;</span></span><br><span class="line"><span class="type">int</span> num2 = <span class="built_in">add</span>(<span class="number">1</span>);      <span class="comment">// num2 = 1;</span></span><br></pre></td></tr></table></figure>
<p>注意：第一个默认值之后的每个参数也必须有默认值。</p>
<p>函数相关的知识点还有：函数定义、函数声明、函数签名、函数递归。这些与C语言中的知识互通。</p>
<h4 id="函数重载">函数重载</h4>
<p>具有相同名称但不同参数列表的函数，不能单独重载返回类型。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数设计">函数设计</h4>
<p>约定：</p>
<ul>
<li>前提条件：您对输入值的期望/要求是什么?</li>
<li>后置条件：对于输出值应该给出什么保证?</li>
<li>不变量：函数的调用者/用户希望不改变什么?</li>
<li>目的：你的职能有明确的目的吗?</li>
<li>名称：函数的名称是否反映了它的目的?</li>
<li>参数：调用者/用户是否容易混淆它们的含义?</li>
</ul>
<p>C++17中，支持使用 <code>[[nodiscard]]</code> 鼓励编译器在发现返回值被丢弃时发生警告：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">odd</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> yes = <span class="built_in">odd</span>(<span class="number">3</span>);  <span class="comment">// 正常</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">odd</span>(<span class="number">4</span>); <span class="comment">// 警告，因为返回值被丢弃</span></span><br></pre></td></tr></table></figure>
<p>C++11及以后支持使用关键字 <code>noexcept</code>，指定函数承诺永远不会抛出异常/让异常逃逸。如果一个异常从noexcept函数中逃逸，程序将被中止。</p>
<h3 id="内存模型-部分">内存模型（部分）</h3>
<ul>
<li>堆
<ul>
<li>用于动态存储持续时间的对象，例如std：：vector的内容</li>
<li>空间大，可用于大容量存储（大部分主存）</li>
<li>可以按需分配和解除分配任何对象</li>
<li>不按特定顺序分配（取消）资源</li>
<li>缓慢分配：需要为新对象找到连续的未占用空间</li>
</ul>
</li>
<li>栈（先进后出）
<ul>
<li>用于对象的自动存储期限：局部变量、函数参数等。</li>
<li>空间小（通常只有几MB）</li>
<li>快速分配：新对象总是放在最上面</li>
<li>对象按其创建的相反顺序解除分配</li>
<li>无法取消分配最顶层（=最新）以下的对象</li>
</ul>
</li>
</ul>
<p>对象存储生存期：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">生存期</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自动回收型</td>
<td style="text-align:center">对象生存期绑定到语句块范围的开始和结束</td>
<td style="text-align:center">如局部变量，函数参数</td>
</tr>
<tr>
<td style="text-align:center">动态变化型</td>
<td style="text-align:center">用特殊语句控制的对象生存期</td>
<td style="text-align:center">按需创建/销毁的对象</td>
</tr>
<tr>
<td style="text-align:center">线程生存型</td>
<td style="text-align:center">对象生存期绑定到线程的开始和结束</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">静态生存型</td>
<td style="text-align:center">对象生存期与程序的开始和结束有关</td>
<td style="text-align:center">静态变量(static)</td>
</tr>
</tbody>
</table>
<h2 id="输入和输出">输入和输出</h2>
<h3 id="命令行的输入输出">命令行的输入输出</h3>
<p>Windows 系统中，打开控制台（命令提示符，CMD），可以在里面输入一些命令。</p>
<p>C++ 也支持通过命令输入一些参数。有时候会遇到下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>argc</code> 表示命令行传入参数的个数， <code>argv</code> 表示命令行传入的参数字符串数组。</p>
<ul>
<li><code>argv[0]</code> 为当前程序名</li>
</ul>
<p>比如有一程序代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        std::cout &lt;&lt; argv[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在经过编译后，可以在 cmd 中进行调用可执行文件：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">g++ -o test.exe test.cpp</span><br><span class="line">test.exe <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/learnCpp_cmdlinein.jpg" alt="运行截图"></p>
<p>上述 <code>test.cpp</code> 代码中，功能是将程序的命令行输入都输出到控制台。</p>
<hr>
<p>实际上 C++ 程序的输出（返回值）也是可以获取的。</p>
<p>比如有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> argc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过编译后运行有：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">g++ -o test.exe test.cpp</span><br><span class="line">test.exe</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%errorlevel%</span></span><br><span class="line">test.exe <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%errorlevel%</span></span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/learnCpp_cmdlineout.jpg" alt="运行截图"></p>
<hr>
<h3 id="输入输出流">输入输出流</h3>
<p>一些标准输入输出流有：</p>
<ul>
<li>输入流 <code>istream</code></li>
<li>输出流 <code>ostream</code></li>
<li>文件输入流 <code>ifstream</code>：从文件中读取提取的数据</li>
<li>文件输出流 <code>ofstream</code>：插入的数据存储在文件中</li>
<li>字符串输入流 <code>istringstream</code>：从字符串缓冲区读取提取的数据</li>
<li>字符串输出流 <code>ostringstream</code>：插入的数据存储在字符串缓冲区中</li>
</ul>
<p>一些关于流的控制格式函数：</p>
<p><em>冒号表示进入命名空间，表示该函数或内容属于某命名空间，防止命名冲突</em></p>
<ul>
<li><code>std::getline(istream&amp;, string&amp;, stopat='\n')</code>：读取到下一个停止字符（默认直到行尾）</li>
<li><code>std::istream::ignore(n, c)</code>：忽略字符，直至忽略 n 个字符或字符 c 被发现</li>
<li><code>std::setprecision(n)</code>：定义保留精度，对于小数表示共保留 n 位。需要包含头文件 <code>&lt;iomanip&gt;</code></li>
<li><code>std::fixed</code>：修改浮点输入/输出为默认格式</li>
<li><code>std::scientific</code>：修改浮点输入/输出为科学计数法格式</li>
<li><code>std::boolalpha</code>：修改 bool 类型的输入/输出为字母格式</li>
</ul>
<h3 id="文件的输入输出">文件的输入输出</h3>
<p>需要包含头文件 <code>&lt;fstream&gt;</code>。</p>
<h4 id="打开和关闭文件">打开和关闭文件</h4>
<p>在输入输出流中，使用文件输入输出流 <code>ifstream</code> 和 <code>ofstream</code> 操作文件。</p>
<p>函数 <code>open()</code> 和 <code>clost()</code> 分别控制文件的打开和关闭。</p>
<p>打开文件操作如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化流时打开文件</span></span><br><span class="line"><span class="function">std::ifstream <span class="title">in1</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;   <span class="comment">// 使用文件名打开文件</span></span><br><span class="line">std::string path = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"><span class="function">std::ifstream <span class="title">in2</span><span class="params">(path)</span></span>; <span class="comment">// 文件名使用字符串和字符数组都可以</span></span><br><span class="line"><span class="comment">// 文件将自动关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用open函数打开文件</span></span><br><span class="line">std::ifstream in3;</span><br><span class="line">in<span class="number">3.</span><span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>关闭文件操作如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ifstream in4;</span><br><span class="line">in<span class="number">4.</span><span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">in<span class="number">4.</span><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>文件在打开时，可以选择打开的模式：</p>
<ul>
<li>默认情况下，文件输入流的模式为 <code>std::ios::in</code>，即只读模式；文件输出流的模式为 <code>std::ios::out</code>，即只写模式；</li>
<li>追加到现有文件： <code>std::ios::app</code>；</li>
<li>以二进制方式打开文件： <code>std::ios::binary</code>；</li>
</ul>
<p>只需要在初始化时声明打开模式即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以二进制方式打开文件</span></span><br><span class="line"><span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>; </span><br></pre></td></tr></table></figure>
<h4 id="读文件">读文件</h4>
<p>使用文件输入流 <code>ifstream</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>当打开模式为二进制打开时，读文件使用 <code>std::istream::read()</code>。</p>
<ul>
<li>函数参数为指针和长度，将文件读入到指针的空间中，返回读取的字节数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">in.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;i), <span class="built_in">sizeof</span>(i));</span><br></pre></td></tr></table></figure>
<h4 id="写文件">写文件</h4>
<p>使用文件输出流 <code>ofstream</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(out.<span class="built_in">good</span>())  <span class="comment">// 判断流是否正常可写文件</span></span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当打开模式为二进制打开时，写文件使用 <code>std::ostream::write()</code>。</p>
<ul>
<li>函数参数为指针和长度，将指针指向的内容写入文件，返回写入的字节数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">out.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;i), <span class="built_in">sizeof</span>(i));</span><br></pre></td></tr></table></figure>
<h3 id="输入流的错误">输入流的错误</h3>
<p>当有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;input i:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; i;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;input j:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; j;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果输入的是： <code>1 2</code> 这没有问题；</p>
<p>但如果输入的是： <code>asd 2</code>，此时将中断 j 的输入并输出 <code>0 0</code>。</p>
<p>当进行输入时，读取不能转换为 int 的字符（非0~9）：</p>
<ul>
<li><code>cin</code> 将会置错误位；</li>
<li><code>cin</code> 的缓冲区内容不会被丢弃，并且仍然包含有问题的输入；</li>
<li>任何随后从 <code>cin</code> 读取 <code>int</code> 的尝试也将失败。</li>
</ul>
<p>要想解决这个问题，需要清除 <code>cin</code> 的错误位以及输入缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetCin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 清空错误状态</span></span><br><span class="line">    std::cin.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">    std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;input i:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(std::cin.<span class="built_in">fail</span>())  <span class="built_in">resetCin</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;input j:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; j;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再次输入 <code>asd 2</code>，将输出 <code>0 2</code>。</p>
<hr>
<p>更多参考官方文档：</p>
<ul>
<li><a href="https://cplusplus.com/reference/iostream/">C++ iostream</a></li>
<li><a href="https://cplusplus.com/reference/fstream/">C++ fstream</a></li>
</ul>
<h2 id="类的初接触">类的初接触</h2>
<h3 id="引例">引例</h3>
<ol>
<li>实现一个单调计数器，支持自增和读取计数值。</li>
</ol>
<p>分析要求，如果是 C 语言，可以包装成结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Counter cnt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt.count; <span class="comment">// 访问</span></span><br><span class="line">cnt.count++; <span class="comment">// 自增</span></span><br><span class="line">cnt.count = <span class="number">10</span>; <span class="comment">// 访问</span></span><br></pre></td></tr></table></figure>
<p>可是应当考虑到：</p>
<ul>
<li>成员变量未显式初始化；</li>
<li>可以自由地修改任何整数成员</li>
<li>甚至跟基础的 <code>int</code> 无差别</li>
</ul>
<p>在 C++ 中，考虑实现为一个类。</p>
<p>C++ 的类可以有构造函数，析构函数，成员函数，成员变量，以及成员函数的重载，成员变量的默认初始化等。</p>
<p><em>注：虽然结构体 struct 在 C++ 中也支持成员函数，但此处介绍类 class</em></p>
<h3 id="类成员的受限制访问">类成员的受限制访问</h3>
<h4 id="成员函数">成员函数</h4>
<p>成员函数可用于</p>
<ul>
<li>操作或查询数据成员，通过成员函数访问成员变量</li>
<li>控制/限制对数据成员的访问，通过成员函数访问私有成员变量</li>
<li>隐藏低级实现详细信息</li>
<li>确保正确性：保持/保证不变量</li>
<li>确保清晰：为类型的用户提供结构良好的界面</li>
<li>确保稳定性：大部分内部数据表示独立于接口</li>
<li>避免重复/样板：对于潜在的复杂操作封装成成员函数，只需要一个调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter cnt;</span><br><span class="line">std::cout &lt;&lt; cnt.<span class="built_in">get</span>();</span><br><span class="line">cnt.<span class="built_in">inc</span>();</span><br><span class="line">std::cout &lt;&lt; cnt.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<h4 id="公有与私有">公有与私有</h4>
<p>私有成员只能通过成员函数访问！！！</p>
<p>结构体与类的主要区别是默认的成员访问权限：</p>
<ul>
<li>结构体默认为公有</li>
<li>类默认为私有。</li>
</ul>
<h4 id="const限定的成员函数">const限定的成员函数</h4>
<p>非 <code>const</code> 对象不管是否 <code>const</code> 限定都可以调用，<code>const</code> 对象只能调用 <code>const</code> 限定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Counter</span><span class="params">(<span class="type">int</span> _count)</span> </span>&#123; count = _count;&#125;     <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Counter cnt1;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;pcnt1 = cnt1;</span><br><span class="line">    pcnt<span class="number">1.</span><span class="built_in">inc</span>();    <span class="comment">// 编译错误，inc() 是非const函数</span></span><br><span class="line">    std::cout &lt;&lt; pcnt<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量在 <code>const</code> 限定的成员函数内 也具有 <code>const</code> 属性。</p>
<p>如果一个函数是常量限定的，另一个不是，则两个成员函数可以有相同的名称（和参数列表）。这使得可以清楚地区分只读访问和读/写操作。</p>
<ul>
<li>即成员函数可以被 <code>const</code> 重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAndSet</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125; <span class="comment">// 只读访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getAndSet</span><span class="params">(<span class="type">int</span> newcount)</span> </span>&#123; count = newcount; &#125; <span class="comment">// 写</span></span><br></pre></td></tr></table></figure>
<h4 id="成员函数的定义">成员函数的定义</h4>
<p>当类的成员函数较为复杂时，一般不会在类内定义，而是定义在类的外部，此时加上作用域：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::setValue</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<h4 id="成员初始化">成员初始化</h4>
<ol>
<li>成员变量初始化，C++11 下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构造函数的初始化列表</li>
</ol>
<p><em>构造函数是创建对象时执行的特殊成员函数</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">   <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>确保初始化列表中的成员顺序始终与成员声明顺序相同</strong></p>
<h4 id="构造函数">构造函数</h4>
<p>构造函数：创建对象时执行的特殊成员函数。</p>
<ul>
<li>构造函数名就是其类型名</li>
<li>没有返回类型</li>
<li>可以通过初始化列表初始化数据成员
<ul>
<li>确保初始化列表中的成员顺序始终与成员声明顺序相同</li>
</ul>
</li>
<li>可以在首次使用对象之前执行代码</li>
<li>可以用来建立不变量</li>
<li>调用顺序自上而下</li>
</ul>
<h5 id="默认构造函数">默认构造函数</h5>
<p>类默认提供 <strong>默认构造函数</strong>，<strong>其不带参数</strong>。但是当显式定义构造函数时，需要手动提供一个默认构造函数，默认构造函数只能有一个（避免二义性），但构造函数可以有多个。<br>
如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;     <span class="comment">// 默认构造函数，采用初始化列表，确保初始化列表中的成员顺序始终与成员声明顺序相同！</span></span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> _count) &#123; count = _count;&#125;     <span class="comment">// 构造函数，且默认用1初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter cnt1;       <span class="comment">// 默认构造函数，并初始化count = 0</span></span><br><span class="line"><span class="function">Counter <span class="title">cnt2</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 构造函数，初始化count = 10</span></span><br></pre></td></tr></table></figure>
<p>或者使用 <code>TypeName() = default;</code>，编译器提供默认构造函数的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() = <span class="keyword">default</span>;        <span class="comment">// 默认构造函数，未初始化</span></span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> _count) &#123; count = _count;&#125;     <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认构造函数还可以通过给函数参数设置默认值提供：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> _count = <span class="number">0</span>) &#123; count = _count; &#125; <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="comment">// Counter() = default; // 默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义构造函数时，加上关键字 <code>explicit</code> 表示构造函数只能用于显式转换，即不会被隐式调用，隐式调用的构造是很难找到的 bug 的主要来源。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Counter</span><span class="params">(<span class="type">int</span> _count)</span> </span>&#123; count = _count;&#125;     <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span> <span class="params">(Counter c)</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">get</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 编译错误，避免了由2隐式转换为Counter的bug</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fun</span>(<span class="built_in">Counter</span>(<span class="number">2</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以尝试把 <code>explicit</code> 去掉，体验如何隐式调用构造函数。</p>
<h5 id="拷贝构造函数">拷贝构造函数</h5>
<p>默认情况下，类也提供默认拷贝构造函数</p>
<p>默认拷贝构造函数：简单来说就是从源复制到新的地方，进行变量之间的复制</p>
<ul>
<li>默认拷贝构造函数是浅复制
<ul>
<li>浅复制（拷贝）：拷贝者和被拷贝者是同一个地址，改变其中一个，另一个也改变</li>
<li>深复制（拷贝）：拷贝者和被拷贝者不是同一个地址，改变其中一个，另一个不变</li>
</ul>
</li>
<li><strong>拷贝构造函数的函数名就是其类型名，参数为拷贝源</strong></li>
</ul>
<p>拷贝函数的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T::<span class="built_in">T</span>(<span class="type">const</span> T&amp; t) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以重载拷贝构造函数，进行一些自定义的复制操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;							<span class="comment">// 默认构造函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Counter</span><span class="params">(<span class="type">int</span> _count)</span> </span>&#123; count = _count;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">const</span> Counter &amp;c) &#123; count = c.<span class="built_in">get</span>(); &#125;	<span class="comment">// 拷贝构造函数 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter cnt1;       <span class="comment">// 默认构造函数，并初始化count = 0</span></span><br><span class="line">Counter cnt2 = cnt1;	<span class="comment">// 调用拷贝构造函数 </span></span><br></pre></td></tr></table></figure>
<h5 id="赋值运算符函数">赋值运算符函数</h5>
<p>默认赋值运算符函数：就是重载了赋值运算符</p>
<ul>
<li>具有其返回值类型，函数名字以及参数列表</li>
</ul>
<p>赋值运算符函数形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>=(<span class="type">const</span> Counter&amp; rhs)</span><br></pre></td></tr></table></figure>
<p>具体如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;                  <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;							<span class="comment">// 默认构造函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Counter</span><span class="params">(<span class="type">int</span> _count)</span> </span>&#123; count = _count;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">const</span> Counter &amp;c) &#123; count = c.<span class="built_in">get</span>(); &#125;	<span class="comment">// 拷贝构造函数 </span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span> =(<span class="type">const</span> Counter &amp;c) 			<span class="comment">// 赋值运算符函数 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> != &amp;c)  <span class="comment">// 判断赋值是否为本身，若为本身则无需操作</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">set</span>(c.<span class="built_in">get</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; count++; &#125;     <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> _count)</span> </span>&#123; count = _count; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了赋值运算符，其他大部分运算符也可以重载。但不可重载的运算符有：</p>
<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*</code>，<code>-&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
<h5 id="移动构造函数和移动赋值运算符函数">移动构造函数和移动赋值运算符函数</h5>
<p>C++引入了移动语义，也产生了移动构造函数和移动赋值运算符函数。</p>
<p>移动构造函数：能够从一个右值引用创建新的对象，而无需进行深拷贝</p>
<p><em>假设你搬家，有一堆家具需要装进卡车。传统的深拷贝（复制构造函数）就像是你把每一件家具都精心地复制一份，然后放进卡车上。这个过程费时费力，而且你原本的家具还要保留。但是，如果你找来一位勇敢的快递员（移动构造函数），他们可以直接将你的家具移动到新的屋子里，而不用复制。这样，节省了时间和精力，而且你原本的家具可以顺利放进新的屋子。</em></p>
<p>移动构造函数形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T::<span class="built_in">T</span>(T&amp;&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>移动赋值运算符函数：允许将一个对象的资源转移到另一个对象上</p>
<p><em>想象一下，你在一家公司工作，有一天你被调往另外一个部门。传统的方式是，你将自己的工作内容复制一份，再将新工作的内容复制回来，形成了两份一样的工作内容。这样的操作显然很冗余。然而，通过移动赋值操作符，你可以直接将自己的工作内容交给新的员工，并且接管他们原本的工作，省去了不必要的复制步骤。</em></p>
<p>移动赋值运算符函数形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);</span><br></pre></td></tr></table></figure>
<h3 id="析构函数">析构函数</h3>
<p>析构函数：当对象的生命周期结束时，会调用析构函数，用于释放对象的资源。</p>
<ul>
<li>如果不定义默认构造函数和析构函数，编译器会生成它们。</li>
</ul>
<p>函数形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type::~<span class="built_in">Type</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>析构函数的执行顺序：<strong>所有数据成员的析构函数将以其构造函数相反的声明顺序执行</strong></p>
<ul>
<li>调用顺序自下而上</li>
</ul>
<h4 id="资源获取即初始化raii">资源获取即初始化RAII</h4>
<ul>
<li>对象构建：获取资源</li>
<li>对象销毁：释放资源</li>
</ul>
<p>如 <code>std::vector</code></p>
<ul>
<li>每个 vector 对象都是堆中存储实际内容的单独缓冲区的所有者。</li>
<li>该缓冲区按需分配，如果vector对象被销毁则取消分配。</li>
</ul>
<p><em>如果一个对象对其生命周期(初始化/创建、结束/销毁)负责，则该对象被称为资源(内存、文件句柄、连接、线程、锁等)的所有者。</em></p>
<p>注意资源的使用，避免资源泄漏。</p>
<h4 id="零规则">零规则</h4>
<p>The Rule of Zero：尽量不要自己写特殊成员函数。</p>
<ul>
<li>避免编写特殊的成员函数，除非需要进行 RAII 风格的资源管理或跟踪生命周期。
<ul>
<li>编译器生成的默认构造函数和析构函数在大多数情况下就足够了。</li>
</ul>
</li>
<li>初始化并不总是依赖编写构造函数。
<ul>
<li>大多数数据成员都可以用成员初始化器初始化（声明定义时初始化）。</li>
</ul>
</li>
<li>不要给类型添加空析构函数。
<ul>
<li>用户定义析构函数的存在阻止了许多优化，并可能严重影响性能。</li>
<li>如果不需要在析构函数体中做任何事情，那么就不要定义它。</li>
</ul>
</li>
<li>几乎不需要编写析构函数。
<ul>
<li>在现代 C++ 中，内存管理策略大多封装在专用类(容器、智能指针、分配器等)中。</li>
</ul>
</li>
</ul>
<h2 id="指针">指针</h2>
<h3 id="为什么需要指针？">为什么需要指针？</h3>
<ul>
<li>观察对象
<ul>
<li>引用/跟踪对象</li>
<li>在运行时更改间接的目标</li>
</ul>
</li>
<li>访问动态内存
<ul>
<li>访问动态存储持续时间的对象，即生命周期不与变量/作用域绑定的对象</li>
</ul>
</li>
<li>构建动态、基于结点的数据结构
<ul>
<li>动态数组</li>
<li>链表</li>
<li>树/图</li>
</ul>
</li>
</ul>
<p>有时候可以用于前向声明：定义一个类型，它的所有成员的内存大小必须是已知的。</p>
<p>例子中，Hub 类和 Device 类相互类型引用。</p>
<ul>
<li>因为，所有指针类型都具有相同的大小。</li>
<li>所以先声明 Hub 的存在。</li>
<li>然后 Device 只需要一个指向 Hub 的指针，即已知成员内存大小。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hub</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line">  Hub* hub_;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hub</span> &#123;</span><br><span class="line">  std::vector&lt;Device <span class="type">const</span>*&gt; devs_;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="指向类型为t的对象的指针">指向类型为T的对象的指针</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T* ptr;</span><br></pre></td></tr></table></figure>
<ul>
<li>存储类型为 T 的对象 <code>ptr</code> 的内存地址；</li>
<li>可以用来检查/观察/修改目标对象；</li>
<li>可以重定向到不同的目标（不同于引用，引用不可以重定向）；</li>
<li>也可能根本不指向任何对象，为空指针。</li>
</ul>
<p>原始指针：<code>T *</code></p>
<ul>
<li>本质：一个存储内存地址的（无符号）整数变量</li>
<li>大小：64位，8个字节（64位机）</li>
<li>许多原始指针可以指向相同的地址/对象</li>
<li>指针和目标（被指向）对象的生存期是独立的，可能会出现野指针。
<ul>
<li>野指针：指向一个已经销毁的对象的指针或指向一个未定义内容的内存地址。</li>
</ul>
</li>
</ul>
<p>智能指针：（C++11及以后）</p>
<ul>
<li><code>std::unique_pointer&lt;T&gt;</code>
<ul>
<li>用于访问动态存储，即堆上的对象；</li>
<li>每个对象只能有一个 <code>unique_pointer</code>；</li>
<li>指针与指向对象具有相同的生存期。</li>
</ul>
</li>
<li><code>std::shared_pointer&lt;T&gt;</code>
<ul>
<li>用于访问动态存储，即堆上的对象；</li>
<li>每个对象可以有多个 <code>shared_pointer</code></li>
<li>只要至少有一个 <code>shared_pointer</code> 指向目标对象，目标对象就存在</li>
</ul>
</li>
<li><code>std::weak_pointer&lt;T&gt;</code>
<ul>
<li>用于访问动态存储，即堆上的对象；</li>
<li>每个对象可以有多个 <code>weak_pointer</code></li>
</ul>
</li>
</ul>
<p>C++11及以后： <code>nullptr</code></p>
<ul>
<li>特殊指针值；</li>
<li>可隐式转换为 <code>false</code></li>
<li>在内存中不一定用0表示（取决于平台）</li>
<li><code>nullptr</code> 表示值不可用
<ul>
<li>在初始化时设置指向空指针或有效地址的指针</li>
<li>取消引用前检查是否为nullptr</li>
</ul>
</li>
</ul>
<h3 id="指针相关的运算符">指针相关的运算符</h3>
<p>取地址符 <code>&amp;</code> ：返回内存地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> *pc = &amp;c;</span><br></pre></td></tr></table></figure>
<p>解引用（取值）符 <code>*</code> ： 访问地址中的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> *pc = &amp;c;</span><br><span class="line">*pc = <span class="number">66</span>;</span><br></pre></td></tr></table></figure>
<p>成员访问符 <code>-&gt;</code> ： 访问指针指向的对象的成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">coord</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coord a&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">coord *pa = &amp;a;</span><br><span class="line"><span class="type">char</span> v = pa-&gt;x;     <span class="comment">// 访问指针pa指向地址中的x成员的值</span></span><br><span class="line"><span class="type">char</span> w = (*pa).y;   <span class="comment">// 解引用后使用.访问成员 </span></span><br></pre></td></tr></table></figure>
<p><code>*</code> 和 <code>&amp;</code> 的语法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">用处</th>
<th style="text-align:center"><code>*</code></th>
<th style="text-align:center"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">作类型修饰符</td>
<td style="text-align:center">声明指针：<code>Type *ptr = nullptr</code></td>
<td style="text-align:center">声明引用：<code>Type &amp;ref = variable</code></td>
</tr>
<tr>
<td style="text-align:center">作一元运算符</td>
<td style="text-align:center">解引用：<code>value = *pointer</code></td>
<td style="text-align:center">取地址：<code>pointer = &amp;variable</code></td>
</tr>
<tr>
<td style="text-align:center">作二元运算符</td>
<td style="text-align:center">乘法：<code>ans = expr1 * expr2</code></td>
<td style="text-align:center">按位与：<code>bitand = expr1 &amp; expr2</code></td>
</tr>
</tbody>
</table>
<p><em>指针声明时注意：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p1, p2;    <span class="comment">// p1 是 int*，p2 是 int</span></span><br><span class="line"><span class="type">int</span> *p1, *p2;    <span class="comment">// p1 是 int*，p2 是 int*</span></span><br></pre></td></tr></table></figure>
<h3 id="const-指针">const 指针</h3>
<p>目的：</p>
<ul>
<li>对于目标只读访问</li>
<li>防止指针重定向</li>
</ul>
<p>语法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">T类型的指针</th>
<th style="text-align:center">指向的值能否修改</th>
<th style="text-align:center">指针能否重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T *</code></td>
<td style="text-align:center">能</td>
<td style="text-align:center">能</td>
</tr>
<tr>
<td style="text-align:center"><code>T const *</code></td>
<td style="text-align:center">不能</td>
<td style="text-align:center">能</td>
</tr>
<tr>
<td style="text-align:center"><code>T * const</code></td>
<td style="text-align:center">能</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center"><code>T const * const</code></td>
<td style="text-align:center">不能</td>
<td style="text-align:center">不能</td>
</tr>
</tbody>
</table>
<p><strong>从右向左读：(是否const修饰的) 指针指向一个（是否const修饰的）类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp = &amp;i;</span><br><span class="line">*cp = <span class="number">8</span>;   <span class="comment">//  编译器错误：指向的值是常量</span></span><br><span class="line">cp = &amp;j;   <span class="comment">//  OK</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> pc = &amp;i;</span><br><span class="line">*pc = <span class="number">8</span>;   <span class="comment">//  OK</span></span><br><span class="line">pc = &amp;j;   <span class="comment">//  编译器错误：指针本身是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> cpc = &amp;i;</span><br><span class="line">*cpc = <span class="number">8</span>;  <span class="comment">//  编译器错误：指向的值是常量</span></span><br><span class="line">cpc = &amp;j;  <span class="comment">//  编译器错误：指针本身是常量</span></span><br></pre></td></tr></table></figure>
<hr>
<p>还有代码风格的一致性问题：使用像是 <code>int const</code> 而不是 <code>const int</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const 修饰它的左边</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> c = ...;          <span class="comment">// const 修饰它的左边（int）</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> &amp;cr = ...;        <span class="comment">// const 修饰它的左边（int）</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *pc = ...;        <span class="comment">// const 修饰它的左边（int）</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> cp = ...;       <span class="comment">// const 修饰它的左边（*）</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> cpc = ...;<span class="comment">// const 修饰它的左边（int和*）</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="this-指针">this 指针</h3>
<p><code>this</code>：</p>
<ul>
<li>成员函数内部可用</li>
<li><code>this</code> 返回对象本身的地址</li>
<li><code>this-&gt;</code> 可用于访问成员</li>
<li><code>*this</code> 访问对象本身</li>
</ul>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntRange</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l_ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r_ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span></span></span><br><span class="line"><span class="function">    <span class="title">IntRange</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>: l_&#123;</span>l&#125;, r_&#123;r&#125; </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l_ &gt; r_) std::<span class="built_in">swap</span>(l_, r_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span> <span class="params">()</span>  <span class="type">const</span> </span>&#123; <span class="keyword">return</span> l_; &#125;</span><br><span class="line">    <span class="comment">// 也可以使用“this”访问成员：</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;r_; &#125;</span><br><span class="line">    <span class="comment">// 返回对象本身的引用</span></span><br><span class="line">    <span class="function">IntRange&amp; <span class="title">shift</span> <span class="params">(<span class="type">int</span> by)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        l_ += by;</span><br><span class="line">        r_ += by;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="少使用指针">少使用指针</h3>
<p>推荐合适使用 <strong>引用</strong> 代替指针。</p>
<ol>
<li>指针容易悬空
<ul>
<li>悬空：指针指向无效或不可访问的内存地址</li>
<li>指针中的值可以是任意地址，程序员必须确保指针目标是有效的/仍然存在</li>
</ul>
</li>
<li>容易出现错误参数传递</li>
<li>指针让代码更难理解
<ul>
<li><code>*p = *p * *p + (2 * *p + 1);</code></li>
</ul>
</li>
</ol>
<h2 id="异常">异常</h2>
<h3 id="什么是异常">什么是异常</h3>
<p>对象可以在调用层次结构中向上抛出：</p>
<ul>
<li>通过“抛出”将控制转回到当前函数的调用方。</li>
<li>如果不处理，异常会一直传播，直到它们到达 <code>main</code> 函数。但如果在主函数中中没有处理异常，将会调用 <code>std::terminate</code>，即终止程序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">&quot;Exception&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fun2</span>(); <span class="comment">// 没有处理异常，终止程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 <code>throw</code> 关键字抛出异常。</li>
<li>通过 <code>try-catch</code> 语句捕获异常。</li>
</ol>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义除法函数， a / b </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::invalid_argument&#123;<span class="string">&quot;divided by 0&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> number1 = <span class="number">0</span>, number2 = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	std::cin &gt;&gt; number1 &gt;&gt; number2;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans = <span class="built_in">division</span>(number1, number2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::invalid_argument <span class="type">const</span> &amp;err)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; number1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; number2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1 2</span><br><span class="line">输出：1 / 2 = 0.5</span><br><span class="line"></span><br><span class="line">输入：1 0</span><br><span class="line">输出：divided by 0</span><br></pre></td></tr></table></figure>
<h3 id="异常用处">异常用处</h3>
<p>报告违规行为。</p>
<ol>
<li>
<p>输入与期望或规定不符（违法输入，或违法的函数参数）。</p>
<ul>
<li>如：负数的平方根、下标越界等。</li>
</ul>
</li>
<li>
<p>定义或保留不变量失败。</p>
<ul>
<li>如：公共成员函数无法设置有效的成员值、<code>vector</code> 扩充空间期间爆内存。</li>
</ul>
</li>
<li>
<p>输出、返回值与期望或规定不符，函数无法生成有效的返回值或损坏全局。</p>
<ul>
<li>如：构造函数失败、无法返回除以零的结果。</li>
</ul>
</li>
</ol>
<p>异常的优劣：</p>
<ol>
<li>错误处理代码与业务逻辑的分离</li>
<li>错误处理的集中化</li>
<li>当不引发异常时，性能影响可以忽略不计</li>
<li>抛出异常时通常会影响性能，由于额外的有效性检查而导致的性能影响</li>
<li>容易产生资源/内存泄漏</li>
</ol>
<h3 id="异常替代方案">异常替代方案</h3>
<ol>
<li>
<p>输入值无效：输入前进行检查，用参数类型排除无效值。</p>
</li>
<li>
<p>定义或保留不变量失败：设置错误状态/标志，将对象设置为特殊，无效值/状态。</p>
</li>
<li>
<p>不能返回有效值：通过单独的输出参数（引用或指针）返回错误代码、返回特殊的有效值、返回特殊类型 <code>std::optional</code>(C++17)</p>
</li>
</ol>
<h3 id="标准库异常">标准库异常</h3>
<p><code>std::exception</code>：其子类型有：</p>
<ul>
<li><code>logic_error</code>
<ul>
<li><code>invalid_argument</code></li>
<li><code>domain_error</code></li>
<li><code>length_error</code></li>
<li><code>out_of_range</code></li>
<li>……</li>
</ul>
</li>
<li><code>runtime_error</code>
<ul>
<li><code>range_error</code></li>
<li><code>overflow_error</code></li>
<li><code>underflow_error</code></li>
<li>……</li>
</ul>
</li>
</ul>
<p><code>vector</code> 支持一种“宽规约”函数，通过抛出异常来报告无效的输入值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="type">int</span> a = v[<span class="number">3</span>];   <span class="comment">// 越界且窄规约，即错误</span></span><br><span class="line"><span class="type">int</span> b = v.<span class="built_in">at</span>(<span class="number">3</span>); <span class="comment">// 越界且宽规约，即抛出异常 std::out_of_range</span></span><br></pre></td></tr></table></figure>
<h3 id="处理异常">处理异常</h3>
<p>重复抛出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::exception <span class="type">const</span> &amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获所有异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集中异常处理：</p>
<ul>
<li>如果在许多不同的地方抛出相同的异常类型，可以避免代码重复。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_init_errors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// 重抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(err::device_unreachable <span class="type">const</span> &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(err::bad_connection <span class="type">const</span> &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(err::bad_protocol <span class="type">const</span> &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_server</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123; <span class="built_in">handle_init_errors</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123; <span class="built_in">handle_init_errors</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常的问题">异常的问题</h3>
<p>几乎任何一段代码都可能引发异常，对C++类型和库的设计产生重大影响。</p>
<p>资源/内存泄漏的潜在来源：</p>
<ol>
<li>进行自己的内存管理的外部C库；</li>
<li>不使用 RAII 进行自动资源管理的C++库（设计存在缺陷）；</li>
<li>在销毁时不清理资源的类型（设计存在缺陷）；</li>
</ol>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_database</span> <span class="params">(database <span class="type">const</span>&amp; db, std::string_view filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DBHandle h = <span class="built_in">open_dabase_conncection</span>(db);  <span class="comment">// 建立远程连接</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">open_file</span>(filename);</span><br><span class="line">    <span class="comment">// 如果 open_file 抛出异常，则不会调用 close_database_connection</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// do work…</span></span><br><span class="line">    <span class="built_in">close_database_connection</span>(h);   <span class="comment">// 断开远程连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子可以使用 RAII，在类析构时断开连接释放资源。</p>
<ul>
<li>但也不要让异常逃离析构函数，如果在析构函数运行时发生异常，可能导致析构函数终止，但对象还没完全释放。</li>
<li>需要在析构函数作成套的 <code>try-catch</code>。</li>
</ul>
<h3 id="异常保障">异常保障</h3>
<p>为了避免抛出异常：</p>
<ul>
<li>
<p>当没有保障时：</p>
<ul>
<li>操作可能会失败</li>
<li>资源可能会泄露</li>
<li>可能违反不变量（=成员可能包含无效值）</li>
<li>部分执行失败的操作可能会产生副作用（例如输出）</li>
<li>异常可能向外传播</li>
</ul>
</li>
<li>
<p>存在基本保障时：</p>
<ul>
<li>不变量被保留，没有资源泄露</li>
<li>所有成员都将包含有效值</li>
<li>部分执行失败的操作可能会产生副作用（例如，值可能已写入文件）</li>
</ul>
</li>
<li>
<p>强保障时：</p>
<ul>
<li>操作可能会失败，但不会产生明显的副作用</li>
<li>所有成员都保留其原始值</li>
<li>内存分配容器应提供这种保证，即如果增长期间内存分配失败，容器应保持有效且不变</li>
</ul>
</li>
<li>
<p>使用无抛出保障时：</p>
<ul>
<li>行动一定会成功</li>
<li>无法从外部观察到的异常，即没有抛出或内部捕获</li>
<li>使用 <code>noexcept</code> 关键字进行记录和强制执行</li>
</ul>
</li>
</ul>
<p>无抛出保障关键字： <code>noexcept</code> （C++11）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>f</code> 函数承诺永远不抛出异常，不允许任何转义</li>
<li>如果从 <code>noexcept</code> 函数中逃脱出异常，则程序将终止</li>
</ul>
<p>带条件的 <code>noexcept</code> 语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">noexcept</span><span class="params">(exp)</span> <span class="comment">// 如果表达式产生真值，声明&#x27;A&#x27;为noexcept</span></span></span><br><span class="line"><span class="function">A <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(B))</span> <span class="comment">// 如果`B`没有抛出异常，声明`A`为noexcept</span></span></span><br></pre></td></tr></table></figure>
<p><code>noexcept()</code> 默认是 <code>true</code>。</p>
<h3 id="终止处理程序">终止处理程序</h3>
<p>当在主函数有未捕获的异常时：</p>
<ul>
<li>调用终止函数 <code>std::terminate</code>。</li>
<li>它调用终止处理程序，默认调用 <code>std::abort</code> ，从而正常终止程序。</li>
</ul>
<p>可以自定义处理程序：<code>std::set_terminate(handler);</code></p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_handler</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unhandled Exception!\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">set_terminate</span>(my_handler);</span><br><span class="line">    <span class="keyword">throw</span> std::exception&#123;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常指针">异常指针</h3>
<ul>
<li><code>std::current_exception</code>：
<ul>
<li>捕获当前异常对象</li>
<li>返回一个 <code>std::exception_ptr</code> 引用该异常</li>
<li>如果没有异常，则返回空的 <code>std::exception_ptr</code></li>
</ul>
</li>
<li><code>std::exception_ptr</code>
<ul>
<li>保存一个异常副本或对异常的引用</li>
</ul>
</li>
<li><code>std::rethrow_exception(exception_ptr)</code>
<ul>
<li>抛出异常指针所引用的异常对象</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_init_errors</span> <span class="params">(std::exception_ptr eptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eptr) std::<span class="built_in">rethrow_exception</span>(eptr);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (err::bad_connection <span class="type">const</span>&amp; e)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (err::bad_protocol <span class="type">const</span>&amp; e)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_client</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exp) <span class="keyword">throw</span> err::bad_connection; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::exception_ptr eptr;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initialize_client</span>(); </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        eptr = std::<span class="built_in">current_exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">handle</span>(eptr);</span><br><span class="line">&#125; <span class="comment">// eptr已销毁，则捕获的异常已销毁</span></span><br></pre></td></tr></table></figure>
<h3 id="计数未捕获的异常">计数未捕获的异常</h3>
<p>C++17中，<code>std::uncaught_exceptions</code> 返回当前线程中当前未处理的异常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>(); <span class="comment">// 可能抛出异常</span></span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">uncaught_exceptions</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-诊断">C++诊断</h2>
<h3 id="关于诊断的术语">关于诊断的术语</h3>
<ul>
<li><code>Warnings</code>：编译器指出潜在的有问题的行为，可能在运行时形成错误。</li>
<li><code>Assertions</code>：断言，用于比较和报告表达式的预期值和实际值的语句。</li>
<li><code>Testing</code>：比较部分或整个程序的实际情况和预期行为。</li>
<li><code>Code Coverage</code>：代码覆盖情况，即实际执行或测试了多少代码。</li>
<li><code>Static Analysis</code>：静态分析，通过分析源代码（就看着代码）发现潜在的运行时问题，如未定义行为。</li>
<li><code>Dynamic Analysis</code>：动态分析，通过运行实际的程序（跑下代码）发现潜在的问题，如内存泄漏。</li>
<li><code>Debugging</code>：在运行时逐步执行代码并检查内存中的值。</li>
<li><code>Profiling</code>：找出每个函数、循环、代码块占总运行时间、内存消耗等的比例。</li>
<li><code>Micro Benchmarking</code>：对单个函数或语句块调用的小测试。</li>
</ul>
<p><em>记得使用针对性的数据类型，避免出错。</em></p>
<h3 id="编译警告">编译警告</h3>
<ul>
<li><code>Compiler Error</code>：CE，编译器错误，程序不能编译。</li>
<li><code>Compiler Warning</code>：程序能够编译，但是有一段有问题的代码可能会导致运行时错误。</li>
</ul>
<p>一些 gcc/clang 编译器的编译设置：</p>
<ul>
<li><code>Wall</code>：没有真正启用所有警告，而是启用了最重要的警告，这些警告不会产生太多的干扰。</li>
<li><code>Wextra</code>：启用比 <code>-Wall</code> 更多的警告。</li>
<li><code>Wpedantic</code>：发出严格 ISO C++ 要求的所有警告；拒绝特定于编译器的扩展。</li>
<li><code>Wshadow</code>：当变量或类型声明相互隐藏时发出警告。</li>
<li><code>Werror</code>：把所有警告当作错误行为。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc [options] file ..</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -Wall -o test.exe test.cpp</span><br></pre></td></tr></table></figure>
<p>MS Visual Studio 的编译设置：</p>
<ul>
<li><code>/W1</code>：严重的警告。</li>
<li><code>/W2</code>：重要的警告。</li>
<li><code>/W3</code>：生产级别警告。</li>
<li><code>/W4</code>：并不能真正启用所有警告，而是最重要的警告，新项目推荐。</li>
<li><code>/Wall</code>：启用比级别4更多的警告。</li>
<li><code>/WX</code>：把所有的警告当成错误行为。</li>
</ul>
<h3 id="断言">断言</h3>
<p>头文件：<code>#include &lt;cassert&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="type">bool</span> 表达式);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果表达式产生 <code>false</code>，则中止程序。</li>
</ul>
<p>使用案例：</p>
<ol>
<li>在运行时检查预期值/条件</li>
<li>验证前提条件（输入值）</li>
<li>验证不变量（例如，中间状态/结果）</li>
<li>验证后置条件（输出/返回值）</li>
</ol>
<p>注意，逗号需要加上括号：<code>assert</code> 是一个预处理器宏，逗号将被解释为宏参数分隔符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>( <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">1</span> );   <span class="comment">// error</span></span><br><span class="line"><span class="built_in">assert</span>((<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">1</span>));   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>可以使用自定义宏添加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assertmsg(expr，msg) assert (((void)msg，expr))</span></span><br><span class="line"><span class="built_in">assertmsg</span>(<span class="number">1</span><span class="number">+2</span>=<span class="number">2</span>，<span class="string">&quot;1加1必须是2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对于 g++/clang，通过定义预处理器宏 <code>NDEBUG</code> 来停用断言，例如，使用编译器开关：<code>g++-DNDEBUG…</code></p>
<p>对于 MS Visual Studio：</p>
<ul>
<li>断言会被显式激活的情况：
<ul>
<li>如果定义了预处理器宏 <code>_DEBUG</code>，例如使用编译器开关<code>/D_DEBUG</code>。</li>
<li>如果提供了编译器开关 <code>/MDd</code>。</li>
</ul>
</li>
<li>断言会被显式停用的情况：
<ul>
<li>如果定义了预处理器宏 <code>NDEBUG</code>。</li>
<li>在项目设置中或使用编译器开关 <code>/DNDEBUG</code>。</li>
</ul>
</li>
</ul>
<h4 id="静态断言">静态断言</h4>
<p><em>C++11支持。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="type">bool</span> 表达式);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">1</span><span class="number">+1</span>==<span class="number">2</span>，<span class="string">&quot;1加1必须是2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>C++17下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="type">bool</span> 表达式);</span><br></pre></td></tr></table></figure>
<p>功能：如果编译时常数表达式产生 <code>false</code>，则中止编译。</p>
<h3 id="测试">测试</h3>
<p>测试准则：</p>
<ul>
<li>使用断言：检查类型无法表达、保证的期望或假设，如
<ul>
<li>仅在运行时可用的预期值</li>
<li>先决条件（输入值）</li>
<li>不变量（例如，中间状态/结果）</li>
<li>后置条件（输出/返回值）</li>
</ul>
</li>
</ul>
<p><em>Release版本中应该去掉断言。</em></p>
<ul>
<li>编写测试用例：一旦确定了函数或类型的基本目的和接口即可开始准备。</li>
<li>使用测试框架：
<ul>
<li>小项目可以使用：doctest</li>
<li>大工程可以使用：Catch2</li>
</ul>
</li>
</ul>
<p>测试中最好不要 <strong>直接</strong> 用 <code>cin</code>、<code>cout</code>、<code>cerr</code>。</p>
<p>直接使用全局I/O流使得函数或类型难以测试。</p>
<ul>
<li>函数中用引用传递流：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;std::string msg; ...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::ostream &amp;os, State <span class="type">const</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; s.meg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_CASE</span>(<span class="string">&quot;State Log&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    State s&#123;<span class="string">&quot;expected&quot;</span>&#125;;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="built_in">log</span>(oss, s);</span><br><span class="line">    <span class="built_in">CHECK</span>(oss.<span class="built_in">str</span>() == <span class="string">&quot;expected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类作用域中使用流指针存储：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line">    std::ostream *_os;</span><br><span class="line">    <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Logger</span><span class="params">(std::ostream *os)</span> : _os(os), _count(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(std::string_view msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!_os)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *_os &lt;&lt; _count &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        ++_count;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_CASE</span>(<span class="string">&quot;Logging&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    Logger log&#123;&amp;oss&#125;;</span><br><span class="line">    log.<span class="built_in">add</span>(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    <span class="built_in">CHECK</span>(oss.<span class="built_in">str</span>() == <span class="string">&quot;0: message\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-gdb-进行调试">使用 gdb 进行调试</h3>
<p>gdb，GNU Debugger，是一种开源的调试器，与在 Visual Studio 上进行调试类似。不同的是，gdb 通过命令进行调试。</p>
<p>现有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fun</span>(n - <span class="number">1</span>) * n; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = std::<span class="built_in">stoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">fun</span>(num) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -o test test.cpp</span><br></pre></td></tr></table></figure>
<p>编译后，使用 gdb 调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU gdb (GDB) 11.2</span><br><span class="line">Copyright (C) 2022 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-w64-mingw32&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from test...</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>接着输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run 5</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting program: F:\Program\C++\\test.exe 5</span><br><span class="line">[New Thread 11572.0x4338]</span><br><span class="line">[New Thread 11572.0x28e8]</span><br><span class="line">[New Thread 11572.0x307c]</span><br><span class="line">120</span><br><span class="line">[Thread 11572.0x4dcc exited with code 0]</span><br><span class="line">[Thread 11572.0x4338 exited with code 0]</span><br><span class="line">[Thread 11572.0x307c exited with code 0]</span><br><span class="line">[Inferior 1 (process 11572) exited normally]</span><br></pre></td></tr></table></figure>
<p>这就完成了输入为 5 的测试。</p>
<p>可以设置断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在当前源代码的第12行添加断点</span><br><span class="line">break  12</span><br><span class="line"></span><br><span class="line">在所有源代码文件中第一个执行 fun 函数的那行添加断点</span><br><span class="line">break fun</span><br><span class="line"></span><br><span class="line">在 test.cpp 的第12行添加断点</span><br><span class="line">break test.cpp:12</span><br><span class="line"></span><br><span class="line">// 在 test.cpp 的 main 函数第一行添加断点</span><br><span class="line">break test.cpp:main</span><br></pre></td></tr></table></figure>
<p>也可以使用条件型断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break 20 if i == 2000</span><br></pre></td></tr></table></figure>
<p>控制断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下一行</span><br><span class="line">next</span><br><span class="line"></span><br><span class="line">单步步进</span><br><span class="line">step</span><br></pre></td></tr></table></figure>
<p>还有一些控制断点的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出所有断点</span><br><span class="line">info breakpoints</span><br><span class="line"></span><br><span class="line">删除所有断点</span><br><span class="line">delete</span><br><span class="line"></span><br><span class="line">删除1号断点</span><br><span class="line">delete 1</span><br><span class="line"></span><br><span class="line">禁用2号断点</span><br><span class="line">disable 2</span><br><span class="line"></span><br><span class="line">启用2号断点</span><br><span class="line">enable 2</span><br><span class="line"></span><br><span class="line">保存断点到 file</span><br><span class="line">save breakpoints file</span><br><span class="line"></span><br><span class="line">从 file 中加载断点</span><br><span class="line">source file</span><br></pre></td></tr></table></figure>
<p>可以监视和设置变量值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">监视局部变量</span><br><span class="line">info locals</span><br><span class="line"></span><br><span class="line">输出变量（表达式）值</span><br><span class="line">print x</span><br><span class="line">print x + 2</span><br><span class="line"></span><br><span class="line">设置变量值</span><br><span class="line">set x = 20</span><br></pre></td></tr></table></figure>
<p>常用命令还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">跳转</span><br><span class="line">jump &lt;loc&gt;</span><br><span class="line"></span><br><span class="line">继续直到下一个断点或结束</span><br><span class="line">continue</span><br><span class="line"></span><br><span class="line">继续直到下一个位置（函数、行）</span><br><span class="line">until &lt;loc&gt;</span><br><span class="line"></span><br><span class="line">结束（跳出）当前函数</span><br><span class="line">finish</span><br><span class="line"></span><br><span class="line">查看调用栈</span><br><span class="line">backtrace</span><br></pre></td></tr></table></figure>
<h3 id="清理器">清理器</h3>
<p>C++ 功能强大，但会遇到一些 bug，所以需要清理器（善后）。</p>
<h4 id="地址清理器asan">地址清理器ASAN</h4>
<p>对于 g++ 和 clang++而言：</p>
<ul>
<li>检测内存损坏 bug：
<ul>
<li>内存泄漏</li>
<li>访问已释放的内存</li>
<li>访问不正确的堆栈区域</li>
<li>…</li>
</ul>
</li>
<li>用附加指令对代码进行检测：
<ul>
<li>运行时间大约增加70%</li>
<li>内存使用量大约增加了3倍</li>
</ul>
</li>
</ul>
<p>如有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu 中使用 gcc 9.4.0，输入下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test -fsanitize=address</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>后提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddressSanitizer:DEADLYSIGNAL</span><br><span class="line">=================================================================</span><br><span class="line">==1698==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x56468da812d8 bp 0x7fff3402eec0 sp 0x7fff3402eeb0 T0)</span><br><span class="line">==1698==The signal is caused by a READ memory access.</span><br><span class="line">==1698==Hint: address points to the zero page.</span><br><span class="line">    #0 0x56468da812d7 in main (/home/ecs-assist-user/test/tes+0x12d7)</span><br><span class="line">    #1 0x7f22b0c18082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)</span><br><span class="line">    #2 0x56468da811cd in _start (/home/ecs-assist-user/test/tes+0x11cd)</span><br><span class="line"></span><br><span class="line">AddressSanitizer can not provide additional info.</span><br><span class="line">SUMMARY: AddressSanitizer: SEGV (/home/ecs-assist-user/test/tes+0x12d7) in main</span><br><span class="line">==1698==ABORTING</span><br></pre></td></tr></table></figure>
<p>对于 MSVC：</p>
<blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/sanitizers/asan?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/sanitizers/asan?view=msvc-170</a></p>
</blockquote>
<ul>
<li>从 Visual Studio 2019 版本 16.9 开始，Microsoft C/C++ 编译器 (MSVC) 和 IDE 支持AddressSanitizer清理器。</li>
<li>检测 bug：
<ul>
<li>alloc/dealloc 不匹配和 new/delete 类型不匹配</li>
<li>分配对堆来说太大</li>
<li>calloc 溢出和 alloca 溢出</li>
<li>重复释放和释放后使用</li>
<li>全局变量溢出</li>
<li>堆缓冲区溢出</li>
<li>对齐值对齐无效</li>
<li>memcpy 和 strncat 参数重叠</li>
<li>堆栈缓冲区溢出和下溢</li>
<li>return 后使用堆栈和限定作用域后使用</li>
<li>在内存中毒后使用内存</li>
</ul>
</li>
</ul>
<h4 id="未定义行为清理器ubsan">未定义行为清理器UBSAN</h4>
<p>对于 g++ 和 clang++而言：</p>
<ul>
<li>在运行时检测许多类型的未定义行为：
<ul>
<li>解引用空指针</li>
<li>从未对齐的指针中读取</li>
<li>整数溢出</li>
<li>除零</li>
<li>…</li>
</ul>
</li>
<li>用附加指令检测代码：
<ul>
<li>调试版运行时间增加25%</li>
</ul>
</li>
</ul>
<p>如有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu 中使用 gcc 9.4.0，输入下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test -fsanitize=undefined</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>后提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.cpp:9:7: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type &#x27;int&#x27;</span><br><span class="line">-2147483648</span><br></pre></td></tr></table></figure>
<h4 id="内存泄漏检测工具valgrind">内存泄漏检测工具valgrind</h4>
<p>Valgrind是一套 <strong>Linux</strong> 下，开放源代码（GPL V2）的仿真调试工具的集合。</p>
<ul>
<li>检测常见的运行时错误：
<ul>
<li>读/写释放内存或不正确的堆栈区域</li>
<li>使用未初始化的值</li>
<li>不正确的内存释放，如双重释放</li>
<li>错误地使用函数来分配内存</li>
<li>内存泄漏——通常与程序有关的无意内存消耗</li>
<li>导致内存指针在释放之前丢失的逻辑缺陷</li>
</ul>
</li>
</ul>
<p>更多查看：<a href="https://blog.csdn.net/weixin_45518728/article/details/119865117">https://blog.csdn.net/weixin_45518728/article/details/119865117</a></p>
<h2 id="lambda函数">Lambda函数</h2>
<p>Lambda 函数的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[捕获列表] (参数列表) -&gt; 返回值类型 &#123; 代码块 &#125;</span><br></pre></td></tr></table></figure>
<p>举几个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[] &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">[] (<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x * x + y * y; &#125;</span><br><span class="line"></span><br><span class="line">[] (<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">double</span> &#123; <span class="keyword">return</span> <span class="number">1.0</span> * x * x + y * y; &#125;</span><br></pre></td></tr></table></figure>
<p>Lambda 函数可以看作匿名函数，它没有名字。</p>
<p>关于变量捕获：</p>
<ul>
<li><code>[=]</code>：捕获所有变量，值传递。</li>
<li><code>[&amp;]</code>：捕获所有变量，引用传递。</li>
<li><code>[x, &amp;y]</code>：x为值传递，y为引用传递。</li>
<li><code>[=, &amp;y]</code>：除了y是引用传递，其他都是值传递。</li>
</ul>
<p>在某些情况下，可以使用 Lambda 函数。</p>
<ul>
<li>函数 <code>std::partition(@first, @last, p)</code>，定义于头文件 <code>&lt;algorithm&gt;</code>。
<ul>
<li>其一个功能用法是：重排序范围 <code>[first, last)</code> 中的元素，使得谓词 <code>p</code> 对其返回 <code>true</code> 的元素前于谓词 <code>p</code> 对其返回 <code>false</code> 的元素。不保持相对顺序。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">-3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">99</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	</span><br><span class="line">std::<span class="built_in">partition</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// 5 3 3 2 7 1 99 0 -3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>std::transform(@first, @last, @result, @op)</code>，定义于头文件 <code>&lt;algorithm&gt;</code>。
<ul>
<li>其一个功能用法是：将范围 <code>[first, last)</code> 中的元素应用 <code>op</code> 变化 ，结果存储在 <code>result</code> 中。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转全大写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upper</span><span class="params">(std::string &amp;s)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), [] (<span class="type">unsigned</span> <span class="type">char</span> c) &#123; <span class="keyword">return</span> <span class="built_in">toupper</span>(c); &#125;);</span><br><span class="line">    <span class="comment">// 等价于 std::transform(s.begin(), s.end(), s.begin(), ::toupper);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对序列每个数字求平方</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> squared = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="comment">// 匿名函数类型还是用 auto 自动推导吧</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), squared);</span><br><span class="line"><span class="comment">// 等价于std::transform(v.begin(), v.end(), v.begin(), [](int x) &#123; return x * x; &#125;);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>std::generate(@first, @last, @op)</code>，定义于头文件 <code>&lt;algorithm&gt;</code>。
<ul>
<li>其中一个用法是：为 <code>[first, last)</code>范围内的每个元素分配一个由给定函数对象 <code>g</code> 生成的值。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">1</span>;</span><br><span class="line">    std::<span class="built_in">generate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;step] </span><br><span class="line">    &#123;</span><br><span class="line">        step *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> step; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在C++14及以后，如果变量的类型复制代价昂贵，可以使用<code>std::move</code></em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Expensive</span> &#123;...&#125;;</span><br><span class="line">Expensive f&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> g = [cf = std::<span class="built_in">move</span>(f)]() &#123; <span class="keyword">return</span> cf; &#125;;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GPU服务器的选用</title>
    <url>/2023/gpuserver/</url>
    <content><![CDATA[<p>介绍关于GPU服务器：租用、使用</p>
<h2 id="gpu服务器服务商">GPU服务器服务商</h2>
<ol>
<li>AutoDL算力云</li>
</ol>
<ul>
<li>网站：<a href="https://www.autodl.com/home">AutoDL算力云</a></li>
<li>个人评价：本人具有使用经历，价格偏便宜，镜像有现成，适合新手入门尝试。</li>
</ul>
<ol start="2">
<li><a href="https://mistgpu.com/">MistGPU</a></li>
</ol>
<ul>
<li>网站：<a href="https://mistgpu.com/">MistGPU</a></li>
<li>个人评价：价格还行，备用选择。</li>
</ul>
<ol start="3">
<li>阿里云</li>
</ol>
<ul>
<li>网站：<a href="https://www.aliyun.com/product/ecs/gpu">阿里云</a></li>
<li>个人评价：阿里云，不多说，可靠也不便宜。</li>
</ul>
<h2 id="gpu服务器使用">GPU服务器使用</h2>
<ol>
<li>选择适合的GPU型号、显存大小、浮点算力、存储盘大小。</li>
<li>选择合适的镜像进行环境配置。</li>
<li>一般无图形窗口，命令行使用，文件上传下载。</li>
<li>详细可参考各个服务商的帮助文档。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>OI Wiki，一个整合了编程竞赛的知识整合站点</title>
    <url>/2023/oiwiki/</url>
    <content><![CDATA[<p>Github分享</p>
<h2 id="是什么">是什么</h2>
<p>“OI Wiki 致力于成为一个免费开放且持续更新的知识整合站点，大家可以在这里获取关于 编程竞赛 (competitive programming) 有趣又实用的知识，我们为大家准备了竞赛中的基础知识、常见题型、解题思路以及常用工具等内容，帮助大家更快速深入地学习编程竞赛。”</p>
<h2 id="内容链接">内容链接</h2>
<p><a href="https://oi-wiki.org/">OI Wiki——网页使用</a><br>
<a href="https://github.com/OI-wiki/OI-wiki">Github 仓库</a><br>
<a href="https://gitee.com/OI-wiki/OI-wiki">Gitee 仓库</a></p>
<h2 id="如何使用">如何使用</h2>
<p>在Github主页上有详细介绍。</p>
<p>可以直接点击上面的OI Wiki链接使用。</p>
<p>我在此用Windows 10做一个简单的 <strong>离线版</strong> 使用示例。</p>
<ol>
<li>直接或git方式下载仓库压缩包。</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_download.jpg" alt="下载"></p>
<ol start="2">
<li>
<p>解压压缩包</p>
</li>
<li>
<p>在Python下（没有Python的可以<a href="https://fingsinz.space/2023/8">安装Python</a>），使用命令建立静态网页：在解压后的目录下地址栏输入cmd，接着输入下面的命令启动网页。</p>
</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_run.jpg" alt="打开cmd"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 如果是 python3</span><br><span class="line">python3 -m http.server</span><br><span class="line"># 如果是 python2</span><br><span class="line">python2 -m SimpleHTTPServer</span><br><span class="line"># 有些环境下找不到名叫 python3/python2 的可执行文件，不妨运行 python 试试</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_run2.jpg" alt="启动网页服务"></p>
<ul>
<li>如上图则为启动网页服务成功。我在此输入的是<code>python</code>，可以试试<code>python3</code>或者<code>python2</code>能不能运行。</li>
<li>在浏览器地址栏中输入<code>http://localhost:8000/</code>或<code>127.0.0.1:8000</code>即可进入网页，其中<code>8000</code>为上图启动网页服务的端口，并不一定是<code>8000</code>。</li>
</ul>
<ol start="4">
<li>页面如下图即可进行阅读学习</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_home.jpg" alt="OI Wiki"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>读《快乐的Linux命令行》记录</title>
    <url>/2024/linux-command-line/</url>
    <content><![CDATA[<p>关键词： Linux</p>
<span id="more"></span>
<hr>
<blockquote>
<p>Reference：<a href="https://billie66.github.io/TLCL/">TLCL (billie66.github.io)</a></p>
</blockquote>
<h2 id="引言">引言</h2>
<blockquote>
<p>图形用户界面（Graphical User Interface，GUI）让简单的任务更容易完成，而命令行界面（Command Line Interface，CLI）使完成复杂的任务成为可能。</p>
</blockquote>
<p>《快乐的Linux命令行》一书面向现代 Linux 命令行用户，传授如何与命令行界面友好相处，如何工作？能做什么？使用命令行最好的方法是什么？</p>
<p>前提条件：</p>
<ul>
<li>安装 Linux 系统</li>
</ul>
<p><em>可使用 WSL，<a href="https://www.fingsinz.space/2024/20/">WSL安装记录</a></em></p>
<h2 id="学习-shell">学习 shell</h2>
<h3 id="一-什么是shell">一、什么是shell</h3>
<h4 id="1-1-初次接触">1.1 初次接触</h4>
<p>shell 是一个程序，能够接受命令并且传递给操作系统执行。Linux 发行版都提供一个名为 <code>bash</code> 的shell 程序。bash 全称为 Bourne Again Shell。</p>
<p>同时，终端（Terminal）也能访问 shell。启动终端时，提示如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$</span><br></pre></td></tr></table></figure>
<p>其解释如下：<code>当前用户名@主机名:工作目录$</code>。</p>
<ul>
<li>其中 <code>$</code> 表示这个终端具有 root（超级管理员）权限；</li>
<li>如果是 <code>#</code> 则表示当前权限是普通用户权限。</li>
</ul>
<p>可以尝试输入一些命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ abcd</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的命令并不是一条有效命令，只是举例。</li>
</ul>
<p>还有，可以通过 <code>↑</code> 按键获取上次输入的命令，也可以通过 <code>←</code> 或 <code>→</code> 按键移动光标从而编辑命令。</p>
<p><strong>不要尝试在终端里使用 <code>ctrl + c</code> 和 <code>ctrl + v</code> 进行拷贝粘贴操作</strong>，这两个控制代码有着不同的含义。</p>
<h4 id="1-2-简单命令">1.2 简单命令</h4>
<p>现在尝试运行一些简单的命令：</p>
<ol>
<li><code>date</code>，显示系统当前时间和日期。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">date</span></span><br><span class="line">Tue Jul  9 13:53:43 CST 2024</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>cal</code>，显示当前月份日历。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ cal</span><br><span class="line">     July 2024</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">    1  2  3  4  5  6</span><br><span class="line"> 7  8  9 10 11 12 13</span><br><span class="line">14 15 16 17 18 19 20</span><br><span class="line">21 22 23 24 25 26 27</span><br><span class="line">28 29 30 31</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>df</code>，查看磁盘剩余空间数量。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">df</span></span><br><span class="line">Filesystem     1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sdb       263174212   1673872 248062184   1% /</span><br><span class="line">tmpfs            6499788         0   6499788   0% /mnt/wsl</span><br><span class="line">tools          124064548 105175296  18889252  85% /init</span><br><span class="line">none             6497704         0   6497704   0% /dev</span><br><span class="line">none             6499788        16   6499772   1% /run</span><br><span class="line">none             6499788         0   6499788   0% /run/lock</span><br><span class="line">none             6499788         0   6499788   0% /run/shm</span><br><span class="line">none             6499788         0   6499788   0% /run/user</span><br><span class="line">tmpfs            6499788         0   6499788   0% /sys/fs/cgroup</span><br><span class="line">drivers        124064548 105175296  18889252  85% /usr/lib/wsl/drivers</span><br><span class="line">lib            124064548 105175296  18889252  85% /usr/lib/wsl/lib</span><br><span class="line">C:\            124064548 105175296  18889252  85% /mnt/c</span><br><span class="line">D:\            124708860 102747776  21961084  83% /mnt/d</span><br><span class="line">E:\            488372220 367103492 121268728  76% /mnt/e</span><br><span class="line">F:\            488372220 416662024  71710196  86% /mnt/f</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>free</code>，显示空闲内存的数量。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       12999576       86816    11784240          80     1128520    12640980</span><br><span class="line">Swap:       4194304           0     4194304</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>exit</code>，关闭终端。</li>
</ol>
<h4 id="1-3-幕后控制台">1.3 幕后控制台</h4>
<p>在完全的 Linux 系统下，即使终端仿真器没有运行，在后台仍然有几个终端运行着。它们叫做虚拟终端或者是虚拟控制台。这些终端会话都可以通过按下 <code>Ctrl + Alt + F1</code> 到 <code>Ctrl + Alt + F6</code> 访问。当一个会话被访问的时候，它会显示登录提示框，需要输入用户名和密码。要从一个虚拟控制台转换到另一个，按下 Alt 和 F1-F6 （中的一个）。返回图形桌面，按下 <code>Alt + F7</code>。</p>
<h3 id="二-文件系统中跳转">二、文件系统中跳转</h3>
<h4 id="2-1-理解文件系统树">2.1 理解文件系统树</h4>
<p>Linux 以分层目录结构来组织所有文件，将所有文件组成了一棵树型目录。文件系统中的第一级目录称为<strong>根目录（/）</strong>。根目录包含文件和子目录， 子目录包含更多的文件和子目录。</p>
<p>当首次登录系统（或者启动终端仿真器会话）后，当前工作目录是<strong>家目录</strong>（~）。每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入文件的地方。</p>
<h4 id="2-2-文件目录的相关命令">2.2 文件目录的相关命令</h4>
<p>命令 <code>ls</code> 可以列出（一个或多个）目录（默认是工作目录）的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /</span><br><span class="line">bin   dev  home  lib    lib64       media  opt   root  sbin  srv  tmp  var</span><br><span class="line">boot  etc  init  lib32  lost+found  mnt    proc  run   snap  sys  usr</span><br></pre></td></tr></table></figure>
<p>命令 <code>pwd</code> （print working directory）可以显示当前工作目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/fingsinz</span><br></pre></td></tr></table></figure>
<p>命令 <code>cd</code> 可以进入某个目录，把某个目录作为工作目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cd</span> /</span><br><span class="line">fingsinz@FingsinzStudio:/$ <span class="built_in">ls</span></span><br><span class="line">bin   dev  home  lib    lib64       media  opt   root  sbin  srv  tmp  var</span><br><span class="line">boot  etc  init  lib32  lost+found  mnt    proc  run   snap  sys  usr</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>cd</code> 的目录可用绝对路径或相对路径。</p>
</li>
<li>
<p>绝对路径是以根目录 <code>/</code> 开始。</p>
</li>
<li>
<p>相对路径中，<code>.</code> 表示当前工作目录，<code>..</code> 表示当前工作目录的上一级目录（父目录）。</p>
</li>
</ul>
<p><code>cd</code> 有一些快捷的输入：</p>
<ul>
<li>
<p><code>cd</code> 可以更改工作目录到家目录</p>
</li>
<li>
<p><code>cd -</code> 可以更改工作目录到先前的工作目录。</p>
</li>
<li>
<p><code>cd ~user_name</code> 可以更改工作目录到用户家目录。</p>
</li>
</ul>
<h4 id="2-3-文件名的相关规则">2.3 文件名的相关规则</h4>
<blockquote>
<p>关于文件名的重要规则</p>
<ol>
<li>以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们，需要用 ls -a 命令。当创建帐号后，几个配置帐号的隐藏文件被放置在家目录下。另外，一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。</li>
<li>文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的 文件名。</li>
<li>Linux 没有“文件扩展名”的概念。可以用你喜欢的任何名字来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统，不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。</li>
<li>虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限“.”、“－”、下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与词间的空格，用下划线字符来代替。</li>
</ol>
</blockquote>
<h3 id="三-探究操作系统">三、探究操作系统</h3>
<h4 id="3-1-查询命令帮助">3.1 查询命令帮助</h4>
<p>命令通常会有一些选项，选项通过一些参数设定，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> -options arguments</span><br></pre></td></tr></table></figure>
<p>当不清楚命令的用法时，可以使用 <code>man</code> 进行查询，了解其功能以及参数，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-ls-的乐趣">3.2 ls 的乐趣</h4>
<p>对于 <code>ls</code> 比较常用的估计是 <code>ls -l</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:/$ <span class="built_in">ls</span> -l</span><br><span class="line">total 420</span><br><span class="line">drwxr-xr-x   2 root root   4096 Jul  9 12:04 bin</span><br><span class="line">drwxr-xr-x   2 root root   4096 May 21  2019 boot</span><br><span class="line">drwxr-xr-x   8 root root   2740 Jul  9 12:12 dev</span><br><span class="line">drwxr-xr-x  91 root root   4096 Jul  9 12:44 etc</span><br><span class="line">drwxr-xr-x   3 root root   4096 Jul  9 12:05 home</span><br><span class="line">-rwxr-xr-x   2 root root 644432 Aug  1  2023 init</span><br><span class="line">drwxr-xr-x  20 root root   4096 Jul  9 12:42 lib</span><br><span class="line">drwxr-xr-x   2 root root   4096 Jul  9 12:42 lib32</span><br><span class="line">drwxr-xr-x   2 root root   4096 Jul  9 12:23 lib64</span><br><span class="line">drwx------   2 root root  16384 Apr 11  2019 lost+found</span><br><span class="line">drwxr-xr-x   2 root root   4096 May 21  2019 media</span><br><span class="line">drwxr-xr-x   7 root root   4096 Jul  9 12:04 mnt</span><br><span class="line">drwxr-xr-x   2 root root   4096 May 21  2019 opt</span><br><span class="line">dr-xr-xr-x 153 root root      0 Jul  9 12:12 proc</span><br><span class="line">drwx------   2 root root   4096 May 21  2019 root</span><br><span class="line">drwxr-xr-x   9 root root    220 Jul  9 12:23 run</span><br><span class="line">drwxr-xr-x   2 root root   4096 Jul  9 12:04 sbin</span><br><span class="line">drwxr-xr-x   2 root root   4096 Mar 21  2019 snap</span><br><span class="line">drwxr-xr-x   2 root root   4096 May 21  2019 srv</span><br><span class="line">dr-xr-xr-x  11 root root      0 Jul  9 12:12 sys</span><br><span class="line">drwxrwxrwt   2 root root   4096 Jul  9 12:47 tmp</span><br><span class="line">drwxr-xr-x  11 root root   4096 Jul  9 12:42 usr</span><br><span class="line">drwxr-xr-x  13 root root   4096 May 21  2019 var</span><br></pre></td></tr></table></figure>
<p>对于上面输出的第一行 <code>drwxr-xr-x   2 root root   4096 Jul  9 12:04 bin</code>，含义依次如下：</p>
<ul>
<li><code>drwxr-xr-x</code> 表示文件访问权限。第一个字符表示文件类型，“-”表示普通文件，“d”表示目录；后三个字符是文件所有者的访问权限；再后三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限。<em>完整含义后面讨论。</em></li>
<li><code>2</code> 表示文件硬链接数目。</li>
<li><code>root</code> 表示文件所有者用户名。</li>
<li><code>root</code> 表示文件所属用户组名字。</li>
<li><code>4096</code> 表示文件字节数大小。</li>
<li><code>Jul 9 12:06</code> 表示上次修改文件的时间和日期。</li>
<li><code>bin</code> 表示文件名。</li>
</ul>
<h4 id="3-4-确定文件类型">3.4 确定文件类型</h4>
<p>命令 <code>file</code> 可以输出文件内容的简单描述。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ file man.png</span><br><span class="line">man.png: PNG image data, 1175 x 731, 8-bit/color RGBA, non-interlaced</span><br></pre></td></tr></table></figure>
<h4 id="3-5-less浏览文件内容">3.5 less浏览文件内容</h4>
<p>命令 <code>less</code> 可以查看文本文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ less hello.cpp</span><br></pre></td></tr></table></figure>
<p><code>less</code> 运行起来后，如果文件内容多于一页，那么可以上下滚动文件。按下“q”键，退出 <code>less</code> 程序。下面还有一些常用的键盘命令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>PageUp</code> 或 <code>b</code></td>
<td style="text-align:center">向上翻滚一页</td>
</tr>
<tr>
<td style="text-align:center"><code>PageDown</code> 或 <code>空格</code></td>
<td style="text-align:center">向下翻滚一页</td>
</tr>
<tr>
<td style="text-align:center">上箭头</td>
<td style="text-align:center">向上翻滚一行</td>
</tr>
<tr>
<td style="text-align:center">下箭头</td>
<td style="text-align:center">向下翻滚一行</td>
</tr>
<tr>
<td style="text-align:center"><code>G</code></td>
<td style="text-align:center">移到最后一行</td>
</tr>
<tr>
<td style="text-align:center"><code>1G</code> 或 <code>g</code></td>
<td style="text-align:center">移动到开头1行</td>
</tr>
<tr>
<td style="text-align:center"><code>/字符</code></td>
<td style="text-align:center">查找指定字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>n</code></td>
<td style="text-align:center">向前查找下一个出现的字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>h</code></td>
<td style="text-align:center">显示帮助</td>
</tr>
</tbody>
</table>
<h4 id="3-6-符号链接和硬链接">3.6 符号链接和硬链接</h4>
<p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -l /bin/</span><br><span class="line">total 15320</span><br><span class="line">-rwxr-xr-x 1 root root 1113504 May  3  2019 bash</span><br><span class="line">...</span><br><span class="line">-rwsr-xr-x 1 root root   64424 Mar 10  2017 ping</span><br><span class="line">lrwxrwxrwx 1 root root       4 Mar 10  2017 ping4 -&gt; ping</span><br><span class="line">lrwxrwxrwx 1 root root       4 Mar 10  2017 ping6 -&gt; ping</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>ping4</code> 和 <code>ping6</code> 都有 <code>-&gt; ping</code>，其含义是符号链接（也称为软链接或者 symlink ）。在大多数“类Unix”系统中，有可能一个文件被多个文件名所指向。在这种链接下，当使用 <code>ping4</code> 时，实际上是使用 <code>ping</code>。</p>
<p>还有一种链接类型，叫做硬链接。硬链接同样允许文件有多个名字，但是硬链接以不同的方法来创建多个文件名。<em>更多见后面章节。</em></p>
<h4 id="3-7-部分目录含义">3.7 部分目录含义</h4>
<table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">根目录，一切起源</td>
</tr>
<tr>
<td style="text-align:center"><code>/bin</code></td>
<td style="text-align:center">包含系统启动和运行所必需的可执行二进制程序</td>
</tr>
<tr>
<td style="text-align:center"><code>/boot</code></td>
<td style="text-align:center">Linux 内核、初始 RAM 磁盘映像和启动加载程序</td>
</tr>
<tr>
<td style="text-align:center"><code>/dev</code></td>
<td style="text-align:center">设备结点目录，内核维护着所有设备的列表</td>
</tr>
<tr>
<td style="text-align:center"><code>/etc</code></td>
<td style="text-align:center">系统层面的配置文件</td>
</tr>
<tr>
<td style="text-align:center"><code>/home</code></td>
<td style="text-align:center">给每个用户在此分配家目录</td>
</tr>
<tr>
<td style="text-align:center"><code>/lib</code></td>
<td style="text-align:center">核心系统查询所使用的共享库文件，类似于 Windows 中的 DLL</td>
</tr>
<tr>
<td style="text-align:center"><code>/lost+found</code></td>
<td style="text-align:center">当部分恢复一个损坏的文件系统时会用到</td>
</tr>
<tr>
<td style="text-align:center"><code>/media</code></td>
<td style="text-align:center">可移动介质挂载的地方</td>
</tr>
<tr>
<td style="text-align:center"><code>/mnt</code></td>
<td style="text-align:center">可移动介质（存储空间）挂载的地方</td>
</tr>
<tr>
<td style="text-align:center"><code>/opt</code></td>
<td style="text-align:center">用来安装可选的软件。这个主要用来存储可能安装在系统中的商业软件产品</td>
</tr>
<tr>
<td style="text-align:center"><code>/proc</code></td>
<td style="text-align:center">由内核维护的虚拟文件系统，它所包含的文件是内核的窥视孔</td>
</tr>
<tr>
<td style="text-align:center"><code>/root</code></td>
<td style="text-align:center">超级管理员的家目录</td>
</tr>
<tr>
<td style="text-align:center"><code>/sbin</code></td>
<td style="text-align:center">包含系统二进制文件，通常为超级用户保留。</td>
</tr>
<tr>
<td style="text-align:center"><code>/tmp</code></td>
<td style="text-align:center">存储由各种程序创建的临时文件的地方</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr</code></td>
<td style="text-align:center">包含普通用户所需要的所有程序和文件</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr/bin</code></td>
<td style="text-align:center">包含系统安装的可执行程序</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr/lib</code></td>
<td style="text-align:center">包含由 <code>/usr/bin</code> 目录中的程序所用的共享库</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr/local</code></td>
<td style="text-align:center">是非系统发行版自带程序的安装目录</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr/sbin</code></td>
<td style="text-align:center">包含许多系统管理程序</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr/share</code></td>
<td style="text-align:center">包含许多由 <code>/usr/bin</code> 目录中的程序使用的共享数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>/usr/share/doc</code></td>
<td style="text-align:center">大多数安装在系统中的软件包会包含一些文档</td>
</tr>
<tr>
<td style="text-align:center"><code>/var</code></td>
<td style="text-align:center">存放动态文件。各种数据库，假脱机文件，用户邮件等等</td>
</tr>
<tr>
<td style="text-align:center"><code>/var/log</code></td>
<td style="text-align:center">包含日志文件、各种系统活动的记录</td>
</tr>
</tbody>
</table>
<h3 id="四-操作文件和目录">四、操作文件和目录</h3>
<h4 id="4-1-通配符">4.1 通配符</h4>
<p>通配符，一些特殊字符帮助快速指定一组文件名。</p>
<table>
<thead>
<tr>
<th style="text-align:center">通配符</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">匹配任意多个字符（包括零个或一个）</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">匹配任意一个字符（不包括零个）</td>
</tr>
<tr>
<td style="text-align:center"><code>[字符]</code></td>
<td style="text-align:center">匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[!字符]</code></td>
<td style="text-align:center">匹配任意一个不是字符集中的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[[:class:]]</code></td>
<td style="text-align:center">匹配任意一个属于指定字符集类中的字符</td>
</tr>
</tbody>
</table>
<p>字符类有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符类</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[:alnum:]</code></td>
<td style="text-align:center">匹配任意一个字母或数字</td>
</tr>
<tr>
<td style="text-align:center"><code>[:alpha:]</code></td>
<td style="text-align:center">匹配任意一个字母</td>
</tr>
<tr>
<td style="text-align:center"><code>[:digit:]</code></td>
<td style="text-align:center">匹配任意一个数字</td>
</tr>
<tr>
<td style="text-align:center"><code>[:lower:]</code></td>
<td style="text-align:center">匹配任意一个小写字母</td>
</tr>
<tr>
<td style="text-align:center"><code>[:upper:]</code></td>
<td style="text-align:center">匹配任意一个大写字母</td>
</tr>
</tbody>
</table>
<p>举一些例子：</p>
<ul>
<li><code>*</code>：匹配所有文件。</li>
<li><code>g*</code>：匹配文件名以“g”开头的文件。</li>
<li><code>b*.txt</code>：匹配文件名以“b”开头，中间可以有零个或任意多个字符，且以“.txt”结尾的文件。</li>
<li><code>Data???</code>：匹配以“Data”开头，其后接着3个字符的文件。</li>
<li><code>[abc]*</code>：匹配文件名以“a”或“b”或“c”开头的文件。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>：匹配以“BACKUP.”开头，后接三个数字的文件。</li>
<li><code>[[:upper:]]*</code>：匹配以大写字母开头的文件。</li>
<li><code>*[[:lower:]123]</code>：匹配文件名以小写字母结尾，或以“1”、“2”、“3”结尾的文件。</li>
</ul>
<h4 id="4-2-创建目录">4.2 创建目录</h4>
<p>创建目录命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory...</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">mkdir</span> tests</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span></span><br><span class="line">hello.cpp  man.png  tests</span><br></pre></td></tr></table></figure>
<p>可以一次性创建多个目录。</p>
<h4 id="4-3-复制文件和目录">4.3 复制文件和目录</h4>
<p>复制文件或者目录命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> item1 item2</span><br></pre></td></tr></table></figure>
<ul>
<li>意思是复制文件或目录 <code>item1</code> 到 文件或目录 <code>item2</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> item... directory</span><br></pre></td></tr></table></figure>
<ul>
<li>意思是复制多个文件或目录到 <code>directory</code> 中。</li>
</ul>
<p><code>cp</code> 命令有一些常用选项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-a</code>，<code>--archive</code></td>
<td style="text-align:center">复制文件和目录，以及它们的属性，包括所有权和权限。通常副本具有用户所操作文件的默认属性</td>
</tr>
<tr>
<td style="text-align:center"><code>-i</code>，<code>--interactive</code></td>
<td style="text-align:center">重写已存在文件之前，提示用户确认。如果不指定该选项，则默认重写文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-r</code> ，<code>--recursive</code></td>
<td style="text-align:center">递归复制目录以及目录中的内容</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code>，<code>--update</code></td>
<td style="text-align:center">当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在 的文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-v</code>，<code>--verbose</code></td>
<td style="text-align:center">显示翔实的命令操作信息</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ul>
<li><code>cp file1 file2</code>：复制文件 <code>file1</code> 内容到文件 <code>file2</code>。如果 <code>file2</code> 已经存在，<code>file2</code> 的内容会被 <code>file1</code> 的内容重写。如果 <code>file2</code> 不存在，则会创建 <code>file2</code>。</li>
<li><code>cp -i file1 file2</code>：这条命令和上面的命令一样，但是如果文件 <code>file2</code> 存在的话， 在文件 <code>file2</code> 被重写之前，会提示用户确认信息。</li>
<li><code>cp file1 file2 dir1</code>：复制文件 <code>file1</code> 和文件 <code>file2</code> 到目录 <code>dir1</code>。目录 <code>dir1</code> 必须存在。</li>
<li><code>cp dir1/* dir2</code>：使用一个通配符，在目录 <code>dir1</code> 中的所有文件都被复制到目录 <code>dir2</code> 中。<code>dir2</code> 必须已经存在。</li>
<li><code>cp -r dir1 dir2</code>：复制目录 <code>dir1</code> 中的内容到目录 <code>dir2</code>。如果目录 <code>dir2</code> 不存在， 创建目录 <code>dir2</code>，操作完成后，目录 <code>dir2</code> 中的内容和 <code>dir1</code> 中 的一样。如果目录 <code>dir2</code> 存在，则目录 <code>dir1</code> （和目录中的内 容）将会被复制到 <code>dir2</code> 中。</li>
</ul>
<h4 id="4-4-移动和重命名文件">4.4 移动和重命名文件</h4>
<p><code>mv</code> 命令可以执行文件的移动和文件的命名。使用与 <code>cp</code> 命令类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> item1 item2</span><br></pre></td></tr></table></figure>
<ul>
<li>意思是文件或目录 <code>item1</code> 移动或重命名为 <code>item2</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> item... directory</span><br></pre></td></tr></table></figure>
<ul>
<li>意思是移动多个文件或目录到 <code>directory</code> 中。</li>
</ul>
<p><code>mv</code> 命令有一些常用选项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-i</code>，<code>--interactive</code></td>
<td style="text-align:center">重写已存在文件之前，提示用户确认。如果不指定该选项，则默认重写文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code>，<code>--update</code></td>
<td style="text-align:center">当把文件从一个目录移动到另一个目录时，仅移动目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在 的文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-v</code>，<code>--verbose</code></td>
<td style="text-align:center">显示翔实的命令操作信息</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ul>
<li><code>mv file1 file2</code>：移动文件 <code>file1</code> 到文件 <code>file2</code>。如果 <code>file2</code> 已经存在，<code>file2</code> 的内容会被 <code>file1</code> 的内容重写。如果 <code>file2</code> 不存在，则会创建 <code>file2</code>。之后 <code>file1</code> 不再存在。</li>
<li><code>mv -i file1 file2</code>：这条命令和上面的命令一样，但是如果文件 <code>file2</code> 存在的话， 在文件 <code>file2</code> 被重写之前，会提示用户确认信息。</li>
<li><code>mv file1 file2 dir1</code>：移动 <code>file1</code> 和 <code>file2</code> 到目录 <code>dir1</code>。目录 <code>dir1</code> 必须存在。</li>
<li><code>mv dir1 dir2</code>：如果 <code>dir2</code> 不存在则创建，并且移动目录 <code>dir1</code> 的内容到目录 <code>dir2</code> 中，同时删除目录 <code>dir1</code>。如果 <code>dir2</code> 存在，则移动 <code>dir1</code> 以及它的内容到目录 <code>dir2</code>。</li>
</ul>
<h4 id="4-5-删除文件和目录">4.5 删除文件和目录</h4>
<p>删除文件和目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> item..</span><br></pre></td></tr></table></figure>
<p><code>rm</code> 有一些常用选项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-i</code>，<code>--interactive</code></td>
<td style="text-align:center">在删除已存在文件前，提示确认信息。</td>
</tr>
<tr>
<td style="text-align:center"><code>-r，</code>–recursive`</td>
<td style="text-align:center">递归删除文件。当删除一整个目录时，需要该选项</td>
</tr>
<tr>
<td style="text-align:center"><code>-f</code>，<code>--force</code></td>
<td style="text-align:center">忽视不存在的文件，强力删除</td>
</tr>
<tr>
<td style="text-align:center"><code>-v</code>，<code>--verbose</code></td>
<td style="text-align:center">显示翔实的命令操作信息</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ul>
<li><code>rm file1</code>：删除文件 <code>file1</code>。</li>
<li><code>rm -i file1</code>：删除之前提示确定。</li>
<li><code>rm -r file dir1</code>：递归删除文件 <code>file1</code>、目录 <code>dir1</code> 以及里面的内容。</li>
<li><code>rm -rf file1 dir1</code>：强制删除文件 <code>file1</code> 和 目录 <code>dir1</code> 以及里面的内容。</li>
</ul>
<p><strong>注意：<code>rm</code> 命令一旦删除没有复原，你需要知道你删的是什么，特别是与通配符一起用的情况，很容易删完所有文件。</strong></p>
<h4 id="4-6-链接">4.6 链接</h4>
<p>硬链接时最初 Unix 创建链接的方式，每个文件默认会有一个硬链接，这个硬链接给予文件名字。每创建一个硬链接，就为一个文件创建了一个额外的目录下。硬链接的局限性如下：</p>
<ol>
<li>一个硬链接不能关联它所在文件系统之外的文件，即一个链接不能关联与链接本身不在同一个磁盘分区上的文件。</li>
<li>一个硬链接不能关联一个目录。</li>
</ol>
<p>一个硬链接和文件本身没有什么区别。当列出一个包含硬链接的目录内容时，会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的链接都删除掉。</p>
<p>符号链接克服了硬链接的局限性。符号链接生效是通过创建一个特殊类型的文件， 这个文件包含一个关联文件或目录的文本指针。在这一方面，和 Windows 的快捷方式差不多。</p>
<p>一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例如，如果往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，<code>ls</code> 命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。</p>
<p><code>ln</code> 命令可以创建硬链接或者符号链接。</p>
<ul>
<li>创建硬链接：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file <span class="built_in">link</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建符号链接：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s item <span class="built_in">link</span></span><br></pre></td></tr></table></figure>
<h4 id="4-7-实操命令">4.7 实操命令</h4>
<p>首先在家目录中创建一个 <code>playground</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">mkdir</span> playground</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span></span><br><span class="line">playground</span><br></pre></td></tr></table></figure>
<p>进入 <code>playground</code> 目录，同时创建两个子目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">mkdir</span> dir1 dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2</span><br></pre></td></tr></table></figure>
<p>复制一些数据到 <code>playground</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">cp</span> /etc/passwd .</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2  passwd</span><br></pre></td></tr></table></figure>
<p>尝试一下 <code>cp</code> 的选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">cp</span> -iv /etc/passwd .</span><br><span class="line"><span class="built_in">cp</span>: overwrite <span class="string">&#x27;./passwd&#x27;</span>? y</span><br><span class="line"><span class="string">&#x27;/etc/passwd&#x27;</span> -&gt; <span class="string">&#x27;./passwd&#x27;</span></span><br></pre></td></tr></table></figure>
<p>感受一下 <code>mv</code> 文件移动，尝试理解下面的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2  passwd</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">mv</span> passwd dir1/</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> dir1</span><br><span class="line">passwd</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">cd</span> dir1</span><br><span class="line">fingsinz@FingsinzStudio:~/playground/dir1$ <span class="built_in">mv</span> -v passwd ../dir2/</span><br><span class="line">renamed <span class="string">&#x27;passwd&#x27;</span> -&gt; <span class="string">&#x27;../dir2/passwd&#x27;</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground/dir1$ <span class="built_in">ls</span> ../dir2</span><br><span class="line">passwd</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">rm</span> -r dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">mv</span> dir1/passwd  dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> dir2</span><br><span class="line">dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> dir1</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> dir1/</span><br></pre></td></tr></table></figure>
<ul>
<li>注意17行处，此时的 <code>dir2</code> 是一个文件，是 passwd 文件改名后，并不是一个目录。</li>
</ul>
<p>好的现在恢复原样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">mv</span> dir2 passwd</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">mkdir</span> dir2</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2  passwd</span><br></pre></td></tr></table></figure>
<p>再试试创建硬链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ln</span> passwd <span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ln</span> passwd dir1/test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ln</span> passwd dir2/test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> -l . dir1 dir2</span><br><span class="line">.:</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir1</span><br><span class="line">drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir2</span><br><span class="line">-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 passwd</span><br><span class="line">-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">dir1:</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">dir2:</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到 <code>passwd</code> 和 <code>test</code> 文件的硬链接数目都是 4。文件至少有一个硬链接，因为文件名就是由链接创建的。</li>
</ul>
<p>通过 <code>ls -li</code> 展示文件索引节点信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> -li . dir1 dir2</span><br><span class="line">.:</span><br><span class="line">total 16</span><br><span class="line">2261 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir1</span><br><span class="line">2285 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:04 dir2</span><br><span class="line">2307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 passwd</span><br><span class="line">2307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">dir1:</span><br><span class="line">total 4</span><br><span class="line">2307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">dir2:</span><br><span class="line">total 4</span><br><span class="line">2307 -rw-r--r-- 4 fingsinz fingsinz 1562 Jul 10 13:51 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可知所有的 <code>test</code> 和 <code>passwd</code> 的索引号都是一样的，这就证实这些文件是同一个文件。</li>
</ul>
<p>先把之前的硬链接简单删掉，然后创建符号链接玩玩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">rm</span> <span class="built_in">test</span> dir1/test dir2/test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ln</span> -s passwd <span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ln</span> -s passwd dir1/test</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> -li . dir1</span><br><span class="line">.:</span><br><span class="line">total 12</span><br><span class="line">2261 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:13 dir1</span><br><span class="line">2285 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:12 dir2</span><br><span class="line">2307 -rw-r--r-- 1 fingsinz fingsinz 1562 Jul 10 13:51 passwd</span><br><span class="line">2364 lrwxrwxrwx 1 fingsinz fingsinz    6 Jul 10 14:13 <span class="built_in">test</span> -&gt; passwd</span><br><span class="line"></span><br><span class="line">dir1:</span><br><span class="line">total 0</span><br><span class="line">2366 lrwxrwxrwx 1 fingsinz fingsinz 6 Jul 10 14:13 <span class="built_in">test</span> -&gt; passwd</span><br></pre></td></tr></table></figure>
<ul>
<li>需要注意，此处第14行的 <code>test</code> 应该是红色名字的，这表示是一个坏链接，找不到文件 <code>passwd</code>。</li>
</ul>
<p>删掉这个坏链接，然后进入到 <code>dir1</code> 目录重新建立符号链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground/dir1$ <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground/dir1$ <span class="built_in">rm</span> <span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground/dir1$ <span class="built_in">ln</span> -s ../passwd <span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground/dir1$ <span class="built_in">ls</span> -li</span><br><span class="line">total 0</span><br><span class="line">2366 lrwxrwxrwx 1 fingsinz fingsinz 9 Jul 10 14:17 <span class="built_in">test</span> -&gt; ../passwd</span><br></pre></td></tr></table></figure>
<ul>
<li>此时第7行的链接应该不是红色的了，是有效链接。</li>
<li>符号链接的文件索引并不一样，但是 <code>ls</code> 命令会提示链接的是什么。</li>
</ul>
<p>建立符号链接时应当注意目录，符号链接的目录是目标文件的相对目录。建立符号链接时，可以使用绝对路径名，这样万无一失。</p>
<p>最后，删掉 <code>playground/passwd</code>，观察链接情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2  passwd  <span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">rm</span> passwd</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> -li . dir1</span><br><span class="line">.:</span><br><span class="line">total 8</span><br><span class="line">2261 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:17 dir1</span><br><span class="line">2285 drwxr-xr-x 2 fingsinz fingsinz 4096 Jul 10 14:19 dir2</span><br><span class="line">2364 lrwxrwxrwx 1 fingsinz fingsinz    6 Jul 10 14:13 <span class="built_in">test</span> -&gt; passwd</span><br><span class="line"></span><br><span class="line">dir1:</span><br><span class="line">total 0</span><br><span class="line">2366 lrwxrwxrwx 1 fingsinz fingsinz 9 Jul 10 14:17 <span class="built_in">test</span> -&gt; ../passwd</span><br></pre></td></tr></table></figure>
<ul>
<li>此时所有的链接都已失效，名字呈红色。</li>
</ul>
<p>最后的最后，恢复现场，把 <code>playground</code> 一并删了，记得 <code>-r</code> 递归：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">cd</span> ..</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">rm</span> -r playground/</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -li</span><br><span class="line">total 0</span><br></pre></td></tr></table></figure>
<h3 id="五-使用命令">五、使用命令</h3>
<p>命令可以是：</p>
<ol>
<li>一个可执行程序，是诸如 C 和 C++ 语言写成的程序编译的二进制文件，也可以是由诸如 shell，perl， python，ruby 等等脚本语言写成的程序。</li>
<li>一个 shell 自身的命令。bash 支持若干命令， 例如 <code>cd</code> 命令。</li>
<li>一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。</li>
<li>一个命令别名。可以定义自己的命令，建立在其它命令之上。</li>
</ol>
<h4 id="5-1-显示命令类型">5.1 显示命令类型</h4>
<p><code>type</code> 命令是 shell 内部的命令，会显示命令的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>一些使用例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is aliased to `<span class="built_in">ls</span> --color=auto<span class="string">&#x27;</span></span><br><span class="line"><span class="string">fingsinz@FingsinzStudio:~$ type cp</span></span><br><span class="line"><span class="string">cp is /bin/cp</span></span><br><span class="line"><span class="string">fingsinz@FingsinzStudio:~$ type cd</span></span><br><span class="line"><span class="string">cd is a shell builtin</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>shell builtin</code>：表示是 shell 自身的命令，内建于 shell 的命令。</li>
</ul>
<h4 id="5-2-显示可执行程序的位置">5.2 显示可执行程序的位置</h4>
<p>为了确定所给定的执行程序的准确位置，使用 <code>which</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> exe</span><br></pre></td></tr></table></figure>
<p>由前面可以知道，<code>/bin</code> 目录下存放的是一些二进制文件，所以可以试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">which</span> <span class="built_in">cp</span></span><br><span class="line">/bin/cp</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">which</span> <span class="built_in">cd</span></span><br><span class="line">fingsinz@FingsinzStudio:~$</span><br></pre></td></tr></table></figure>
<ul>
<li><code>which</code> 只能用于显示可执行程序的位置，上面操作中， <code>cd</code> 并不是一个可执行程序，故没有输出。</li>
</ul>
<h4 id="5-3-获取shell内建命令的帮助文档">5.3 获取shell内建命令的帮助文档</h4>
<p>有时候我们并不能完全记住每个命令的用法，这个时候需要查阅帮助文档。</p>
<ul>
<li><code>help</code> 命令可以获取 shell 内建命令的帮助文档。</li>
<li><code>man</code> 命令可以获取程序的帮助文档（手册）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">help</span> <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span>: <span class="built_in">cd</span> [-L|[-P [-e]] [-@]] [<span class="built_in">dir</span>]</span><br><span class="line">    Change ...(省略)</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cd</span> --<span class="built_in">help</span></span><br><span class="line"><span class="built_in">cd</span>: <span class="built_in">cd</span> [-L|[-P [-e]] [-@]] [<span class="built_in">dir</span>]</span><br><span class="line">    Change ...(省略)</span><br><span class="line">fingsinz@FingsinzStudio:~$ man <span class="built_in">cp</span></span><br><span class="line"><span class="comment"># 省略 man cp 的输出</span></span><br></pre></td></tr></table></figure>
<p>在大多数Linux 系统中，<code>man</code> 使用 less 工具来显示参考手册。所显示的参考手册，被分成几个章节，它们不仅仅包括用户命令，也包括系统管理员 命令、程序接口、文件格式等等：</p>
<table>
<thead>
<tr>
<th style="text-align:center">章节</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">用户命令</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">程序接口内核系统调用</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">C库函数程序接口</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">特殊文件，比如设备结点和驱动程序</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">文件格式</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">游戏娱乐</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">其他方面</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">系统管理员命令</td>
</tr>
</tbody>
</table>
<p>默认情况下，会自动匹配 <code>man</code> 的对象属于什么内容显示。但如果要查找一 种文件格式，而同时它也是一个命令名时，这种情况没有指定章节号，总是得到第一个匹配项。具体使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man section xxx</span><br></pre></td></tr></table></figure>
<h4 id="5-4-显示命令说明">5.4 显示命令说明</h4>
<p>手册只是参考，阅读起来很困难。使用 <code>whatis</code> 程序可以显示匹配特定关键字的手册的名字和一行命令说明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ whatis <span class="built_in">rm</span></span><br><span class="line"><span class="built_in">rm</span> (1)               - remove files or directories</span><br><span class="line">fingsinz@FingsinzStudio:~$ whatis <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> (1)               - list directory contents</span><br></pre></td></tr></table></figure>
<h4 id="5-5-给命令起别名">5.5 给命令起别名</h4>
<p>使用 <code>alias</code> 命令可以创建自己的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> name=<span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>
<p>首先，多个命令可以通过 <code>;</code> 连接在一行使用，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">mkdir</span> playground; <span class="built_in">cd</span> playground; <span class="built_in">ls</span> -liha; <span class="built_in">cd</span> ..; <span class="built_in">rm</span> playground -r;</span><br><span class="line">total 8.0K</span><br><span class="line"> 509 drwxr-xr-x  2 fingsinz fingsinz 4.0K Jul 18 11:20 .</span><br><span class="line">1396 drwxr-xr-x 11 fingsinz fingsinz 4.0K Jul 18 11:20 ..</span><br><span class="line">fingsinz@FingsinzStudio:~$</span><br></pre></td></tr></table></figure>
<ul>
<li>一番操作下来，创建并进入 <code>playground</code> 文件夹，然后列出目录文件，最后退出目录并删除。</li>
</ul>
<p>在起别名之前最好用 <code>type</code> 命令看看是否已经被用了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure>
<p>然后再起别名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">alias</span> foo=<span class="string">&#x27;mkdir playground; cd playground; ls -liha; cd ..; rm playground -r;&#x27;</span></span><br><span class="line">fingsinz@FingsinzStudio:~$ foo</span><br><span class="line">total 8.0K</span><br><span class="line"> 509 drwxr-xr-x  2 fingsinz fingsinz 4.0K Jul 18 11:22 .</span><br><span class="line">1396 drwxr-xr-x 11 fingsinz fingsinz 4.0K Jul 18 11:22 ..</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">type</span> foo</span><br><span class="line">foo is aliased to `<span class="built_in">mkdir</span> playground; <span class="built_in">cd</span> playground; <span class="built_in">ls</span> -liha; <span class="built_in">cd</span> ..; <span class="built_in">rm</span> playground -r;<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>删除别名使用 <code>unalias</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">unalias</span> foo</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">type</span> foo</span><br><span class="line">-bash: <span class="built_in">type</span>: foo: not found</span><br></pre></td></tr></table></figure>
<p>在此章节介绍中，建立的别名会在 shell 会话结束时会消失。随后的章节里， 会了解怎样把自己的别名添加到文件中去，每次登录系统，这些文件会建立系统环境。</p>
<h3 id="六-重定向">六、重定向</h3>
<h4 id="6-1-标准输入-输出和错误">6.1 标准输入、输出和错误</h4>
<p>命令运行结果会输送到一个叫做<strong>标准输出</strong>的特殊文件（经常用<strong>stdout</strong>表示），而它们的状态信息则送到另 一个叫做<strong>标准错误</strong>的文件（<strong>stderr</strong>）。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。除此之外，许多程序从一个叫做<strong>标准输入</strong>（<strong>stdin</strong>）的设备得到输入，默认情况下，标准输入连接到键盘。</p>
<p>I/O 重定向允许更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但 是通过 I/O 重定向，可以做出改变。</p>
<h4 id="6-2-标准输出重定向">6.2 标准输出重定向</h4>
<p>重定向符 <code>&gt;</code> ，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> / &gt; ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh</span><br><span class="line">total 12K</span><br><span class="line">-rw-r--r--  1 fingsinz fingsinz  112 Jul 18 11:51 ls-output.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>重定向符输出的文件如果不存在，会自动创建。</li>
</ul>
<p>再比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /aaaaa &gt; ls-output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaaaa&#x27;</span>: No such file or directory</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh ls-output.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 0 Jul 18 11:53 ls-output.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>尝试将一个不存在的目录 <code>ls</code> 出来。</li>
<li>错误信息显示在屏幕，并没有输出到文件中，因为 <code>ls</code> 程序不把它的错误信息输送到标准输出，而是输送到标准错误。</li>
<li>每次重定向输出是，文件重视从头开始重写。</li>
</ul>
<p>这有一个技巧，简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是创建一个新的空文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ &gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<p>如果想要追加输出，使用 <code>&gt;&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh ls-output.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 0 Jul 18 11:58 ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> / &gt;&gt; ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh ls-output.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 112 Jul 18 11:58 ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> / &gt;&gt; ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh ls-output.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 224 Jul 18 11:58 ls-output.txt</span><br></pre></td></tr></table></figure>
<h4 id="6-3-标准错误重定向">6.3 标准错误重定向</h4>
<p>文件流的标准输入、标准输出和标准错误分别对应 shell 内部的文件描述符<code>0</code>、<code>1</code>、<code>2</code>。。shell 使用件描述符提供了一种表示法来重定向文件。标准错误和文件描述符 <code>2</code> 一样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /aaaa 2&gt; ls-error.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh ls-error.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 53 Jul 18 16:52 ls-error.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$</span><br></pre></td></tr></table></figure>
<h4 id="6-4-标准输出和错误到同一个文件">6.4 标准输出和错误到同一个文件</h4>
<p>使用 <code>&amp;&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -l /aaa &amp;&gt; ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh ls-output.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 52 Jul 18 16:54 ls-output.txt</span><br></pre></td></tr></table></figure>
<h4 id="6-5-处理不需要的输出">6.5 处理不需要的输出</h4>
<p>如果不需要命令的输出结果，可以重定向到 <code>/dev/null</code>。</p>
<ul>
<li><code>/dev/null</code> 是系统的一个设备，叫做位存储桶，可以接受输入且不对输入做处理。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -l /aaa 2&gt; /dev/null</span><br></pre></td></tr></table></figure>
<h4 id="6-6-cat命令">6.6 cat命令</h4>
<p><code>cat</code> 命令可以读取一个或多个文件，然后复制到标准输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [file]</span><br></pre></td></tr></table></figure>
<p>当 <code>cat</code> 的对象只有一个文件时，可以用来显示文件里面的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -l /aaa 2&gt; ls-output.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cat</span> ls-output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaa&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<p>当 <code>cat</code> 的对象有多个文件时，可以用来拼接文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cat</span> ls-output.txt ls-output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaa&#x27;</span>: No such file or directory</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaa&#x27;</span>: No such file or directory</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cat</span> ls-output.txt ls-output.txt &gt; ls-output2.txt</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cat</span> ls-output2.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaa&#x27;</span>: No such file or directory</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaa&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<p>当 <code>cat</code> 不带参数时，它会从标准输入读入数据并输出到标准输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cat</span></span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">fingsinz@FingsinzStudio:~$</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>ctrl + d</code> 告诉 <code>cat</code> 从标准输入的读取结束。</li>
</ul>
<h4 id="6-7-标准输入重定向">6.7 标准输入重定向</h4>
<p>使用符号<code>&lt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cat</span> &lt; ls-output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/aaa&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然不使用 <code>&lt;</code>，单靠 <code>cat</code> 也可以完成，但是 <code>&lt;</code> 就是一个重定向标准输入符号，后面会有更好的例子。</li>
</ul>
<h4 id="6-8-管道线">6.8 管道线</h4>
<p>使用管道操作符 <code>|</code>（竖杠），可以让一个命令的标准输出通过管道送至另一个命令的标准输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>
<ul>
<li>管道符前面的命令需要有标准输出，后面的命令需要接受标准输入。</li>
</ul>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> / | less</span><br></pre></td></tr></table></figure>
<h4 id="6-9-过滤器">6.9 过滤器</h4>
<p>有可能会把几个命令放在一起组成一个管道线。 以这种方式使用的命令被称为过滤器。</p>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> / | <span class="built_in">sort</span> | less</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sort</code> 具有排序的作用。</li>
</ul>
<h4 id="6-10-报道或忽略重复行">6.10 报道或忽略重复行</h4>
<p><code>uniq</code> 从标准输入或单个文件名参数接受数据有序列表（详情查看uniq 手册页），默认情况下，从数据列表中删除任何重复行。</p>
<ul>
<li>如果想看到重复的数据列表，让 <code>uniq</code> 命令带上 <code>-d</code> 选项。</li>
</ul>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">mkdir</span> playground</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">cd</span> playground/</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ &gt; a; &gt; b</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ &gt; <span class="built_in">test</span>/a</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> . <span class="built_in">test</span>/</span><br><span class="line">.:</span><br><span class="line">a  b  <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>/:</span><br><span class="line">a</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> . <span class="built_in">test</span>/ | <span class="built_in">sort</span> | <span class="built_in">uniq</span> | <span class="built_in">cat</span></span><br><span class="line"></span><br><span class="line">.:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>/:</span><br><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> . <span class="built_in">test</span>/ | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -d | <span class="built_in">cat</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<ul>
<li>先创建一个演示环境，在 <code>playground</code> 里面创建文件 <code>a</code>、<code>b</code>和文件夹 <code>test</code>，在文件夹 <code>test</code> 内创建文件 <code>a</code>。</li>
<li>使用管道符和 <code>uniq</code> 连接并重定向到 <code>cat</code> 中，输出并没有出现重复的文件 <code>a</code>。</li>
<li>第一行是空格是因为，<code>ls</code> 两个目录时中间会空一行，经过 <code>sort</code> 后排序到第一位。</li>
</ul>
<h4 id="6-11-wc命令">6.11 wc命令</h4>
<p><code>wc</code>（字计数）命令是用来显示文件所包含的行数、字数和字节数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">wc</span> ls-output.txt</span><br><span class="line"> 1  9 52 ls-output.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>输出的三个数字分别是：行数、单词数和字节数。</li>
<li><code>-l</code>  选项可以限制只输出行数。</li>
</ul>
<p>同样可以通过管道线进行统计数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~/playground$ <span class="built_in">ls</span> ./ <span class="built_in">test</span>/ | <span class="built_in">sort</span> | <span class="built_in">uniq</span> | <span class="built_in">wc</span> -l</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<ul>
<li>6 表示输出有6行。</li>
</ul>
<h4 id="6-12-grep命令">6.12 grep命令</h4>
<p><code>grep</code> 用来找到文件中的匹配文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep pattern [file...]</span><br></pre></td></tr></table></figure>
<ul>
<li>匹配的模式支持正则表达式。</li>
</ul>
<p>比如现在要从系统安装的程序中找到包含 <code>zip</code> 的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">uniq</span> | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">gpg-zip</span><br><span class="line">zipdetails</span><br></pre></td></tr></table></figure>
<p><code>grep</code> 有一些方便的选项：<code>-i</code> 使得 <code>grep</code> 在执行搜索时忽略大小写（通常，搜索是大小写敏感的）；<code>-v</code> 选项会告诉 <code>grep</code> 只打印不匹配的行。</p>
<h4 id="6-13-head和tail命令">6.13 head和tail命令</h4>
<p><code>head</code> 命令可以输出文件的前几行，<code>tail</code> 命令可以输出文件的后几行。</p>
<ul>
<li>默认输出十行，可以通过 <code>-n</code> 调整打印的行数。</li>
<li>也可以用到管道线中。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /bin | <span class="built_in">head</span></span><br><span class="line">bash</span><br><span class="line">btrfs</span><br><span class="line">btrfs-debug-tree</span><br><span class="line">btrfs-find-root</span><br><span class="line">btrfs-image</span><br><span class="line">btrfs-map-logical</span><br><span class="line">btrfs-select-super</span><br><span class="line">btrfs-zero-log</span><br><span class="line">btrfsck</span><br><span class="line">btrfstune</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /bin | <span class="built_in">tail</span> -n 2</span><br><span class="line">zmore</span><br><span class="line">znew</span><br></pre></td></tr></table></figure>
<p><code>tail</code> 命令的 <code>-f</code> 选项可以持续检测文件，当新内容添加后会立即出现，直至 <code>ctrl + c</code>。</p>
<h4 id="6-14-tee命令">6.14 tee命令</h4>
<p><code>tee</code> 命令制造了一个 “tee”安装到管道上。<code>tee</code> 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）。</p>
<p>当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span> | <span class="built_in">tee</span> bin.txt | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gpg-zip</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">zipdetails</span><br><span class="line">fingsinz@FingsinzStudio:~$ <span class="built_in">ls</span> -lh bin.txt</span><br><span class="line">-rw-r--r-- 1 fingsinz fingsinz 14K Jul 18 18:18 bin.txt</span><br></pre></td></tr></table></figure>
<h2 id="配置文件和shell环境">配置文件和shell环境</h2>
<h2 id="常见任务和基本工具">常见任务和基本工具</h2>
<h2 id="编写-shell脚本">编写 shell脚本</h2>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>给大一的你</title>
    <url>/2023/tofreshman/</url>
    <content><![CDATA[<p>如今大二将完，给大一朋友的一些话。</p>
<p>关键词：经验</p>
<span id="more"></span>
<hr>
<!-- toc -->
<p>刚高考完就像是刚解放了一样，有的人安排得忙忙的：把好久没看的纪录片、电视剧、电影看个遍；有的人还不知道干什么，日复一日看手机无聊度过。</p>
<p>在我自己看来，大一的你可以是这样：</p>
<ul>
<li>
<p><font face="kaiti">广泛阅读，看看文学，看看历史等等；</font></p>
</li>
<li>
<p><font face="kaiti">广泛交友，识得良师益友；</font></p>
</li>
<li>
<p><font face="kaiti">进入一两个社团组织，培养技能，提高能力；</font></p>
</li>
<li>
<p><font face="kaiti">……</font></p>
</li>
</ul>
<p>大一其实还算处于一种很自由，很空闲的状态。这个时候拥有很多试错的机会，可以去长见识。</p>
<p>如果说你想拼搏努力地度过大一，那就去关注比赛等学术上的活动，同样也是获得经验的过程。如果说你想时而摆烂，不想逼得自己那么紧，那也完全可以，慢慢提升自己。你可以走得很慢，但绝不后退。</p>
<p>趁着大一，我觉得最好是提高广度。更重要的是，你是你，无需别人怎么样你也怎么样。有时候遇到的室友、同学摆烂或者很卷，你可以不受他们影响，自个过自个的。注意，这个观念很简单，做到其实很难。</p>
<p>其实还有一点，大一是视野逐渐开阔的过程，这个过程中也有很多骗子趁机而入，希望能够三思，能够谨慎，能够小心，谨防诈骗。</p>
<hr>
<p>接着，我想说一些计算机专业相关的建议。其实很多同学大一之前对于计算机的知识是不全面的，更不用说丰富，你可以当作从零开始慢慢积累。</p>
<p>计算机并不是一门单纯地如何如何敲代码的学科，它其实更多是一门综合学科。你不用担心高中怎么偏科带来的影响，你可以先把高中带来的放到一边。</p>
<p>我个人觉得，计算机专业大一应该学习与实践结合，多用电脑，养成计算机的大局观：</p>
<p>学习方面</p>
<ul>
<li>
<p>编程语言：C语言或C++或者Python等其他语言，这是你的基本能力之一，学会一门编程语言之后便可以用计算机语言去解决一些问题。本博客也有部分编程语言的教程，可参考学习。</p>
</li>
<li>
<p>计算机导论：关于计算机的部分术语和基本内容，开始慢慢了解计算机，便于养成计算机大局观。推荐两个课程，<a href="https://www.bilibili.com/video/BV1EW411u7th/">【计算机科学速成课】40集全/精校 - Crash Course Computer Science</a>，<a href="https://www.bilibili.com/video/BV1Rb411378V/?spm_id_from=333.880.my_history.page.click&amp;vd_source=2accbe36e414045d5297e94e0d032887">【哈佛】计算机科学CS50-哈佛大学</a></p>
</li>
<li>
<p>计算机组成原理：关于计算机硬件方面的知识，慢慢知道从最小的逻辑门到整个CPU的组成原理，知道计算机的运作过程。</p>
</li>
<li>
<p>计算机网络：关于网络方面的知识，慢慢知道不同设备之间的连接通信的协议。</p>
</li>
<li>
<p>数据结构：关于编程基础的知识，用于进一步处理编程问题。</p>
</li>
<li>
<p>操作系统：关于计算机硬件和软件之间的内容，慢慢建立系统观念，了解如Windows系统和Linux系统。</p>
</li>
</ul>
<p>上面的这些内容可能大一的时候还没开始学，但是个人大一学是很好的机会。通过对这些方面的了解，会更好地认识计算机这一专业甚至行业。如果跟着学习的话，知识量上、方向上会超过同龄人很多。</p>
<p>还有一些很平常，学校不会怎么教学但很重要的内容：</p>
<ul>
<li>
<p>英语能力：尤其是阅读英语文章的能力，很多先进的理念知识都是由国外引进，直接阅读原文比别人翻译后喂到嘴里的感觉不一样的。很多国内的课程都可以找找国外大学有无网课，锻炼英语的同时也学到了技术。</p>
</li>
<li>
<p>学会使用Github和Gitee：<a href="https://www.github.com">Github（国外）</a>和<a href="https://www.gitee.com">Gitee（国内）</a>是较为出名的代码保管仓库，简单来说就是有很多大牛在上面发布他们的代码。</p>
</li>
<li>
<p>了解编程语言到程序的过程：比如知道C语言是怎么编程可执行文件，知道一些编译的事情。</p>
</li>
<li>
<p>了解编程工具的配置使用：编程工具的使用，比如Visual Studio，Visual Studio Code、Vim等工具。</p>
</li>
<li>
<p>养成良好的代码风格习惯：比如代码的格式，何时对齐，何时缩进。</p>
</li>
<li>
<p>程序项目和文件的管理：对于电脑上的文件敏感，懂得安排位置；对于项目知道大概的方向等等。</p>
</li>
</ul>
<p>实践方面</p>
<ul>
<li>
<p>光有理论还不行，在以上学习之余，也建议多去做一些小东西。哪怕是很简单的程序，哪怕就是一个黑窗口，都可以试着写一遍、运行一遍。有一些很简单的问题可以写程序解决，如一元二次方程求解、斐波那契数列求解等。</p>
</li>
<li>
<p>刷题：除了学校那一点的计算机作业，刷题是提高计算机代码能力的一个不错的途径，国内比较好的刷题网站有：<a href="https://ac.nowcoder.com/">牛客竞赛</a>、<a href="https://www.luogu.com.cn/">洛谷</a>、<a href="https://leetcode.cn/problemset/all/">力扣Leetcode</a>、<a href="https://www.acwing.com/problem/">Acwing</a>，在刷题的过程中不断解决问题，学习到算法，渐渐找找算法比赛的兴趣。如果实在没有算法也可以保持每日刷个一两题。</p>
</li>
</ul>
<p>比赛方面</p>
<ul>
<li>
<p>算法比赛/程序设计比赛：实际上与算法息息相关，如果你是有兴趣、或者对数学比较热爱，建议全身投入到算法的学习上，参加几个比赛看看成效。</p>
</li>
<li>
<p>常见的算法比赛有蓝桥杯、ACM等，可以关注学校、学院发布的消息。</p>
</li>
</ul>
<p>其实，大学里计算机的上课并不一定重要，要学会学习，不要盲目上课。如果你觉得老师授课模糊，理解不了，根本不能学习， <strong>上课时就坐到后排，及时上网找网课补救</strong> 。学校里的课程考试，考前突击、弄懂作业，一般及格就行（如果你是希望走保研、拿奖学金的方向，那还是得花功夫把考试考好），真正重要的是你是否学习到了知识。</p>
<p>如若你在大一结束时真能了解计算机组成原理、计算机网络、数据结构和操作系统这四门课，恭喜你，这是计算机考研408的专业课，你也比其他人提前了许多，后面做项目的意识也会改变许多。如果自己很忙，大一学不了学不完也无所谓，这本来就是比别人提前的课程。</p>
<p>希望在大一里扩宽自己的认识面，找到自己的发展方向。</p>
<hr>
<p>最后，如果想和我交流，或者是想要资料，欢迎<u>QQ：1192697361</u></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验之谈</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 语言学习记录</title>
    <url>/2024/rustbasic/</url>
    <content><![CDATA[<p>关键词：Rust</p>
<hr>
<p><strong>References：</strong></p>
<ul>
<li><a href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a></li>
<li><a href="https://rustwiki.org/zh-CN/book/">Rust 程序设计语言 中文版</a></li>
</ul>
<p>未完，待施工…</p>
<h2 id="前言">前言</h2>
<h3 id="什么是-rust">什么是 Rust</h3>
<p>Rust 是一门新的静态编译编程语言，其功能定位与 C++ 相似，它的 1.0 版本于 2015 年发布。</p>
<p><code>rustc</code> 使用 LLVM 作为它的后端。</p>
<p>Rust 支持多种平台和架构：x86、ARM、WebAssembly、Linux、Mac、Windows……</p>
<p>Rust 被广泛用于各种设备中：</p>
<ul>
<li>固件和引导程序</li>
<li>智能显示器</li>
<li>手机</li>
<li>桌面</li>
<li>服务器</li>
</ul>
<p>Rust 和 C++ 适用于类似的场景：</p>
<ul>
<li>极高的灵活性。</li>
<li>高度的控制能力。</li>
<li>能够在资源匮乏的设备（如手机）上运行。</li>
<li>没有运行时和垃圾收集。</li>
<li>关注程序可靠性和安全性，而不会牺牲任何性能。</li>
</ul>
<p>Rust 系统由许多工具组成：</p>
<ul>
<li><code>rustc</code>：Rust 编译器，将 <code>.rs</code> 文件转换为二进制文件和其他中间格式。</li>
<li><code>cargo</code>：Rust 依赖项管理器和构建工具（包管理工具）。负责下载依赖项并在构建项目时传递给编译器。其还附带内置的测试运行程序，用于执行单元测试。</li>
<li><code>rustup</code>：Rust 工具链安装和更新工具。当更新版本时，其用于安装并更新 <code>rustc</code> 和 <code>cargo</code>。还可用于下载标准库的文档，同时安装多个 Rust 版本。</li>
</ul>
<p>Rust 区分版本。这些版本支持对语言进行向后不兼容的更改。</p>
<ul>
<li>为防止破坏代码，版本是可选的： 通过 <code>Cargo.toml</code> 文件为 <code>crate</code> 选择合适的版本。</li>
<li>为免分割生态系统，Rust 编译器可以混合使用为不同版本编写的代码。</li>
</ul>
<h4 id="rust-的优势">Rust 的优势</h4>
<p>编译时内存安全：在编译时可防止所有类内存 bug。</p>
<ul>
<li>不存在未初始化的变量。</li>
<li>不存在“双重释放”。</li>
<li>不存在“释放后使用”。</li>
<li>不存在 NULL 指针。</li>
<li>不存在被遗忘的互斥锁。</li>
<li>不存在线程之间的数据竞争。</li>
<li>不存在迭代器失效。</li>
</ul>
<p>没有未定义的运行时行为：每个 Rust 语句的行为都有明确定义。</p>
<ul>
<li>数组访问有边界检查。</li>
<li>整数溢出有明确定义（panic 或回绕）。</li>
</ul>
<p>现代语言功能：具有与高级语言一样丰富且人性化的表达能力。</p>
<ul>
<li>枚举和模式匹配。</li>
<li>泛型。</li>
<li>无额外开销的外部函数接口（FFI）。</li>
<li>零成本抽象。</li>
<li>强大的编译器错误提示。</li>
<li>内置依赖管理器。</li>
<li>对测试的内置支持。</li>
<li>优秀的语言服务协议（Language Server Protocol）支持。</li>
</ul>
<h3 id="windows-下安装-rust">Windows 下安装 Rust</h3>
<p>可执行二进制文件下载地址：</p>
<ul>
<li><a href="https://www.rust-lang.org/zh-CN/tools/install">https://www.rust-lang.org/zh-CN/tools/install</a></li>
<li><a href="https://rustup.rs/">https://rustup.rs/</a></li>
<li>两个地址下载一个即可。</li>
</ul>
<p>点击运行 <code>rustup-init.exe</code>。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_install.jpg" alt="安装路径提示"></p>
<p>显示默认安装在 C 盘。</p>
<ul>
<li>此处已做修改，自定义安装路径。</li>
</ul>
<p>自定义安装路径步骤如下：</p>
<ol>
<li>创建自定义文件夹，我此处为 <code>D:/rust</code>。在内创建两个文件夹，分别为 <code>.cargo</code> 和 <code>.rustup</code>。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_newpath.jpg" alt="创建文件夹"></p>
<ol start="2">
<li>配置环境变量：把新建的文件夹添加到环境变量中。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_cargohome.jpg" alt="CargoHome"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_rustuphome.jpg" alt="RustupHome"></p>
<ol start="3">
<li>在 <code>PATH</code> 环境变量中加入上两个变量。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_addPath.jpg" alt="添加到PATH"></p>
<p>至此再打开 <code>rustup-init.exe</code>，观察路径是否修改。</p>
<p>接着输入 <code>1</code> 执行默认安装即可。</p>
<h3 id="在-vscode-上使用-rust">在 VSCode 上使用 Rust</h3>
<p>步骤如下：</p>
<ol>
<li>在扩展中查找并安装 <code>rust-analyzer</code> 和 <code>Native Debug</code> 两个插件。</li>
</ol>
<ul>
<li>另外两个推荐插件：
<ul>
<li>Even Better TOML，支持 .toml 文件完整特性</li>
<li>Error Lens，更好的获得错误展示</li>
</ul>
</li>
</ul>
<ol start="2">
<li>新建代码文件夹，在终端使用命令生成工程：</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cargo new hello</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写代码后，在终端使用命令运行：</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cargo build</span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure>
<h4 id="第一个-rust-程序">第一个 Rust 程序</h4>
<p>每一个语言一开始会有它的 Hello World。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数以 <code>fn</code> 开头。</li>
<li>代码块以 <code>&#123;</code> 开头，以 <code>&#125;</code> 结尾。</li>
<li>Rust 有卫生宏，<code>println!</code> 就是一个例子。
<ul>
<li>这意味着它们不会意外地捕获它们所在作用域中的标识符。</li>
</ul>
</li>
<li>Rust 字符串是 <code>UTF-8</code> 编码，可以包含 Unicode 字符。</li>
</ul>
<h3 id="下载依赖卡顿问题">下载依赖卡顿问题</h3>
<p>解决方法是：覆盖默认的镜像地址</p>
<p>在 <code>$HOME/.cargo/config.toml</code> 添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &#x27;ustc&#x27;</span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个新的镜像源 <code>[source.ustc]</code>，然后将默认的 <code>crates-io</code> 替换成新的镜像源: <code>replace-with = 'ustc'</code>。</li>
</ul>
<h2 id="rust-基础入门">Rust 基础入门</h2>
<p>速览语法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用let来声明变量，进行绑定，默认a是不可变的</span></span><br><span class="line">    <span class="comment">// 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>; <span class="comment">// 语句的末尾必须以分号结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动指定b的类型为i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在数值中带上类型:30i32表示数值是30，类型是i32</span></span><br><span class="line">    <span class="comment">// 声明变量时添加 mut 表示变量是可变的，mut是mutable的缩写</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="number">30i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还能在数值和类型中间添加一个下划线，让可读性更好</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = <span class="number">30_i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = <span class="title function_ invoke__">add</span>(<span class="title function_ invoke__">add</span>(a, b), <span class="title function_ invoke__">add</span>(c, d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块</span></span><br><span class="line">    <span class="comment">// 该函数将指定的格式化字符串输出到标准输出中(控制台)</span></span><br><span class="line">    <span class="comment">// &#123;&#125;是占位符，在具体执行过程中，会把e的值代入进来</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;( a + b ) + ( c + d ) = &#123;&#125;&quot;</span>, e);</span><br><span class="line">    <span class="comment">// println! 会自动推导出具体的类型，因此无需手动指定输出类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(i: <span class="type">i32</span>, j: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 返回相加值，这里可以省略return</span></span><br><span class="line">    <span class="comment">// 不添加 ;，表示返回 i + j，添加则表示返回空。</span></span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量绑定与解构">变量绑定与解构</h3>
<p>Rust 默认变量是不可修改的，这使得程序运行时性能上的提升。</p>
<p>在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 <a href="https://course.rs/practice/naming.html">Rust 命名规范</a>。</p>
<h4 id="变量绑定">变量绑定</h4>
<p>在其他语言中，如 <code>int a = 1</code> 称为赋值。但 Rust 中， <code>let a = 1</code> 称为 <strong>变量绑定</strong>。</p>
<p>绑定一词源自 Rust 的所有权问题。</p>
<ul>
<li>任何内存对象都是有主人的（Owner），对象完全属于它的主人。</li>
<li>绑定就是把这个对象绑定给一个变量，使变量成为它的主人。</li>
</ul>
<h4 id="变量的不可变与可变">变量的不可变与可变</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;  <span class="comment">// 错误：x 是不可变的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125;&quot;</span>, y);</span><br><span class="line">    y = <span class="number">11</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种不可变的优势是：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。</p>
<h4 id="忽略未使用的变量">忽略未使用的变量</h4>
<p>Rust 的高安全性会认为不使用的变量可能会是个 BUG，所以进行警告。</p>
<p>使用下划线 <code>_</code> 开头的变量名会被忽略。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量解构">变量解构</h4>
<p><code>let</code> 不仅可以进行变量的绑定，还可以进行复杂变量的解构。</p>
<ul>
<li>从一个相对复杂的变量中，匹配出该变量的一部分内容。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 匹配 a 和 b</span></span><br><span class="line">    <span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>, <span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不可变量与常量">不可变量与常量</h4>
<p>Rust 默认的是不可变量。常量是经过 <code>const</code> 修饰的量，且在 Rust 中值类型必须标注。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123</span>; <span class="comment">// 可以编译，但可能有警告，因为该变量没有被使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> b: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">2</span>;  <span class="comment">// 错误：常量不能被重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量遮蔽">变量遮蔽</h4>
<p>像上面写过的，Rust 允许声明相同的变量名，且后声明的变量名会遮蔽前面声明的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = : &#123;x&#125;&quot;</span>); <span class="comment">// 12</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = : &#123;x&#125;&quot;</span>); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个程序首先将数值 5 绑定到 <code>x</code>，然后通过重复使用 <code>let x =</code> 来遮蔽之前的 <code>x</code>，并取原来的值加上 1，所以 <code>x</code> 的值变成了 6。第三个 <code>let</code> 语句同样遮蔽前面的 <code>x</code>，取之前的值并乘上 2，得到的 <code>x</code> 最终值为 12。</li>
<li>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</li>
</ul>
<p>变量遮蔽的用处，在于在某个作用域内无需再使用之前的变量时，就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<h3 id="基本类型">基本类型</h3>
<p>内置数据类型有：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类型</th>
<th style="text-align:center">字面量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">有符号整数</td>
<td style="text-align:center"><code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>isize</code></td>
<td style="text-align:center"><code>-10</code>、<code>0</code>、<code>1_000</code>、<code>123_i64</code></td>
</tr>
<tr>
<td style="text-align:center">无符号整数</td>
<td style="text-align:center"><code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code></td>
<td style="text-align:center"><code>0</code>、<code>123</code>、<code>10_u16</code></td>
</tr>
<tr>
<td style="text-align:center">浮点数</td>
<td style="text-align:center"><code>f32</code>、<code>f64</code></td>
<td style="text-align:center"><code>3.14</code>、<code>-10.0e20</code>、<code>2_f32</code></td>
</tr>
<tr>
<td style="text-align:center">Unicode 标量类型</td>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>'a'</code>、<code>'α'</code>、<code>'∞'</code></td>
</tr>
<tr>
<td style="text-align:center">布尔值</td>
<td style="text-align:center"><code>bool</code></td>
<td style="text-align:center"><code>true</code>、<code>false</code></td>
</tr>
<tr>
<td style="text-align:center">单元类型</td>
<td style="text-align:center"><code>()</code></td>
<td style="text-align:center">其唯一的值也是 <code>()</code></td>
</tr>
</tbody>
</table>
<ul>
<li>数字中的下划线均可忽略，仅方便辨识，即 <code>1_000</code> 可以写成 <code>1000</code>，<code>123_i64</code> 等价 <code>123i64</code></li>
</ul>
<p>每种类型占用空间为：</p>
<ul>
<li><code>iN</code>、<code>uN</code> 和 <code>fN</code> 占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 位。</li>
<li><code>isize</code> 和 <code>usize</code> 占用一个指针大小的空间。</li>
<li><code>char</code> 占用 4 个字节，32 位空间。</li>
<li><code>bool</code> 占用 1 个字节，8 位空间。</li>
</ul>
<p>类型推导与标注：编译器必须在编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型。</p>
<ul>
<li>Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型。</li>
<li>在某些情况下，Rust 编译器无法推导出变量类型，需要手动去给予一个类型标注。</li>
</ul>
<h4 id="数值类型">数值类型</h4>
<h5 id="整数运算溢出">整数运算溢出</h5>
<p>关于运算时整数溢出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mul</span>(a: <span class="type">i16</span>, b: <span class="type">i16</span>, c: <span class="type">i16</span>) <span class="punctuation">-&gt;</span> <span class="type">i16</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_product</span> = <span class="title function_ invoke__">mul</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 尝试与溢出相乘，有符号整数16位的最大值为65535</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic（崩溃,Rust 使用这个术语来表明程序因错误而退出）。</li>
</ul>
<p>可以显式处理溢出，通过标准库针对原始数字类型提供的方法：</p>
<ul>
<li><code>wrapping_*</code> 在所有模式下都按照补码循环溢出规则，如 <code>wrapping_add</code>。</li>
<li><code>checked_*</code> 在发生溢出时返回 <code>None</code> 值。</li>
<li><code>overflowing_*</code> 返回该值和一个指示是否存在溢出的布尔值。</li>
<li><code>saturating_*</code> 可以限定计算后的结果不超过目标类型的最大值或低于最小值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = a.<span class="title function_ invoke__">checked_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = a.<span class="title function_ invoke__">overflowing_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = a.<span class="title function_ invoke__">saturating_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;a&#125;&quot;</span>);    <span class="comment">// 255</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;b&#125;&quot;</span>);    <span class="comment">// 19</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;c:?&#125;&quot;</span>);  <span class="comment">// None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;d:?&#125;&quot;</span>);  <span class="comment">// (19, true)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>);    <span class="comment">// 255</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="浮点数陷阱">浮点数陷阱</h5>
<p>浮点数的使用需要谨慎，原因：</p>
<ol>
<li>浮点数往往是数字的近似表达（并不是精确的）。</li>
<li>浮点数在某些特性上时反直觉的（比如比较时）。</li>
</ol>
<p>所以：</p>
<ul>
<li>避免在浮点数上判断相等；</li>
<li>当结果在数学上存在未定义时需要小心。</li>
</ul>
<p>一段代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">abc</span>: (<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span>: (<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;abc (f32)&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;   0.1 + 0.2: &#123;:x&#125;&quot;</span>, (abc.<span class="number">0</span> + abc.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;         0.3: &#123;:x&#125;&quot;</span>, (abc.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;xyz (f64)&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;   0.1 + 0.2: &#123;:x&#125;&quot;</span>, (xyz.<span class="number">0</span> + xyz.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3fd3333333333334</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;         0.3: &#123;:x&#125;&quot;</span>, (xyz.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3fd3333333333333</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(abc.<span class="number">0</span> + abc.<span class="number">1</span> == abc.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(xyz.<span class="number">0</span> + xyz.<span class="number">1</span> == xyz.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="nan">NaN</h5>
<p>对于数学上未定义的结果，比如负数取平方根，会返回一个 <code>NaN</code>表示。</p>
<ul>
<li>所有与 <code>NaN</code> 交互的操作都会返回一个 <code>NaN</code>。</li>
<li><code>NaN</code> 并不能用于比较。</li>
</ul>
<p>可以使用 <code>is_nan()</code> 方法判断是否为 <code>NaN</code>。</p>
<h5 id="数字运算">数字运算</h5>
<p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。</p>
<p>更多，运算符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">是否可重载</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>ident!(...), ident!&#123;...&#125;, ident![...]</code></td>
<td style="text-align:center">宏展开</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>!expr</code></td>
<td style="text-align:center">按位非或逻辑非</td>
<td style="text-align:center">Not</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center"><code>var != expr</code></td>
<td style="text-align:center">不等比较</td>
<td style="text-align:center">PartialEq</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center"><code>expr % expr</code></td>
<td style="text-align:center">算术取模</td>
<td style="text-align:center">Rem</td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center"><code>var %= expr</code></td>
<td style="text-align:center">算术取模与赋值</td>
<td style="text-align:center">RemAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;expr</code>, <code>&amp;mut expr</code></td>
<td style="text-align:center">借用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td>
<td style="text-align:center">借用指针类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>expr &amp; expr</code></td>
<td style="text-align:center">按位与</td>
<td style="text-align:center">BitAnd</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;=</code></td>
<td style="text-align:center"><code>var &amp;= expr</code></td>
<td style="text-align:center">按位与及赋值</td>
<td style="text-align:center">BitAndAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center"><code>expr &amp;&amp; expr</code></td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>expr * expr</code></td>
<td style="text-align:center">算术乘法</td>
<td style="text-align:center">Mul</td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center"><code>var *= expr</code></td>
<td style="text-align:center">算术乘法与赋值</td>
<td style="text-align:center">MulAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>*expr</code></td>
<td style="text-align:center">解引用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>*const type</code>, <code>*mut type</code></td>
<td style="text-align:center">裸指针</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>trait + trait</code>, <code>'a + trait</code></td>
<td style="text-align:center">复合类型限制</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>expr + expr</code></td>
<td style="text-align:center">算术加法</td>
<td style="text-align:center">Add</td>
</tr>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center"><code>var += expr</code></td>
<td style="text-align:center">算术加法与赋值</td>
<td style="text-align:center">AddAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>,</code></td>
<td style="text-align:center"><code>expr, expr</code></td>
<td style="text-align:center">参数以及元素分隔符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>- expr</code></td>
<td style="text-align:center">算术取负</td>
<td style="text-align:center">Neg</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>expr - expr</code></td>
<td style="text-align:center">算术减法</td>
<td style="text-align:center">Sub</td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center"><code>var -= expr</code></td>
<td style="text-align:center">算术减法与赋值</td>
<td style="text-align:center">SubAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>-&gt;</code></td>
<td style="text-align:center"><code>fn(...) -&gt; type</code>, <code>\|...\| -&gt; type</code></td>
<td style="text-align:center">函数与闭包，返回类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center"><code>expr.ident</code></td>
<td style="text-align:center">成员访问</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td>
<td style="text-align:center">右排除范围</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>..expr</code></td>
<td style="text-align:center">结构体更新语法</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>variant(x, ..)</code>, <code>struct_type &#123; x, .. &#125;</code></td>
<td style="text-align:center">“与剩余部分”的模式绑定</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>...</code></td>
<td style="text-align:center"><code>expr...expr</code></td>
<td style="text-align:center">模式: 范围包含模式</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>expr / expr</code></td>
<td style="text-align:center">算术除法</td>
<td style="text-align:center">Div</td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center"><code>var /= expr</code></td>
<td style="text-align:center">算术除法与赋值</td>
<td style="text-align:center">DivAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>pat: type</code>, <code>ident: type</code></td>
<td style="text-align:center">约束</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>ident: expr</code></td>
<td style="text-align:center">结构体字段初始化</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>'a: loop &#123;...&#125;</code></td>
<td style="text-align:center">循环标志</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>;</code></td>
<td style="text-align:center"><code>expr;</code></td>
<td style="text-align:center">语句和语句结束符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>;</code></td>
<td style="text-align:center"><code>[...; len]</code></td>
<td style="text-align:center">固定大小数组语法的部分</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>expr &lt;&lt; expr</code></td>
<td style="text-align:center">左移</td>
<td style="text-align:center">Shl</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;=</code></td>
<td style="text-align:center"><code>var &lt;&lt;= expr</code></td>
<td style="text-align:center">左移与赋值</td>
<td style="text-align:center">ShlAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center"><code>expr &lt; expr</code></td>
<td style="text-align:center">小于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center"><code>expr &lt;= expr</code></td>
<td style="text-align:center">小于等于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center"><code>var = expr</code>, <code>ident = type</code></td>
<td style="text-align:center">赋值/等值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center"><code>expr == expr</code></td>
<td style="text-align:center">等于比较</td>
<td style="text-align:center">PartialEq</td>
</tr>
<tr>
<td style="text-align:center"><code>=&gt;</code></td>
<td style="text-align:center"><code>pat =&gt; expr</code></td>
<td style="text-align:center">匹配准备语法的部分</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center"><code>expr &gt; expr</code></td>
<td style="text-align:center">大于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center"><code>expr &gt;= expr</code></td>
<td style="text-align:center">大于等于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>expr &gt;&gt; expr</code></td>
<td style="text-align:center">右移</td>
<td style="text-align:center">Shr</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;=</code></td>
<td style="text-align:center"><code>var &gt;&gt;= expr</code></td>
<td style="text-align:center">右移与赋值</td>
<td style="text-align:center">ShrAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>@</code></td>
<td style="text-align:center"><code>ident @ pat</code></td>
<td style="text-align:center">模式绑定</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>expr ^ expr</code></td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">BitXor</td>
</tr>
<tr>
<td style="text-align:center"><code>^=</code></td>
<td style="text-align:center"><code>var ^= expr</code></td>
<td style="text-align:center">按位异或与赋值</td>
<td style="text-align:center">BitXorAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center"><code>pat \| pat</code></td>
<td style="text-align:center">模式选择</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center"><code>expr \| expr</code></td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">BitOr</td>
</tr>
<tr>
<td style="text-align:center"><code>\|=</code></td>
<td style="text-align:center"><code>var \|= expr</code></td>
<td style="text-align:center">按位或与赋值</td>
<td style="text-align:center">BitOrAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>\|\|</code></td>
<td style="text-align:center"><code>expr \|\| expr</code></td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center"><code>expr?</code></td>
<td style="text-align:center">错误传播</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h5 id="序列">序列</h5>
<p>即基于范围，如 <code>1..5</code> 生成从1到4的连续数字，左闭右开，常用于循环中。</p>
<ul>
<li><code>1..=5</code> 即可表示全闭区间。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-as-完成类型转换">使用 As 完成类型转换</h5>
<p>使用 <code>As</code> 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型。</p>
<h5 id="有理数与复数">有理数与复数</h5>
<p>社区开发的高质量 Rust 数值库：<a href="https://crates.io/crates/num">num</a>。</p>
<p>导入也十分简单：</p>
<ol>
<li>创建工程：<code>cargo new complex-num</code>；</li>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 添加 <code>num = &quot;0.4.0&quot;</code>。</li>
<li>导入 <code>num</code>：<code>use num::Complex;</code>。</li>
<li><code>cargo build &amp;&amp; cargo run</code>。</li>
</ol>
<p>实例代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Complex &#123; re: <span class="number">2.1</span>, im: -<span class="number">1.2</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">11.1</span>, <span class="number">22.2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im);</span><br><span class="line">    <span class="comment">// 13.2 + 21i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符-布尔-单元类型">字符、布尔、单元类型</h4>
<p>字符：</p>
<ul>
<li>所有的 Unicode 值都可以作为 Rust 字符。</li>
<li>Unicode 为 4 字节编码，故字符类型也占用 4 个字节。</li>
</ul>
<p>布尔类型：</p>
<ul>
<li>占用 1 字节。</li>
</ul>
<p>单元类型：</p>
<ul>
<li>就是 <code>()</code>，唯一的值也为 <code>()</code>，可以理解为 <code>void</code>。</li>
<li><code>main</code> 函数返回的就是单元类型。</li>
<li>可以用 <code>()</code> 作为 map 的值，表示不关注具体的值，只关注 <code>key</code>。</li>
</ul>
<p><em>Rust中没有返回值的函数称为发散函数，即无法收敛的函数。</em></p>
<h4 id="语句与表达式">语句与表达式</h4>
<p>Rust 的语句和表达式：</p>
<ul>
<li>语句会执行一些操作但是不会返回一个值</li>
<li>表达式会在求值后返回一个值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">0</span>; <span class="comment">// 语句</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">// 语句</span></span><br><span class="line">x + <span class="number">1</span>       <span class="comment">// 表达式</span></span><br></pre></td></tr></table></figure>
<p><strong>表达式总要返回值，且不能包含分号</strong></p>
<ul>
<li>带上分号则变成一条语句。</li>
</ul>
<p><code>let</code> 也是语句，故不能将 <code>let</code> 语句赋值给其他值。</p>
<p>表达式可以成为语句的一部分，例如 <code>let y = 6</code> 中，<code>6</code> 就是一个表达式，处理后后返回一个值 <code>6</code>。</p>
<p><em>能返回值，它就是表达式。</em></p>
<h4 id="函数">函数</h4>
<p>大概的格式如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>规范上，函数名和变量名需要使用蛇形命名法。</li>
<li>函数的位置随便，不在乎定义在何处。</li>
</ul>
<p>Rust 中定义函数如果需要具备参数 <strong>必须声明参数名称和类型</strong> 。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">fun</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 函数声明返回值类型的方式：</p>
<ul>
<li>在参数声明之后用 <code>-&gt;</code> 来声明函数返回值的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在函数体中，随时都可以以 <code>return</code> 关键字结束函数运行并返回一个类型合适的值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ten</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数无返回值时：</p>
<ul>
<li>返回一个 <code>()</code>。</li>
<li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code>。</li>
</ul>
<p>上面的发散函数，可以用 <code>!</code> 作返回类型，表示永不返回。</p>
<ul>
<li>这种语法往往用作会导致程序崩溃的函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">eend</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="所有权和借用">所有权和借用</h3>
<h4 id="所有权">所有权</h4>
<p>Rust 使用 <strong>所有权系统</strong>。</p>
<p>对于内存管理方面，计算机语言出现了三种流派：</p>
<ul>
<li>垃圾回收机制（GC）：程序运行时不断寻找不再使用的内存，代表有 Java、Go；</li>
<li>手动管理内存：通过调用函数方式进行申请和释放内存，代表有 C++；</li>
<li>通过所有权管理内存：编译器在编译时会根据一系列规则进行检查。
<ul>
<li>检查只发生在编译器，所有在运行期并不会有性能上的损失。</li>
</ul>
</li>
</ul>
<p>C 语言上的不安全：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> *c = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码可以编译通过。</li>
<li><code>a</code> 为局部变量，当离开作用域时，其内存会被系统回收，从而返回成了悬挂指针。</li>
<li><code>c</code> 的值时常量，存储在常量区，其生命周期为整个程序运行期间，当程序结束系统才会回收这片内存。</li>
</ul>
<h5 id="栈与堆">栈与堆</h5>
<p>栈：先进后出。栈中的所有数据都必须占用已知且固定大小的内存空间。</p>
<p>堆：可存放对于大小未知或可能变化的数据。</p>
<ul>
<li>当往堆上放入数据时，请求一定大小的内存空间，OS在堆的某处寻找并标记区域为已使用，返回该地址的指针。这个过程称为在堆上分配内存（分配）。</li>
<li>指针会被推入栈中，通过栈中的指针获取在堆上的数据。</li>
</ul>
<p>两者在性能上：在栈上分配内存比在堆上分配内存要快，处理器在栈上分配数据会比在堆上分配数据更高效。</p>
<p>当代码调用函数时，传递给函数的参数（可能指向堆上数据的指针和函数的局部变量）依次入栈；当调用结束时，这些值按相反顺序出栈。</p>
<p>堆上的数据是缺乏组织的，所以管理堆上数据的分配和释放尤为重要。</p>
<ul>
<li>当没有及时释放时，便造成了内存泄漏（数据无法被回收）。</li>
</ul>
<h5 id="所有权的原则">所有权的原则</h5>
<p>原则如下：</p>
<ol>
<li>Rust 中每一个值都被一个变量所拥有，该变量称为值的所有者（Owner）。</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。</li>
<li>当变量（所有者）离开作用域时，这个值将被丢弃。</li>
</ol>
<h5 id="变量绑定背后的数据交互">变量绑定背后的数据交互</h5>
<p>了解深拷贝和浅拷贝。</p>
<blockquote>
<p>简单来说，深拷贝在内存上独立，复制内容在新的内存空间上。浅拷贝在内存上共享。比如把A复制到B，如果是深复制，则A和B独立互不影响；如果是浅复制，在修改A，B也会改变。</p>
</blockquote>
<h6 id="拷贝-浅拷贝">拷贝（浅拷贝）</h6>
<p>浅拷贝只发生在栈上，如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<p>基本类型在编译时是已知大小，会存储在栈上，所以拷贝其值是快速的。</p>
<p>Rust 具有 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。</p>
<ul>
<li>如果拥有 <code>Copy</code> 特征，则一个旧变量在被赋值给其他变量后仍可用，即赋值的过程是拷贝的过程。</li>
</ul>
<p>规则：</p>
<ul>
<li>任何基本类型的组合可以 <code>Copy</code>；</li>
<li>不需要分配内存或某种形式的资源的类型是可以 <code>Copy</code></li>
</ul>
<p>一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型；</li>
<li>所有浮点数类型；</li>
<li>布尔类型；</li>
<li>字符类型；</li>
<li>包含的类型都可 <code>Copy</code> 的元组；</li>
<li>不可变引用 <code>&amp;T</code>
<ul>
<li><code>&amp;mut T</code> 是可变引用，不可以 <code>Copy</code>。</li>
</ul>
</li>
</ul>
<h6 id="克隆-深拷贝">克隆（深拷贝）</h6>
<p><strong>Rust 永远不会自动创建数据的深拷贝。</strong></p>
<ul>
<li>任何自动的复制都不是深拷贝。</li>
</ul>
<p>当需要深度复制数据时，使用方法 <code>clone()</code>。</p>
<ul>
<li>使用 <code>clone()</code> 会降低程序性能</li>
</ul>
<h6 id="转移所有权">转移所有权</h6>
<p>有代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是浅拷贝，且没有发生所有权的转移。</li>
<li>整个过程的赋值都是通过浅拷贝方式完成，发生在栈中，所以不需要所有权转移。</li>
</ul>
<p>另有代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>String</code> 为字符串类型，是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存（跟 C++ 的 <code>std::vector</code> 类似）。
<ul>
<li>即不会自动拷贝。</li>
</ul>
</li>
<li>此时处理方式为：当 <code>s1</code> 被赋予 <code>s2</code> 后，Rust 认为 <code>s1</code> 不再有效，因此也无需在 <code>s1</code> 离开作用域后 drop（丢弃） 任何东西。
<ul>
<li>把所有权从 <code>s1</code> 转移给了 <code>s2</code>，<code>s1</code> 在被赋予 <code>s2</code> 后就马上失效了。</li>
<li>这种类似于移动语义的机制，C++ 的 <code>std::move()</code>。</li>
</ul>
</li>
</ul>
<p>如果真的有两个所有者，那么当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放（double free）</strong> 的错误。</p>
<h5 id="函数传值与返回">函数传值与返回</h5>
<p>将值传递给函数，一样会发生移动或者赋值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                        <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line">                        <span class="comment">// println!(&quot;s value: &#123;&#125;&quot;, s); // 报错，s 已经移出作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// x 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x value: &#123;&#125;&quot;</span>, x); <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line"><span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></span><br></pre></td></tr></table></figure>
<p>对于返回的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>(); <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s2 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// s2 被移动到 takes_and_gives_back 中,它也将返回值移给 s3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1: &#123;:?&#125;&quot;</span>, s1);</span><br><span class="line">    <span class="comment">// println!(&quot;s2: &#123;:?&#125;&quot;, s2); // s2 被移走</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3: &#123;:?&#125;&quot;</span>, s3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line"><span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gives_ownership 将返回值移动给调用它的函数</span></span><br><span class="line"><span class="comment">/// #### 返回值</span></span><br><span class="line"><span class="comment">/// 返回一个 String 的所有权</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    some_string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="comment">/// #### 参数</span></span><br><span class="line"><span class="comment">/// * `a_string` - 要被移动给调用者的 String</span></span><br><span class="line"><span class="comment">/// #### 返回值</span></span><br><span class="line"><span class="comment">/// 将接收到的 String 的所有权返回出去</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于所有权，所以总是把一个值传来传去来使用它。</p>
<h4 id="引用和借用">引用和借用</h4>
<p>Rust 具有 <strong>借用</strong> 这一概念。</p>
<ul>
<li>借用：获取变量的引用。
<ul>
<li>如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。</li>
</ul>
</li>
</ul>
<h5 id="引用和解引用">引用和解引用</h5>
<p>常规引用是一个指针类型，指向了对象存储的内存地址。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>*</code> 进行解引用。</li>
</ul>
<h5 id="不可变引用">不可变引用</h5>
<p>有如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 构造一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">    <span class="comment">// hello 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此处函数传入字符串，但无需再用返回的方式传出所有权。</li>
<li>函数参数为 <code>&amp;String</code>。</li>
<li><code>&amp;</code> 在此处表示引用，允许使用值，但不获取所有权。</li>
<li><code>&amp;s1</code> 为指向 <code>s1</code> 的引用，但不拥有它。</li>
</ul>
<p>这样借用可以进行对变量一定的访问。</p>
<h5 id="可变引用">可变引用</h5>
<p>当然也可以试着修改借用的变量。（得寸进尺）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, 🌏&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// hello, 🌏</span></span><br><span class="line">    <span class="comment">// 由于 Unicode 编码，当然 🌏 也可以显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s</code> 是可变类型，<code>&amp;mut s</code> 是可变的引用，<code>string: &amp;mut String</code> 是接收可变引用的参数。</li>
</ul>
<p>但是，<strong>可变引用同时只能存在一个</strong>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="comment">// let r2 = &amp;mut s; // 报错</span></span><br><span class="line">    <span class="comment">// print!(&quot;&#123;&#125; &#123;&#125;&quot;, r1, r2);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可变借用 <code>r1</code> 持续到最后一次使用的位置（即输出）；</li>
<li>在 <code>r1</code> 存活间，又尝试创建第二个可变借用 <code>r2</code> 是会引起出错的。</li>
</ul>
<p>这种限制的好处就是使 Rust 在编译期就避免数据竞争。数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。</p>
<p>数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<p><em>可以通过加大括号限制作用域的方式解决部分问题。引用的作用域从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号</em></p>
<p>还有一件事，<strong>可变引用与不可变引用不能同时存在</strong>。（太安全了吧QAQ）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="comment">// 大问题，不能将`s`借用为可变的，因为它也被借用为不可变的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以理解为，正在借用不可变引用的用户，肯定不希望借用的东西莫名其妙被改了。</li>
</ul>
<h5 id="nll">NLL</h5>
<p>NLL：Not-Lexical-Lifetimes，一种 Rust 编译器优化行为。</p>
<ul>
<li>用于找到某个引用在作用域 <code>&#125;</code> 结束前就不再被使用的代码位置。</li>
</ul>
<h5 id="悬垂引用">悬垂引用</h5>
<p>悬垂引用也叫做悬垂指针。</p>
<ul>
<li>指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。</li>
</ul>
<p>如在 C++ 中，易见的悬挂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> aa = *<span class="built_in">fun</span>();</span><br><span class="line">	cout &lt;&lt; aa;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这其实是可以编译通过，但函数 <code>fun</code> 返回的指针式悬挂的。
<ul>
<li>当 <code>fun</code> 中的 <code>a</code> 离开作用域时，<code>a</code> 会被释放，但 <code>fun</code> 返回的指针仍然指向 <code>a</code>。</li>
</ul>
</li>
</ul>
<p>在 Rust 中编译器可以确保 <strong>引用永远也不会变成悬垂状态</strong>。</p>
<ul>
<li>当获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。（🐂牛）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = <span class="title function_ invoke__">no_dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 报错：该函数返回了一个借用的值，但是已经找不到它所借用值的来源</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 正常的，返回一个解引用，即值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    *&amp;a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="借用规则总结">借用规则总结</h5>
<ul>
<li>同一时刻，要么只有一个可变引用，要么有任意数量的不可变引用。</li>
<li>引用必须总是有效的（非悬挂）。</li>
</ul>
<h3 id="复合类型">复合类型</h3>
<p>复合类型是由其它类型组合而成的，最典型的就是结构体 <code>struct</code> 和枚举 <code>enum</code>。</p>
<h4 id="字符串与切片">字符串与切片</h4>
<p>Rust 的字符串并没有想象中的简单。</p>
<h5 id="切片">切片</h5>
<p>切片：允许引用集合中部分连续的元素序列，而不是引用整个集合。</p>
<ul>
<li>创建切片的语法：<code>[开始索引..终止索引]</code>，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，左闭右开。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">// 等价于 &amp;s[..5]</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">all1</span> = &amp;s[<span class="number">0</span>..len];      <span class="comment">// 完整切片</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all2</span> = &amp;s[..];          <span class="comment">// 完整切片</span></span><br></pre></td></tr></table></figure>
<p>注意，中文在 UTF-8 中占用三个字节。</p>
<p>字符串切片的类型标识是 <code>&amp;str</code>。</p>
<p>一个对初学者难受的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串">字符串</h5>
<p>Rust 中的字符是 Unicode 类型。</p>
<ul>
<li>每个字符占据 4 个字节内存空间。</li>
</ul>
<p>但是在字符串中是 UTF-8 编码。</p>
<ul>
<li>也就是字符串中的字符所占的字节数是变化的（1 - 4）。</li>
</ul>
<p>Rust 语言级别上的字符串类型：<code>str</code>。</p>
<ul>
<li>通常以引用类型出现 <code>&amp;str</code>，即字符串切片。</li>
<li><code>str</code> 是硬编码进可执行文件，无法修改。</li>
</ul>
<p><code>String</code> 是一个可增长、可改变且具有所有权的 UTF-8 编码字符串。</p>
<p><em>当提及字符串，往往指的是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型。</em></p>
<ul>
<li>除了 <code>String</code>，还有 <code>OsString</code>、<code>OsStr</code>、<code>CsString</code>、<code>CsStr</code> 等。</li>
<li>都以 <code>String</code> 或 <code>Str</code> 结尾，分别对应具有所有权和被借用的变量。</li>
</ul>
<h6 id="string-与-str-的转换">String 与 &amp;str 的转换</h6>
<p>从 <code>&amp;str</code> 类型生成 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>
<p>从 <code>String</code> 类型转为 <code>&amp;str</code>：取引用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Fingsinz&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..<span class="number">2</span>]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="字符串索引">字符串索引</h6>
<p>字符串底层数据存储是 <code>[u8]</code>。</p>
<ul>
<li><strong>但不能使用索引进行访问字符串的子串。</strong>
<ul>
<li>因为字符串中的字符所占的字节数是变化的。</li>
<li>比如汉字占 3 个字节，而英文占 1 个字节。</li>
</ul>
</li>
</ul>
<p>以此类推，使用索引进行字符串切片（如 <code>&amp;str[0..2]</code>）时也需要格外小心。</p>
<h6 id="字符串的操作">字符串的操作</h6>
<p>追加：在原有的字符串上追加，并不会返回新的字符串。</p>
<ul>
<li><code>push(@pos, @char)</code> 追加字符 <code>char</code>；</li>
<li><code>push_str(@pos, @str)</code> 追加字符串字面量。</li>
<li>字符串需要是可变的。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">insert</span>(<span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);  <span class="comment">// Hello!</span></span><br><span class="line">    s.<span class="title function_ invoke__">insert_str</span>(<span class="number">6</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);  <span class="comment">// Hello!World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换：将字符串中的某个字符串替换成其他字符串。</p>
<ul>
<li><code>replace(@target, @replacement)</code>：将所有的目标字符串替换成新字符串。适用于 <code>String</code> 和 <code>&amp;str</code>。
<ul>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串。</li>
</ul>
</li>
<li><code>replacen(@target, @replacement, @count)</code>：将 <code>count</code> 个的目标字符串替换成新字符串。适用于 <code>String</code> 和 <code>&amp;str</code>。
<ul>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串。</li>
</ul>
</li>
<li><code>replace_range(@range, @replacement)</code>：将范围内的字符串替换成新字符串。仅适用于 <code>String</code> 类型。
<ul>
<li>该方法是直接操作原来的字符串，不会返回新的字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;rust rust rust&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">news1</span> = s.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">news2</span> = s.<span class="title function_ invoke__">replacen</span>(<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;Rust&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, news1); <span class="comment">// Rust Rust Rust</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, news2); <span class="comment">// Rust Rust rust</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ms</span> = <span class="string">&quot;rust rust rust&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    ms.<span class="title function_ invoke__">replace_range</span>(<span class="number">5</span>..<span class="number">6</span>, <span class="string">&quot;R&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ms); <span class="comment">// rust Rust rust</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除：都仅适用于 <code>String</code> 类型。</p>
<ul>
<li><code>pop()</code>：删除并返回字符串的最后一个字符。
<ul>
<li>该方法直接操作原来的字符串。</li>
<li>返回值是一个 <code>Option</code> 类型，如果字符串为空，则返回 <code>None</code>。</li>
</ul>
</li>
<li><code>remove(@pos)</code>：删除并返回字符串指定位置（按字节处理）的字符。
<ul>
<li>该方法直接操作原来的字符串。</li>
</ul>
</li>
<li><code>truncate(@pos)</code>：删除字符串从指定位置（按字节处理）开始到结尾的全部字符。
<ul>
<li>该方法直接操作原来的字符串。</li>
</ul>
</li>
<li><code>clear()</code>：清空字符串。
<ul>
<li>该方法直接操作原来的字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="string">&quot;Rrust!&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">popstr</span> = s1.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, popstr.<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// !</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">remove</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">// Rust</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">truncate</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">// Ru</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">// s1 为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接：连接字符串。</p>
<ul>
<li>使用 <code>+</code> 或者 <code>+=</code> 连接字符串：要求右边参数必须为字符串的切片引用类型，不能直接传递 <code>String</code> 类型。
<ul>
<li><code>+</code> 返回一个新的字符串，调用了 <code>add()</code> 方法：<code>fn add(self, s: &amp;str) -&gt; String</code>。</li>
</ul>
</li>
<li><code>format!</code> ：与 <code>print!</code> 类似。适用于 <code>String</code> 和 <code>&amp;str</code> 类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;Hello &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s1); // s1 所有权由函数已经转移给 s3</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2); <span class="comment">// World</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s3); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s4</span> = s3.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    s4 += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s4); <span class="comment">// Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="字符串转义">字符串转义</h6>
<p>通过转移的方式 <code>\</code> 输出 ASCII 和 Unicode 字符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过 \ + 字符的十六进制表示，转移输出一个字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;\x52\x75\x73\x74&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">// Rust</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// \u 可以输出一个 unicode 字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;\u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2); <span class="comment">// ℝ</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加 \ 转义不换行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">&quot;a\</span></span><br><span class="line"><span class="string">        b\</span></span><br><span class="line"><span class="string">        c\</span></span><br><span class="line"><span class="string">        d</span></span><br><span class="line"><span class="string">        e&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s3);</span><br><span class="line">    <span class="comment">// abcd</span></span><br><span class="line">    <span class="comment">//     e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="操作-utf-8-字符串">操作 UTF-8 字符串</h6>
<p>逐字符遍历：</p>
<ul>
<li>避免索引尴尬情况。</li>
</ul>
<p>逐字节遍历：</p>
<ul>
<li>遍历字符串的底层字节数组表现形式。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;我在用 Rust 编程&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我在用 Rust 编程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 230 136 145 229 156 168 231 148 168 32 82 117 115 116 32 231 188 150 231 168 139</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串包含双引号，可以在开头和结尾加 #</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#&quot;a&quot;bbb&quot;a&quot;#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是有歧义，可以继续增加，没有限制</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">longer_delimiter</span> = <span class="string">r###&quot;aaaa&quot;##!&quot;###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, longer_delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要准确从 UTF-8 字符串中获取子串是较为复杂的事情。</p>
<ul>
<li>比如，想要从 <code>holla中国人नमस्ते</code> 这种变长的字符串中取出某一个子串，使用标准库是做不到的。
<ul>
<li>需要在 <a href="http://crates.io">crates.io</a> 上搜索第三方库来寻找想要的功能。</li>
</ul>
</li>
</ul>
<h6 id="剖析字符串">剖析字符串</h6>
<p>关于 <code>String</code> 可变，而字符串字面值 <code>str</code> 却不可以：</p>
<ul>
<li>字面值文本在编译时就知道内容，直接硬编码进可执行文件中。
<ul>
<li>字面值是不可变的，而字符串是有在程序运行中动态变化的需求。</li>
</ul>
</li>
</ul>
<p><code>String</code> 类型支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来管理内容：</p>
<ul>
<li>在使用 <code>String::from</code> 是就会构造 <code>String</code>类型；</li>
<li>在 <code>&#125;</code> 处会自动调用释放内存函数 <code>drop</code>，用于释放离开作用域的变量。</li>
</ul>
<h4 id="元组">元组</h4>
<p><strong>元组是由多种类型组合到一起形成的。</strong></p>
<p>创建元组的语法如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="解构元组">解构元组</h5>
<p>用同样的形式把一个复杂对象中的值匹配出来或者使用 <code>.</code> 都可以访问元组的元素。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>, <span class="string">&quot;aaa&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> (x, y, z, w) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z, w); <span class="comment">// 500, 6.4, 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//println!(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, tup.0, tup.1, tup.2, tup.3);</span></span><br><span class="line">    <span class="comment">// 上语句会报错，因为字符串的所有权已经转移到 w，所以 tup.3 不再有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>let (x, y, z, w) = tup</code> 进行模式匹配，用相似的模式进行匹配，元组对应的值就会绑定到变量 <code>x</code>、<code>y</code>、<code>z</code> 和 <code>w</code> 上。</li>
</ul>
<p>元组常用于函数的返回值上，返回多个值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;Hello &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s1, len) = <span class="title function_ invoke__">string_splicing</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">string_splicing</span>(s1: <span class="type">String</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ret</span> = s1 + s2;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = ret.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    (ret, len)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体">结构体</h4>
<p>结构体与元组：都是由多种类型组合而成。</p>
<ul>
<li>但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。</li>
</ul>
<h5 id="结构体的语法">结构体的语法</h5>
<p>一个结构体由几部分组成：</p>
<ul>
<li>关键字 <code>struct</code> 定义；</li>
<li>清晰的结构体名称；</li>
<li>几个结构体字段。</li>
</ul>
<p>如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    id: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">i8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">student</span> = Student &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;John&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, student.id, student.name, student.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化实例时，每个字段都需要初始化；</li>
<li>初始化时的顺序不必与定义时的顺序一致。</li>
<li>访问结构体字段时使用 <code>.</code>。</li>
</ul>
<p>另外注意，Rust 不支持将结构体的某个字段标记为可变，需要整个结构体声明为可变。</p>
<p>支持简化结构体构建：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_student</span>(id: <span class="type">i32</span>, name: <span class="type">String</span>, age: <span class="type">i8</span>) <span class="punctuation">-&gt;</span> Student &#123;</span><br><span class="line">    Student &#123; id, name, age &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行结构体更新时，也是挺方便的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">student1</span> = Student &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;John&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">student2</span> = Student &#123;</span><br><span class="line">        age: <span class="number">21</span>,</span><br><span class="line">        ..student1</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, student2.id, student2.name, student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>..</code> 语法表明凡是没有显式声明的字段，全部从 <code>student1</code> 中自动获取。</li>
<li>需要注意的是 <code>..student1</code> 必须在结构体的尾部使用。</li>
<li>此处 <code>student1.name</code> 的所有权已经移到 <code>student2</code>，所以 <code>student1.name</code> 不再有效，不能输出，但是其他字段（基本类型）依旧有效。</li>
</ul>
<h5 id="结构体的内存排序">结构体的内存排序</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>File</code> 的内存排序如下：</p>
<table>
    <caption>File struct</caption>
	<tr>
	    <th colspan="3" align="center">name</th>
	    <th colspan="3" align="center">data</th>
	</tr >
	<tr >
	    <td colspan="3" align="center">String</td>
	    <td colspan="3" align="center">Vec</td>
	</tr>
	<tr>
	    <td>ptr</td>
        <td>size</td>
        <td>capacity</td>
        <td>ptr</td>
        <td>size</td>
        <td>capacity</td>
	</tr>
</table>
<ul>
<li><code>name</code> 的 <code>ptr</code> 指向一块 <code>[u8; name.size]</code> 内存的开头。</li>
<li><code>data</code> 的 <code>ptr</code> 指向另一块 <code>[u8; data.size]</code> 内存的开头。</li>
</ul>
<h5 id="元组结构体">元组结构体</h5>
<p>结构体必须要有名称，但是结构体的字段可以没有名称。</p>
<ul>
<li>元组结构体：这种结构体长得很像元组，字段没有名称。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单元结构体">单元结构体</h5>
<p>单元结构体跟单元类型很像，没有任何字段和属性。</p>
<ul>
<li>当定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用单元结构体。</li>
</ul>
<h5 id="结构体数据的所有权">结构体数据的所有权</h5>
<p>结构体当中它所拥有的数据应当是拥有所有权的，而不是其他地方借用的。</p>
<ul>
<li>借用数据需要考虑生命周期：生命周期确保结构体的作用范围比它所借用的数据的作用范围要小。</li>
</ul>
<h5 id="derive-debug">[derive(Debug)]</h5>
<p>Rust 默认没有给结构体实现 <code>Display</code> 特征，而把输出格式的选择权利交给程序员。</p>
<ul>
<li>顾名思义，<code>Display</code> 特征能够使得结构体实现自动格式输出。</li>
</ul>
<p>使用 <code>#[derive(Debug)]</code> 对结构体进行了标记，这样才能使用 <code>println!(&quot;&#123;:?&#125;&quot;, s);</code> 的方式对其进行打印输出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    <span class="comment">// Rectangle &#123; width: 30, height: 50 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>println!(&quot;&#123;:?&#125;&quot;, s);</code> 输出时，需要结构体实现 <code>Debug</code> 特征。</li>
<li><code>#[derive(Debug)]</code> 用 <code>derive</code> 派生实现了 <code>Debug</code> 特征。</li>
</ul>
<p>当结构体较大时，此时可以使用 <code>&#123;:#?&#125;</code> 来替代 <code>&#123;:?&#125;</code> 会有更美观的格式。</p>
<p>还有一个简单的输出 debug 信息的方法：使用 <code>dbg!</code> 宏。</p>
<ul>
<li>该宏会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，还有表达式的求值结果。</li>
<li>它最终还会把表达式值的所有权返回。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale), <span class="comment">// 30 * scale = 60</span></span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">    <span class="comment">// [src\main.rs:14:5] &amp;rect1 = Rectangle &#123;</span></span><br><span class="line">    <span class="comment">//     width: 60,</span></span><br><span class="line">    <span class="comment">//     height: 50,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举">枚举</h4>
<p>通过列举可能的成员来定义一个枚举类型，如熟悉的枚举一周：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型是一个类型，其会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (oh_no, no_no, ok, come_on, happy) = (</span><br><span class="line">        Weekday::Monday,</span><br><span class="line">        Weekday::Tuesday,</span><br><span class="line">        Weekday::Wednesday,</span><br><span class="line">        Weekday::Thursday,</span><br><span class="line">        Weekday::Friday,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> (happier, sad) = (Weekday::Saturday, Weekday::Sunday);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125; &#123;:?&#125; &#123;:?&#125; &#123;:?&#125;&quot;</span>, oh_no, no_no, ok, come_on, happy);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, happier, sad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Rust 中，任何数据类型都可以放入到枚举中，这给枚举增加了更多功能。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    Quit,                    <span class="comment">// 不包含变量</span></span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>), <span class="comment">// 包含三个 u8 变量</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),           <span class="comment">// 包含一个 String 变量</span></span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;, <span class="comment">// 包含一个匿名结构体变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o1</span> = Operation::Quit;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o2</span> = Operation::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o3</span> = Operation::<span class="title function_ invoke__">Write</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组">数组</h4>
<p>数组：<code>array</code>，长度固定，是基本类型。</p>
<p>动态数组：<code>Vector</code>，长度可动态增长。</p>
<ul>
<li>数组的长度是编译时确定的，而动态数组的长度是运行时确定的。</li>
<li>数组 <code>array</code> 是存储在栈上，而动态数组 <code>Vector</code> 是存储在堆上。</li>
<li><code>Vector</code> 和 <code>String</code> 一样都是高级类型，即集合类型。</li>
</ul>
<h5 id="创建数组">创建数组</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// [3, 3, 3, 3, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组类型通过方括号声明；</li>
<li>可以显式指定数组元素类型和长度。</li>
<li>数组的长度也是类型的一部分。</li>
</ul>
<h5 id="访问数组元素">访问数组元素</h5>
<p>数组是连续的，可以通过索引访问。</p>
<ul>
<li>下标从 0 开始。</li>
</ul>
<p>另外，如果使用索引访问元素时，编译器会在编译期预防越界情况。但如果索引是外部输入的，那么编译器并不能预防。</p>
<p>如果数组元素非基础类型，且出现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust is good!&quot;</span>); <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>那必然是报错的。<code>String</code> 是具有所有权的高级类型，其并不能在数组中使用这种形式进行复制（没有深拷贝）。</li>
</ul>
<p>而解决方法应该是调用 <code>std::array::from_fn</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span>: [<span class="type">String</span>; <span class="number">8</span>] = std::array::<span class="title function_ invoke__">from_fn</span>(|_i| <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数组切片">数组切片</h5>
<p>数组也允许引用集合中的部分连续片段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, slice);</span><br></pre></td></tr></table></figure>
<ul>
<li>省略主函数部分。</li>
</ul>
<p>切片的特点：</p>
<ul>
<li>切片的长度可以与数组不同，并不是固定的，取决于指定的起始和结束位置。</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用。</li>
<li>切片类型 <code>[T]</code> 拥有不固定的大小，而切片引用类型 <code>&amp;[T]</code> 则具有固定的大小，<code>&amp;[T]</code> 更有用，<code>&amp;str</code> 字符串切片也同理。</li>
</ul>
<h3 id="流程控制">流程控制</h3>
<h4 id="if-else-if">if-else if</h4>
<p><code>if else</code> 表达式根据条件执行不同的代码分支：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition == <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// A...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// B...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>若 <code>condition</code> 的值为 <code>true</code>，则执行 A 代码，否则执行 B 代码。</li>
</ul>
<p><code>if</code> 语句（块）是表达式，可以返回值，但是需要保证每个分支的返回类型一样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">if</span> a == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span> <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">//&#x27;6&#x27; // 错误，类型不一致</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>与其它语言一样，通过 <code>if-else if</code> 可以处理多重条件判断。</p>
<h4 id="循环控制">循环控制</h4>
<p>Rust 有三种循环控制方式：</p>
<ul>
<li><code>for</code> 循环；</li>
<li><code>while</code> 循环；</li>
<li><code>loop</code> 循环。</li>
</ul>
<h5 id="for-循环">for 循环</h5>
<p>简单举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>1..=5</code> 是一个范围，表示 从 1 到 5 的 序列。</li>
</ul>
<p>除了数字的循环外，<code>for-in</code> 用法更靓眼：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 元素 <span class="keyword">in</span> 集合 &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
    <caption>for-in的用法</caption>
    <tr>
        <th>使用方法</th>
        <th>等价使用方式</th>
        <th>所有权</th>
    </tr>
    <tr>
        <td><code>for item in collection</code></td>
        <td><code>for item in IntoIterator::into_iter(collection)</code></td>
        <td>转移所有权</td>
    </tr>
    <tr>
        <td><code>for item in &collection</code></td>
        <td><code>for item in collection.iter()</code></td>
        <td>不可变借用</td>
    </tr>
    <tr>
        <td><code>for item in &mut collection</code></td>
        <td><code>for item in collection.iter_mut()</code></td>
        <td>可变借用</td>
</table>
<p><code>for-in</code> 中也可以获取元素的索引：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般的循环，数组实现了深拷贝所以所有权还在</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">        <span class="comment">// 4 3 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可获取索引的循环</span></span><br><span class="line">    <span class="comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i, v) <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;(&#123;&#125;:&#123;&#125;) &quot;</span>, i + <span class="number">1</span>, v);</span><br><span class="line">        <span class="comment">// (1:4) (2:3) (3:2) (4:1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想单纯的循环十次，（用于）循环变量不使用，可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印10次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_</code> 的含义是忽略该值或类型的意思。</li>
</ul>
<p>比较两种循环：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">collection</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..collection.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">item</span> = collection[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> collection &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>性能比较：
<ul>
<li>第一种方式使用索引，会触发边界检查，导致性能损耗。</li>
<li>第二种方式在编译时就完成分析并证明访问时合法的，性能不会有损失。</li>
</ul>
</li>
<li>安全性比较：
<ul>
<li>第一张对 <code>collection</code> 的索引访问是非连续的，存在一定可能性在两次访问之间 <code>collection</code> 发生了变化，导致脏数据产生。</li>
<li>第二种直接迭代是连续访问。（由于所有权限制，访问过程中，数据不会发生变化）</li>
</ul>
</li>
</ul>
<h5 id="continue-和-break">continue 和 break</h5>
<ul>
<li>使用 <code>continue</code> 可以跳过当次循环，开始下次循环。（在其它语言也这样吧）</li>
<li>使用 <code>break</code> 可以直接跳出当前整个循环。</li>
</ul>
<h5 id="while-循环">while 循环</h5>
<p>跟 C++ 类似。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &lt;= <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n); <span class="comment">// 0 1 2 3 4 5 </span></span><br><span class="line"></span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="loop-循环">loop 循环</h5>
<p><code>loop</code> 就是一个简单的 <strong>无限循环</strong>，不会自动结束。</p>
<ul>
<li>需要额外的 <code>break</code> 关键字控制循环结束。</li>
<li><code>loop</code> 是一个表达式，可以返回值。</li>
<li>在 <code>loop</code> 循环中，<code>break</code> 结束时可以带出一个返回值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ret</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配">模式匹配</h3>
<p><code>match</code> 的魅力。</p>
<h4 id="match-匹配">match 匹配</h4>
<p><code>match</code> 的通用形式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>match</code> 允许将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码。</li>
<li><code>match</code> 的分支有两个部分：<strong>一个模式和针对该模式的处理代码</strong>。</li>
<li>跟 <code>switch</code> 很像，<code>_</code> 类似于 <code>default</code>。
<ul>
<li>除了 <code>_</code>，还可以随便用一个变量名承接即可。</li>
</ul>
</li>
<li><code>match</code> 语句会从上往下匹配，遇到第一个匹配的就执行对应的表达式，然后结束。</li>
<li>可能会出现 <code>|</code>，类似于逻辑或，比如 <code>X|Y</code> 可以匹配 <code>X</code> 也可以匹配 <code>Y</code>。</li>
</ul>
<p>举一个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">match</span> direction &#123;</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Up&quot;</span>),</span><br><span class="line">        Direction::Down =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Down&quot;</span>),</span><br><span class="line">        Direction::Left =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Left&quot;</span>),</span><br><span class="line">        Direction::Right =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Right&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="match-表达式赋值">match 表达式赋值</h5>
<p><code>match</code> 本身也是一个表达式，因此可以用来赋值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction_num</span> = <span class="keyword">match</span> direction &#123;</span><br><span class="line">        Direction::Up =&gt; <span class="number">0</span>,</span><br><span class="line">        Direction::Down =&gt; <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, direction_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模式绑定">模式绑定</h5>
<p>模式匹配还可以从模式中取出绑定的值，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">MoveTo</span>(<span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">actions</span> = [Action::<span class="title function_ invoke__">Say</span>(<span class="string">&quot;Hello Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>()), Action::<span class="title function_ invoke__">MoveTo</span>(<span class="number">1</span>, <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">action</span> <span class="keyword">in</span> actions &#123;</span><br><span class="line">        <span class="keyword">match</span> action &#123;</span><br><span class="line">            Action::<span class="title function_ invoke__">Say</span>(s) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">            &#125;</span><br><span class="line">            Action::<span class="title function_ invoke__">MoveTo</span>(x, y) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Point (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>enum</code> 中可以放入数据类型，再加上模式匹配可以从模式中取出绑定的值，所以可以实现上述代码。</li>
</ul>
<h5 id="穷尽匹配">穷尽匹配</h5>
<p><code>match</code> 的匹配必须穷尽所有情况，比如下述代码因为没有穷尽所有情况而报错。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">match</span> direction &#123;</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">&quot;UpUp&quot;</span>),</span><br><span class="line">        <span class="comment">// 缺少 Down 的匹配</span></span><br><span class="line">        Direction::Left | Direction::Right =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;ohh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-let-匹配">if let 匹配</h4>
<p>当只要匹配一个条件，且忽略其他条件时就用 <code>if let</code>。</p>
<p>如下面两个代码是等价的：</p>
<p>实现1：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现2：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量遮蔽">变量遮蔽</h4>
<p>无论是 <code>match</code> 还是 <code>if let</code>，这里都是一个新的代码块，而且这里的绑定相当于新变量，如果你使用同名变量，会发生变量遮蔽：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">action</span> = Action::<span class="title function_ invoke__">Say</span>(<span class="string">&quot;Hello Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">match</span> action &#123;</span><br><span class="line">        Action::<span class="title function_ invoke__">Say</span>(s) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// Hello Rust</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="matches-宏">matches! 宏</h4>
<p><code>matches!</code> 宏可以将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> 或者 <code>false</code>。</p>
<p>如使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ch</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, matches!(ch, <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, matches!(number, <span class="number">10</span>..=<span class="number">20</span>)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解构-option">解构 Option</h4>
<p><code>Option</code> 是一种枚举，用于解决 Rust 中变量是否有值的问题：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>一个变量要么有值：Some(T)，要么为空：None。</strong></li>
<li>由于封装，可以直接使用 <code>Some(T)</code> 和 <code>None</code>，而不需要使用  <code>Option::Some(T)</code> 和 <code>Option::None</code>。</li>
</ul>
<p>使用 <code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况。</p>
<p>编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code>，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 <code>None</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="title function_ invoke__">Some</span>(x + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (ans1, ans2) = (<span class="title function_ invoke__">add_one</span>(five), <span class="title function_ invoke__">add_one</span>(none));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;&quot;</span>, ans1, ans2); <span class="comment">// Some(6), None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模式使用场景">模式使用场景</h4>
<p>用到模式的地方：</p>
<ul>
<li><code>match</code> 分支。</li>
<li><code>if let</code> 语句。</li>
<li><code>while let</code> 循环。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = v.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c b a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>for</code> 循环：使用特定模式匹配可迭代容器。</li>
<li><code>let</code> 语句：使用变量绑定数据也是一种模式匹配。</li>
<li>函数参数也是模式。</li>
</ul>
<p>还有关于 <code>let</code> 和 <code>if let</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为右边的值可能不为 <code>Some</code>，而是 <code>None</code>，这种时候就不能进行匹配。</li>
<li>对于 <code>let</code>、<code>for</code>、<code>match</code> 都要求完全覆盖匹配。</li>
</ul>
<p>而 <code>if let</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>if let</code> 允许匹配一种模式，忽略其余模式。</li>
</ul>
<h4 id="全模式列表">全模式列表</h4>
<p><em>模式的相关语法</em></p>
<h5 id="匹配字面值">匹配字面值</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码获得特定的具体值。</li>
</ul>
<h5 id="匹配命名变量">匹配命名变量</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;match y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;match： x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;main: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>变量遮蔽。</li>
</ul>
<h5 id="单分支多模式">单分支多模式</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>|</code> 表示或。</li>
</ul>
<h5 id="通过序列-匹配值范围">通过序列 …= 匹配值范围</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;1~5&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>序列只允许用于数字或字符类型，原因是它们可以连续。</li>
</ul>
<h5 id="解构并分解值">解构并分解值</h5>
<p>使用模式来解构结构体、枚举、元组、数组和引用。</p>
<h6 id="解构结构体">解构结构体</h6>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x, y &#125; = p;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, x, y); <span class="comment">// (0, 7)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, a, b); <span class="comment">// (0, 7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模式中的变量名不必与结构体中的字段名一致。</li>
</ul>
<p>还可以匹配结构体中的某个字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;在x轴上&#123;&#125;&quot;</span>, x),</span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;在y轴上&#123;&#125;&quot;</span>, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;不在轴上(&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在y轴上7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="解构枚举">解构枚举</h6>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Op</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move1 &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;, <span class="comment">// 绑定结构体</span></span><br><span class="line">    <span class="title function_ invoke__">Move2</span>(<span class="type">i32</span>, <span class="type">i32</span>),          <span class="comment">// 绑定元组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = Op::<span class="title function_ invoke__">Move2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        Op::Quit =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Quit&quot;</span>),</span><br><span class="line">        Op::Move1 &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Move1: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">        Op::<span class="title function_ invoke__">Move2</span>(x, y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Move2: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模式匹配需要类型相同。</li>
</ul>
<h6 id="解构嵌套的结构体和枚举">解构嵌套的结构体和枚举</h6>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Op</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Op::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Op::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;R:&#123;&#125;, G:&#123;&#125;, B:&#123;&#125;&quot;</span>, r, g, b)</span><br><span class="line">        &#125;</span><br><span class="line">        Op::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;H:&#123;&#125;, S:&#123;&#125;, V:&#123;&#125;&quot;</span>, h, s, v)</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>match</code> 可以匹配嵌套的项。</li>
</ul>
<h6 id="解构结构体和元组">解构结构体和元组</h6>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        x: <span class="type">i32</span>,</span><br><span class="line">        y: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ((feet, inches), Point &#123; x, y &#125;) = ((<span class="number">3</span>, <span class="number">10</span>), Point &#123; x: <span class="number">3</span>, y: -<span class="number">10</span> &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;feet: &#123;&#125;, inches: &#123;&#125;, x: &#123;&#125;, y: &#123;&#125;&quot;</span>, feet, inches, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用复杂的方式来混合、匹配和嵌套解构模式。</li>
<li>上述代码为结构体和元组嵌套在元组中，把原始类型解构出来。</li>
</ul>
<h6 id="解构数组">解构数组</h6>
<ul>
<li>定长数组解构：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> [x, y, z] = arr;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不定长数组解构：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = &amp;_arr[..];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> [x, ..] = arr &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> &amp;[.., y] = arr &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: &amp;[<span class="type">i32</span>] = &amp;[];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(matches!(arr, [..])); <span class="comment">// 断言成功</span></span><br><span class="line">    <span class="built_in">assert!</span>(!matches!(arr, [x, ..])); <span class="comment">// 断言成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="忽略模式中的值">忽略模式中的值</h5>
<ul>
<li>使用 <code>_</code> 忽略整个值：当不再需要特定函数参数时，最好修改签名不再包含无用的参数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>(_: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;只使用y：&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">fun</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用嵌套的 <code>_</code> 忽略部分值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> (setting_value, new_setting_value) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(_), <span class="title function_ invoke__">Some</span>(_)) =&gt; &#123;&#125; <span class="comment">// 不关心值，只关心类型</span></span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, _, third, _, fifth) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, third, fifth);</span><br><span class="line">            <span class="comment">// 2, 6, 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用下划线开头忽略未使用的变量。</p>
<ul>
<li>带 <code>_</code> 的变量仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。</li>
</ul>
</li>
<li>
<p>用 <code>..</code> 忽略剩余值。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., end) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, first, end);</span><br><span class="line">            <span class="comment">// 2, 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, ..) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, first); <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="匹配守卫提供的额外条件">匹配守卫提供的额外条件</h5>
<p>匹配守卫（match guard）是一个位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> n &gt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&gt; 5&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(_) | <span class="literal">None</span> <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;aa&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;bb&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匹配守卫直接取得解构后的值作比较（如匹配分支1）；</li>
<li>匹配守卫可以直接用外部的 <code>y</code>（如匹配分支2）；</li>
<li>使用 <code>|</code> 加上匹配守卫，需要先满足前面 或 的条件再判断匹配守卫的条件（如匹配分支3），即 <code>(Some(_) | None) if y</code>。</li>
</ul>
<h5 id="绑定">@ 绑定</h5>
<p><code>@</code> 运算符允许为一个字段绑定另一个变量。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Op</span> &#123;</span><br><span class="line">    Operation &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = Op::Operation &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">match</span> op &#123;</span><br><span class="line">        Op::Operation &#123; id: mid @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &gt;= 3 and &#123;&#125; &lt;= 7&quot;</span>, mid, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        Op::Operation &#123; id: <span class="number">0</span>..=<span class="number">2</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&gt;= 0 and &lt;= 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Op::Operation &#123; id &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个匹配分支中，测试 <code>Op::Operation</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>mid</code> 变量中以便此分支中相关的代码可以使用它。
<ul>
<li>其实也可以把 <code>mid</code> 命名为 <code>id</code>，不影响、</li>
</ul>
</li>
<li>第二个匹配分支中，没有使用 <code>@</code> 绑定，所以不能再使用结构体中的 <code>id</code>。</li>
</ul>
<p>在 Rust 1.56 时新增，使用 <code>@</code> 还可以在绑定新变量的同时对目标进行解构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 绑定新变量 `p`，同时对 `Point` 进行解构</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> @ Point &#123; x: px, y: py &#125; = Point &#123; x: <span class="number">10</span>, y: <span class="number">23</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, px, py); <span class="comment">// x: 10, y: 23</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p); <span class="comment">// Point &#123; x: 10, y: 23 &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">p</span> @ Point &#123; x: <span class="number">10</span>, y &#125; = point &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;(&#123;&#125;,&#123;&#125;)&quot;</span>, p.x, p.y); <span class="comment">// (10,5)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;:(&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Rust 1.53 新增特性：</p>
<ul>
<li>在 Rust 1.53 之前，需要这么写：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        num @ <span class="number">1</span> | num @ <span class="number">2</span> | num @ <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是在 Rust 1.53 之后，可以这么写：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        num @ (<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<p>在面向对象编程中，方法指的是对象可执行的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object.method();</span><br></pre></td></tr></table></figure>
<h4 id="定义方法">定义方法</h4>
<p>使用 <code>impl</code> 来定义方法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(w: <span class="type">i32</span>, h: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Rect &#123;</span><br><span class="line">        Rect &#123;</span><br><span class="line">            width: w,</span><br><span class="line">            height: h,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shape</span> = Rect::<span class="title function_ invoke__">new</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>impl Rect</code> 表示为 <code>Rect</code> 实现方法，即 <code>impl</code> 语句块中一切都是跟 <code>Rect</code> 相关联的。</li>
<li><code>new</code> 是 <code>Rect</code> 的关联函数，因为第一个参数不是 <code>self</code>，且 <code>new</code> 不是关键字。</li>
<li><code>area</code> 中的参数 <code>&amp;self</code> 表示借用当前的 <code>Rect</code> 结构体，</li>
</ul>
<p><strong>Rust 的对象定义和方法定义是分离的。</strong></p>
<p>方法代替函数的好处有：</p>
<ul>
<li>不用再在函数签名中书写 <code>self</code> 对应的类型；</li>
<li>代码的组织性、内聚性更强，对于代码维护和阅读有好处。</li>
</ul>
<h5 id="self">self</h5>
<p><code>self</code> 指代类型的实例（跟Python中挺像）。</p>
<ul>
<li>为哪个结构体实现方法，那么 <code>self</code> 就是指代哪个结构体的实例。</li>
</ul>
<p><code>self</code> 依然具有所有权的概念：</p>
<ul>
<li><code>self</code> 表示 <code>Rect</code> 的所有权转移到该方法中，这种形式用的较少。</li>
<li><code>&amp;self</code> 表示该方法对 <code>Rect</code> 的不可变借用。</li>
<li><code>&amp;mut self</code> 表示可变引用。</li>
</ul>
<h5 id="方法名">方法名</h5>
<p><strong>在 Rust 中，允许方法名跟结构体的字段名相同。</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">height</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时，<code>rect.width()</code> 表示调用方法，<code>rect.width</code> 表示访问字段。</li>
</ul>
<p>方法跟字段同名，适用于 <code>getter</code> 访问器的实现。</p>
<h5 id="运算符？">-&gt;运算符？</h5>
<p>C/C++ 中，如果对象指针调用方法时，会使用到 <code>-&gt;</code>：<code>object-&gt;fun()</code>。</p>
<p>但在 Rust 中，会有自动引用和解引用的功能。</p>
<ul>
<li>当使用 <code>object.fun()</code> 调用方法时，会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使得与方法签名匹配。</li>
<li>因为方法中明确接收 <code>self</code> 的类型。</li>
</ul>
<h4 id="带有多个参数的方法">带有多个参数的方法</h4>
<p>和普通函数一样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt;= other.width &amp;&amp; <span class="keyword">self</span>.height &gt;= other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关联函数">关联函数</h4>
<p>关联函数：定义在 <code>impl</code> 中且参数没有 <code>self</code> 的函数。</p>
<p>构造函数的写法：不包含 <code>self</code> 即可。</p>
<p>Rust 中有一个约定俗成的规则，使用 <code>new</code> 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 <code>new</code> 作为关键字。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">i32</span>, height: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Rect &#123;</span><br><span class="line">        Rect &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rect::<span class="title function_ invoke__">new</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个-impl-定义">多个 impl 定义</h4>
<p>Rust 允许为一个结构体定义多个 <code>impl</code> 块，目的是提供更多的灵活性和代码组织性。</p>
<ul>
<li>例如当方法多了后，可以把相关的方法组织在同一个 <code>impl</code> 块中。</li>
</ul>
<h4 id="为枚举实现方法">为枚举实现方法</h4>
<p>枚举可以像结构体一样，实现方法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">WeekDays</span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">WeekDays</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_day_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            WeekDays::Monday =&gt; <span class="string">&quot;Monday&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Tuesday =&gt; <span class="string">&quot;Tuesday&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Wednesday =&gt; <span class="string">&quot;Wednesday&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Thursday =&gt; <span class="string">&quot;Thursday&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Friday =&gt; <span class="string">&quot;Friday&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">day</span> = WeekDays::Friday;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;今天是 &#123;&#125;&quot;</span>, day.<span class="title function_ invoke__">get_day_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型和特征">泛型和特征</h3>
<h4 id="泛型-generics">泛型 Generics</h4>
<p>当出现需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。</p>
<ul>
<li>C++ 中的模板函数就是一种解决方法。</li>
</ul>
<p><em>泛型怎么不是一种多态呢。</em></p>
<p>Rust 给出的解决方案是：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">add</span>(<span class="number">1i8</span>, <span class="number">2i8</span>),       <span class="comment">// 3</span></span><br><span class="line">        <span class="title function_ invoke__">add</span>(<span class="number">1.2f32</span>, <span class="number">2.3f32</span>), <span class="comment">// 3.5</span></span><br><span class="line">        <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>)          <span class="comment">// 50</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T</code> 就是泛型参数。</li>
<li><code>std::ops::Add&lt;Output = T</code> 为对 <code>T</code> 进行限制，因为不是所有的 <code>T</code> 类型都能进行相加。</li>
</ul>
<h5 id="结构体中使用泛型">结构体中使用泛型</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="number">3.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要提前声明泛型参数 <code>Point&lt;T&gt;</code>。</li>
<li><code>x</code> 和 <code>y</code> 字段时相同的类型。</li>
</ul>
<p>当然可以不止一个泛型参数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="枚举中使用泛型">枚举中使用泛型</h5>
<p>很明显，<code>Option</code> 中过就有一个泛型参数 <code>T</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个枚举主要用于函数返回值，<code>Result</code> 关注的主要是值的正确性。</li>
</ul>
<h5 id="方法中使用泛型">方法中使用泛型</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span>&lt;T&gt; &#123;</span><br><span class="line">    width: T,</span><br><span class="line">    height: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Rect&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用泛型参数前，需要提前声明，如 <code>impl&lt;T&gt;</code>。</li>
<li><code>impl</code> 处的 <code>Rect&lt;T&gt;</code> 不再是泛型声明，而是一个完整的结构体类型。</li>
</ul>
<h6 id="为具体的泛型类型实现方法">为具体的泛型类型实现方法</h6>
<p>把 <code>T</code> 换成特定的具体类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span>&lt;T, U&gt; &#123;</span><br><span class="line">    width: T,</span><br><span class="line">    height: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span>&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rect &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">22.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">width</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect2.<span class="title function_ invoke__">width</span>()); <span class="comment">// 报错，无该方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="const-泛型">const 泛型</h5>
<p><em>Rust 1.51 版本引入。</em></p>
<p>const 泛型是针对值的泛型。</p>
<p>正好可以用于处理数组长度的问题。</p>
<ul>
<li>数组而言，长度也是类型的一部分。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个类型为 <code>[T; N]</code> 的数组，<code>T</code> 是一个基于类型的泛型参数；而 <code>N</code> 是一个基于值的泛型参数，用来代替数组的长度。</li>
</ul>
<h5 id="泛型的性能">泛型的性能</h5>
<p>在 Rust 中泛型是零成本的抽象，意味着在使用泛型时，完全不用担心性能上的问题。</p>
<ul>
<li>实际上是损失了编译速度和增大了最终生成文件的大小。</li>
</ul>
<p>Rust 通过在编译时进行泛型代码的单态化来保证效率。</p>
<ul>
<li>单态化：将通用代码转换为特定代码的过程。</li>
<li>编译器的工作与创建泛型函数的步骤相反。</li>
</ul>
<p>对于程序员而言，使用泛型可以编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。</p>
<h4 id="特征-trait">特征 Trait</h4>
<p>特征定义了<strong>一组可以被共享的行为：只要实现了特征，就能使用这组行为</strong>。</p>
<h5 id="定义特征">定义特征</h5>
<p>定义特征：把一些方法组合在一起。</p>
<ul>
<li>目的是定义一个实现某些目标所必需的行为的集合。</li>
</ul>
<p>举个例子，在数据中有小说和日记等内容载体，希望对相应的内容进行总结。那么总结这个行为就是共享的，可以都用一个特征：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>trait</code> 关键字声明一个特征，<code>Summary</code> 是特征名。</li>
<li>大括号中定义了该特征的所有方法。
<ul>
<li>特征不定义行为具体是怎么样的，因此使用函数签名。</li>
<li>每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现 <code>Summary</code> 特征的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</li>
</ul>
</li>
</ul>
<h5 id="为类型实现特征">为类型实现特征</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Novel</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Diary</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> date: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Novel</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; by &#123;&#125;&quot;</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Diary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Diary for &#123;&#125;&quot;</span>, <span class="keyword">self</span>.date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = Novel &#123;</span><br><span class="line">        title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dracula&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bram Stoker&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;Bram Stoker&#x27;s classic novel about a bloodthirsty master of the night.&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diary</span> = Diary &#123;</span><br><span class="line">        date: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;2014-01-02&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;A record of my daily life.&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Novel: &#123;:#?&#125;&quot;</span>, novel);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Diary: &#123;:#?&#125;&quot;</span>, diary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="特征定义与实现的位置">特征定义与实现的位置</h6>
<p><em>孤儿规则</em></p>
<p>上述代码中，<code>Summary</code> 被定义为公开的 <code>pub</code>，所以只需要引入到包中，就可使用该特征。</p>
<p>关于特征实现与定义的位置：<strong>如果想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 至少有一个是在当前作用域中定义的</strong>。</p>
<p>这样确保其他人编写的代码不会破坏自己的代码。</p>
<h6 id="默认实现">默认实现</h6>
<p>在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;Reading...&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有，默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">simple_summary</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">simple_summary</span>());</span><br><span class="line">        <span class="string">&quot;Reading...&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Novel</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">simple_summary</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>那么通过上述代码，<code>Novel</code> 的实例可以通过调用 <code>summarize</code> 方法间接调用了 <code>simple_summary</code> 方法。</li>
</ul>
<h5 id="使用特征作为函数参数">使用特征作为函数参数</h5>
<p>先定义一个函数，使用特征作为函数参数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>impl Summary</code> 表示实现了 <code>Summary</code> 特征的 <code>item</code> 参数。</li>
<li>可以使用任何实现了 <code>Summary</code> 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法。</li>
</ul>
<h5 id="特征约束">特征约束</h5>
<p>通过特征约束一些变量类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T: Summary</code> 被称为特征约束。</li>
</ul>
<p>特征约束的表达很奇妙，比如；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的两个参数可以是实现了 <code>Summary</code> 特征的不同的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: SUmmary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的两个参数都必须是实现了 <code>Summary</code> 特征的相同的类型。</li>
</ul>
<h6 id="多重约束">多重约束</h6>
<p>可以指定多个约束条件：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + <span class="built_in">Send</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + <span class="built_in">Send</span>&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T: Summary + Send</code> 表示 <code>T</code> 必须同时实现 <code>Summary</code> 和 <code>Send</code> 特征。</li>
</ul>
<h6 id="where-约束">Where 约束</h6>
<p>当特征约束变得很多时，使用 <code>where</code> 进行一些形式上的改进：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + Summary,</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h6 id="例-找最大值">例-找最大值</h6>
<p>方式一：使用特征约束，且使用引用方式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_1</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>PartialOrd</code> 特征可以用于比较两个值。</li>
</ul>
<p>方法二：使用特征约束，使得值具有 <code>Copy</code> 特征。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_2</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="特征约束有条件地实现方法或特征">特征约束有条件地实现方法或特征</h6>
<p>特征约束，可以在指定类型 + 指定特征的条件下去实现方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">        x: T,</span><br><span class="line">        y: T,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有同时实现了 <code>Display</code> 和 <code>PartialOrd</code> 特征的类型 <code>T</code>，才可以调用 <code>cmp_display</code> 方法。</li>
</ul>
<h5 id="函数返回中的-impl-trait">函数返回中的 impl Trait</h5>
<p>可以通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ret_summary</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Novel &#123;</span><br><span class="line">        title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;b&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Novel</code> 实现了 <code>Summary</code> 特征，所以可以用它作为返回值。</li>
<li><code>ret_summary</code> 返回一个实现了 <code>Summary</code> 特征的类型，但不知道具体什么类型。</li>
</ul>
<p><em>可能在数据类型十分复杂，不知道怎么声明，就可以使用这种返回类型。如闭包和迭代器的类型就是很复杂。</em></p>
<p>但是这种返回值只能有一种具体的类型，不能模棱两可。</p>
<ul>
<li>即一个分支下返回实现了某特征的 A 类型，而另一个分支又返回实现了某特征的 B 类型。这种情况是拒绝的。</li>
</ul>
<h5 id="通过-derive-派生特征">通过 derive 派生特征</h5>
<p>形如 <code>#[derive(Debug)]</code> 的代码，是一种特征派生语法。</p>
<p><code>derive</code> 派生出来的是 Rust 默认提供的特征。</p>
<p>更多见<a href="https://course.rs/appendix/derive.html">派生特征</a>。</p>
<h5 id="调用方法需要引入特征">调用方法需要引入特征</h5>
<p><strong>如果要使用一个特征的方法，那么需要将该特征引入当前的作用域中。</strong></p>
<p><em>Rust 把最常用的标准库中的特征通过 <code>std::prelude</code> 模块提前引入到当前作用域中。</em></p>
<h5 id="综合例子">综合例子</h5>
<ul>
<li>自定义类型实现加法操作。</li>
<li>自定义类型实现打印输出。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt::Display, ops::Add&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//限制类型 T 必须实现了 Add 特征，否则无法进行 + 操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span>&lt;T: Add&lt;T, Output = T&gt;&gt; &#123;</span><br><span class="line">    real: T,</span><br><span class="line">    imag: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 Complex&lt;T: Add&lt;T, Output = T&gt;&gt; 实现 Add 特征</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt;&gt; Add <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Complex&lt;T&gt;;</span><br><span class="line">    <span class="comment">// 定义了一个类型别名 Output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, p: Complex&lt;T&gt;) <span class="punctuation">-&gt;</span> Complex&lt;T&gt; &#123;</span><br><span class="line">        Complex &#123;</span><br><span class="line">            real: <span class="keyword">self</span>.real + p.real,</span><br><span class="line">            imag: <span class="keyword">self</span>.imag + p.imag,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 Complex&lt;T: Add&lt;T, Output = T&gt;&gt; 实现 Display 特征</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt; + Display&gt; Complex&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, <span class="keyword">self</span>.real, <span class="keyword">self</span>.imag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: Add&lt;T, Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Complex &#123; real: <span class="number">1</span>, imag: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Complex &#123; real: <span class="number">3</span>, imag: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">add</span>(a, b);</span><br><span class="line">    c.<span class="title function_ invoke__">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="特征对象-todo">特征对象 Todo</h4>
<h4 id="深入特征-todo">深入特征 Todo</h4>
<h3 id="集合类型-todo">集合类型 Todo</h3>
<h4 id="动态数组-vector">动态数组 Vector</h4>
<h4 id="kv-存储-hashmap">KV 存储 HashMap</h4>
<h3 id="认识生命周期-todo">认识生命周期 Todo</h3>
<h3 id="返回值和错误处理-todo">返回值和错误处理 Todo</h3>
<h3 id="包和模块-todo">包和模块 Todo</h3>
<h4 id="包-crate">包 Crate</h4>
<h4 id="模块-module">模块 Module</h4>
<h4 id="使用-use-引入模块及受限可见性">使用 use 引入模块及受限可见性</h4>
<h3 id="注释和稳定-todo">注释和稳定 Todo</h3>
<h3 id="格式化输出-todo">格式化输出 Todo</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>一个小巧的Markdown编辑工具</title>
    <url>/2023/tools1/</url>
    <content><![CDATA[<p>介绍一个小巧方便的编写Markdown语言工具——MarkText。</p>
<p>关键词：Markdown工具</p>
<span id="more"></span>
<hr>
<!-- toc -->
<h1>什么是Markdown</h1>
<ul>
<li>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
</li>
<li>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
</li>
<li>
<p>Markdown可用于编写记录笔记、博客、电子书等电子文档。</p>
</li>
</ul>
<h1>MarkText</h1>
<ul>
<li>MarkText是一款开源的Markdown工具，可用于编辑输出Markdown文件。本人推荐的是英文语言软件，如何汉化自行研究。</li>
</ul>
<p>软件地址：建议安装到非系统盘（非C盘）</p>
<p><a href="https://github.com/marktext/marktext/releases">MarkText下载 - 官网</a></p>
<p><a href="https://www.aliyundrive.com/s/CoADkVDj1Sq">MarkText下载 - 个人网盘（Windows64位）</a></p>
<ul>
<li>MarkText具有多个明暗主题选择，软件菜单内容明确，主打轻便，是一款很不错的小工具。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%B8%BB%E7%95%8C%E9%9D%A2.jpg" alt="软件界面（明亮主题）"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%B8%BB%E7%95%8C%E9%9D%A22.jpg" alt="软件界面（灰暗主题）"></p>
<ul>
<li>使用方法</li>
</ul>
<p>输入<code>@</code>选择插入的模块，包括段落、分割线、标题、表格、数学公式、引用块、列表等。如果本身对于Markdown语言有一定基础的话，也可直接建立该模块。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%BD%BF%E7%94%A81.jpg" alt="使用过程"></p>
<p>在编写完内容后，可以直接保存为Markdown文件（<code>.md</code>后缀），也可以导出为PDF文件和HTML文件。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%BF%9D%E5%AD%98.jpg" alt="选择保存"></p>
<h1>进阶使用</h1>
<ul>
<li>
<p>有时候对于PDF文件，会有显示目录大纲的需求，但是该软件直接导出并不能设置，此时需要借助另一个工具：wkhtmltopdf。</p>
</li>
<li>
<p><strong>wkhtmltopdf</strong></p>
</li>
</ul>
<p>一款<strong>将HTML文件转化为PDF文件</strong>的小工具，但是其并没有软件UI界面，对小白不友好，但是万能的网络能搜到使用方法，此处针对如何导出带目录的PDF进行介绍。</p>
<ol>
<li>下载软件</li>
</ol>
<p>下载地址：可能提示有风险，建议安装到非系统盘（非C盘）</p>
<p><a href="https://wkhtmltopdf.org/downloads.html">wkhtmltopdf下载 - 官网</a></p>
<p><a href="https://www.aliyundrive.com/s/V4SBUcntBAv">wkhtmltopdf下载 - 个人网盘（Windows64位）</a></p>
<ol start="2">
<li>安装并配置</li>
</ol>
<p>安装后，需要记住安装的具体位置，比如我是安装在D盘，位置就是<code>D:\wkhtmltopdf</code>，接着进行系统环境变量的配置。在电脑设置中搜索环境变量，打开编辑页面。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="配置环境变量"></p>
<p>具体步骤：编辑→新建→输入安装的位置里面的bin文件夹即<code>D:\wkhtmltopdf\bin</code>→确定所有系统设置窗口。</p>
<p>（添加错误的环境变量并不会对电脑造成严重伤害，但不要胡乱删除环境变量）</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E.jpg" alt="配置环境变量后"></p>
<p>再接着确认环境变量是否配置成功：按快捷键<code>win+r</code>，输入cmd，打开黑窗口，在窗口内输入<code>wkhtmltopdf -V</code>（查询wkhtmltopdf的版本），如果出现类似于版本号的数字，则说明添加环境变量成功。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_cmd.jpg" alt="配置成功"></p>
<ol start="3">
<li>软件使用</li>
</ol>
<p>在cmd黑窗口切换到想要HTML文件转换为PDF文件的位置，直接输入<code>F:</code>切换到不同的盘，输入<code>cd xx</code>可以进入不同文件夹。如果不知道自己是什么路径，可以先进入所在盘，再打开文件所在文件夹，在地址栏点击获得路径，然后复制粘贴到黑窗口进入。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" alt="进入工作文件夹"></p>
<p>接着回到MarkText软件，将文件导出为HTML文件，保存在特定文件夹，该文件夹应该跟cmd黑窗口进入的文件夹一样。举例时，我将该文件保存为<code>test.html</code>文件在<code>F:\14.Books</code>文件夹。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E5%AF%BC%E5%87%BAHTML.jpg" alt="导出HTML"></p>
<p>再回到黑窗口，使用命令<code>wkhtmltopdf 目的文件名字 新文件名字</code>转换，我这里应该是<code>wkhtmltopdf test.html test.pdf</code>。等待转换成功。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8A%9F.jpg" alt="转换成功"></p>
<p>此时回到文件夹，就可以看到转换完成的带目录的PDF文件。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_test.jpg" alt="转换成功的PDF文件"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Markdown工具</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL图形学编程基础学习记录</title>
    <url>/2024/basicOpenGL/</url>
    <content><![CDATA[<p>关键词：C++、OpenGL</p>
<span id="more"></span>
<hr>
<p><em>未完待施工…</em></p>
<h2 id="一-opengl安装与使用">一、OpenGL安装与使用</h2>
<p><em>Reference：计算机图形学编程（使用OpenGL和C++）（第2版）</em></p>
<h3 id="1-1-认识opengl">1.1 认识OpenGL</h3>
<p>在 C++中使用 OpenGL 需要配置多个库。此处，使用到：</p>
<ul>
<li>
<p>C++开发环境；</p>
</li>
<li>
<p>OpenGL / GLSL：2004 年，2.0 版本中引入了 OpenGL 着色语言 GLSL，使得“着色器程序”可以被直接安装到图形管线的各个阶段并执行；</p>
</li>
<li>
<p>窗口管理库：OpenGL会将图像渲染到一个帧缓冲区，然后由计算机将帧缓冲区的内容绘制到屏幕的窗口中，GLFW 库是最流行的选择之一。</p>
</li>
<li>
<p>扩展库：常用如 GLEW 库；</p>
</li>
<li>
<p>数学库：3D 图形编程会大量使用向量和矩阵代数，可使用 OpenGL Mathematics（GLM）库、 Eigen 库或 vmath 库；</p>
</li>
<li>
<p>纹理图像加载库：比如 FreeImage、DevIL、GLI、Glraw 和 SOIL。</p>
</li>
</ul>
<h3 id="1-2-安装和配置opengl">1.2 安装和配置OpenGL</h3>
<p><em>基于Visual Studio 2022进行</em></p>
<h4 id="1-2-1-准备opengl-glsl">1.2.1 准备OpenGL/GLSL</h4>
<ul>
<li>了解计算机支持什么版本的OpenGL，可使用 <a href="https://www.realtech-vr.com/home/?page_id=1402">GLView</a> 查看。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_OpenGLversion.jpg" alt="OpenGL版本"></p>
<h4 id="1-2-2-准备glfw">1.2.2 准备GLFW</h4>
<ol>
<li>下载 GLFW 源代码，<a href="https://www.glfw.org/">下载地址</a></li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glfwfiles.jpg" alt="GLFW文件"></p>
<ol start="2">
<li>使用 CMake 进行编译源码</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glfwbuild.jpg" alt="编译GLFW"></p>
<p>接着找到 GLFW.sln，使用VS打开并编译为64位应用程序。</p>
<ol start="3">
<li>构建完成后得到下面两个内容：lib静态库文件和include文件夹</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs%2Fopengl_glfwlib.jpg" alt="静态库"></p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs%2Fopengl_glfwinclude.jpg" alt="include"></p>
<h4 id="1-2-3-准备glew">1.2.3 准备GLEW</h4>
<p>下载 GLEW 的二进制文件，<a href="https://glew.sourceforge.net/">下载地址</a>。解压后内有库文件和头文件等。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glew.jpg" alt="GLEW文件夹"></p>
<h4 id="1-2-4-准备glm">1.2.4 准备GLM</h4>
<p>下载 GLM 压缩包，<a href="https://github.com/g-truc/glm/releases">下载地址</a>，解压后即可。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_glm.jpg" alt="GLM"></p>
<h4 id="1-2-5-准备soil2">1.2.5 准备SOIL2</h4>
<ol>
<li>
<p>下载并解压 <a href="https://premake.github.io/">premake</a>，包含 premake5.exe。</p>
</li>
<li>
<p>下载 SOIL2 的源码，<a href="https://github.com/SpartanJ/SOIL2/tags">下载地址</a>，解压。</p>
</li>
<li>
<p>将 premake5.exe 复制到 soil2 目录下。</p>
</li>
<li>
<p>在 soil2 目录下使用cmd，运行命令：</p>
</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">premake5 vs2022</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_premake.jpg" alt="运行命令"></p>
<ol start="5">
<li>打开 make/windows 文件夹的 SOIL2.sln 文件，右键 soil2-static-lib 在 x64 下选择进行生成。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_soil2.jpg" alt="生成文件"></p>
<h4 id="1-2-6-准备共享的lib和include">1.2.6 准备共享的lib和include</h4>
<p>选择合适的位置创建文件夹，并设置 lib 和 include 子文件夹。</p>
<ul>
<li>
<p>在 lib 文件夹中放入 glew32.lib、glfw3.lib 和 soil2-debug.lib。</p>
</li>
<li>
<p>在 include 文件夹中放入 GLEW 的 GL 文件夹、GLFW 文件夹、glm 文件夹 和 SOIL2-1.3.0/src 的 SOIL2 文件夹。</p>
</li>
<li>
<p>在当前文件夹放入 glew32.dll</p>
</li>
</ul>
<p>文件结构如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_openglstructure.jpg" alt="共享文件夹结构"></p>
<h3 id="1-3-在vs中配置opengl项目">1.3 在VS中配置OpenGL项目</h3>
<p><em>创建 VS 自定义项目模板</em></p>
<ol>
<li>
<p>启动 VS， 创建空白项目，选择 x64。</p>
</li>
<li>
<p>在 Debug 模式下，进入“项目属性”，在“VC++”目录下的包含目录添加上共享文件夹的 include 文件夹；在“链接器”下，“常规-&gt;附加库目录”（或“VC+±&gt;库目录”）添加上共享文件夹的 lib 文件夹，“输入-&gt;附加依赖项”添加以下文件名： <code>glfw3.lib</code>、<code>glew32.lib</code>、<code>soil2-debug.lib</code> 和 <code>opengl32.lib</code>。</p>
</li>
<li>
<p>在 Release 模式下，重复上述步骤。</p>
</li>
<li>
<p>“项目-&gt;导出模板”，选择项目模板，命名自定义，此处为“OpenGL project”。</p>
</li>
</ol>
<p>创建 OpenGL C++ 项目时，启动 VS 时，点击“新建项目”，在左上方选择 OpenGL 模板即可使用。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_template.jpg" alt="使用模板创建项目"></p>
<p>需要注意的是，在新建OpenGL C++项目时，需要把 <code>glew32.dll</code> 放到项目目录下。</p>
<h3 id="1-4-创建一个窗口">1.4 创建一个窗口</h3>
<p>这部分可以用来测试上面的配置是否成功。下面给出一个 OpenGL C++ 创建窗口的代码：</p>
<details><summary>展开代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">GLFWwindow *window;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// MacOS 不需要</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个窗口并创建它的OpenGL上下文</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;New Window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GLEW</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保我们可以捕捉到下面按下的转义键</span></span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(window, GLFW_STICKY_KEYS, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蓝色背景</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清除屏幕</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换缓冲区</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>); <span class="comment">// 检查是否按下了ESC键或窗口已关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭OpenGL窗口并终止GLFW</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>运行结果：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/opengl_newwindow.jpg" alt="运行结果"></p>
<h2 id="二-opengl图像管线">二、OpenGL图像管线</h2>
<p>C++/OpenGL 应用程序的一个重要任务是让程序员的 GLSL 代码运行于 GPU 上。</p>
<p>OpenGL 提供了一个多级图形管线，可以使用 GLSL 语言进行部分编程。GLSL 是一种着色器语言。着色器语言主要运行于 GPU 上，在图形管线上下文中。</p>
<h3 id="2-1-管线">2.1 管线</h3>
<p>OpenGL 图像管线是 OpenGL 的核心，它是一个图像处理的管线。图像管线的工作原理是将图像数据从原始的纹理中渲染到屏幕上。</p>
<p>3D 图形编程会使用管线的概念，在管线中，将 3D 场景转换成  2D 图形的过程被分割成许多步骤。</p>
<p>C++/OpenGL 应用程序发送图形数据到顶点着色器，随着管线处理，最终生成在显示器上显示的像素点。</p>
<h4 id="2-1-1-第一个c-opengl应用程序">2.1.1 第一个C++/OpenGL应用程序</h4>
<p><em>即详细解释之前的创建窗口代码</em></p>
<p>该程序将会使用一些扩展库：GLEW、GLM、SOIL2 和 GLFW。</p>
<ul>
<li>GLFW 库提供了 GLFWwindow 类，可在其上进行3D场景绘制。</li>
</ul>
<p>该程序的大概操作有：</p>
<ol>
<li>初始化 GLFW</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 GLFW</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建窗口的设置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// WindowHint 指定了计算机必须与 OpenGL 版本 4.6 兼容（主版本号为 4，次版本号为 6）。</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建一个 GLFWwindow 实例并创建窗口</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;New Window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// glfwCreateWindow 命令的参数指定了窗口的宽、高（以像素为单位）以及窗口顶部的标题，后两个NULL分别用来控制全屏显示和资源共享）</span></span><br><span class="line"><span class="comment">// 创建一个新窗口，大小为1024×768，窗口名为“New Window”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="comment">// 创建 GLFW 窗口并不会自动将它与当前 OpenGL 上下文关联起来，因此需要调用 glfwMakeContextCurrent()。</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>设置窗口属性</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保我们可以捕捉到下面按下的转义键</span></span><br><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_STICKY_KEYS, GL_TRUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置绿色背景，四个参数分别为RGBA。</span></span><br><span class="line"><span class="comment">// glClearColor()能够指定颜色缓冲区清除后填充的值</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>初始化 GLEW 库</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 GLEW</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>循环显示窗口</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 清除屏幕，重置缓冲区时填充的颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲区，绘制屏幕</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="comment">// 处理窗口相关事件（如按键事件）</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>); <span class="comment">// 检查是否按下了ESC键或窗口已关闭</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>退出程序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭OpenGL窗口并终止GLFW</span></span><br><span class="line"><span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br></pre></td></tr></table></figure>
<details><summary>完整程序</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> glm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个窗口并创建它的OpenGL上下文</span></span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;New Window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保我们可以捕捉到下面按下的转义键</span></span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(window, GLFW_STICKY_KEYS, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绿色背景</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GLEW</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清除屏幕</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换缓冲区</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>); <span class="comment">// 检查是否按下了ESC键或窗口已关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭OpenGL窗口并终止GLFW</span></span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="2-2-顶点着色器和片段着色器">2.2 顶点着色器和片段着色器</h3>
<p>多数 3D 模型通常由多个三角形图元构成。如点、线、三角形这些简单的图形称作图元。</p>
<p>图元由顶点组成。</p>
<p>在加载顶点之前，C++/OpenGL 应用程序必须编译并链接合适的 GLSL 顶点着色器和片段着色器程序，之后将它们载入管线。</p>
<p>比如绘画三角形时，可以通过该函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GLenum mode, Glint first, Glsizei count);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>mode：表示图元的类型；</p>
</li>
<li>
<p>first：表示从哪个顶点开始绘制；</p>
</li>
<li>
<p>count：表示绘制的顶点数。</p>
</li>
</ul>
<p>以绘画三角形为例子，步骤如下：</p>
<p><em>注： <code>GLuint</code> 是 OpenGL 提供的 <code>unsigned int</code></em></p>
<ol>
<li>
<p>初始化阶段，对 GLFW 和 GLEW 库进行初始化，同时创建窗口；</p>
</li>
<li>
<p>创建顶点数组对象VAO和缓存区；</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个顶点数组对象，并将它设为当前对象</span></span><br><span class="line">GLuint VertexArrayID;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VertexArrayID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> GLfloat g_vertex_buffer_data[] = &#123;</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓存区</span></span><br><span class="line">GLuint vertexbuffer; <span class="comment">// 顶点缓冲区标识</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer); <span class="comment">// 生成1个缓冲区，将生成的标识符放入顶点缓冲</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); <span class="comment">// 把这个三角形传给OpenGL</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>循环中绘画三角形</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 启用顶点数组</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);    <span class="comment">// 绘制三角形</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 禁用顶点数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);    <span class="comment">// 交换缓冲区，更新屏幕</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();            <span class="comment">// 监听事件</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS <span class="keyword">and</span> <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>后处理，删除申请的资源</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后处理，删除资源</span></span><br><span class="line"><span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer);</span><br><span class="line"><span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br></pre></td></tr></table></figure>
<details><summary>完整代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个窗口并创建它的OpenGL上下文</span></span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;triangle&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保我们可以捕捉到下面按下的转义键</span></span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(window, GLFW_STICKY_KEYS, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绿色背景</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GLEW</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个顶点数组对象，并将它设为当前对象</span></span><br><span class="line">    GLuint VertexArrayID; <span class="comment">// 顶点数组标识</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VertexArrayID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> GLfloat g_vertex_buffer_data[] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓存区</span></span><br><span class="line">    GLuint vertexbuffer; <span class="comment">// 顶点缓冲区标识</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer); <span class="comment">// 生成1个缓冲区，将生成的标识符放入顶点缓冲</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); <span class="comment">// 把这个三角形传给OpenGL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 启用顶点数组属性</span></span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);    <span class="comment">// 绘制三角形</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 禁用顶点数组属性</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);    <span class="comment">// 交换缓冲区，更新屏幕</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();            <span class="comment">// 监听事件</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS <span class="keyword">and</span> <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理，删除资源</span></span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer);</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_triangle.jpg" alt="绘画三角形"></p>
<p>这个三角形是白色的，因为其并没有进行任何着色。</p>
<p>使用顶点着色器和片段着色器可以进行着色。</p>
<details><summary>完整代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">createShadeProgram</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *vshaderSource =</span><br><span class="line">        <span class="string">&quot;#version 460 core\n&quot;</span></span><br><span class="line">        <span class="string">&quot;layout(location = 0) in vec3 vertexPosition_modelspace;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123; gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0; &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fshaderSource =</span><br><span class="line">        <span class="string">&quot;#version 460 core\n&quot;</span></span><br><span class="line">        <span class="string">&quot;out vec3 color;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123; color = vec3(0, 0, 0.3); &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OpenGL 创建每个着色器对象（初始值为空）的时候，会返回一个整数 ID 作为后面引用它的序号</span></span><br><span class="line">    <span class="comment">// 分别存入 vShader 和 fShader 变量</span></span><br><span class="line">    GLuint vShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">// 创建了类型为GL_VERTEX_SHADER 的着色器，即顶点着色器</span></span><br><span class="line">    GLuint fShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER); <span class="comment">// 创建了类型为GL_FRAGMENT_SHADER 的着色器，即片段着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GLSL 代码从字符串载入空着色器对象中</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vShader, <span class="number">1</span>, &amp;vshaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fShader, <span class="number">1</span>, &amp;fshaderSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vShader);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个叫作 vfProgram 的程序对象并记录其ID</span></span><br><span class="line">    GLuint vProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="comment">// 将着色器加入程序对象</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, vShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, fShader);</span><br><span class="line">    <span class="comment">// 请求 GLSL 编译器，以确保它们的兼容性</span></span><br><span class="line">    <span class="built_in">glLinkProgram</span>(vProgram);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vProgram; <span class="comment">// 返回着色器程序ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个窗口并创建它的OpenGL上下文</span></span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;triangle&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保我们可以捕捉到下面按下的转义键</span></span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(window, GLFW_STICKY_KEYS, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绿色背景</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GLEW</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个顶点数组对象，并将它设为当前对象</span></span><br><span class="line">    GLuint VertexArrayID; <span class="comment">// 顶点数组标识</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VertexArrayID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> GLfloat g_vertex_buffer_data[] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓存区</span></span><br><span class="line">    GLuint vertexbuffer; <span class="comment">// 顶点缓冲区标识</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer); <span class="comment">// 生成1个缓冲区，将生成的标识符放入顶点缓冲</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); <span class="comment">// 把这个三角形传给OpenGL</span></span><br><span class="line"></span><br><span class="line">    GLuint programID = <span class="built_in">createShadeProgram</span>(); <span class="comment">// 创建着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUseProgram</span>(programID);    <span class="comment">// 使用着色器</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 启用顶点数组属性</span></span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);    <span class="comment">// 绘制三角形</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 禁用顶点数组属性</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);    <span class="comment">// 交换缓冲区，更新屏幕</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();            <span class="comment">// 监听事件</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS <span class="keyword">and</span> <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理，删除资源</span></span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer);</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(programID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_triangle1.jpg" alt="着色后的三角形"></p>
<p>观察着色器部分的代码：</p>
<p>顶点着色器：所有顶点着色器的主要目标都是将顶点发送给管线。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;#version 460 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 0) in vec3 vertexPosition_modelspace;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123; gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0; &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>第一行表示OpenGL版本，同时也使用该版本的语法，我这里是4.6.0；</p>
</li>
<li>
<p>第二行</p>
<ul>
<li><code>layout(location = 0)</code> 指用来赋给 <code>vertexPosition_modelspace</code> 这个属性的缓冲区。每个顶点能有多种属性：位置，一种或多种颜色，一个或多个纹理坐标，等等；通过将 <code>glvertexAttribPointer</code> 函数的第一个参数值赋给layout，就完成了这一点。参数值“0”并不重要，它可以是12（但是不大于 <code>glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;v)</code> ）；重要的是两边参数值保持一致</li>
<li><code>in</code> 表示表明变量是输入变量；</li>
<li><code>vec3</code> 在GLSL中是一个三维向量；</li>
<li><code>vertexPosition_modelspace</code> 是变量名，将包含每个顶点着色器运行所需的顶点位置值。</li>
</ul>
</li>
<li>
<p>第三行表示主函数，与C++语法相似；</p>
</li>
<li>
<p>第四行内置变量 gl_Position 用来设置顶点在 3D 空间中的坐标位置，并将其发送至下一个管线阶段。</p>
</li>
</ol>
<p>片段着色器：所有片段着色器的目的都是给为要展示的像素赋予颜色。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;#version 460 core\n&quot;</span> </span><br><span class="line"><span class="string">&quot;out vec3 color;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123; color = vec3(0, 0, 0.3); &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>第一行表示OpenGL版本，同时也使用该版本的语法，我这里是4.6.0；</p>
</li>
<li>
<p>第二行 out 标签表明 color 变量是输出变量；</p>
</li>
<li>
<p>第三行表示主函数，与C++语法相似；</p>
</li>
<li>
<p>第四行表示设置颜色RGB值。</p>
</li>
</ol>
<p>解释 <code>glvertexAttribPointer</code> 函数，函数使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>第一参数：指定要配置的顶点属性。在顶点着色器中使用 <code>layout(location = 0)</code> 定义了顶点属性的位置值，它可以把顶点属性的位置值设置为0，所以这里传入0；</p>
</li>
<li>
<p>第二参数：指定顶点属性的大小；</p>
</li>
<li>
<p>第三参数：指定数据的类型；</p>
</li>
<li>
<p>第四参数：是否希望数据被标准化（Normalize）；</p>
</li>
<li>
<p>第五参数：步长，告诉在连续的顶点属性组之间的间隔；</p>
</li>
<li>
<p>第六参数：数组缓冲区偏移量。</p>
</li>
</ol>
<p>此示例中着色器代码较短，可以直接编写到程序中。但当着色器代码较为复杂时，希望能文件分开，从文件中读入着色器代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读代码函数</span></span><br><span class="line"><span class="function">std::string <span class="title">readShaderSource</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fileStream</span><span class="params">(filePath, std::ios::in)</span></span>;</span><br><span class="line">    std::string line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fileStream.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(fileStream, line);</span><br><span class="line">        content.<span class="built_in">append</span>(line + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileStream.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地 <code>createShadeProgram()</code> 改成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string vs = <span class="built_in">readShaderSource</span>(<span class="string">&quot;vertex.glsl&quot;</span>);</span><br><span class="line">std::string fs = <span class="built_in">readShaderSource</span>(<span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vshaderSource = vs.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fshaderSource = fs.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>
<h3 id="2-3-glsl代码检查">2.3 GLSL代码检查</h3>
<p>编译和运行 GLSL 代码的过程与普通代码的不同，GLSL 的编译发生在 C++运行时。另外一个复杂的点是 GLSL 代码并没有运行在 CPU 中（它运行在 GPU 中），因此操作系统并不总能捕获 OpenGL 运行时的错误。着色器运行时错误的常见结果是输出屏幕上完全空白，根本没有输出。</p>
<p>但是 GLSL 函数 <code>glGetShaderiv()</code> 和 <code>glGetProgramiv()</code> 可提供有关编译过的 GLSL 着色器和程序的信息。</p>
<p>设计三个函数：</p>
<ul>
<li>
<p><code>checkOpenGLError()</code>：既用于检测 GLSL 代码编译错误，又用于检测 OpenGL 运行时的错误。</p>
</li>
<li>
<p><code>printShaderLog()</code>：当 GLSL 代码编译失败时，显示 OpenGL 日志内容。</p>
</li>
<li>
<p><code>printProgramLog()</code>：当 GLSL 链接失败时，显示 OpenGL 日志内容。</p>
</li>
</ul>
<details><summary>详细代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param shader 着色器标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printShaderLog</span><span class="params">(GLuint shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(shader, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(shader, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shader Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 链接失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param program 着色器程序标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printProgramLog</span><span class="params">(GLuint program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(program, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(program, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Program Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkOpenGLerror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> err = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    <span class="keyword">while</span> (glErr != GL_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;glError: &quot;</span> &lt;&lt; glErr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        err = <span class="literal">true</span>;</span><br><span class="line">        glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>加入错误检查，创建着色器程序代码更改为：</p>
<details><summary>展开代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">createShadeProgram</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    GLint vertCompiled, fragCompiled, linked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    std::string vs = <span class="built_in">readShaderSource</span>(<span class="string">&quot;vertex.glsl&quot;</span>);</span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    std::string fs = <span class="built_in">readShaderSource</span>(<span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *vshaderSource = vs.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fshaderSource = fs.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OpenGL 创建每个着色器对象（初始值为空）的时候，会返回一个整数 ID 作为后面引用它的序号</span></span><br><span class="line">    <span class="comment">// 分别存入 vShader 和 fShader 变量</span></span><br><span class="line">    GLuint vShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">// 创建了类型为GL_VERTEX_SHADER 的着色器，即顶点着色器</span></span><br><span class="line">    GLuint fShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER); <span class="comment">// 创建了类型为GL_FRAGMENT_SHADER 的着色器，即片段着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GLSL 代码从字符串载入空着色器对象中</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vShader, <span class="number">1</span>, &amp;vshaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fShader, <span class="number">1</span>, &amp;fshaderSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);</span><br><span class="line">    <span class="keyword">if</span> (vertCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vertex compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(vShader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(fShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);</span><br><span class="line">    <span class="keyword">if</span> (fragCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fragment compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(fShader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个叫作 vfProgram 的程序对象并记录其ID</span></span><br><span class="line">    GLuint vProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="comment">// 将着色器加入程序对象</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, vShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, fShader);</span><br><span class="line">    <span class="comment">// 请求 GLSL 编译器，以确保它们的兼容性</span></span><br><span class="line">    <span class="built_in">glLinkProgram</span>(vProgram);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(vProgram, GL_LINK_STATUS, &amp;linked);</span><br><span class="line">    <span class="keyword">if</span> (linked == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;linking failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printProgramLog</span>(vProgram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vProgram; <span class="comment">// 返回着色器程序ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="2-4-让图像动起来">2.4 让图像动起来</h3>
<p>实际上，在主函数的循环中，每一次循环都会刷新一次显示。但由于显示内容相同，故看起来是静态的。</p>
<p>对于上面的三角形，添加上些许偏移量，则会自由移动。</p>
<p>效果如下：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_movingtriangle.gif" alt="移动的三角形"></p>
<details><summary>主函数代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个窗口并创建它的OpenGL上下文</span></span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;triangle&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保我们可以捕捉到下面按下的转义键</span></span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(window, GLFW_STICKY_KEYS, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绿色背景</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GLEW</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个顶点数组对象，并将它设为当前对象</span></span><br><span class="line">    GLuint VertexArrayID; <span class="comment">// 顶点数组标识</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VertexArrayID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三角形的三个顶点：(-1,-1,0),(1,-1,0),(0,1,0)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> GLfloat g_vertex_buffer_data[] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓存区</span></span><br><span class="line">    GLuint vertexbuffer; <span class="comment">// 顶点缓冲区标识</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer); <span class="comment">// 生成1个缓冲区，将生成的标识符放入顶点缓冲</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); <span class="comment">// 把这个三角形传给OpenGL</span></span><br><span class="line"></span><br><span class="line">    GLuint programID = <span class="built_in">createShadeProgram</span>(); <span class="comment">// 创建着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> x = <span class="number">0.0f</span>, inc = <span class="number">0.001f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUseProgram</span>(programID);    <span class="comment">// 使用着色器</span></span><br><span class="line"></span><br><span class="line">        x += inc;    <span class="comment">// 移动</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1.0f</span>) inc = <span class="number">-0.001f</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">-1.0f</span>) inc = <span class="number">0.001f</span>;</span><br><span class="line">        <span class="comment">// 获取指向 offset 变量的指针</span></span><br><span class="line">        GLuint offsetLoc = <span class="built_in">glGetUniformLocation</span>(programID, <span class="string">&quot;offset&quot;</span>);</span><br><span class="line">        <span class="comment">// 将 x 的值复制给 offset</span></span><br><span class="line">        <span class="built_in">glProgramUniform1f</span>(programID, offsetLoc, x);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 启用顶点数组</span></span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vertexbuffer); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);    <span class="comment">// 绘制三角形</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);    <span class="comment">// 禁用顶点数组</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);    <span class="comment">// 交换缓冲区，更新屏幕</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();            <span class="comment">// 监听事件</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) != GLFW_PRESS <span class="keyword">and</span> <span class="built_in">glfwWindowShouldClose</span>(window) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理，删除资源</span></span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;vertexbuffer);</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VertexArrayID);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(programID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>而顶点着色器也需要根据偏移量作修改：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> <span class="keyword">offset</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexPosition_modelspace;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(vertexPosition_modelspace.x + <span class="keyword">offset</span>, vertexPosition_modelspace.y, vertexPosition_modelspace.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>uniform</code> 表示统一变量。</p>
<h2 id="三-opengl数学基础">三、OpenGL数学基础</h2>
<h3 id="3-1-坐标系">3.1 坐标系</h3>
<p>3D 空间中常常使用三个坐标轴组成的坐标系，如左手坐标系和右手坐标系。</p>
<ul>
<li>
<p>左手坐标系：伸出左手，使得拇指、食指和中指两两垂直，则拇指指向为 x 方向，中指指向为 z 方向，食指指向为 y 方向。</p>
</li>
<li>
<p>右手坐标系：伸出右手，使得拇指、食指和中指两两垂直，则拇指指向为 x 方向，中指指向为 z 方向，食指指向为 y 方向。</p>
</li>
</ul>
<p><em>此学习记录使用右手坐标系</em></p>
<h3 id="3-2-点">3.2 点</h3>
<p>齐次坐标：具有四个值，分别是 x 坐标、y 坐标、z 坐标、w 坐标。其中 w 总是非零值。</p>
<p>OpenGL 中可用 <code>vec3</code> 或 <code>vec4</code> 类表示点数据。</p>
<h3 id="3-3-向量">3.3 向量</h3>
<p>向量表示大小和方向。它们没有特定位置。在 3D 图形学中，向量一般用空间中的单个点表示，向量的大小是原点到该点的距离，方向则是原点到该点的方向。</p>
<p>GLSL 和 GLM 所提供的 <code>vec3</code> 和 <code>vec4</code> 类型既能用来存储点，又能用来存储向量。</p>
<p>设有向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 和 向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(u,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>：</p>
<ul>
<li>
<p>向量的加法：对应位置相加</p>
</li>
<li>
<p>向量归一化：将长度变为1。GLM 库提供了函数 <code>glm::normalize(vec3)</code></p>
</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>^</mo></mover><mo>=</mo><mfrac><mi>A</mi><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>=</mo><mfrac><mi>A</mi><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\hat{A}=\frac A{\vert A\vert}=\frac A{\sqrt{x^2+y^2+z^2}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9467699999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.11110999999999999em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">A</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.49033em;vertical-align:-1.13em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.1521660000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578340000000001em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.917834em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2821659999999999em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">A</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.13em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p>向量点积： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi><mo>=</mo><mi>x</mi><mi>u</mi><mo>+</mo><mi>y</mi><mi>v</mi><mo>+</mo><mi>z</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">A\cdot B = xu+yv+zw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>。GLM 库提供了函数 <code>glm::dot(vec3,vec3)</code></p>
</li>
<li>
<p>向量叉积： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mi>w</mi><mo>−</mo><mi>v</mi><mi>z</mi><mo separator="true">,</mo><mi>u</mi><mi>z</mi><mo>−</mo><mi>x</mi><mi>w</mi><mo separator="true">,</mo><mi>x</mi><mi>v</mi><mo>−</mo><mi>u</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A\times B=(yw-vz, uz-xw, xv-uy)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。GLM 库提供了函数 <code>glm::cross(vec3,vec3)</code></p>
</li>
</ul>
<h4 id="3-3-1-点积的应用">3.3.1 点积的应用</h4>
<ol>
<li>点积的基本应用是求两向量夹角。</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>=</mo><mfrac><mrow><mi>V</mi><mo>⋅</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>W</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\cos\theta=\frac{V\cdot W}{\vert V\vert\vert W\vert}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ol start="2">
<li>
<p>求向量的大小： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mi>V</mi><mo>⋅</mo><mi>V</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{V\cdot V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>判断向量是否正交，若正交，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>⋅</mo><mi>W</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">V\cdot W=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
</li>
<li>
<p>判断向量是否平行，若平行，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>⋅</mo><mi>W</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>W</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">V\cdot W=\vert V\vert\vert W\vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">∣</span></span></span></span></p>
</li>
</ol>
<h4 id="3-3-2-叉积的应用">3.3.2 叉积的应用</h4>
<ul>
<li>
<p>两向量叉积的一个重要特性是，它会生成一个新的向量（法向量），新的向量正交（垂直）于之前两个向量所定义的平面。所得法向量的方向遵循右手定则，即将右手手指从 V 向 W 卷曲会使得大拇指指向法向量 R 的方向。</p>
</li>
<li>
<p>叉积的计算与向量顺序有关。</p>
</li>
</ul>
<h3 id="3-4-矩阵">3.4 矩阵</h3>
<p>矩阵式矩形的值的阵列，跟很多领域上的矩阵概念相似。</p>
<p>GLSL中的 <code>mat4</code> 数据类型便是用来存储 4 x 4 矩阵。同样 GLM 中的 <code>mat4</code> 类也是用来实例化并表示 4 x 4 矩阵。</p>
<p>比如单位矩阵是对角线值全为1，其余值都为0的矩阵。在 GLM 中，调用构造函数 <code>glm::mat4 m(1.0f)</code> 可以在变量 m 中生成单位矩阵。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(单位矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
\tag{单位矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>矩阵转置：矩阵的列与行交换。GLM 库和 GLSL 库都有转置函数，分别是 <code>glm::transpose(mat4)</code> 和 <code>transpose(mat4)</code>。</p>
<p>矩阵加法：两个矩阵对应值相加。在GLSL中，<code>+</code> 作了重载，支持矩阵加法。</p>
<p>矩阵乘法：与线性代数中的矩阵乘法一致。</p>
<ul>
<li>在 3D 图形学中，点与矩阵相乘通常将点视作列向量，并从右向左计算，得到点。</li>
<li>矩阵相乘也叫作合并。
<ul>
<li>矩阵乘法结合律</li>
</ul>
</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>e</mi><mi>w</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>=</mo><msub><mi>M</mi><mn>1</mn></msub><mo>×</mo><mo stretchy="false">[</mo><msub><mi>M</mi><mn>2</mn></msub><mo>×</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mn>3</mn></msub><mo>×</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo>×</mo><msub><mi>M</mi><mn>2</mn></msub><mo>×</mo><msub><mi>M</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">NewPoint = M_1\times[M_2\times(M_3\times Point)]=(M_1\times M_2\times M_3)\times Point
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<ul>
<li>GLSL 和 GLM 都支持 vec4 与矩阵相乘，并使用 <code>*</code> 操作符表示。</li>
</ul>
<p>逆矩阵： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>M</mi><mo>=</mo><mtext>单位矩阵</mtext></mrow><annotation encoding="application/x-tex">MM^{-1}=M^{-1}M=单位矩阵</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span></span></span>，GLSL 和 GLM 都提供了 <code>mat4.inverse()</code> 函数。</p>
<h3 id="3-5-变换矩阵">3.5 变换矩阵</h3>
<p>变换矩阵基于 4x4 矩阵，使用齐次坐标系，包括平移矩阵、缩放矩阵、旋转矩阵、投影矩阵和 LookAt 矩阵。</p>
<h4 id="3-5-1-平移矩阵">3.5.1 平移矩阵</h4>
<p>平移矩阵 A 用于将物体从一个位置移至另一位置。</p>
<p>在单位矩阵的基础上，将 x、y、z 的移动量记录在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>03</mn></msub></mrow><annotation encoding="application/x-tex">A_{03}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>13</mn></msub></mrow><annotation encoding="application/x-tex">A_{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>23</mn></msub></mrow><annotation encoding="application/x-tex">A_{23}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 位置。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mo>+</mo><msub><mi>T</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mo>+</mo><msub><mi>T</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Z</mi><mo>+</mo><msub><mi>T</mi><mi>z</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(
\begin{matrix}
X+T_x\\
Y+T_y\\
Z+T_z\\
1
\end{matrix}
\right)
=
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; T_x\\
0 &amp; 1 &amp; 0 &amp; T_y\\
0 &amp; 0 &amp; 1 &amp; T_z\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
\left(
\begin{matrix}
X\\
Y\\
Z\\
1
\end{matrix}
\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>结果就是点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X,Y,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> 平移到位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><msub><mi>T</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>Y</mi><mo>+</mo><msub><mi>T</mi><mi>y</mi></msub><mo separator="true">,</mo><mi>Z</mi><mo>+</mo><msub><mi>T</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X+T_x,Y+T_y,Z+T_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>平移矩阵的构建可以使用 GLM 中 <code>glm::translate(x,y,z)</code> 函数。接着矩阵与点相乘。</p>
<h4 id="3-5-2-缩放矩阵">3.5.2 缩放矩阵</h4>
<p>缩放矩阵用于改变物体的大小或者将点沿朝向或远离原点的方向移动。</p>
<p>缩放矩阵 A 在单位矩阵的基础上，将位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>00</mn></msub></mrow><annotation encoding="application/x-tex">A_{00}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">A_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>22</mn></msub></mrow><annotation encoding="application/x-tex">A_{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值替换为 x、y、z 缩放因子。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>X</mi><mtext> </mtext><msub><mi>S</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Y</mi><mtext> </mtext><msub><mi>S</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>Z</mi><mtext> </mtext><msub><mi>S</mi><mi>z</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>S</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>S</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>S</mi><mi>z</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(
\begin{matrix}
X\ S_x\\
Y\ S_y\\
Z\ S_z\\
1
\end{matrix}
\right)
=
\left[
\begin{matrix}
S_x &amp; 0 &amp; 0 &amp; 0\\
0 &amp; S_y &amp; 0 &amp; 0\\
0 &amp; 0 &amp; S_z &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
\left(
\begin{matrix}
X\\
Y\\
Z\\
1
\end{matrix}
\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>GLM 的 <code>glm::scale(x,y,z)</code> 函数用于构建依照 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 缩放的矩阵，接着矩阵与点相乘。</p>
<p>缩放还可以用来切换坐标系，比如在右手坐标系下确定左手坐标系的坐标，只需把 z 坐标反转即可。切换坐标系的缩放矩阵：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -1&amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="3-5-3-旋转矩阵">3.5.3 旋转矩阵</h4>
<p>3D 空间中旋转物体需要指定旋转轴和旋转角（以度或弧度为单位）。</p>
<p>数学上可证明：围绕任何轴的旋转都可以表示为绕 x 轴、y<br>
轴、z 轴旋转的组合。围绕这 3 个轴的旋转角度被称为欧拉角。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(绕x轴旋转)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left(\begin{matrix}X \\ Y&#x27;\\ Z&#x27;\\ 1\end{matrix}\right)=\left[\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; \cos\theta &amp; -\sin\theta &amp; 0\\ 0 &amp; \sin\theta &amp; \cos\theta &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left(\begin{matrix}X\\ Y\\ Z\\ 1\end{matrix}\right)\tag{绕x轴旋转}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">绕</span><span class="mord">x</span><span class="mord cjk_fallback">轴</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(绕y轴旋转)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left(\begin{matrix}X&#x27; \\ Y\\ Z&#x27;\\ 1\end{matrix}\right)=\left[\begin{matrix}\cos\theta &amp; 0 &amp; \sin\theta &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ -\sin\theta &amp; 0 &amp; \cos\theta &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left(\begin{matrix}X\\ Y\\ Z\\ 1\end{matrix}\right)\tag{绕y轴旋转}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">绕</span><span class="mord">y</span><span class="mord cjk_fallback">轴</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>X</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>Z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(绕z轴旋转)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left(\begin{matrix}X&#x27; \\ Y&#x27;\\ Z\\ 1\end{matrix}\right)=\left[\begin{matrix}\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0\\ \sin\theta &amp; \cos\theta &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left(\begin{matrix}X\\ Y\\ Z\\ 1\end{matrix}\right)\tag{绕z轴旋转}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">绕</span><span class="mord">z</span><span class="mord cjk_fallback">轴</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>旋转变换有 3 种，分别是绕 x 轴、y 轴、z 轴旋转。GLM 提供了函数 <code>glm::rotate(mat4,θ,x,y,z)</code> 构建绕 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 旋转 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 度的矩阵，接着矩阵与点相乘。</p>
<p>通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>−</mtext><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\cos(−θ) = \cos(θ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>−</mtext><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>−</mtext><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(−θ) = −\sin(θ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 即可验证反向旋转的矩阵恰等于其转置矩阵。</p>
<p>当在 3D 空间中旋转轴不穿过原点时，物体使用欧拉角进行旋转需要几个额外的步骤。一般有：</p>
<ol>
<li>平移旋转轴以使它经过原点；</li>
<li>绕 x 轴、y 轴、z 轴旋转适当的欧拉角；</li>
<li>复原步骤 1 中的平移。</li>
</ol>
<h3 id="3-6-视觉空间和合成相机">3.6 视觉空间和合成相机</h3>
<p>3D 空间中，需要找到一点并确立观察方向，这个点叫作视图或视觉空间或合成相机。</p>
<p>观察 3D 世界需要以下步骤</p>
<ol>
<li>确定相机的位置；</li>
<li>调整相机的角度，通常需要一套它自己的直角坐标轴u、v、n；</li>
<li>定义一个视体。视体是从相机的位置出发，沿着相机的视线朝向的可视范围。</li>
<li>将视体内的对象投影到投影平面上。</li>
</ol>
<p>OpenGL 具有一个固定在原点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 且朝向 z 轴负方向的相机。所以当使用这个相机时，由于相机自身不能移动，所以需要将对象移动到适合的位置并调整合适的方向。</p>
<p>假设有世界空间（类似于全局的空间）中某点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>W</mi></msub></mrow><annotation encoding="application/x-tex">P_W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，需要对该点进行变换转换成相机空间中适合的点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">P_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。构建一个单一变换矩阵以完成旋转和平移，这个矩阵叫作视图变换矩阵，记作 V（V合并了平移矩阵和旋转矩阵）。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub><mo>=</mo><mi>V</mi><mo>×</mo><msub><mi>P</mi><mi>W</mi></msub></mrow><annotation encoding="application/x-tex">P_C=V\times P_W
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>将 V 矩阵与模型矩阵 M 的积定义为 <strong>模型-视图(Model-View, MV)</strong> 矩阵，记作MV，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>V</mi><mo>=</mo><mi>V</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">MV=VM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>。</p>
<ul>
<li><em>模型矩阵 M 是世界空间中对象定位及定向的矩阵</em></li>
</ul>
<p>之后，对于某点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">P_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就可以从自己的模型空间直接转换到相机空间：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>C</mi></msub><mo>=</mo><mi>M</mi><mi>V</mi><msub><mi>P</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">P_C=MVP_M
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="3-7-投影矩阵">3.7 投影矩阵</h3>
<p>透视投影矩阵和正射投影矩阵</p>
<h4 id="3-7-1-透视投影矩阵">3.7.1 透视投影矩阵</h4>
<p>透视投影通过使用透视概念模仿我们看真实世界的方<br>
式，尝试让 2D 图像看起来像是 3D 的。</p>
<p>使用叫作 <strong>透视矩阵</strong> 或者 <strong>透视变换</strong> 的变换矩阵将平行线变为恰当的不平行线来实现这个效果。定义 4 个参数来构建视体：</p>
<ul>
<li>纵横比：远近剪裁平面的宽度与高度之比；</li>
<li>视场：可视空间的纵向角度；</li>
<li>近剪裁平面（也称投影平面）</li>
<li>远剪裁平面。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_View.jpg" alt="透视视体或视锥，图源计算机图形学编程（第2版）"></p>
<p>透视矩阵：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>q</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>B</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>C</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(透视矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
A &amp; 0 &amp; 0 &amp; 0\\
0 &amp; q &amp; 0 &amp; 0\\
0 &amp; 0 &amp; B &amp; C\\
0 &amp; 0 &amp;-1 &amp; 0
\end{matrix}
\right]
\tag{透视矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">透</span><span class="mord cjk_fallback">视</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>其中：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mi>tan</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mtext>视场</mtext><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">q = \frac{1}{\tan{(\frac{视场}{2})}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.428771em;vertical-align:-1.1073309999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2376690000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">tan</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">视</span><span class="mord cjk_fallback mtight">场</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1073309999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mi>q</mi><mtext>纵横比</mtext></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{q}{纵横比}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">纵</span><span class="mord cjk_fallback">横</span><span class="mord cjk_fallback">比</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mfrac><mrow><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>+</mo><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><mrow><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub><mo>−</mo><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">B = \frac{Z_{near}+Z_{far}}{Z_{nead}-Z_{far}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.332438em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><mrow><msub><mi>Z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>−</mo><msub><mi>Z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac><mrow></mrow></mrow><annotation encoding="application/x-tex">C = \frac{2Z_{near}Z_{far}}{Z_{near}-Z_{far}}{}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.332438em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"></span></span></span></span></span></p>
<p>GLM 库提供了构建透视矩阵函数 <code>glm::perspective()</code>。</p>
<h4 id="3-7-2-正射投影矩阵">3.7.2 正射投影矩阵</h4>
<p>在正射投影中，平行线仍然是平行的。</p>
<p>构建正射矩阵需要以下参数：</p>
<ol>
<li>从相机到投影平面的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{near}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>从相机到远剪裁平面的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{far}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>投影平面左边界 x 坐标 L， 投影平面右边界 x 坐标 R，投影平面上边界 y 坐标 T， 投影平面下边界 y 坐标 B</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_zhengshe.jpg" alt="正射投影，图源计算机图形学编程（第2版）"></p>
<p>正射矩阵：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>R</mi><mo>−</mo><mi>L</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>R</mi><mo>+</mo><mi>L</mi></mrow><mrow><mi>R</mi><mo>−</mo><mi>L</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>T</mi><mo>−</mo><mi>B</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>T</mi><mo>+</mo><mi>B</mi></mrow><mrow><mi>T</mi><mo>−</mo><mi>B</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>−</mo><mn>2</mn></mrow><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>+</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><mrow><msub><mi>z</mi><mrow><mi>f</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(正射矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
\frac{2}{R-L} &amp; 0 &amp; 0 &amp; -\frac{R+L}{R-L}\\
0 &amp; \frac{2}{T-B} &amp; 0 &amp; -\frac{T+B}{T-B}\\
0 &amp; 0 &amp; \frac{-2}{z_{far}-z_{near}} &amp; -\frac{z_{far}+z_{near}}{z_{far}-z_{near}}\\
0 &amp; 0 &amp;0 &amp; 1
\end{matrix}
\right]
\tag{正射矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.220815em;vertical-align:-2.3604075em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">L</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5480799999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8604075em;"><span style="top:-4.9880765em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">L</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.7124145em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3876725em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.921411em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.51308em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5480799999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.9995925000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3604075em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:5.220815em;vertical-align:-2.3604075em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">射</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<h3 id="3-8-lookat矩阵">3.8 LookAt矩阵</h3>
<p>当把相机放在某处并看向一个特定的位置时，就需要用到 LookAt 矩阵。LookAt 变换依然由相机旋转决定。</p>
<p>通过指定大致旋转朝向的向量（如世界空间 y 轴）。可以通过一系列叉积获得一组向量，代表相机的正面（向量 fwd）、侧面（向量 side），以及上面（向量 up）。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_lookat.jpg" alt="LookAt元素，图源计算机图形学编程（第2版）"></p>
<p>由相机位置（点eye）、目标位置（点target）、初始向上向量 Y 构建 LookAt 矩阵：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>i</mi><mi>d</mi><msub><mi>e</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>i</mi><mi>d</mi><msub><mi>e</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>⋅</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><msub><mi>p</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><msub><mi>p</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><msub><mi>p</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>u</mi><mi>p</mi><mo>⋅</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>f</mi><mi>w</mi><msub><mi>d</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>f</mi><mi>w</mi><msub><mi>d</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>f</mi><mi>w</mi><msub><mi>d</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mi>w</mi><mi>d</mi><mo>⋅</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(LookAt矩阵)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[
\begin{matrix}
side_x &amp; side_y &amp; size_z &amp; -(side\cdot eye)\\
up_x &amp; up_y &amp; up_z &amp; -(up\cdot eye)\\
-fwd_x &amp; -fwd_y &amp; -fwd_z &amp; -(-fwd\cdot eye)\\
0 &amp; 0 &amp;0 &amp; 1
\end{matrix}
\right]
\tag{LookAt矩阵}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">L</span><span class="mord">o</span><span class="mord">o</span><span class="mord">k</span><span class="mord">A</span><span class="mord">t</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>其中：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>w</mi><mi>d</mi><mo>=</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>e</mi><mi>y</mi><mi>e</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fwd = normalize(eye-target)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>=</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mi>w</mi><mi>d</mi><mo>×</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">side = normalize(-fwd \times Y)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mo>=</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>×</mo><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mi>w</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">up = normalize(side \times (-fwd))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="四-opengl管理3d图形数据">四、OpenGL管理3D图形数据</h2>
<p>使用 OpenGL 渲染一个 3D 图形 需要将若干数据发送给 OpenGL 着色器管线。</p>
<p>比如一个立方体，需要发送：</p>
<ul>
<li>立方体模型的顶点；</li>
<li>控制立方体在3D空间中朝向的变换矩阵。</li>
</ul>
<p>然而，发送数据到 OpenGL 管线的方式有：</p>
<ul>
<li>通过顶点属性的 <strong>缓冲区</strong>；</li>
<li>直接发送给 <strong>统一变量</strong>。</li>
</ul>
<h3 id="4-1-缓冲区和顶点属性">4.1 缓冲区和顶点属性</h3>
<p>绘制对象时，它的顶点数据需要发送给顶点着色器。通常：</p>
<ol>
<li>顶点数据被发送到一个缓冲区中；</li>
<li>把缓冲区和着色器中声明的顶点属性相关联。</li>
</ol>
<p>完成这件事，有一系列的步骤，有的步骤只需要做一次，有的步骤每帧都需做一次：</p>
<ul>
<li>只做一次的步骤：
<ol>
<li>创建缓冲区</li>
<li>将顶点数据复制到缓冲区</li>
</ol>
</li>
<li>每帧刷新需要的步骤：
<ol>
<li>启用包含顶点数据的缓冲区</li>
<li>将缓冲区和一个顶点属性相关联</li>
<li>启用这个顶点属性</li>
<li>使用 <code>glDrawArrays()</code> 绘制对象</li>
</ol>
</li>
</ul>
<p>在 OpenGL 中，缓冲区被包含在顶点缓冲对象（Vertex Buffer Object，VBO）中，VBO 在 C++/OpenGL 应用程序中被声明和实例化。一个场景可能需要很多 VBO，所以常常会在一个地方中生成并填充若干个 VBO，以备程序需要时直接使用。</p>
<p>缓冲区使用特定的方式和顶点属性交互。当 <code>glDrawArrays()</code> 执行时，缓冲区中的数据开始流动，从缓冲区的开头开始，按顺序流过顶点着色器，顶点着色器对每个顶点执行一次。</p>
<p>OpenGL 中还有一种相关的结构，叫作顶点数组对象（Vertex Array Object，VAO）。OpenGL的 3.0 版本引入了 VAO，作为一种组织缓冲区的方法，让缓冲区在复杂场景中更容易操控。OpenGL 要求至少创建一个 VAO。</p>
<p>举个例子，假设想显示两个对象，那么声明一个 VAO 和两个相关的 VBO：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint vao[<span class="number">1</span>];</span><br><span class="line">GLuint vbo[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, vao);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">2</span>, vbo);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>glGenVertexArrays()</code>：生成一个 VAO，返回 VAO 的整型 ID 并将存到vao
<ul>
<li>第一参数表示创建 ID 个数</li>
<li>第二参数表示保存返回 ID 的数组</li>
</ul>
</li>
<li><code>glBindVertexArray()</code>：将 vao[0] 设为当前对象，这样生成的缓冲区就会和这个 VAO 相关联</li>
<li><code>glGenBuffers()</code>：生成两个 VBO，返回 VBO 的整型 ID 并将它们存到vbo
<ul>
<li>第一参数表示创建 ID 个数</li>
<li>第二参数表示保存返回 ID 的数组</li>
</ul>
</li>
</ul>
<p>缓冲区大概完成之后，顶点着色器需要有相应地顶点属性变量。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>layout (location = 0)</code>：layout修饰符，顶点属性和特定缓冲区关联的方法，这里表示顶点属性的识别号是0</li>
<li><code>in</code>：表示顶点属性将会从缓冲区中接收数值</li>
<li><code>vec3</code>：表示顶点属性的类型是三维向量</li>
<li><code>position</code>：顶点属性的名字</li>
</ul>
<p>继续假设绘制一个立方体，假定立方体的顶点数据在代码中用数组直接指定，还需要进行以下步骤：</p>
<ol>
<li>将顶点数据值复制到之前生成的两个缓冲区之一。使用 OpenGL 的函数 <code>glBindBuffer()</code> 将缓冲区标为活跃（使用）</li>
<li>使用 <code>glBufferData()</code> 函数将包含顶点数据的数组复制进活跃缓冲区</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>上述是初始化时执行一次的步骤，接下来对于每一帧刷新，需要进行：</p>
<ol>
<li>使用 <code>glBindBuffer()</code> 函数标记缓冲区为活跃</li>
<li>将活跃缓冲区与着色器中的顶点属性相关联</li>
<li>启用顶点属性</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标记第0个缓冲区为活跃</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 将第0个属性关联到缓冲区</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 启用第0个顶点属性</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-统一变量">4.2 统一变量</h3>
<p>使用关键字 <code>uniform</code> 在着色器中声明统一变量。</p>
<p>将数据从 C++/OpenGL 应用程序发送到统一变量需要以下步骤：</p>
<ol>
<li>获取统一变量的引用</li>
<li>将指向所需数值的指针与获取的统一变量引用相关联</li>
</ol>
<p>比如在上面绘制立方体的例子，假设链接的渲染程序保存在名为 <code>rendering</code> 的变量中，则以下代码会把 MV 和投影矩阵发送到两个统一变量中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取着色器程序中的统一变量位置</span></span><br><span class="line">mvLoc = <span class="built_in">glGetUniformLocation</span>(rendering, <span class="string">&quot;mv_m&quot;</span>);</span><br><span class="line">projLoc = <span class="built_in">glGetUniformLocation</span>(rendering, <span class="string">&quot;proj_m&quot;</span>);</span><br><span class="line"><span class="comment">// 将矩阵数据发送到统一变量中</span></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mv));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(proj));</span><br><span class="line"><span class="comment">// mv 是模型视图矩阵，proj 是投影矩阵</span></span><br></pre></td></tr></table></figure>
<p><em><code>value_ptr()</code> 返回对矩阵数据的引用， <code>glUniformMatrix4fv()</code> 将矩阵数据传递给统一变量</em></p>
<h3 id="4-3-顶点属性插值">4.3 顶点属性插值</h3>
<p>在片段着色器栅格化之前，由顶点定义的图元被转换为片段。</p>
<ul>
<li>栅格化：将 3D 空间信息表达在 2D 屏幕的栅格（像素阵列）中。</li>
<li>栅格化过程会线性插值顶点属性值，以便显示的像素能无缝连接建模后的曲面。</li>
<li>比如栅格化一个三角形时，将三角形顶点传入，首先沿着连接顶点的线开始插值，其精度级别和像素显示密度相关。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_rasterized.png" alt="三角形栅格化"></p>
<p>而统一变量在每次顶点着色器调用时保持不变，本身不是插值的，无论顶点数量有多少，变量都包含相同的值。</p>
<p>顶点着色器中，顶点属性被声明为 <code>in</code>，表示从缓冲区接收，也可以被声明为 <code>out</code>，表示值发送到管线的下一阶段。</p>
<p>OpenGL 内置一个 <code>vec4</code> 变量 <code>gl_Position</code>，在顶点着色器中，将矩阵变换后的顶点赋值给它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gl_Position = proj_matrix * mv_matrix * position;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-mv-矩阵和透视矩阵">4.4 MV 矩阵和透视矩阵</h3>
<p>渲染 3D 对象的一个基础步骤是创建适当的变换矩阵并将它们发送到统一变量。</p>
<ul>
<li>模型矩阵：在世界空间中表示对象的位置和朝向。</li>
<li>视图矩阵：移动并旋转世界中的模型，以模拟相机看到的效果。</li>
<li>透视矩阵：根据所需的视锥提供 3D 效果。</li>
</ul>
<p>假设模型是变动的，相机是可移动的，那么：</p>
<ul>
<li>需要每帧为每个模型创建模型矩阵；</li>
<li>需要每帧创建视图矩阵，对于这一帧所渲染的所有对象都是一致的；</li>
<li>需要创建一次透视矩阵，确定视锥。</li>
</ul>
<h3 id="4-5-构建一个-3d-立方体">4.5 构建一个 3D 立方体</h3>
<p>由于 OpenGL 代码繁多，需要处理多文件，给出文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenGL项目</span><br><span class="line">├─ main.cpp        // 主程序</span><br><span class="line">├─ fragment.glsl   // 片段着色器</span><br><span class="line">├─ vertex.glsl     // 顶点着色器</span><br><span class="line">├─ Util.h          // 常用函数的声明</span><br><span class="line">└─ Util.cpp        // 常用函数的实现</span><br></pre></td></tr></table></figure>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_greenCube.jpg" alt="绿色的立方体"></p>
<details><summary>源代码main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">1</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line"><span class="type">double</span> cubeLocX, cubeLocY, cubeLocZ;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> vertexs[<span class="number">108</span>] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]); <span class="comment">// 生成的缓冲区和 VAO 相关联</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]); <span class="comment">// 将缓冲区标为活跃（使用）</span></span><br><span class="line">    <span class="comment">// 将包含顶点数据的数组复制进活跃缓冲区</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertexs), vertexs, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">8.0f</span>;</span><br><span class="line">    cubeLocX = <span class="number">0.0f</span>, cubeLocY = <span class="number">-2.0f</span>, cubeLocZ = <span class="number">0.0f</span>;    <span class="comment">// 沿 y 轴下移展示透视</span></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MV 矩阵 和投影矩阵的统一变量</span></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建透视矩阵</span></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="comment">// 参数为：视角，宽高比，近裁剪面，远裁剪面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建视图矩阵、模型矩阵和 MV 矩阵</span></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(cubeLocX, cubeLocY, cubeLocZ));</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将矩阵复制给相应的统一变量</span></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 VBO 关联给顶点着色器中相应的顶点属性</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 OpenGL 设置，绘制模型</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Cube&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释 <code>main.cpp</code>：</p>
<ul>
<li>函数 <code>makeVertexArray()</code>
<ul>
<li>创建顶点数组，使用三角形绘制立方体，每个面需要两个三角形，共需要12个三角形，有36个顶点，合36×3=108个坐标（值）。</li>
<li>立方体定义在自己的坐标系上，中心为(0,0,0)。</li>
<li>建立一个 VAO 和 VBO，并把立方体顶点加载到VBO中。</li>
</ul>
</li>
<li>函数 <code>init()</code>
<ul>
<li>读取着色器代码并构建渲染程序。</li>
<li>将立方体通过函数 <code>makeVertexArray()</code> 加载到 VBO 中。</li>
<li>定义立方体和相机在世界中的位置：(0,0,8)和(0,-2,0)。</li>
</ul>
</li>
<li>函数 <code>display()</code>
<ul>
<li>不断重绘帧。</li>
<li>调用 <code>glClear(GL_DEPTH_BUFFER_BIT)</code> 清除深度缓冲区。</li>
<li>调用 <code>glUseProgram()</code> 启用着色器，在 GPU 上加载 GLSL 代码，但不会运行着色器程序。</li>
<li>获取统一变量位置，构建透视、视图矩阵和模型矩阵，并合成 MV 矩阵。
<ul>
<li>使用 <code>glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));</code> 构建视图矩阵。为了模拟以某种方式移动的相机的表现，需要向相反的方向移动物体本身。</li>
<li>使用 <code>glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ));</code> 构建模型矩阵。</li>
</ul>
</li>
<li>将透视矩阵和 MV 矩阵赋给相应的统一变量。</li>
<li>启用立方体顶点数据的缓冲区，并将其附加到第0个顶点属性。</li>
<li>调用 <code>glDrawArrays()</code> 绘制模型。</li>
</ul>
</li>
</ul>
</details>
<details><summary>Util.h</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Util.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SOIL2/soil2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">readShaderSource</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printShaderLog</span><span class="params">(GLuint shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printProgramLog</span><span class="params">(GLuint program)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">checkOpenGLerror</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> GLuint <span class="title">createShadeProgram</span><span class="params">(<span class="type">const</span> std::string vpath, <span class="type">const</span> std::string fpath)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>Util.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Util.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从文件中读取 GLSL 代码</span></span><br><span class="line"><span class="comment">* @param path 文件路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">std::string <span class="title">Util::readShaderSource</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fileStream</span><span class="params">(path, std::ios::in)</span></span>;</span><br><span class="line">    std::string line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fileStream.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(fileStream, line);</span><br><span class="line">        content.<span class="built_in">append</span>(line + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileStream.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param shader 着色器标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Util::printShaderLog</span><span class="params">(GLuint shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(shader, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(shader, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shader Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 链接失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param program 着色器程序标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Util::printProgramLog</span><span class="params">(GLuint program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(program, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(program, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Program Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Util::checkOpenGLerror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> err = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    <span class="keyword">while</span> (glErr != GL_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;glError: &quot;</span> &lt;&lt; glErr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        err = <span class="literal">true</span>;</span><br><span class="line">        glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建着色器程序</span></span><br><span class="line"><span class="comment">* @param vpath 顶点着色器路径</span></span><br><span class="line"><span class="comment">* @param fpath 片段着色器路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">GLuint <span class="title">Util::createShadeProgram</span><span class="params">(<span class="type">const</span> std::string vpath, <span class="type">const</span> std::string fpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    GLint vertCompiled, fragCompiled, linked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    std::string vs = <span class="built_in">readShaderSource</span>(vpath);</span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    std::string fs = <span class="built_in">readShaderSource</span>(fpath);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *vshaderSource = vs.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fshaderSource = fs.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别存入 vShader 和 fShader 变量</span></span><br><span class="line">    GLuint vShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    GLuint fShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GLSL 代码从字符串载入空着色器对象中</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vShader, <span class="number">1</span>, &amp;vshaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fShader, <span class="number">1</span>, &amp;fshaderSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);</span><br><span class="line">    <span class="keyword">if</span> (vertCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vertex compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(vShader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(fShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);</span><br><span class="line">    <span class="keyword">if</span> (fragCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fragment compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(fShader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLuint vProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, vShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, fShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(vProgram);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(vProgram, GL_LINK_STATUS, &amp;linked);</span><br><span class="line">    <span class="keyword">if</span> (linked == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;linking failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printProgramLog</span>(vProgram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vProgram; <span class="comment">// 返回着色器程序ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>vertex.glsl 和 fragment.glsl</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0.6</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于着色器方面</p>
<ul>
<li>着色器中传入的顶点属性的 <code>position</code> 变量上存在。<code>layout</code> 修饰符，位置指定为“0”，因此 <code>display()</code> 函数可以简单地通过在 <code>glVertexAttribPointer()</code> 函数调用中（第一个参数）和在 <code>glEnableVertexAttribArray()</code> 函数调用中使用 0 来引用此变量。</li>
<li><code>position</code> 顶点属性被声明为 <code>vec3</code> 类型，需要将其转换为 <code>vec4</code> 类型，由 <code>vec4(position,1.0)</code> 完成。</li>
<li>顶点着色器中的乘法将矩阵变换应用于顶点，将其转换为相机空间，接着被放入内置的 OpenGL 输出变量 <code>gl_Position</code> 中，然后继续通过管线，并由光栅着色器进行插值。</li>
<li>插值后的像素位置（称为片段）被发送到片段着色器。
<ul>
<li>片段着色器中也有两个统一变量，但在该着色器中尚未使用。</li>
</ul>
</li>
</ul>
</details>
<details><summary>通过修改着色器，实现彩色立方体</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line">out vec4 changingColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    changingColor = <span class="built_in">vec4</span>(position, <span class="number">1.0</span>) * <span class="number">0.5</span> + <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">in vec4 changingColor;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = changingColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_coloredCube.jpg" alt="彩色立方体"></p>
<p>同样地，也可以让立方体动起来，只需要在刷新的每一帧加上平移变换和旋转变换：</p>
<details><summary>展开代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MV 矩阵 和投影矩阵的统一变量</span></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建透视矩阵</span></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="comment">// 参数为：视角，宽高比，近裁剪面，远裁剪面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一系列旋转变换矩阵</span></span><br><span class="line">    glm::mat tMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(<span class="number">0.35f</span> * currentTime) * <span class="number">2.0f</span>, <span class="built_in">cos</span>(<span class="number">0.52f</span> * currentTime) * <span class="number">2.0f</span>, <span class="built_in">sin</span>(<span class="number">0.7f</span> * currentTime) * <span class="number">2.0f</span>));</span><br><span class="line">    glm::mat rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="number">1.75f</span> * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    rMat = glm::<span class="built_in">rotate</span>(rMat, <span class="number">1.75f</span> * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    rMat = glm::<span class="built_in">rotate</span>(rMat, <span class="number">1.75f</span> * <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建视图矩阵、模型矩阵和 MV 矩阵</span></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    <span class="comment">//mMat = glm::translate(glm::mat4(1.0f), glm::vec3(cubeLocX, cubeLocY, cubeLocZ));</span></span><br><span class="line">    mMat = rMat * tMat;</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将矩阵复制给相应的统一变量</span></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 VBO 关联给顶点着色器中相应的顶点属性</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 OpenGL 设置，绘制模型</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure>
</details>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_coloredCube1.gif" alt="旋转的立方体"></p>
<h3 id="4-6-渲染一个对象的多个副本">4.6 渲染一个对象的多个副本</h3>
<p>上面实现了一个翻滚的立方体，接着可以考虑实现多个翻滚的立方体。</p>
<p>可以将 <code>display()</code> 函数中用于构建 MV 矩阵并绘制立方体的代码移动到一个执行 24 次的循环中来完成此操作。</p>
<details><summary>展开代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">32.0f</span>;</span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MV 矩阵 和投影矩阵的统一变量</span></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视图矩阵</span></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建透视矩阵</span></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="comment">// 参数为：视角，宽高比，近裁剪面，远裁剪面</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> tf;</span><br><span class="line">    glm::mat4 tMat, rMat;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        tf = currentTime + i;</span><br><span class="line">        tMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(<span class="number">0.35f</span> * tf) * <span class="number">8.0f</span>, <span class="built_in">cos</span>(<span class="number">0.52f</span> * tf) * <span class="number">8.0f</span>, <span class="built_in">sin</span>(<span class="number">0.7f</span> * tf) * <span class="number">8.0f</span>));</span><br><span class="line">        rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="number">1.75f</span> * tf, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        rMat = glm::<span class="built_in">rotate</span>(rMat, <span class="number">1.75f</span> * tf, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        rMat = glm::<span class="built_in">rotate</span>(rMat, <span class="number">1.75f</span> * tf, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        <span class="comment">// 构建模型矩阵和 MV 矩阵</span></span><br><span class="line">        mMat = rMat * tMat;</span><br><span class="line">        mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将矩阵复制给相应的统一变量</span></span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 VBO 关联给顶点着色器中相应的顶点属性</span></span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整 OpenGL 设置，绘制模型</span></span><br><span class="line">        <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">        <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_mcoloredCube.gif" alt="效果展示"></p>
<p>OpenGL 的实例化提供了一种机制，可以只用一个调用就渲染一个对象的多个副本。</p>
<ul>
<li>带来显著的性能优势</li>
</ul>
<p>把原来调用的 <code>glDrawArrays()</code> 改为 <code>glDrawArraysInstanced()</code>。</p>
<p>同时实例化时，顶点着色器可以访问内置变量 <code>gl_InstanceID</code> 来获取当前正在处理对象的实例序号。</p>
<p>实例化的程序：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">1</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line"><span class="type">float</span> aspect, timeFactor;</span><br><span class="line"></span><br><span class="line">GLuint mLoc, vLoc, projLoc, tfLoc;</span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line">glm::mat4 pMat, vMat, mMat;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> vertexs[<span class="number">108</span>] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]); <span class="comment">// 生成的缓冲区和 VAO 相关联</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]); <span class="comment">// 将缓冲区标为活跃（使用）</span></span><br><span class="line">    <span class="comment">// 将包含顶点数据的数组复制进活跃缓冲区</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertexs), vertexs, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">32.0f</span>;</span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取视图矩阵和投影矩阵的统一变量</span></span><br><span class="line">    vLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;v_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(vLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(vMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时间因子的统一变量</span></span><br><span class="line">    timeFactor = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime);</span><br><span class="line">    tfLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;tf&quot;</span>);</span><br><span class="line">    <span class="built_in">glUniform1f</span>(tfLoc, timeFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 VBO 关联给顶点着色器中相应的顶点属性</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    <span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>, <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Cube&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从之前的循环多个模型矩阵展示 改为了 在顶点着色器中构建模型矩阵。</p>
<ul>
<li>将时间因子通过统一变量传递给顶点着色器，还需要将视图矩阵传递到单独的统一变量中</li>
<li>旋转计算被移动到了顶点着色器中</li>
</ul>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 v_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line">uniform <span class="type">float</span> tf;</span><br><span class="line"></span><br><span class="line">out vec4 changingColor;</span><br><span class="line"></span><br><span class="line"><span class="function">mat4 <span class="title">buildRotateX</span><span class="params">(<span class="type">float</span> rad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat4 xrot = <span class="built_in">mat4</span>(</span><br><span class="line">        <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="built_in">cos</span>(rad), -<span class="built_in">sin</span>(rad), <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="built_in">sin</span>(rad), <span class="built_in">cos</span>(rad), <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> xrot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat4 <span class="title">buildRotateY</span><span class="params">(<span class="type">float</span> rad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat4 yrot = <span class="built_in">mat4</span>(</span><br><span class="line">        <span class="built_in">cos</span>(rad), <span class="number">0.0</span>, <span class="built_in">sin</span>(rad), <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        -<span class="built_in">sin</span>(rad), <span class="number">0.0</span>, <span class="built_in">cos</span>(rad), <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> yrot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat4 <span class="title">buildRotateZ</span><span class="params">(<span class="type">float</span> rad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat4 zrot = <span class="built_in">mat4</span>(</span><br><span class="line">        <span class="built_in">cos</span>(rad), -<span class="built_in">sin</span>(rad), <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="built_in">sin</span>(rad), <span class="built_in">cos</span>(rad), <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> zrot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat4 <span class="title">buildTranslate</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat4 trans = <span class="built_in">mat4</span>(</span><br><span class="line">        <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        x, y, z, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> trans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> i = gl_InstanceID + tf;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> a = <span class="built_in">sin</span>(<span class="number">0.35</span> * i) * <span class="number">8.0</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="built_in">cos</span>(<span class="number">0.52</span> * i) * <span class="number">8.0</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">sin</span>(<span class="number">0.70</span> * i) * <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line">    mat4 localRotx = <span class="built_in">buildRotateX</span>(<span class="number">1.75</span> * i);</span><br><span class="line">    mat4 localRoty = <span class="built_in">buildRotateY</span>(<span class="number">1.75</span> * i);</span><br><span class="line">    mat4 localRotz = <span class="built_in">buildRotateZ</span>(<span class="number">1.75</span> * i);</span><br><span class="line">    mat4 localTrans = <span class="built_in">buildTranslate</span>(a, b, c);</span><br><span class="line"></span><br><span class="line">    mat4 newM_matrix = localTrans * localRotx * localRoty * localRotz;</span><br><span class="line">    mat4 mv_matrix = v_matrix * newM_matrix;</span><br><span class="line"></span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    changingColor = <span class="built_in">vec4</span>(position, <span class="number">1.0</span>) * <span class="number">0.5</span> + <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于着色器内部无法调用 GLM 的函数，故需要编写矩阵变换的相关函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">in vec4 changingColor;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = changingColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器无需做改变。</p>
</details>
<p>如果渲染的立方体很多时，实例化极大的方便了程序的编写，只需要修改视野相关的常量：</p>
<p>比如想渲染 100000 个彩色立方体，只需修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="comment">// 实例化个数</span></span><br><span class="line"><span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="comment">// 镜头位置，镜头拉远</span></span><br><span class="line">cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">402.0f</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="comment">// 位移变大</span></span><br><span class="line"><span class="type">float</span> a = <span class="built_in">sin</span>(<span class="number">203.0</span> * i / <span class="number">8000.0</span>) * <span class="number">403.0</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="built_in">cos</span>(<span class="number">301.0</span> * i / <span class="number">4001.0</span>) * <span class="number">401.0</span>;</span><br><span class="line"><span class="type">float</span> c = <span class="built_in">sin</span>(<span class="number">400.0</span> * i / <span class="number">6003.0</span>) * <span class="number">405.0</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_100kcubes.jpg" alt="效果截图(静态图)"></p>
<h3 id="4-7-同一场景渲染多个对象">4.7 同一场景渲染多个对象</h3>
<p>要在单个场景中渲染多个模型，简单的做法：</p>
<ol>
<li>为每个模型使用单独的缓冲区；</li>
<li>每个模型都需要自己的模型矩阵，为渲染的每个模型生成一个新的 MV 矩阵；</li>
<li>为每个模型单独调用 <code>glDrawArrays()</code>。</li>
</ol>
<p>假如在场景中渲染立方体和四棱锥，且不考虑复杂的情况，复用着色器，效果如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_2objects.gif" alt="渲染立方体和四棱锥"></p>
<p>代码如下（自主研究，不过多解释）：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">2</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line"><span class="type">float</span> cubeLocx, cubeLocy, cubeLocz;</span><br><span class="line"><span class="type">float</span> pyramidLocx, pyramidLocy, pyramidLocz;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> vertexs[<span class="number">108</span>] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pyramids[<span class="number">54</span>] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]); <span class="comment">// 生成的缓冲区和 VAO 相关联</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="comment">// 立方体与缓冲区0绑定</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertexs), vertexs, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 四棱锥与缓冲区1绑定</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(pyramids), pyramids, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">8.0f</span>;</span><br><span class="line">    cubeLocx = <span class="number">0.0f</span>, cubeLocy = <span class="number">-2.0f</span>, cubeLocz = <span class="number">0.0f</span>;</span><br><span class="line">    pyramidLocx = <span class="number">0.0f</span>, pyramidLocy = <span class="number">1.0f</span>, pyramidLocz = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取视图矩阵和投影矩阵的统一变量</span></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘画立方体</span></span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(cubeLocx, cubeLocy, cubeLocz));</span><br><span class="line">    mMat *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">0.25f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘画四棱锥</span></span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(pyramidLocx, pyramidLocy, pyramidLocz));</span><br><span class="line">    mMat *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">0.25f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Cube&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line">out vec4 changingColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    changingColor = <span class="built_in">vec4</span>(position, <span class="number">1.0</span>) * <span class="number">0.5</span> + <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 片段着色器</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">in vec4 changingColor;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = changingColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="4-8-矩阵栈">4.8 矩阵栈</h3>
<p>前面渲染的模型都是由一组顶点构成，而实际上希望通过组装许多简单地模型来构建复杂的模型。以这种方式构建的对象称为分层模型。</p>
<ul>
<li>构建分层模型的棘手部分是跟踪所有 MV 矩阵并保证矩阵完美协调。</li>
</ul>
<p>矩阵栈：变换矩阵的栈。</p>
<ul>
<li>使得创建和管理复杂分层对象和场景变得容易</li>
<li>使得变换可以构建在其他变换之上</li>
<li>通过 STL 的 <code>stack</code> 类构建 <code>mat4</code> 的栈。</li>
</ul>
<p>对于 <code>std::stack&lt;glm::mat4&gt;</code> 的实例 <code>s</code>：</p>
<ul>
<li><code>s.push(mat4)</code>：将栈顶的矩阵复制一份，并作变换后把新的矩阵压入栈。</li>
<li><code>s.pop()</code>：弹出栈顶的矩阵。</li>
<li><code>s.top()</code>：返回栈顶的矩阵的引用。</li>
<li><code>s.top() *= rotate(args)</code>：直接对栈顶矩阵作旋转变换。</li>
<li><code>s.top() *= translate(args)</code>：直接对栈顶矩阵作平移变换。</li>
<li><code>s.top() *= scale(args)</code>：直接对栈顶矩阵作缩放变换。</li>
</ul>
<p>在此之后，不再通过创建 <code>mat4</code> 的实例来构建变换，而是使用 <code>push()</code> 命令在栈顶部创建新的矩阵，然后根据需要将期望的变换应用于栈顶部的新创建的矩阵。</p>
<ul>
<li>压入栈的第一个矩阵通常是视图矩阵。它上面的矩阵是复杂程度越来越高的 MV 矩阵，也就是说，它们应用了越来越多的模型变换。这些变换既可以直接应用，也可以先结合其他矩阵再应用。</li>
</ul>
<p>假设一个例子，实现一个地球围绕太阳旋转和月球围绕地球旋转的场景：</p>
<ol>
<li>首先压入视图矩阵 V；</li>
<li>压入太阳的 MV 矩阵；</li>
<li>压入地球的 MV 矩阵，由太阳的 MV 矩阵的副本和应用于其之上的地球模型矩阵变换组成；</li>
<li>压入月球的 MV 矩阵，由地球的 MV 矩阵的副本和应用于其之上的月球模型矩阵变换组成。</li>
</ol>
<p>接着，渲染月球并把月球矩阵弹出，后面的地球和太阳只需要重复即可。步骤如下：</p>
<ol>
<li>声明矩阵栈；</li>
<li>当相对于父对象创建新对象时，调用 <code>s.push(s.top())</code>；</li>
<li>应用新对象所需的变换；</li>
<li>完成对象或子对象的绘制后，弹出栈顶，移除对应的 MV 矩阵。</li>
</ol>
<p>在这个例子中，需要注意：</p>
<ul>
<li>太阳的自转在它自己的局部坐标空间中进行，不应影响地球和月球。因此，太阳的旋转变换矩阵被推到栈上，但是在绘制太阳之后，它必须被从栈中弹出。</li>
<li>地球的公转将影响月球的运动，因此地球的平移变换矩阵被压入栈并保持到绘制月球。</li>
<li>地球的自转是局部的，不会影响月球，因此在绘制月球之前地球的旋转变换矩阵需要从栈中弹出。</li>
</ul>
<p>效果如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_sunearthmoon.gif" alt="太阳-地球-月球场景"></p>
<p>顶点着色器与片段着色器无需改变，同上面渲染两个目标的程序。</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">2</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line">std::stack&lt;glm::mat4&gt; matrixStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> vertexs[<span class="number">108</span>] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]); <span class="comment">// 生成的缓冲区和 VAO 相关联</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertexs), vertexs, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">4.0f</span>, cameraZ = <span class="number">20.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    matrixStack.<span class="built_in">push</span>(vMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制太阳</span></span><br><span class="line">    matrixStack.<span class="built_in">push</span>(matrixStack.<span class="built_in">top</span>());</span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)); <span class="comment">// 太阳位置</span></span><br><span class="line">    matrixStack.<span class="built_in">push</span>(matrixStack.<span class="built_in">top</span>());</span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)); <span class="comment">// 太阳自转</span></span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(matrixStack.<span class="built_in">top</span>()));</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    matrixStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制地球</span></span><br><span class="line">    matrixStack.<span class="built_in">push</span>(matrixStack.<span class="built_in">top</span>());</span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime)) * <span class="number">8.0</span>, <span class="number">0.0</span>, <span class="built_in">cos</span>(<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime)) * <span class="number">8.0</span>)); <span class="comment">// 平移矩阵变换</span></span><br><span class="line">    matrixStack.<span class="built_in">push</span>(matrixStack.<span class="built_in">top</span>());</span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime) * <span class="number">2.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">2.0f</span>, <span class="number">0.0f</span>)); <span class="comment">// 旋转矩阵变换</span></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(matrixStack.<span class="built_in">top</span>()));</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    matrixStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制月球</span></span><br><span class="line">    matrixStack.<span class="built_in">push</span>(matrixStack.<span class="built_in">top</span>());</span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="built_in">sin</span>(<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime)) * <span class="number">2.0</span>, <span class="built_in">cos</span>(<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime)) * <span class="number">2.0</span>)); <span class="comment">// 平移矩阵变换</span></span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(currentTime), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)); <span class="comment">// 旋转矩阵变换</span></span><br><span class="line">    matrixStack.<span class="built_in">top</span>() *= glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.25f</span>, <span class="number">0.25f</span>, <span class="number">0.25f</span>));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(matrixStack.<span class="built_in">top</span>()));</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    matrixStack.<span class="built_in">pop</span>(); matrixStack.<span class="built_in">pop</span>(); matrixStack.<span class="built_in">pop</span>();</span><br><span class="line">    matrixStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;sun-earth-moon&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意的点：</p>
<ul>
<li>加入缩放矩阵调节各个模型的大小</li>
<li>使用三角函数实现自转和公转</li>
<li>在 <code>glUniformMatrix4fv()</code> 命令中调用的  <code>glm::value_ptr(mvStack.top())</code> 函数，获取栈顶部矩阵中的值</li>
</ul>
</details>
<h3 id="4-9-应对-z冲突-伪影">4.9 应对“Z冲突”伪影</h3>
<p>在渲染多个对象时，OpenGL 使用 Z-buffer 算法来进行隐藏面消除。通常情况下，通过选择最接近相机的相应片段的颜色作为像素的颜色，这种方法可决定哪些物体的曲面可见并呈现到屏幕，而位于其他物体后面的曲面不应该被渲染。</p>
<p><em>Z-buffer 算法思想：先将 Z 缓冲器中各单元的初始置设置为最小值。当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值（保存在该像素所对应的Z 缓冲器的单元中）。如果大于原来的 Z 值，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色。</em></p>
<p>然而，有时候场景中的两个物体表面重叠并位于重合的平面中，这使得深度缓冲区算法难以确定应该渲染两个表面中的哪一个。</p>
<p>发生这种情况时，浮点舍入误差可能会导致渲染表面的某些部分使用其中一个对象的颜色，而其他部分则使用另一个对象的颜色。这种不自然的伪影称为 Z 冲突（Z-fighting）或深度冲突（depth-fighting）。</p>
<ul>
<li>是渲染的片段在深度缓冲区中相互对应的像素条目上“斗争”的结果。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_zfighting.jpg" alt="Z冲突例子，图源计算机图形学编程（第2版）"></p>
<p>部分应对方法：</p>
<ul>
<li>可以选择适当的近、远剪裁平面值来最小化两个平面之间的距离，同时仍然确保场景必需的所有对象都位于视锥内</li>
<li>建议避免选择太靠近相机的近剪裁平面</li>
</ul>
<h3 id="4-10-其他图元">4.10 其他图元</h3>
<p>目前一直使用三角形进行绘制，其实 OpenGL 还有其他选择。</p>
<h4 id="4-10-1-三角形图元">4.10.1 三角形图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_TRIANGLES</code></td>
<td style="text-align:center">管线中传递的每3个顶点数据组成一个三角形</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gltriangle.jpg"></img></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLE_STRIP</code></td>
<td style="text-align:center">管线中传递的每个顶点和之前的两个顶点组成一个三角形</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gltrianglestrip.png"></img></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLE_FAN</code></td>
<td style="text-align:center">管线中传递的每对顶点和最开始的顶点组成一个三角形</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gltrianglefan.png"></img></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLES_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，允许着色器访问当前三角形的顶点，以及额外的相邻顶点</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_TRIANGLE_STRIP_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，类似于 <code>GL_TRIANGLES_ADJACENCY</code>，但三角形顶点像在 <code>GL_TRIANGLE_STRIP</code> 中一样重叠</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="4-10-2-线图元">4.10.2 线图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_LINES</code></td>
<td style="text-align:center">管线中传递的每两个顶点组成一条线</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_glline.png"></img></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_STRIP</code></td>
<td style="text-align:center">管线中每个顶点和前一个顶点组成一条线</td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_gllinestrip.png"></img></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_LOOP</code></td>
<td style="text-align:center">类似于 <code>GL_LINE_STRIP</code>，但最后的顶点和第一个顶点之间会形成一条线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，允许着色器访问当前线的顶点，以及额外的相邻顶点</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>GL_LINE_STRIP_ADJACENCY</code></td>
<td style="text-align:center">仅用于几何着色器，类似于 <code>GL_LINE_ADJACENCY</code>，但线顶点像在 <code>GL_LINE_STRIP</code> 中一样重叠</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="4-10-3-点图元">4.10.3 点图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_POINTS</code></td>
<td style="text-align:center">管线中传递的每个顶点组成一个点</td>
</tr>
</tbody>
</table>
<h4 id="补丁图元">补丁图元</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GL_PATCHES</code></td>
<td style="text-align:center">仅用于细分着色器，指示一组顶点从顶点着色器传递到细分控制着色器，在这里它们通常用于将曲面细分网格塑造成曲面</td>
</tr>
</tbody>
</table>
<h3 id="4-11-性能优先编程">4.11 性能优先编程</h3>
<p>随着 3D 场景逐渐复杂，性能方面不得不关心。</p>
<ol>
<li>尽量减少动态内存空间分配
<ul>
<li>关键部分 <code>display()</code> 函数会被重复调用
<ul>
<li>避免重复实例化对象</li>
<li>避免重复声明变量</li>
</ul>
</li>
<li>C++ 栈类，每次入栈可能会导致动态内存分配</li>
<li>将数据从一种类型转换为另一种类型的函数调用在某些情况下可能会实例化并返回新转换的数据</li>
<li>GLM 库函数优化有限，可能引起动态内存分配</li>
</ul>
</li>
<li>预先计算透视矩阵
<ul>
<li>将透视矩阵的计算移动到 <code>init()</code> 函数中</li>
<li>一般情况下不需要重新计算透视矩阵，但窗口大小变化时需要重新计算，可以将计算透视矩阵添加到回调函数中。</li>
</ul>
</li>
<li>背面剔除
<ul>
<li>利用 OpenGL 的背面剔除能力：当 3D 模型完全闭合时，其内部永远不可见时，那么这些部分不需要被栅格化或渲染。</li>
<li>默认背面剔除时关闭的</li>
<li>使用函数 <code>glEnable(GL_CULL_FACE)</code> 开启</li>
<li>启用背面剔除时，默认情况下，三角形只有朝前时才会被渲染。此外，默认情况下，从 OpenGL相机的角度看，如果三角形的 3 个顶点是以逆时针顺序排列的（基于它们在缓冲区中定义的顺序），则三角形被视为朝前；顶点沿顺时针方向排列的三角形是朝后的，不会被渲染
<ul>
<li><strong>定义“前向”的顶点顺序有时被称为缠绕顺序</strong></li>
<li>使用 <code>glFrontFace(GL_CW)</code> 设置顺时针为正向，使用 <code>glFrontFace(GL_CCW)</code> 设置逆时针为正向</li>
<li>默认下，<code>glCullFace(GL_BACK)</code> 设置背向的三角形被剔除，但参数还有 <code>GL_FRONT</code> 和 <code>GL_FRONT_AND_BACK</code>，分别设置前向或全部三角形被剔除</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="五-纹理贴图">五、纹理贴图</h2>
<p>纹理贴图是在栅格化的模型表面上覆盖图像的技术。</p>
<p>纹理图像可以是任何图像。</p>
<h3 id="5-1-加载纹理图像文件">5.1 加载纹理图像文件</h3>
<p>OpenGL/GLSL 中完成纹理贴图需要协调不同的数据集和机制：</p>
<ul>
<li>保存纹理图像的纹理对象</li>
<li>特殊的统一采样器变量，用于顶点着色器访问纹理</li>
<li>保存纹理坐标的缓冲区</li>
<li>将纹理坐标传递给管线的顶点属性</li>
<li>显卡上的纹理单元</li>
</ul>
<p>此处将用 SOIL2 库进行加载图像文件用于贴图：</p>
<ol>
<li>使用 SOIL2 实例化 OpenGL 纹理对象并从图像文件中读入数据；</li>
<li>调用 <code>glBindTexture()</code> 使得新创建的纹理对象处于激活状态；</li>
<li>使用 <code>glTexParameteri()</code> 调整纹理设置；</li>
</ol>
<ul>
<li>最终得到的结果是可用的 OpenGL 纹理对象的整型 ID。</li>
</ul>
<p>加载纹理的代码（加入在 Util 类中）如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">Util::loadTexture</span><span class="params">(<span class="type">const</span> std::string &amp;imgPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLuint textureID;</span><br><span class="line">    textureID = <span class="built_in">SOIL_load_OGL_texture</span>(imgPath.<span class="built_in">c_str</span>(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);</span><br><span class="line">    <span class="keyword">if</span> (textureID == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture: &quot;</span> &lt;&lt; imgPath &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码先声明了一个 <code>GLuint</code> 类型的变量用于记录 OpenGL 纹理对象的 ID，接着调用 <code>SOIL_load_OGL_texture()</code> 函数生成纹理对象。</p>
<ul>
<li>函数参数及返回值
<ul>
<li>第一个参数为文件名；</li>
<li>第二个说明符，<code>SOIL_LOAD_AUTO</code> 表示使用磁盘载入的；</li>
<li>第三个表示让SOIL为我们创建一个ID；</li>
<li>第四个参数 <code>SOIL_FLAG_INVERT_Y</code> 允许做是翻转Y轴</li>
<li>返回值，0表示失败，其他表示 OpenGL 上下文句柄</li>
</ul>
</li>
</ul>
<h3 id="5-2-纹理坐标">5.2 纹理坐标</h3>
<p>通过为模型中的每个顶点指定纹理坐标来完成纹理贴图。</p>
<p>纹理坐标是对纹理图像（2D 图像文件）中像素的引用，用于将 3D 模型上的点映射到纹理中的位置。</p>
<ul>
<li>模型除了 3D 空间中的定位坐标 (x, y, z) 外，表面上每个点还具有纹理坐标 (s, t)，用来指定纹理图像中哪个像素为它提供颜色。</li>
</ul>
<p><strong>必须为要添加纹理的对象中每个顶点提供纹理坐标。</strong></p>
<p>设置两个缓冲区，一个用于顶点坐标，另一个用于纹理坐标。每次调用顶点着色器会接收到两组坐标。</p>
<p>2D 纹理图像被设定为矩形，左下角坐标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，右上角坐标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，故纹理坐标取值区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</p>
<p>由于之前渲染的立方体模型都是由三角形构成，每个面需要两个三角形。</p>
<p><em>对于立方体或四棱锥这样的简单模型，选择纹理坐标相对容易。但对于具有大量三角形的更复杂的弯曲模型，手动确定它们是不切实际的。在弯曲的几何形状（例如球形或环面）的情况下，可以通过算法或数学方式计算纹理坐标。使用 Maya 或 Blender 等建模工具构建模型时，可以使用“UV 映射”功能，使得确定纹理坐标的任务更容易完成</em></p>
<h3 id="5-3-构建一个带纹理的四棱锥">5.3 构建一个带纹理的四棱锥</h3>
<ol>
<li>首先创建纹理对象：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;texture.jpg&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>接着构建纹理坐标：
<ul>
<li>四棱锥具有五个面，由6个三角形组成，每个三角形有3个顶点，共18个顶点</li>
<li>使图像的顶部中心对应四棱锥的顶（简单地贴上去）。</li>
</ul>
</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_texture.jpg" alt="纹理贴图"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> textures[<span class="number">36</span>] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>然后将纹理载入缓冲区：载入缓冲区1。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(textures), textures, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在着色器中使用纹理：采样器变量和纹理单元。为了提高性能，在硬件中执行纹理处理。则需要通过统一采样器变量实现。
<ul>
<li>统一采样器变量：指示显卡上的纹理单元，从加载的纹理对象中提取或采样纹理图像中的像素。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>layout(binding = 0)</code> 表示采样器变量 <code>samp</code> 的绑定第0个纹理单元。</p>
</li>
<li>
<p>可用纹理单元的数量取决于显卡提供的数量。</p>
</li>
</ul>
<ol start="5">
<li>
<p>在 <code>display()</code> 函数中，调用 <code>glActiveTexture()</code> 函数激活纹理单元并调用 <code>glBindTexture()</code> 函数将纹理单元绑定到特定的纹理对象。</p>
<ul>
<li>代码中使用 <code>GL_TEXTURE0</code> 让第0个纹理单元处于激活状态。</li>
</ul>
</li>
<li>
<p>片段着色器中使用顶点着色器接收的插值纹理坐标来对纹理对象进行采样：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">in vec2 tc;</span><br><span class="line">……</span><br><span class="line">color = <span class="built_in">texture</span>(samp, tc);</span><br></pre></td></tr></table></figure>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_pyramidwithtexture.jpg" alt="带纹理的四棱锥"></p>
<p>完整代码：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">2</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line">std::stack&lt;glm::mat4&gt; matrixStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> pyramidVertexs[<span class="number">54</span>] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> textures[<span class="number">36</span>] = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(pyramidVertexs), pyramidVertexs, GL_STATIC_DRAW);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(textures), textures, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">1.5f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">5.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">    textureID[<span class="number">0</span>] = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;brick1.jpg&quot;</span>);</span><br><span class="line">    textureID[<span class="number">1</span>] = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;ice.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">        mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(i * <span class="number">3.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        <span class="comment">// 旋转展示各个面</span></span><br><span class="line">        mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">-0.45f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">0.61f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">0.00f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">        mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">        <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Pyramid with texture&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>Util.h</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SOIL2/soil2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">readShaderSource</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printShaderLog</span><span class="params">(GLuint shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printProgramLog</span><span class="params">(GLuint program)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">checkOpenGLerror</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> GLuint <span class="title">createShadeProgram</span><span class="params">(<span class="type">const</span> std::string vpath, <span class="type">const</span> std::string fpath)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> GLuint <span class="title">loadTexture</span><span class="params">(<span class="type">const</span> std::string &amp;imgPath)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>Util.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从文件中读取 GLSL 代码</span></span><br><span class="line"><span class="comment">* @param path 文件路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">std::string <span class="title">Util::readShaderSource</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fileStream</span><span class="params">(path, std::ios::in)</span></span>;</span><br><span class="line">    std::string line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fileStream.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(fileStream, line);</span><br><span class="line">        content.<span class="built_in">append</span>(line + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileStream.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param shader 着色器标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Util::printShaderLog</span><span class="params">(GLuint shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(shader, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(shader, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shader Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 链接失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param program 着色器程序标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Util::printProgramLog</span><span class="params">(GLuint program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(program, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(program, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Program Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Util::checkOpenGLerror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> err = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    <span class="keyword">while</span> (glErr != GL_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;glError: &quot;</span> &lt;&lt; glErr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        err = <span class="literal">true</span>;</span><br><span class="line">        glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建着色器程序</span></span><br><span class="line"><span class="comment">* @param vpath 顶点着色器路径</span></span><br><span class="line"><span class="comment">* @param fpath 片段着色器路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">GLuint <span class="title">Util::createShadeProgram</span><span class="params">(<span class="type">const</span> std::string vpath, <span class="type">const</span> std::string fpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    GLint vertCompiled, fragCompiled, linked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    std::string vs = <span class="built_in">readShaderSource</span>(vpath);</span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    std::string fs = <span class="built_in">readShaderSource</span>(fpath);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *vshaderSource = vs.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fshaderSource = fs.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别存入 vShader 和 fShader 变量</span></span><br><span class="line">    GLuint vShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    GLuint fShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GLSL 代码从字符串载入空着色器对象中</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vShader, <span class="number">1</span>, &amp;vshaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fShader, <span class="number">1</span>, &amp;fshaderSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);</span><br><span class="line">    <span class="keyword">if</span> (vertCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vertex compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(vShader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(fShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);</span><br><span class="line">    <span class="keyword">if</span> (fragCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fragment compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(fShader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLuint vProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, vShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, fShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(vProgram);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(vProgram, GL_LINK_STATUS, &amp;linked);</span><br><span class="line">    <span class="keyword">if</span> (linked == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;linking failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printProgramLog</span>(vProgram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vProgram; <span class="comment">// 返回着色器程序ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从文件中读取纹理图像并返回纹理 ID</span></span><br><span class="line"><span class="comment">* @param imgPath 图像文件路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">GLuint <span class="title">Util::loadTexture</span><span class="params">(<span class="type">const</span> std::string &amp;imgPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLuint textureID;</span><br><span class="line">    textureID = <span class="built_in">SOIL_load_OGL_texture</span>(imgPath.<span class="built_in">c_str</span>(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);</span><br><span class="line">    <span class="keyword">if</span> (textureID == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture: &quot;</span> &lt;&lt; imgPath &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>vertex.glsl</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 texCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br><span class="line"></span><br><span class="line">out vec2 tc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    tc = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>fragment.glsl</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">in vec2 tc;</span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = <span class="built_in">texture</span>(samp, tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="5-4-多级渐远纹理贴图">5.4 多级渐远纹理贴图</h3>
<p>纹理贴图经常会在渲染图像中导致各种不利的伪影。</p>
<ul>
<li>这是因为纹理图像的分辨率或长宽比很少与被纹理贴图的场景中区域的分辨率或长宽比匹配。</li>
</ul>
<ol>
<li>
<p>当图像分辨率小于所绘制区域的分辨率时，会出现一种很常见的伪影。在这种情况下，需要拉伸图像以覆盖整个区域，这样图像就会变得模糊（并且可能变形）。</p>
<ul>
<li>根据纹理的性质，有时可以通过改变纹理坐标分配方式来应对这种情况，使得纹理需要较少的拉伸。</li>
<li>另一种解决方案是使用更高分辨率的纹理图像。</li>
</ul>
</li>
<li>
<p>相反的情况是图像纹理的分辨率大于被绘制区域的分辨率。</p>
<ul>
<li>在这种情况下，可能会出现明显的叠影，从而产生奇怪的错误图案，或移动物体中的“闪烁”效果。</li>
<li>叠影是由采样错误引起的。</li>
</ul>
</li>
</ol>
<p>使用多级渐远纹理贴图可以很大程度上矫正采样误差伪影。</p>
<ul>
<li>使用各种分辨率创建纹理图像的不同版本。</li>
<li>被贴图的区域使用最适合的分辨率的纹理图像。</li>
</ul>
<p>多级渐远纹理贴图的机制：</p>
<ul>
<li>它在纹理图像中存储相同图像的连续的一系列较低分辨率的副本。</li>
<li>所用的纹理图像比原始图像大 1/3，其中图像的 RGB 值分别存储在纹理图像空间的 3 个 1/4 区域中来实现的。</li>
<li>剩余的 1/4 区域中迭代地将图像分辨率设置为原来的 1/4，直到剩余区域太小而不包含任何有用的图像数据。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_Multileveltexture.jpg" alt="多级渐远纹理贴图示例，图源计算机图形学编程（第二版）"></p>
<p>使用代码进行构建多级渐远纹理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure>
<p>对于函数 <code>glTexparameteri()</code> 其第三个参数设置为所需的缩小方法来选择多级渐远纹理的采样方法，方法如下：</p>
<ul>
<li><code>GL_NEAREST_MIPMAP_NEAREST</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的多级渐远纹理，获取所需纹理坐标的最近的纹理图像像素。</li>
<li><code>GL_LINEAR_MIPMAP_NEAREST</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的多级渐远纹理，获取最接近纹理坐标的4个纹理图像像素的插值。</li>
<li><code>GL_NEAREST_MIPMAP_LINEAR</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的2个多级渐远纹理，从每个多级渐远纹理获取纹理坐标的最近的纹理图像像素进行插值。</li>
<li><code>GL_LINEAR_MIPMAP_LINEAR</code>：选择具有与纹理坐标对应的纹理图像像素区域最相似的分辨率的2多个渐远纹理，从每多个渐远纹理获取最接近纹理坐标的4个纹理图像像素进行插值，又称为“三线性过滤”。</li>
</ul>
<p>通常选择三线性过滤。</p>
<p><em>对于特殊的应用场景，可以使用任何图像编辑软件自行构建多级渐远纹理，然后通过为每个多级渐远纹理级别重复调用 OpenGL 的 <code>glTexImage2D()</code> 函数来创建纹理对象，并将它们添加为多级渐远纹理级别</em></p>
<h3 id="5-5-各向异性过滤">5.5 各向异性过滤</h3>
<p>多级渐远纹理贴图有时看起来比非多级渐远纹理贴图更模糊。</p>
<ul>
<li>这种细节的丢失是因为当物体倾斜时，其图元看起来在一个轴（即沿宽或高）上的尺寸比在另一个轴上更小。</li>
<li>当 OpenGL 为图元贴图时，它选择适合两个轴中尺寸较小的轴的多级渐远纹理）。</li>
</ul>
<p>可以通过各向异性过滤恢复一些丢失的细节。</p>
<ul>
<li>各向异性过滤比标准多级渐远纹理贴图的计算代价更高，并且不是 OpenGL 的必需部分。</li>
</ul>
<p>只需添加以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">glewIsSupported</span>(<span class="string">&quot;GL_EXT_texture_filter_anisotropic&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    GLfloat anisoSetting = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="built_in">glGetFloatv</span>(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);</span><br><span class="line">    <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>if</code> 判断测试显卡是否支持各向异性过滤。如果支持，则设置为支持的最大采样程度，由 <code>glGetFloatv()</code> 函数获取。</li>
<li>使用 <code>glTexParameterf()</code> 函数激活并设置纹理的各向异性采样值。</li>
</ul>
<h3 id="5-6-环绕和平铺">5.6 环绕和平铺</h3>
<p>当纹理坐标超出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 时，可以使用 <code>glTexParameteri()</code> 函数设置：</p>
<ul>
<li><code>GL_REPEAT</code>：重复纹理图像，忽略纹理坐标的整数部分，生成重复或平铺的图案，这是默认选项。</li>
<li><code>GL_MIRRORED_REPEAT</code>：重复纹理图像，忽略纹理坐标的整数部分，但是当整数部分为奇数时反转坐标，重复的图案在原图案和其镜像图案之间交替。</li>
<li><code>GL_CLAMP_TO_EDGE</code>：将纹理坐标限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 之间，小于0的坐标设置为0，大于1的坐标设置为1。</li>
<li><code>GL_CLAMP_TO_BORDER</code>：将纹理坐标限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 之间，区间以外设置为指定的边框颜色。</li>
</ul>
<p>代码上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置为重复</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>
<p>修改为 <code>GL_CLAMP_TO_BORDER</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="type">float</span> redColor[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, redColor);</span><br></pre></td></tr></table></figure>
<h3 id="5-7-透视变形">5.7 透视变形</h3>
<p>在纹理坐标的情况下，线性插值可能导致在具有透视投影的 3D 场景中出现明显的失真。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_distortion.jpg" alt="失真（左），纠正（右），图源计算机图形学编程（第二版）"></p>
<p>默认情况下，OpenGL 在栅格化期间会应用透视校正算法。</p>
<ul>
<li>可以在顶点属性中添加关键字 <code>noperspective</code> 来禁用透视校正。</li>
<li>顶点着色器：<code>noperspective out vec2 texCoord;</code></li>
<li>片段着色器：<code>noperspective in vec2 texCoord;</code></li>
</ul>
<h3 id="5-8-材质的更多细节">5.8 材质的更多细节</h3>
<p>可以使用 C++ 和 OpenGL 函数直接将纹理图像文件数据加载到 OpenGL 中（不适用 SOIL2 库）：</p>
<ol>
<li>使用 C++ 工具读取图像文件数据。
<ul>
<li>C++ 函数 <code>fopen()</code>、<code>fread()</code>。</li>
</ul>
</li>
<li>生成 OpenGL 纹理对象。
<ul>
<li>使用 <code>glGenTextures()</code> 函数生成纹理对象。</li>
<li><code>glGenTextures(1, &amp;textureID);</code></li>
</ul>
</li>
<li>将图像文件数据复制到纹理对象中。
<ul>
<li>
<p>使用 <code>glTexImage2D()</code> 函数将图像文件数据复制到纹理对象中。</p>
</li>
<li>
<p><code>data</code> 为图像文件数据，数据类型为 <code>unsigned char</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="六-3d模型">六、3D模型</h2>
<p>对于四棱锥和立方体，可以通过在OpenGL中使用顶点数组来创建。但是大部分 3D 场景对象都比较复杂，无法手动构建顶点数组。</p>
<p>对于更为复杂的模型，此处关注：</p>
<ul>
<li>通过程序来构建模型</li>
<li>加载外部创建的模型</li>
</ul>
<h3 id="6-1-程序构建模型">6.1 程序构建模型</h3>
<h4 id="6-1-1-构建一个球体">6.1.1 构建一个球体</h4>
<p>像圆、球体等具有数学定义，其顶点数组可以通过数学计算而生成。</p>
<p>建立一个球体模型：</p>
<ol>
<li>选择模型精度：一个表示将球体分成相应份数的圆形部分的数字，体现为切片数。</li>
<li>将每个圆形切片的圆周细分若干个点，此处每个切片具有相同数量的点。</li>
<li>将顶点分组为三角形：逐步遍历顶点，在每一步构建两个三角形。</li>
</ol>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_group.jpg" alt="将顶点组合成三角形"></p>
<ol start="4">
<li>根据纹理图像的性质选择纹理坐标。对于球体，想象让纹理图像围绕球体包裹，可以根据图像中像素的最终对应位置为每个顶点指定纹理坐标。</li>
<li>对于每个顶点，还应该生成法向量，用于光照。</li>
</ol>
<p>在第3点中，存在顶点出现在多个三角形中，导致每个顶点被多次指定，这对程序不利。仅存储每个顶点一次，然后为三角形的每个角指定索引，引用所需的顶点。</p>
<ul>
<li>需要存储每个顶点的位置、纹理坐标和法向量。
<ul>
<li>顶点存储在一维数组中，从最下面的水平切片开始。</li>
<li>索引数组包含相应三角形的每个角，将值设为顶点数组中的下标。</li>
</ul>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_index.png" alt="顶点数组和索引数组"></p>
<p>然后，从球体底部开始，围绕每个水平切片以圆形方式遍历顶点。访问每个顶点时，构建两个三角形，在其右上方形成一个方形区域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slices 为切片数，也是精度</span></span><br><span class="line"><span class="comment">// vertexs 为每个水平切片的顶点数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; slices; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertexs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算顶点j的指向右边相邻顶点、上方顶点</span></span><br><span class="line">        <span class="comment">// 以及右上方顶点的两个三角形的索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>索引数组也加载到 VBO 中，指定 VBO 的类型为 <code>GL_ELEMENT_ARRAY_BUFFER</code>（这会告诉 OpenGL 这个 VBO 包含索引）。</p>
<ul>
<li>在 <code>display()</code> 中：
<ul>
<li>将 <code>glDrawArrays()</code> 调用替换为  <code>glDrawElements()</code> 调用，它会告诉 OpenGL利用索引 VBO 来查找要绘制的顶点。</li>
<li>还需要使用 <code>glBindBuffer()</code> 启用包含索引的 VBO，指定哪个 VBO 包含索引并且为 <code>GL_ELEMENT_ARRAY_BUFFER</code> 类型。</li>
</ul>
</li>
</ul>
<p>编写类 <code>Sphere</code>，用于创建球体模型，球体中心位于原点。</p>
<ul>
<li>
<p>顶点存储在 <code>GLM</code> 中的 <code>vec2</code> 和 <code>vec3</code> 示例的 <code>std::vector</code> 中。</p>
</li>
<li>
<p>因为纹理贴图完全包裹在球体周围，所以在纹理贴图的左右边缘相交的每个点处需要一个额外的顶点来使贴图两侧重合。</p>
<ul>
<li>顶点的总数是 <code>(prec+1)*(prec+1)</code>。由于每个顶点生成 6 个三角形索引，因此索引的总数是 <code>prec*prec*6</code>。</li>
<li><code>prec</code> 为精度，体现在切片数。</li>
</ul>
</li>
</ul>
<p>效果截图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_sphere.jpg" alt="球体"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint textureID;</span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="function">Sphere <span class="title">sphere</span><span class="params">(<span class="number">48</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ind = sphere.<span class="built_in">getIndices</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; vert = sphere.<span class="built_in">getVertices</span>();</span><br><span class="line">    std::vector&lt;glm::vec2&gt; tex = sphere.<span class="built_in">getTexCoords</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; norm = sphere.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numIndices = sphere.<span class="built_in">getNumIndices</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIndices; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 索引放入缓冲区3</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * ind.<span class="built_in">size</span>(), &amp;ind[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">5.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">    textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;ice.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">    mMat *= glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>));</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewIsSupported</span>(<span class="string">&quot;GL_EXT_texture_filter_anisotropic&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        GLfloat anisoSetting = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="built_in">glGetFloatv</span>(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);</span><br><span class="line">        <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, sphere.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Sphere&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>球体类</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sphere.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sphere</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numVertices;    <span class="comment">// 顶点数组大小</span></span><br><span class="line">    <span class="type">int</span> numIndices;        <span class="comment">// 索引数组大小</span></span><br><span class="line">    std::vector&lt;glm::vec3&gt; vertices;    <span class="comment">// 顶点数组</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; indices;            <span class="comment">// 索引数组</span></span><br><span class="line">    std::vector&lt;glm::vec3&gt; normals;        <span class="comment">// 法向量数组</span></span><br><span class="line">    std::vector&lt;glm::vec2&gt; texCoords;    <span class="comment">// 纹理坐标数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">toRadians</span><span class="params">(<span class="type">float</span> degrees)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sphere</span>(<span class="type">int</span> prec = <span class="number">48</span>);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumIndices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">getIndices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getNormals</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec2&gt; <span class="title">getTexCoords</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sphere.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Sphere::<span class="built_in">Sphere</span>(<span class="type">int</span> prec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>(prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sphere::init</span><span class="params">(<span class="type">int</span> _prec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    numVertices = (_prec + <span class="number">1</span>) * (_prec + <span class="number">1</span>);</span><br><span class="line">    numIndices = _prec * _prec * <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        texCoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        normals.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIndices; ++ i)</span><br><span class="line">        indices.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三角形顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= _prec; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= _prec; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">cos</span>(<span class="built_in">toRadians</span>(<span class="number">180.0f</span> - i * <span class="number">180.0f</span> / _prec)));</span><br><span class="line">            <span class="type">float</span> x = - <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">cos</span>(<span class="built_in">toRadians</span>(j * <span class="number">360.0f</span> / _prec)) * <span class="built_in">fabs</span>(<span class="built_in">cos</span>(<span class="built_in">asin</span>(y))));</span><br><span class="line">            <span class="type">float</span> z = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">sin</span>(<span class="built_in">toRadians</span>(j * <span class="number">360.0f</span> / _prec)) * <span class="built_in">fabs</span>(<span class="built_in">cos</span>(<span class="built_in">asin</span>(y))));</span><br><span class="line">            vertices[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">            texCoords[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec2</span>(j * <span class="number">1.0f</span> / _prec, i * <span class="number">1.0f</span> / _prec);</span><br><span class="line">            normals[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三角形索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _prec; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _prec; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            indices[<span class="number">6</span> * (i * _prec + j) + <span class="number">0</span>] = i * (_prec + <span class="number">1</span>) + j;</span><br><span class="line">            indices[<span class="number">6</span> * (i * _prec + j) + <span class="number">1</span>] = i * (_prec + <span class="number">1</span>) + j + <span class="number">1</span>;</span><br><span class="line">            indices[<span class="number">6</span> * (i * _prec + j) + <span class="number">2</span>] = (i + <span class="number">1</span>) * (_prec + <span class="number">1</span>) + j;</span><br><span class="line">            indices[<span class="number">6</span> * (i * _prec + j) + <span class="number">3</span>] = i * (_prec + <span class="number">1</span>) + j + <span class="number">1</span>;</span><br><span class="line">            indices[<span class="number">6</span> * (i * _prec + j) + <span class="number">4</span>] = (i + <span class="number">1</span>) * (_prec + <span class="number">1</span>) + j + <span class="number">1</span>;</span><br><span class="line">            indices[<span class="number">6</span> * (i * _prec + j) + <span class="number">5</span>] = (i + <span class="number">1</span>) * (_prec + <span class="number">1</span>) + j;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Sphere::toRadians</span><span class="params">(<span class="type">float</span> degrees)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * <span class="number">2.0f</span> * <span class="number">3.14159f</span> / <span class="number">360.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sphere::getNumVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numVertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sphere::getNumIndices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numIndices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Sphere::getVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">Sphere::getIndices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Sphere::getNormals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> normals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec2&gt; <span class="title">Sphere::getTexCoords</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> texCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>着色器</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 texCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br><span class="line"></span><br><span class="line">out vec2 tc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    tc = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">in vec2 tc;</span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = <span class="built_in">texture</span>(samp, tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h4 id="6-1-2-构建一个环面">6.1.2 构建一个环面</h4>
<p>产生环面需要一定的算法。</p>
<p>构建一个环面如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_totorus.jpg" alt="图源计算机图形学编程（第二版）"></p>
<p>将一个顶点定位到原点的右侧，然后在 xOy 平面上的圆中让这个顶点围绕 z 轴旋转，以形成“环”，最后将这个环“向外”移动“内径”的距离。</p>
<p>在构建这些顶点时，会为每个顶点计算纹理坐标和法向量，还会额外为每个顶点生成与环面表面相切的向量（称为切向量）。在顶点创建之后，逐环遍历所有顶点，并在每个顶点上生成两个三角形。两个三角形的 6 个索引表的生成方式和之前的球体类似。</p>
<p>效果截图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_torus.jpg" alt="环面"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;Sphere.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint textureID;</span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sphere sphere(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">torus</span><span class="params">(<span class="number">48</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ind = torus.<span class="built_in">getIndices</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; vert = torus.<span class="built_in">getVertices</span>();</span><br><span class="line">    std::vector&lt;glm::vec2&gt; tex = torus.<span class="built_in">getTexCoords</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; norm = torus.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numIndices = torus.<span class="built_in">getNumIndices</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIndices; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 索引放入缓冲区3</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * ind.<span class="built_in">size</span>(), &amp;ind[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">5.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">    textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;ice.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-0.5f</span>));</span><br><span class="line">    mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">30.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mMat *= glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>));</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewIsSupported</span>(<span class="string">&quot;GL_EXT_texture_filter_anisotropic&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        GLfloat anisoSetting = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="built_in">glGetFloatv</span>(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);</span><br><span class="line">        <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, torus.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Torus&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>环面类</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Torus.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Torus</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line">    <span class="type">int</span> numIndices;</span><br><span class="line">    <span class="type">int</span> prec;</span><br><span class="line">    <span class="type">float</span> inner, outer;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">    std::vector&lt;glm::vec3&gt; vertices;</span><br><span class="line">    std::vector&lt;glm::vec2&gt; texCoords;</span><br><span class="line">    std::vector&lt;glm::vec3&gt; normals;</span><br><span class="line">    std::vector&lt;glm::vec3&gt; sTangents;</span><br><span class="line">    std::vector&lt;glm::vec3&gt; tTangents;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">toRadians</span><span class="params">(<span class="type">float</span> degrees)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Torus</span>(<span class="type">int</span> _prec = <span class="number">48</span>, <span class="type">float</span> _inner = <span class="number">0.5</span>, <span class="type">float</span> _outer = <span class="number">0.2</span>);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumIndices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">getIndices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec2&gt; <span class="title">getTexCoords</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getNormals</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getStangents</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getTtangents</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Torus.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Torus::<span class="built_in">Torus</span>(<span class="type">int</span> _prec, <span class="type">float</span> _inner, <span class="type">float</span> _outer)</span><br><span class="line">&#123;</span><br><span class="line">    prec = _prec;</span><br><span class="line">    inner = _inner;</span><br><span class="line">    outer = _outer;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Torus::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    numVertices = (prec + <span class="number">1</span>) * (prec + <span class="number">1</span>);</span><br><span class="line">    numIndices = prec * prec * <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        texCoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        normals.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIndices; ++ i)</span><br><span class="line">        indices.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        sTangents.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">        tTangents.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算第一个环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prec + <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> amt = <span class="built_in">toRadians</span>(i * <span class="number">360.0f</span> / prec);</span><br><span class="line">        glm::mat4 rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), amt, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        <span class="function">glm::vec3 <span class="title">initPos</span><span class="params">(rMat * glm::vec4(<span class="number">0.0f</span>, outer, <span class="number">0.0f</span>, <span class="number">1.0f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        vertices[i] = glm::<span class="built_in">vec3</span>(initPos + glm::<span class="built_in">vec3</span>(inner, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        texCoords[i] = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i) / prec);</span><br><span class="line"></span><br><span class="line">        rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), amt + (<span class="number">3.14159f</span> / <span class="number">2.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        tTangents[i] = glm::<span class="built_in">vec3</span>(rMat * glm::<span class="built_in">vec4</span>(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        sTangents[i] = glm::<span class="built_in">vec3</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line"></span><br><span class="line">        normals[i] = glm::<span class="built_in">cross</span>(tTangents[i], sTangents[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个环绕Y轴旋转，得到其他环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ring = <span class="number">1</span>; ring &lt; prec + <span class="number">1</span>; ++ ring)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prec + <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> amt = <span class="built_in">toRadians</span>(ring * <span class="number">360.0f</span> / prec);</span><br><span class="line"></span><br><span class="line">            glm::mat4 rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), amt, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">            vertices[ring * (prec + <span class="number">1</span>) + i] = glm::<span class="built_in">vec3</span>(rMat * glm::<span class="built_in">vec4</span>(vertices[i], <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">            texCoords[ring * (prec + <span class="number">1</span>) + i] = glm::<span class="built_in">vec2</span>(ring * <span class="number">2.0f</span> / prec, texCoords[i].t);</span><br><span class="line"></span><br><span class="line">            rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), amt, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">            sTangents[ring * (prec + <span class="number">1</span>) + i] = glm::<span class="built_in">vec3</span>(rMat * glm::<span class="built_in">vec4</span>(sTangents[i], <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">            rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), amt, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">            tTangents[ring * (prec + <span class="number">1</span>) + i] = glm::<span class="built_in">vec3</span>(rMat * glm::<span class="built_in">vec4</span>(tTangents[i], <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">            rMat = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), amt, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">            normals[ring * (prec + <span class="number">1</span>) + i] = glm::<span class="built_in">vec3</span>(rMat * glm::<span class="built_in">vec4</span>(normals[i], <span class="number">1.0f</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三角形索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ring = <span class="number">0</span>; ring &lt; prec; ++ ring)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prec; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            indices[((ring * prec + i) * <span class="number">2</span>) * <span class="number">3</span> + <span class="number">0</span>] = ring * (prec + <span class="number">1</span>) + i;</span><br><span class="line">            indices[((ring * prec + i) * <span class="number">2</span>) * <span class="number">3</span> + <span class="number">1</span>] = (ring + <span class="number">1</span>) * (prec + <span class="number">1</span>) + i;</span><br><span class="line">            indices[((ring * prec + i) * <span class="number">2</span>) * <span class="number">3</span> + <span class="number">2</span>] = ring * (prec + <span class="number">1</span>) + i + <span class="number">1</span>;</span><br><span class="line">            indices[((ring * prec + i) * <span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">0</span>] = ring * (prec + <span class="number">1</span>) + i + <span class="number">1</span>;</span><br><span class="line">            indices[((ring * prec + i) * <span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>] = (ring + <span class="number">1</span>) * (prec + <span class="number">1</span>) + i;</span><br><span class="line">            indices[((ring * prec + i) * <span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>] = (ring + <span class="number">1</span>) * (prec + <span class="number">1</span>) + i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Torus::toRadians</span><span class="params">(<span class="type">float</span> degrees)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * <span class="number">2.0f</span> * <span class="number">3.14159f</span> / <span class="number">360.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Torus::getNumVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numVertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Torus::getNumIndices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numIndices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">Torus::getIndices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Torus::getVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec2&gt; <span class="title">Torus::getTexCoords</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> texCoords;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Torus::getNormals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> normals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Torus::getStangents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sTangents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Torus::getTtangents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tTangents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当绕 y 轴旋转生成环时，指定一个从 1 开始并增加到指定精度的变量 <code>ring</code>。然后将纹理坐标值设置为 <code>ring*2.0/prec</code>，使其取值范围为 0.0～2.0，再前面描述的，将纹理的平铺模式设为 <code>GL_REPEAT</code>。运用这种方法的目的是避免纹理图像在水平方向上过度“拉伸”。反之，如果确实希望纹理完全围绕环面拉伸，只需从纹理坐标计算代码中删除 <code>*2.0</code>。</li>
</ul>
</details>
<h3 id="6-2-加载外部构建的模型">6.2 加载外部构建的模型</h3>
<p>通过一些建模工具也可以构建模型，如：Maya、Blender、Cinema4D等，而一般模型导出也有许多格式。此处使用 OBJ 格式进行处理。</p>
<p>OBJ 文件中的行以字符标签开头，表明该行的数据类型，常见的标签如下：</p>
<ul>
<li>v：几何数据（顶点位置）</li>
<li>vt：纹理坐标</li>
<li>vn：顶点法向量</li>
<li>f：面（通常是三角形中的顶点）<br>
可能还有标签存储对象名称、使用的材质、曲线、阴影和许多其他细节。</li>
</ul>
<p>使用 Blender 绘制一个四棱锥，并导出为 OBJ文件：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_blender.jpg" alt="Blender导出设置"></p>
<p>使用记事本打开一个 OBJ 文件，其内容如下：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_Pyramidobj.jpg" alt="立方体的OBJ文件"></p>
<ul>
<li>以 <code>#</code> 开头的是 Blender 添加的注释，可以忽略。</li>
<li>以 <code>o</code> 开头的是对象的名称，导入时也可以忽略。</li>
<li>以 <code>s</code> 开头表明不应该平滑处理，此处同样忽略。</li>
<li>以 <code>v</code> 开头的是顶点位置，顶点位置的顺序是 <code>x y z</code>。此处有8个顶点，原点在中心。</li>
<li>以 <code>vt</code> 开头的是各种纹理坐标，纹理坐标列表比顶点列表长的原因是一些顶点参与了多个三角形的构建，并且在这些情况下可能使用不同的纹理坐标。</li>
<li>以 <code>vn</code> 开头的是各种法向量，通常也是比顶点列表长，原因同上。</li>
<li>以 <code>f</code> 开头的行指定面（三角形）。每个面（三角形）具有三个元素，由 <code>/</code> 分隔。每个元素的值分别是顶点列表、纹理坐标和法向量的索引，如第三个面是：<code>3/4/3 5/2/3 4/5/3</code>，表明顶点列表第3个、第5个、第4个组成一个面，相应的纹理坐标是第4项、第2项、第5项，法向量相同都是第3项。</li>
</ul>
<p>OBJ 格式的模型并不要求具有法向量，甚至纹理坐标。</p>
<ul>
<li>如果模型没有纹理坐标和法向量，则面的数值将仅指定顶点索引：
<ul>
<li><code>3 5 4</code></li>
</ul>
</li>
<li>如果模型有纹理坐标，没有法向量，则格式为：
<ul>
<li><code>3/4 5/2 4/5</code></li>
</ul>
</li>
<li>如果模型没有纹理坐标，有法向量，则格式为：
<ul>
<li><code>3//3 5//3 4//3</code></li>
</ul>
</li>
</ul>
<p>在互联网上可以获得各种能导入 OBJ 模型的程序，但此处手动编写程序进行简单地导入 OBJ 文件，局限如下：</p>
<ul>
<li>仅支持包含 3 个面属性字段，即以 <code>f #/#/# #/#/# #/#/#</code> 的形式存在。</li>
<li>材质标签将被忽略。</li>
<li>仅支持由单个三角形网格组成的 OBJ 模型。</li>
<li>假设每行上的元素都只用一个空格分隔。</li>
<li>没有使用上索引机制。</li>
</ul>
<p>定义两个类（置于同一个文件）：</p>
<ul>
<li><code>ModelImporter</code> 类用于从 OBJ 文件中导入模型数据。</li>
<li><code>ImportedModel</code> 类用于保存并构建一个模型，类似于上面的球体类、环面类。</li>
</ul>
<p>对于四棱锥，加载 OBJ 与先前手动构建的模型差不多。通过 Windows 自带的 3D 查看器，可以获取一些模型（格式为 <code>.glb</code> ，将其放入 Blender 中，再导出为 OBJ 文件）。获取模型后在 OpenGL 程序中加载，如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_unicorn.jpg" alt="独角兽模型"></p>
<p>导入模型后，对模型的大小和位置进行修改，移动适合的相机位置并加入材质，最后如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_iceUnicorn.jpg" alt="冰独角兽"></p>
<p>更多可以自己摸索。</p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint textureID;</span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sphere sphere(48);</span></span><br><span class="line"><span class="comment">//Torus torus(48, 0.5f, 0.2f);</span></span><br><span class="line"><span class="function">ImportedModel <span class="title">model</span><span class="params">(<span class="string">&quot; Pyramid.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::vector&lt;int&gt; ind = model.getIndices(); 不使用索引数组</span></span><br><span class="line">    std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">    std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numObjVertices = model.<span class="built_in">getNumVertices</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numObjVertices; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">    textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;ice.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">30.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mMat *= glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewIsSupported</span>(<span class="string">&quot;GL_EXT_texture_filter_anisotropic&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        GLfloat anisoSetting = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="built_in">glGetFloatv</span>(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);</span><br><span class="line">        <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, model.<span class="built_in">getNumVertices</span>());</span><br><span class="line">    <span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">    <span class="comment">// glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);</span></span><br><span class="line">    <span class="comment">// glDrawElements(GL_TRIANGLES, torus.getVertices(), GL_UNSIGNED_INT, 0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Pyramid&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>导入模型类</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImportedModel.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImportedModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line">    std::vector&lt;glm::vec3&gt; vertices;</span><br><span class="line">    std::vector&lt;glm::vec2&gt; texCoords;</span><br><span class="line">    std::vector&lt;glm::vec3&gt; normals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ImportedModel</span>();</span><br><span class="line">    <span class="built_in">ImportedModel</span>(<span class="type">const</span> std::string &amp;filePath);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec2&gt; <span class="title">getTexCoords</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;glm::vec3&gt; <span class="title">getNormals</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelImporter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// OBJ 读取</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; vertVals;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; stVals;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; normalVals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存为顶点属性以供后续使用的数值</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; triangleVerts;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; texCoords;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; normals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ModelImporter</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseOBJ</span><span class="params">(<span class="type">const</span> std::string &amp;filePath)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">getVertices</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">getTexCoords</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">getNormals</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImportedModel.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ImportedModel::<span class="built_in">ImportedModel</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">ImportedModel::<span class="built_in">ImportedModel</span>(<span class="type">const</span> std::string &amp;filePath)</span><br><span class="line">&#123;</span><br><span class="line">    ModelImporter modelImporter = <span class="built_in">ModelImporter</span>();</span><br><span class="line">    modelImporter.<span class="built_in">parseOBJ</span>(filePath);</span><br><span class="line">    numVertices = modelImporter.<span class="built_in">getNumVertices</span>();</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; verts = modelImporter.<span class="built_in">getVertices</span>();</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; tcs = modelImporter.<span class="built_in">getTexCoords</span>();</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; nms = modelImporter.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(verts[i * <span class="number">3</span>], verts[i * <span class="number">3</span> + <span class="number">1</span>], verts[i * <span class="number">3</span> + <span class="number">2</span>]));</span><br><span class="line">        texCoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>(tcs[i * <span class="number">2</span>], tcs[i * <span class="number">2</span> + <span class="number">1</span>]));</span><br><span class="line">        normals.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(nms[i * <span class="number">3</span>], nms[i * <span class="number">3</span> + <span class="number">1</span>], nms[i * <span class="number">3</span> + <span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ImportedModel::getNumVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numVertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">ImportedModel::getVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vertices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec2&gt; <span class="title">ImportedModel::getTexCoords</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> texCoords;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">ImportedModel::getNormals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> normals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModelImporter::<span class="built_in">ModelImporter</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModelImporter::parseOBJ</span><span class="params">(<span class="type">const</span> std::string &amp;filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">    std::string content;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fin</span><span class="params">(filePath, std::ios::in)</span></span>;</span><br><span class="line">    std::string line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(fin, line);</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::stringstream <span class="title">s</span><span class="params">(line.erase(<span class="number">0</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">            s &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            vertVals.<span class="built_in">push_back</span>(x);</span><br><span class="line">            vertVals.<span class="built_in">push_back</span>(y);</span><br><span class="line">            vertVals.<span class="built_in">push_back</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;vt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::stringstream <span class="title">s</span><span class="params">(line.erase(<span class="number">0</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line">            s &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            stVals.<span class="built_in">push_back</span>(x);</span><br><span class="line">            stVals.<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;vn&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::stringstream <span class="title">s</span><span class="params">(line.erase(<span class="number">0</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line">            s &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            normalVals.<span class="built_in">push_back</span>(x);</span><br><span class="line">            normalVals.<span class="built_in">push_back</span>(y);</span><br><span class="line">            normalVals.<span class="built_in">push_back</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string oneCorner, v, t, n;</span><br><span class="line">            <span class="function">std::stringstream <span class="title">s</span><span class="params">(line.erase(<span class="number">0</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">getline</span>(s, oneCorner, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="function">std::stringstream <span class="title">oneCornerSS</span><span class="params">(oneCorner)</span></span>;</span><br><span class="line">                std::<span class="built_in">getline</span>(oneCornerSS, v, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                std::<span class="built_in">getline</span>(oneCornerSS, t, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                std::<span class="built_in">getline</span>(oneCornerSS, n, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> vertRef = (std::<span class="built_in">stoi</span>(v) - <span class="number">1</span>) * <span class="number">3</span>;</span><br><span class="line">                <span class="type">int</span> tcRef = (std::<span class="built_in">stoi</span>(t) - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> nmRef = (std::<span class="built_in">stoi</span>(n) - <span class="number">1</span>) * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                triangleVerts.<span class="built_in">push_back</span>(vertVals[vertRef]);</span><br><span class="line">                triangleVerts.<span class="built_in">push_back</span>(vertVals[vertRef + <span class="number">1</span>]);</span><br><span class="line">                triangleVerts.<span class="built_in">push_back</span>(vertVals[vertRef + <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">                texCoords.<span class="built_in">push_back</span>(stVals[tcRef]);</span><br><span class="line">                texCoords.<span class="built_in">push_back</span>(stVals[tcRef + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                normals.<span class="built_in">push_back</span>(normalVals[nmRef]);</span><br><span class="line">                normals.<span class="built_in">push_back</span>(normalVals[nmRef + <span class="number">1</span>]);</span><br><span class="line">                normals.<span class="built_in">push_back</span>(normalVals[nmRef + <span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ModelImporter::getNumVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triangleVerts.<span class="built_in">size</span>() / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">ModelImporter::getVertices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triangleVerts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">ModelImporter::getTexCoords</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> texCoords;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">ModelImporter::getNormals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> normals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="七-光照">七、光照</h2>
<h3 id="7-1-光照模型">7.1 光照模型</h3>
<p>光照模型有时也称为着色模型。</p>
<p>常见的光照模型称为 ADS 模型，基于标记为 A、D 和 S 三种类型的反射：</p>
<ul>
<li>A：环境光反射（ambient reflection）：模拟低级光照，影响场景中的所有物体。</li>
<li>D：漫反射（diffuse reflection）：根据光线的入射角度调整物体亮度。</li>
<li>S：镜面反射（specular reflection）：展示物体的光泽，通过在物体表面上，光线直接地反射到我们的眼睛的位置，策略性地放置适当大小的高光来体现。</li>
</ul>
<p>使用 ADS 光照模型需要指定用于像素输出的 RGBA 值上因光照<br>
而产生的分量。因素包括：</p>
<ul>
<li>光源类型及其环境光反射、漫反射和镜面反射特性；</li>
<li>对象材质的环境光反射、漫反射和镜面反射特征；</li>
<li>对象材质的“光泽度”；</li>
<li>光线照射物体的角度；</li>
<li>从中查看场景的角度。</li>
</ul>
<h3 id="7-2-光源">7.2 光源</h3>
<p>常见的光源类型有：</p>
<ul>
<li>全局光：通常称为全局环境光，仅包含环境光组件</li>
<li>定向光：远距离光</li>
<li>位置光：点光源</li>
<li>聚光灯</li>
</ul>
<p>全局环境光用于显示对象的每个像素都有相同的光照。</p>
<ul>
<li>全局环境光模拟了现实世界光线经过多次反射，<strong>无法确定光源和方向</strong>。</li>
<li>仅有环境光反射分量，没有漫反射或镜面反射分量。</li>
<li>通常被建模为偏暗的白光。</li>
<li>用 RGBA 值设定：<code>float globalAmbient[4] = &#123;0.6f, 0.6f, 0.6f, 1.0f&#125;;</code>
<ul>
<li>RGBA 值的范围是 0.0 到 1.0。A 设置为1。</li>
</ul>
</li>
</ul>
<p>定向光或远距离光</p>
<ul>
<li><strong>没有源位置但具有方向</strong>。用于模拟光源距离非常远，光线接近平行的情况。</li>
<li>定向光对物体的影响取决于光照角度，物体朝向定向光的一侧比对侧更亮。</li>
<li>建模定向光需要指定其方向（向量）及其环境、漫反射和镜面特征。</li>
<li>用 RGBA 设定，如指向 z 轴负方向的红色定向光代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> dirLightAmbient[<span class="number">4</span>] = &#123;<span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> dirLightDiffuse[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> dirLightSpecular[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> dirLightDirection[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>位置光在 3D 场景中具有特定位置，用以体现靠近场景的光源。</p>
<ul>
<li><strong>位置光没有方向</strong>，因为它对场景中每个顶点的光照方向都不同。</li>
<li>位置光还可以包含衰减因子，用于模拟它们的强度随着距离减小的程度。</li>
<li>用 RGBA 设定，如位置(5,2,-3)处的红色位置光可以指定为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> posLightAmbient[<span class="number">4</span>] = &#123;<span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> posLightDiffuse[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> posLightSpecular[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> posLightPosition[<span class="number">3</span>] = &#123;<span class="number">5.0f</span>, <span class="number">2.0f</span>, <span class="number">-3.0f</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>衰减因子有许多建模方式，其中一种是使用恒定衰减、线性衰减和二次方衰减，引入3个非负可调参数，与离光源的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 结合进行计算：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>k</mi><mi>c</mi></msub><mo>+</mo><msub><mi>k</mi><mi>l</mi></msub><mi>d</mi><mo>+</mo><msub><mi>k</mi><mi>q</mi></msub><msup><mi>d</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">attenuationFactor = \frac{1}{k_c + k_l d + k_q d^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.293548em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">k_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：应永远大于等于1；</p>
</li>
<li>
<p>另外两个参数至少有一个大于零；</p>
</li>
<li>
<p>使得因子取值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，并当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 增大时接近0。</p>
</li>
<li>
<p>将因子与光的强度相乘即可。</p>
</li>
</ul>
<p>聚光灯</p>
<ul>
<li><strong>同时具有位置和方向</strong>。</li>
<li>聚光灯参数如下图</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_spotlightargs.jpg" alt="聚光灯参数，图源计算机图形学编程（第二版）"></p>
<ul>
<li>具有衰减指数模拟随光束角度的强度变化，具有衰减因子模拟光束距离衰减。
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 时，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 的余弦的衰减指数次幂来计算强度因子。</li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 时，强度因子为0。</li>
<li>强度因子取值范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，将强度因子乘光的强度即可模拟锥形效果。</li>
</ul>
</li>
<li>用 RGBA 设定，如位置(5,2,-3)处向下照射 z 轴负方向的红色聚光灯可以表示为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> spotLightAmbient[<span class="number">4</span>] = &#123;<span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> spotLightDiffuse[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> spotLightSpecular[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> spotLightPosition[<span class="number">3</span>] = &#123;<span class="number">5.0f</span>, <span class="number">2.0f</span>, <span class="number">-3.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> spotLightDirection[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> spotLightCutoff = <span class="number">20.0f</span>;</span><br><span class="line"><span class="type">float</span> spotLightExponent = <span class="number">10.0f</span>;</span><br></pre></td></tr></table></figure>
<p><em>当设计拥有许多光源的系统时，程序员应该考虑创建相应的类结构，如定义 Light 类及其子类 GlobalAmbient、Directional、Positional、Spotlight</em></p>
<h3 id="7-3-材质">7.3 材质</h3>
<p>场景中给物体的外观添加光照，产生反射特性。即对象与 ADS 光照模型相互作用。</p>
<p>通过指定4个值，在 ADS 光照模型中模拟材质：</p>
<ul>
<li>环境光反射</li>
<li>漫反射</li>
<li>镜面反射</li>
<li>光泽</li>
</ul>
<p>如锡铝合金的效果，指定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pewterMatAmbient[<span class="number">4</span>] = &#123;<span class="number">0.11f</span>, <span class="number">0.06f</span>, <span class="number">0.11f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> pewterMatDiffuse[<span class="number">4</span>] = &#123;<span class="number">0.43f</span>, <span class="number">0.47f</span>, <span class="number">0.54f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="type">float</span> pewterMatSpecular[<span class="number">4</span>] = &#123;<span class="number">0.33f</span>, <span class="number">0.33f</span>, <span class="number">0.52f</span>, <span class="number">1.0f</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>没有纹理的物体在渲染时，可以指定材质特性。此处预定义一些可选择的材质（置于Util类中）：</p>
<details><summary>黄金、白银、青铜材质代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 黄金材质的环境光</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::goldAmbient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> ambient[<span class="number">4</span>] = &#123; <span class="number">0.2473f</span>, <span class="number">0.1995f</span>, <span class="number">0.0745f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的漫反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::goldDiffuse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> diffuse[<span class="number">4</span>] = &#123; <span class="number">0.7516f</span>, <span class="number">0.6065f</span>, <span class="number">0.2265f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的镜面反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::goldSpecular</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> specular[<span class="number">4</span>] = &#123; <span class="number">0.6283f</span>, <span class="number">0.5559f</span>, <span class="number">0.3661f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的光泽度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Util::goldShininess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">51.2f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的环境光</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::silverAmbient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> ambient[<span class="number">4</span>] = &#123; <span class="number">0.1923f</span>, <span class="number">0.1923f</span>, <span class="number">0.1923f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的漫反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::silverDiffuse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> diffuse[<span class="number">4</span>] = &#123; <span class="number">0.5075f</span>, <span class="number">0.5075f</span>, <span class="number">0.5075f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的镜面反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::silverSpecular</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> specular[<span class="number">4</span>] = &#123; <span class="number">0.5083f</span>, <span class="number">0.5083f</span>, <span class="number">0.5083f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的光泽度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Util::silverShininess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">51.2f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的环境光</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::bronzeAmbient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> ambient[<span class="number">4</span>] = &#123; <span class="number">0.2125f</span>, <span class="number">0.1275f</span>, <span class="number">0.054f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的漫反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::bronzeDiffuse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> diffuse[<span class="number">4</span>] = &#123; <span class="number">0.714f</span>, <span class="number">0.4284f</span>, <span class="number">0.18144f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的镜面反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::bronzeSpecular</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> specular[<span class="number">4</span>] = &#123; <span class="number">0.393548f</span>, <span class="number">0.271906f</span>, <span class="number">0.166721f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的光泽度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Util::bronzeShininess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">25.6f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p><strong>这些代码仅仅提供了用于描述并存储场景中元素所需光照和材质特性的一种方式，仍然需要自己计算光照。</strong></p>
<h3 id="7-4-ads光照计算">7.4 ADS光照计算</h3>
<p>当绘制场景时，每个顶点坐标都会进行变换以将 3D 世界模拟到 2D 屏幕上。每个像素的颜色都是栅格化、纹理贴图以及插值的结果。</p>
<p>现在需要加入一个新的步骤来调整这些栅格化之后的像素颜色，以便反应场景中的光照和材质。</p>
<p>首先确定每个像素的反射强度 I：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>=</mo><msub><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>I</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>+</mo><msub><mi>I</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{observed} = I_{ambient} + I_{diffuse} + I_{specular}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中环境光值为场景环境光与材质环境光分量的乘积（RGB分别乘积）：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mtext> </mtext><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msubsup><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msubsup><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msubsup><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msubsup><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msubsup><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msubsup><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>I</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msubsup><mi>l</mi><mrow><mi>a</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow></msubsup></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">I_{ambient}=Light_{ambient}\ Material_{ambient}=
\begin{cases}
I_{ambient}^{red}=Light_{ambient}^{red}Material_{ambient}^{red}\\
I_{ambient}^{green}=Light_{ambient}^{green}Material_{ambient}^{green}\\
I_{ambient}^{blue}=Light_{ambient}^{blue}Material_{ambient}^{blue}
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.3986920000000005em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.3986920000000005em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.3986920000000005em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013079999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中漫反射分量基于光对于平面的入射角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_angleOfIncidence.png" alt="入射角"></p>
<p>其中确定入射角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 需要：</p>
<ol>
<li>求从绘制向量到光源的向量（或与光照方向相反的向量） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></li>
<li>渲染物体表明的法向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>由</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>I</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>N</mi><mo>⋅</mo><mi>L</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>N</mi><mi mathvariant="normal">∥</mi><mi>L</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo>≤</mo><mi>θ</mi><mo>≤</mo><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr></mtable></mrow><mspace linebreak="newline"></mspace><mtext>得</mtext><msub><mi>I</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mtext> </mtext><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mtext> </mtext><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>N</mi><mo>⋅</mo><mi>L</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>N</mi><mi mathvariant="normal">∥</mi><mi>L</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mtext>同样分别进行</mtext><mi>R</mi><mi>G</mi><mi>B</mi><mtext>运算</mtext></mrow><annotation encoding="application/x-tex">由\begin{cases}
I_{diffuse}=\cos(\theta)Light_{diffuse}Material_{diffuse}\\
\cos(\theta)=\frac{N\cdot L}{\vert N\|L\vert}\\
-\frac{\pi}{2}\leq\theta\leq\frac{\pi}{2}
\end{cases}\\
得I_{diffuse}=Light_{diffuse}\ Material_{diffuse}\ \max(\frac{N\cdot L}{\vert N\|L\vert},0)\\
同样分别进行RGB运算
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.4079999999999995em;vertical-align:-1.9539999999999997em;"></span><span class="mord cjk_fallback">由</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.454em;"><span style="top:-4.454000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0140000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">∥</span><span class="mord mathdefault mtight">L</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.4860000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9539999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord cjk_fallback">得</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">∥</span><span class="mord mathdefault">L</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">别</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">算</span></span></span></span></span></p>
<p>其中镜面反射分量除了与入射角相关，也与光在表面上的反射角以及观察点与反光表面之间的夹角相关。下图 R 表示光反射，V 表示观察向量（像素到眼睛）。</p>
<ul>
<li>V 是从眼睛到像素的取反。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 越小，镜面反射分量越大。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 用于计算镜面反射分量的方式取决于物体的光泽度。光泽度越大越闪亮，则入射光更多反射给眼睛；光泽度较小，不那么闪亮，则镜面高光会散开。</li>
</ul>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_observationPointIncidence.png" alt="观察点入射角"></p>
<p>反光度可以用衰减函数建模，衰减函数表示角度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 增大时镜面反射分量衰减到0的速度。</p>
<ul>
<li>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><mi>cos</mi><mo>⁡</mo></mo><mi>n</mi></msup><mo stretchy="false">(</mo><mi>φ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\cos^n(\varphi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">cos</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">φ</span><span class="mclose">)</span></span></span></span> 进行衰减，指数越大，衰减速度越快。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 又叫作材质的反光度因子。</li>
<li>反光度因子以光泽度形式给出。</li>
</ul>
</li>
</ul>
<p>镜面反射计算如下（实际运算使用RGB运算）：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mtext> </mtext><mi>M</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><msub><mi>l</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mtext> </mtext><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>R</mi><mo>⋅</mo><mi>V</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>R</mi><mi mathvariant="normal">∥</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">I_{specular}=Light_{specular}\ Material_{specular}\ \max((\frac{R\cdot V}{\vert R\|V\vert})^n,0)\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop">max</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<h3 id="7-5-实现ads光照">7.5 实现ADS光照</h3>
<p>平滑着色方法：</p>
<ul>
<li>Gouraud 着色</li>
<li>Phong 着色</li>
</ul>
<h4 id="7-5-1-gouraud-着色">7.5.1 Gouraud 着色</h4>
<p>这方法又称为双线性光强插值法</p>
<p>使用 3D 图形管线中的自动插值渲染，适用于现代显卡。过程如下：</p>
<ol>
<li>确定每个顶点的颜色，并进行光照相关计算。</li>
<li>允许正常的栅格化过程在插入像素时对颜色也进行插值（同时也对光照进行插值）。</li>
</ol>
<p>OpenGL 中，大多数光照计算都是顶点着色器中完成，片段着色器仅传递并展示自动插值的光照后的颜色。</p>
<ul>
<li>顶点着色器
<ol>
<li>根据顶点计算 N、L、V 和 R 向量</li>
<li>计算 A、D、S分量</li>
<li>输出属性、光照后的颜色、<code>gl_position</code></li>
</ol>
</li>
<li>片段着色器
<ol>
<li>传入插值：颜色、位置</li>
</ol>
</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_goldtorus.jpg" alt="通过 Gouraud 着色的黄金材质环面"></p>
<p>程序代码如下：</p>
<details><summary>Util类</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Util.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SOIL2/soil2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">readShaderSource</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printShaderLog</span><span class="params">(GLuint shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printProgramLog</span><span class="params">(GLuint program)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">checkOpenGLerror</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> GLuint <span class="title">createShadeProgram</span><span class="params">(<span class="type">const</span> std::string vpath, <span class="type">const</span> std::string fpath)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> GLuint <span class="title">loadTexture</span><span class="params">(<span class="type">const</span> std::string &amp;imgPath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">goldAmbient</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">goldDiffuse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">goldSpecular</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">goldShininess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">silverAmbient</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">silverDiffuse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">silverSpecular</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">silverShininess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">bronzeAmbient</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">bronzeDiffuse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> *<span class="title">bronzeSpecular</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">bronzeShininess</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Util.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从文件中读取 GLSL 代码</span></span><br><span class="line"><span class="comment">* @param path 文件路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">std::string <span class="title">Util::readShaderSource</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fileStream</span><span class="params">(path, std::ios::in)</span></span>;</span><br><span class="line">    std::string line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fileStream.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(fileStream, line);</span><br><span class="line">        content.<span class="built_in">append</span>(line + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileStream.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 代码编译失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param shader 着色器标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Util::printShaderLog</span><span class="params">(GLuint shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(shader, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(shader, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shader Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 GLSL 链接失败时，显示 OpenGL 日志内容</span></span><br><span class="line"><span class="comment">* @param program 着色器程序标识</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Util::printProgramLog</span><span class="params">(GLuint program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chWrittn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *log;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(program, GL_INFO_LOG_LENGTH, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(program, len, &amp;chWrittn, log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Program Info: &quot;</span> &lt;&lt; log &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查 OpenGL 错误标志，即是否发生 OpenGL 错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Util::checkOpenGLerror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> err = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    <span class="keyword">while</span> (glErr != GL_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;glError: &quot;</span> &lt;&lt; glErr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        err = <span class="literal">true</span>;</span><br><span class="line">        glErr = <span class="built_in">glGetError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建着色器程序</span></span><br><span class="line"><span class="comment">* @param vpath 顶点着色器路径</span></span><br><span class="line"><span class="comment">* @param fpath 片段着色器路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">GLuint <span class="title">Util::createShadeProgram</span><span class="params">(<span class="type">const</span> std::string vpath, <span class="type">const</span> std::string fpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    GLint vertCompiled, fragCompiled, linked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    std::string vs = <span class="built_in">readShaderSource</span>(vpath);</span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    std::string fs = <span class="built_in">readShaderSource</span>(fpath);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *vshaderSource = vs.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fshaderSource = fs.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别存入 vShader 和 fShader 变量</span></span><br><span class="line">    GLuint vShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    GLuint fShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GLSL 代码从字符串载入空着色器对象中</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vShader, <span class="number">1</span>, &amp;vshaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fShader, <span class="number">1</span>, &amp;fshaderSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vShader, GL_COMPILE_STATUS, &amp;vertCompiled);</span><br><span class="line">    <span class="keyword">if</span> (vertCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vertex compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(vShader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(fShader);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fShader, GL_COMPILE_STATUS, &amp;fragCompiled);</span><br><span class="line">    <span class="keyword">if</span> (fragCompiled == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fragment compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printShaderLog</span>(fShader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLuint vProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, vShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(vProgram, fShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(vProgram);</span><br><span class="line">    <span class="built_in">checkOpenGLerror</span>();</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(vProgram, GL_LINK_STATUS, &amp;linked);</span><br><span class="line">    <span class="keyword">if</span> (linked == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;linking failed\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printProgramLog</span>(vProgram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vProgram; <span class="comment">// 返回着色器程序ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从文件中读取纹理图像并返回纹理 ID</span></span><br><span class="line"><span class="comment">* @param imgPath 图像文件路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">GLuint <span class="title">Util::loadTexture</span><span class="params">(<span class="type">const</span> std::string &amp;imgPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLuint textureID;</span><br><span class="line">    textureID = <span class="built_in">SOIL_load_OGL_texture</span>(imgPath.<span class="built_in">c_str</span>(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);</span><br><span class="line">    <span class="keyword">if</span> (textureID == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture: &quot;</span> &lt;&lt; imgPath &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的环境光</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::goldAmbient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> ambient[<span class="number">4</span>] = &#123; <span class="number">0.2473f</span>, <span class="number">0.1995f</span>, <span class="number">0.0745f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的漫反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::goldDiffuse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> diffuse[<span class="number">4</span>] = &#123; <span class="number">0.7516f</span>, <span class="number">0.6065f</span>, <span class="number">0.2265f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的镜面反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::goldSpecular</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> specular[<span class="number">4</span>] = &#123; <span class="number">0.6283f</span>, <span class="number">0.5559f</span>, <span class="number">0.3661f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄金材质的光泽度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Util::goldShininess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">51.2f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的环境光</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::silverAmbient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> ambient[<span class="number">4</span>] = &#123; <span class="number">0.1923f</span>, <span class="number">0.1923f</span>, <span class="number">0.1923f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的漫反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::silverDiffuse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> diffuse[<span class="number">4</span>] = &#123; <span class="number">0.5075f</span>, <span class="number">0.5075f</span>, <span class="number">0.5075f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的镜面反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::silverSpecular</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> specular[<span class="number">4</span>] = &#123; <span class="number">0.5083f</span>, <span class="number">0.5083f</span>, <span class="number">0.5083f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白银材质的光泽度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Util::silverShininess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">51.2f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的环境光</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::bronzeAmbient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> ambient[<span class="number">4</span>] = &#123; <span class="number">0.2125f</span>, <span class="number">0.1275f</span>, <span class="number">0.054f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的漫反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::bronzeDiffuse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> diffuse[<span class="number">4</span>] = &#123; <span class="number">0.714f</span>, <span class="number">0.4284f</span>, <span class="number">0.18144f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的镜面反射</span></span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">Util::bronzeSpecular</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> specular[<span class="number">4</span>] = &#123; <span class="number">0.393548f</span>, <span class="number">0.271906f</span>, <span class="number">0.166721f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 青铜材质的光泽度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Util::bronzeShininess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">25.6f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint mvLoc, projLoc, nLoc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源属性</span></span><br><span class="line">GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;</span><br><span class="line"><span class="comment">// 材质属性</span></span><br><span class="line">GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line">glm::vec3 currentLightPos, lightPosV;    <span class="comment">// 模型和视觉空间中的光照位置</span></span><br><span class="line"><span class="type">float</span> lightPos[<span class="number">3</span>];    <span class="comment">// 光照位置的浮点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化光照位置</span></span><br><span class="line">glm::vec3 initialLightLoc = glm::<span class="built_in">vec3</span>(<span class="number">5.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白光特性</span></span><br><span class="line"><span class="type">float</span> globalAmbient[<span class="number">4</span>] = &#123; <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightAmbient[<span class="number">4</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightDiffuse[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightSpecular[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *matAmb = Util::<span class="built_in">goldAmbient</span>();</span><br><span class="line"><span class="type">float</span> *matDif = Util::<span class="built_in">goldDiffuse</span>();</span><br><span class="line"><span class="type">float</span> *matSpe = Util::<span class="built_in">goldSpecular</span>();</span><br><span class="line"><span class="type">float</span> matShi = Util::<span class="built_in">goldShininess</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">model</span><span class="params">(<span class="number">48</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>)</span></span>;</span><br><span class="line"><span class="comment">//ImportedModel model(&quot;unicorn.obj&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">installLights</span><span class="params">(glm::mat4 vMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将光源位置转换为视图空间坐标，存入浮点数组</span></span><br><span class="line">    lightPosV = glm::<span class="built_in">vec3</span>(vMatrix * glm::<span class="built_in">vec4</span>(currentLightPos, <span class="number">1.0</span>));</span><br><span class="line">    lightPos[<span class="number">0</span>] = lightPosV.x;</span><br><span class="line">    lightPos[<span class="number">1</span>] = lightPosV.y;</span><br><span class="line">    lightPos[<span class="number">2</span>] = lightPosV.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在着色器获取光源位置和材质属性</span></span><br><span class="line">    globalAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;globalAmbient&quot;</span>);</span><br><span class="line">    ambLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.ambient&quot;</span>);</span><br><span class="line">    diffLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.diffuse&quot;</span>);</span><br><span class="line">    specLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.specular&quot;</span>);</span><br><span class="line">    posLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.position&quot;</span>);</span><br><span class="line">    mAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.ambient&quot;</span>);</span><br><span class="line">    mDifLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.diffuse&quot;</span>);</span><br><span class="line">    mSpecLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.specular&quot;</span>);</span><br><span class="line">    mShiLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.shininess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在着色器中为光源与材质统一变量赋值</span></span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, globalAmbLoc, <span class="number">1</span>, globalAmbient);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, ambLoc, <span class="number">1</span>, lightAmbient);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, diffLoc, <span class="number">1</span>, lightDiffuse);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, specLoc, <span class="number">1</span>, lightSpecular);</span><br><span class="line">    <span class="built_in">glProgramUniform3fv</span>(renderProgram, posLoc, <span class="number">1</span>, lightPos);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, mAmbLoc, <span class="number">1</span>, matAmb);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, mDifLoc, <span class="number">1</span>, matDif);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, mSpecLoc, <span class="number">1</span>, matSpe);</span><br><span class="line">    <span class="built_in">glProgramUniform1f</span>(renderProgram, mShiLoc, matShi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ind = model.<span class="built_in">getIndices</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">    std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 顶点索引放入缓冲区3</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * ind.<span class="built_in">size</span>(), &amp;ind[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">    nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">35.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于当前光源位置，初始化光照</span></span><br><span class="line">    currentLightPos = glm::<span class="built_in">vec3</span>(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);</span><br><span class="line">    <span class="built_in">installLights</span>(vMat);</span><br><span class="line"></span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line">    <span class="comment">// 构建 MV 矩阵的逆转置矩阵，用于变换法向量</span></span><br><span class="line">    invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());</span></span><br><span class="line">    <span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, model.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Light&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>定义函数 <code>installLights()</code> 将光源在视觉空间中的位置和材质的 ADS 特性读入相应的统一变量。</li>
<li>直接对法向量应用 MV 矩阵不能保证法向量依然与物体表面垂直。使用 MV 矩阵的逆转置矩阵，用于变换法向量。</li>
<li>变量 lightPosV 包含光源在相机空间中的位置，每帧只需要计算一次。</li>
</ul>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositionalLight</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    vec3 position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 vertPos;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec3 vertNormal;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line">uniform mat4 norm_matrix;    <span class="comment">// 用于变换法向量</span></span><br><span class="line">uniform vec4 globalAmbient;</span><br><span class="line">uniform PositionalLight light;</span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将顶点位置和法向量转换到视觉空间</span></span><br><span class="line">    <span class="comment">// 计算视觉空间光照向量（从顶点到光源）</span></span><br><span class="line">    vec4 P = mv_matrix * <span class="built_in">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">    vec3 N = <span class="built_in">normalize</span>((norm_matrix * <span class="built_in">vec4</span>(vertNormal, <span class="number">0.0</span>)).xyz);</span><br><span class="line">    vec3 L = <span class="built_in">normalize</span>(light.position - P.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视觉向量等于视觉空间中负顶点位置</span></span><br><span class="line">    vec3 V = <span class="built_in">normalize</span>(-P.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 是 -L 的相对于表面向量 N 的镜像</span></span><br><span class="line">    vec3 R = <span class="built_in">reflect</span>(-L, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环境光、漫反射和镜面反射分量</span></span><br><span class="line">    vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz;</span><br><span class="line">    vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * <span class="built_in">max</span>(<span class="built_in">dot</span>(N, L), <span class="number">0.0</span>);</span><br><span class="line">    vec3 specular = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(R, V), <span class="number">0.0f</span>), material.shininess) * material.specular.xyz * light.specular.xyz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将颜色输出到片段着色器</span></span><br><span class="line"></span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">    color = <span class="built_in">vec4</span>(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>字段选择器符号“.xyz”，是将 <code>vec4</code> 转换为仅包含其前 3 个元素的等效 <code>vec3</code> 的“快捷方式”。</li>
<li><code>normalize()</code> 用来将向量转换为单位长度。</li>
<li><code>reflect()</code> 函数用与计算一个向量基于另一个向量的反射。</li>
<li><code>dot()</code> 函数为点乘运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">in vec4 color;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>Gouraud 着色容易受到其他伪影影响。</p>
<ul>
<li>如果镜面高光范围内一个模型顶点也没有，那么它可能不会被渲染出来。</li>
<li>镜面反射分量是依顶点计算的，因此，当模型的所有顶点都没有镜面反射分量时，其栅格化后的像素也不会有镜面反射效果。</li>
</ul>
<h4 id="7-5-2-phong-着色">7.5.2 Phong 着色</h4>
<p>该算法的结构类似 Gouraud 着色算法，不同之处在于光照计算是<strong>按像素而非顶点</strong>完成的。</p>
<ul>
<li>顶点着色器
<ol>
<li>计算向量 N、L、V</li>
<li>输出属性 N、L、V、<code>gl_position</code></li>
</ol>
</li>
<li>片段着色器
<ol>
<li>传入插值 N、L、V</li>
<li>计算 R、θ、φ</li>
<li>计算 ADS 分量</li>
<li>输出颜色</li>
</ol>
</li>
</ul>
<p>将之前在顶点着色器中实现的过程移到片段着色器中进行。</p>
<p>故 main.cpp和 Util 类无需改变，只需修改着色器的代码。</p>
<p>对于原始的 Phong 进行优化：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 的计算是非必须的。</li>
<li>角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 可以通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的角平分线向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 得到。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mi>L</mi><mo>+</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">H = L + V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>φ</mi></mrow><annotation encoding="application/x-tex">\theta = \frac{1}{2}\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">φ</span></span></span></span></li>
<li>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 代替 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> 就已经可以获得足够好的结果。</li>
</ul>
</li>
<li>最后镜面反射分量在光泽度乘 3.0 作为改善镜面高光的微调。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_optobPointIncidence.png" alt="使用α代替φ"></p>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositionalLight</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    vec3 position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 vertPos;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec3 vertNormal;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line">uniform mat4 norm_matrix;    <span class="comment">// 用于变换法向量</span></span><br><span class="line">uniform PositionalLight light;</span><br><span class="line"></span><br><span class="line">out vec3 normals;    <span class="comment">// 视觉空间顶点法向量</span></span><br><span class="line">out vec3 lightDir;    <span class="comment">// 指向光源的向量</span></span><br><span class="line">out vec3 halfVector;<span class="comment">// 角平分线向量 H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 _vertPos;    <span class="comment">// 视觉空间中的顶点位置</span></span><br><span class="line">    <span class="comment">// 输出顶点位置、光照方向和法向量到光栅着色器进行插值</span></span><br><span class="line">    _vertPos = (mv_matrix * <span class="built_in">vec4</span>(vertPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">    lightDir = light.position - _vertPos;</span><br><span class="line">    normals = (norm_matrix * <span class="built_in">vec4</span>(vertNormal, <span class="number">1.0</span>)).xyz;</span><br><span class="line">    halfVector = (lightDir + (-_vertPos)).xyz;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositionalLight</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    vec3 position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform vec4 globalAmbient;</span><br><span class="line">uniform PositionalLight light;</span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line">in vec3 normals;</span><br><span class="line">in vec3 lightDir;</span><br><span class="line">in vec3 halfVector;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 归一化光照向量、法向量、平分线向量</span></span><br><span class="line">    vec3 L = <span class="built_in">normalize</span>(lightDir);</span><br><span class="line">    vec3 N = <span class="built_in">normalize</span>(normals);</span><br><span class="line">    vec3 H = <span class="built_in">normalize</span>(halfVector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算光照与平面法向量间的角度</span></span><br><span class="line">    <span class="type">float</span> cosTheta = <span class="built_in">dot</span>(L, N);</span><br><span class="line">    <span class="comment">// 计算法向量 N 与角平分线向量 H 之间的角度</span></span><br><span class="line">    <span class="type">float</span> cosPhi = <span class="built_in">dot</span>(H, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按像素计算 ADS 分量，合并构建输出颜色</span></span><br><span class="line">    vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz;</span><br><span class="line">    vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * <span class="built_in">max</span>(cosTheta, <span class="number">0.0</span>);</span><br><span class="line">    vec3 specular = light.specular.xyz * material.specular.xyz * <span class="built_in">pow</span>(<span class="built_in">max</span>(cosPhi, <span class="number">0.0</span>), material.shininess * <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    fragColor = <span class="built_in">vec4</span>(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="7-6-结合光照和纹理">7.6 结合光照和纹理</h3>
<p>结合光照和纹理的方式取决于物体的特性及其纹理的目的：</p>
<ul>
<li>纹理图像很写实地反映了物体真实的表面外观；</li>
<li>物体同时具有材质和纹理；</li>
<li>材质包括阴影和反射信息；</li>
<li>有多种光或多个纹理</li>
</ul>
<p>当物体拥有一个简单的纹理，同时进行光照时，简单的方法是：</p>
<ol>
<li>在片段着色器中完全将材质特性去除；</li>
<li>使用纹理取样所得纹理颜色代替材质的 ADS 值。</li>
</ol>
<ul>
<li>对于闪亮表面：
<ul>
<li>纹理颜色影响了环境光和漫反射分量，而镜面反射颜色仅由光源决定。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fragColor = textureColor * (ambient + diffuse) + specular;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>对于非闪亮表面：</p>
<ul>
<li>
<p>镜面高光部分应当包含物体表面颜色。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fragColor = textureColor * (ambient + diffuse + specular);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>对于物体既有 ADS 材质，又有纹理图像，加权求和。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">textureColor = <span class="built_in">texture</span>(samp, texCoord);</span><br><span class="line">lightColor = (ambLight * ambMaterial) + (diffLight * diffMaterial) + specLight;</span><br><span class="line">fragColor = <span class="number">0.5</span> * textureColor + <span class="number">0.5</span> * lightColor;</span><br></pre></td></tr></table></figure>
<ul>
<li>结合了光照、材质、纹理，并能够扩展到多个光源、多种材质的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">texture1Color = <span class="built_in">texture</span>(sampler1, texCoord);</span><br><span class="line">texture2Color = <span class="built_in">texture</span>(sampler2, texCoord);</span><br><span class="line">light1Color = (ambLight1 * ambMaterial) + (diffLight1 * diffMaterial) + specLight1;</span><br><span class="line">light2Color = (ambLight2 * ambMaterial) + (diffLight2 * diffMaterial) + specLight2;</span><br><span class="line">fragColor = <span class="number">0.25</span> * texture1Color + </span><br><span class="line">            <span class="number">0.25</span> * texture2Color +</span><br><span class="line">            <span class="number">0.25</span> * light1Color +</span><br><span class="line">            <span class="number">0.25</span> * light2Color;</span><br></pre></td></tr></table></figure>
<p>稍作尝试的一个例子：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_movinglight.gif" alt="青铜材质、冰块纹理、移动光源下的恐龙"></p>
<p>对于这个例子的代码（ImportedModel 类和 Util 类同之前）：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint mvLoc, projLoc, nLoc;</span><br><span class="line">GLuint textureID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源属性</span></span><br><span class="line">GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;</span><br><span class="line"><span class="comment">// 材质属性</span></span><br><span class="line">GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line">glm::vec3 currentLightPos, lightPosV;    <span class="comment">// 模型和视觉空间中的光照位置</span></span><br><span class="line"><span class="type">float</span> lightPos[<span class="number">3</span>];    <span class="comment">// 光照位置的浮点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化光照位置</span></span><br><span class="line">glm::vec3 initialLightLoc = glm::<span class="built_in">vec3</span>(<span class="number">5.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白光特性</span></span><br><span class="line"><span class="type">float</span> globalAmbient[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightAmbient[<span class="number">4</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightDiffuse[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightSpecular[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *matAmb = Util::<span class="built_in">bronzeAmbient</span>();</span><br><span class="line"><span class="type">float</span> *matDif = Util::<span class="built_in">bronzeDiffuse</span>();</span><br><span class="line"><span class="type">float</span> *matSpe = Util::<span class="built_in">bronzeSpecular</span>();</span><br><span class="line"><span class="type">float</span> matShi = Util::<span class="built_in">bronzeShininess</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="comment">//Torus model(48, 0.5f, 0.2f);</span></span><br><span class="line"><span class="comment">// 加载的模型还不能使用索引</span></span><br><span class="line"><span class="function">ImportedModel <span class="title">model</span><span class="params">(<span class="string">&quot;model/velociraptor.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">installLights</span><span class="params">(glm::mat4 vMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将光源位置转换为视图空间坐标，存入浮点数组</span></span><br><span class="line">    lightPosV = glm::<span class="built_in">vec3</span>(vMatrix * glm::<span class="built_in">vec4</span>(currentLightPos, <span class="number">1.0</span>));</span><br><span class="line">    lightPos[<span class="number">0</span>] = lightPosV.x;</span><br><span class="line">    lightPos[<span class="number">1</span>] = lightPosV.y * <span class="number">10.0f</span> * <span class="built_in">cos</span>(<span class="built_in">glfwGetTime</span>() * <span class="number">2.0f</span>);</span><br><span class="line">    lightPos[<span class="number">2</span>] = lightPosV.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在着色器获取光源位置和材质属性</span></span><br><span class="line">    globalAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;globalAmbient&quot;</span>);</span><br><span class="line">    ambLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.ambient&quot;</span>);</span><br><span class="line">    diffLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.diffuse&quot;</span>);</span><br><span class="line">    specLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.specular&quot;</span>);</span><br><span class="line">    posLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.position&quot;</span>);</span><br><span class="line">    mAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.ambient&quot;</span>);</span><br><span class="line">    mDifLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.diffuse&quot;</span>);</span><br><span class="line">    mSpecLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.specular&quot;</span>);</span><br><span class="line">    mShiLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.shininess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在着色器中为光源与材质统一变量赋值</span></span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, globalAmbLoc, <span class="number">1</span>, globalAmbient);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, ambLoc, <span class="number">1</span>, lightAmbient);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, diffLoc, <span class="number">1</span>, lightDiffuse);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, specLoc, <span class="number">1</span>, lightSpecular);</span><br><span class="line">    <span class="built_in">glProgramUniform3fv</span>(renderProgram, posLoc, <span class="number">1</span>, lightPos);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, mAmbLoc, <span class="number">1</span>, matAmb);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, mDifLoc, <span class="number">1</span>, matDif);</span><br><span class="line">    <span class="built_in">glProgramUniform4fv</span>(renderProgram, mSpecLoc, <span class="number">1</span>, matSpe);</span><br><span class="line">    <span class="built_in">glProgramUniform1f</span>(renderProgram, mShiLoc, matShi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::vector&lt;int&gt; ind = model.getIndices();</span></span><br><span class="line">    std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">    std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">    std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">        pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">        tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">        nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">    <span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 顶点索引放入缓冲区3</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, 4 * ind.size(), &amp;ind[0], GL_STATIC_DRAW);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;Phong/vertex.glsl&quot;</span>, <span class="string">&quot;Phong/fragment.glsl&quot;</span>);</span><br><span class="line">    cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">    pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeVertexArray</span>();</span><br><span class="line"></span><br><span class="line">    textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;textureImg/ice.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">    mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">    projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">    nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">    mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">35.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    mMat *= glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">5.0f</span>, <span class="number">5.0f</span>, <span class="number">5.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于当前光源位置，初始化光照</span></span><br><span class="line">    currentLightPos = glm::<span class="built_in">vec3</span>(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);</span><br><span class="line">    <span class="built_in">installLights</span>(vMat);</span><br><span class="line"></span><br><span class="line">    mvMat = vMat * mMat;</span><br><span class="line">    <span class="comment">// 构建 MV 矩阵的逆转置矩阵，用于变换法向量</span></span><br><span class="line">    invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewIsSupported</span>(<span class="string">&quot;GL_EXT_texture_filter_anisotropic&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        GLfloat anisoSetting = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="built_in">glGetFloatv</span>(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;anisoSetting);</span><br><span class="line">        <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoSetting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, model.<span class="built_in">getNumVertices</span>());</span><br><span class="line">    <span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[3]);</span></span><br><span class="line">    <span class="comment">//glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Light&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositionalLight</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    vec3 position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 vertPos;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 texCoord;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec3 vertNormal;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br><span class="line"></span><br><span class="line">uniform mat4 mv_matrix;</span><br><span class="line">uniform mat4 proj_matrix;</span><br><span class="line">uniform mat4 norm_matrix;    <span class="comment">// 用于变换法向量</span></span><br><span class="line">uniform PositionalLight light;</span><br><span class="line"></span><br><span class="line">out vec3 normals;    <span class="comment">// 视觉空间顶点法向量</span></span><br><span class="line">out vec3 lightDir;    <span class="comment">// 指向光源的向量</span></span><br><span class="line">out vec3 halfVector;<span class="comment">// 角平分线向量 H</span></span><br><span class="line">out vec2 tc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 _vertPos;    <span class="comment">// 视觉空间中的顶点位置</span></span><br><span class="line">    <span class="comment">// 输出顶点位置、光照方向和法向量到光栅着色器进行插值</span></span><br><span class="line">    _vertPos = (mv_matrix * <span class="built_in">vec4</span>(vertPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">    lightDir = light.position - _vertPos;</span><br><span class="line">    normals = (norm_matrix * <span class="built_in">vec4</span>(vertNormal, <span class="number">1.0</span>)).xyz;</span><br><span class="line">    halfVector = (lightDir + (-_vertPos)).xyz;</span><br><span class="line">    gl_Position = proj_matrix * mv_matrix * <span class="built_in">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">    tc = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositionalLight</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    vec3 position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span></span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform sampler2D samp;</span><br><span class="line"></span><br><span class="line">uniform vec4 globalAmbient;</span><br><span class="line">uniform PositionalLight light;</span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line">in vec2 tc;</span><br><span class="line">in vec3 normals;</span><br><span class="line">in vec3 lightDir;</span><br><span class="line">in vec3 halfVector;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 归一化光照向量、法向量、视觉向量</span></span><br><span class="line">    vec3 L = <span class="built_in">normalize</span>(lightDir);</span><br><span class="line">    vec3 N = <span class="built_in">normalize</span>(normals);</span><br><span class="line">    vec3 H = <span class="built_in">normalize</span>(halfVector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算光照与平面法向量间的角度</span></span><br><span class="line">    <span class="type">float</span> cosTheta = <span class="built_in">dot</span>(L, N);</span><br><span class="line">    <span class="comment">// 计算法向量 N 与角平分线向量 H 之间的角度</span></span><br><span class="line">    <span class="type">float</span> cosPhi = <span class="built_in">dot</span>(H, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按像素计算 ADS 分量，合并构建输出颜色</span></span><br><span class="line">    vec3 ambient = ((globalAmbient * material.ambient) + (light.ambient * material.ambient)).xyz;</span><br><span class="line">    vec3 diffuse = light.diffuse.xyz * material.diffuse.xyz * <span class="built_in">max</span>(cosTheta, <span class="number">0.0</span>);</span><br><span class="line">    vec3 specular = light.specular.xyz * material.specular.xyz * <span class="built_in">pow</span>(<span class="built_in">max</span>(cosPhi, <span class="number">0.0</span>), material.shininess * <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    vec4 textureColor = <span class="built_in">texture</span>(samp, tc);</span><br><span class="line">    vec4 lightColor = light.ambient + light.diffuse + light.specular;</span><br><span class="line">    vec4 stripLightColor = <span class="built_in">vec4</span>(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    fragColor = <span class="number">0.3</span> * textureColor + <span class="number">0.7</span> * stripLightColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="八-阴影">八、阴影</h2>
<h3 id="8-1-投影阴影">8.1 投影阴影</h3>
<p>投影阴影：给定一个位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1, z_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的点光源，一个需要渲染的物体（物体上的点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_w, y_w, z_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）和一个投射阴影的平面，可以通过生成一个变换矩阵：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_projectedShadow.png" alt="投影阴影"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>w</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>S</mi></msub><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>z</mi><mi>S</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_w, y_w, z_w)\rightarrow(x_S,0,z_S)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>通常使用暗色物体与地平面纹理混合作为阴影的纹理。</li>
</ul>
<p>投影阴影易于实现，但仅适用于平坦表面。</p>
<h3 id="8-2-阴影体">8.2 阴影体</h3>
<p>找到被物体阴影覆盖的阴影体，之后减少视体与阴影体相交部分中的多边形的颜色强度。</p>
<p>阴影体的优点在于其高度准确，比起其他方法来更不容易产生伪影。</p>
<p>几何着色器可以用于计算阴影体，模板缓冲区可以用于判断像素<br>
是否在阴影体内。有些显卡对于特定的阴影体操作优化提供了硬件支持。</p>
<h3 id="8-3-阴影贴图">8.3 阴影贴图</h3>
<p>阴影贴图的想法：光线无法“看到”的任何东西都在阴影中。也就是说，如果对象 1 阻挡光线到达对象 2，等同于光线不能“看到”对象 2</p>
<p>所以计算策略是：暂时将相机移动到光的位置，应用 Z-buffer 算法，然后使用生成的深度信息来计算。</p>
<p>由此可得，渲染场景需要两轮：</p>
<ul>
<li>第一轮从光源角度渲染场景（不绘制）。对于每个像素，深度缓冲区包含光源与最近的对象之间的距离。
<ul>
<li>生成深度缓冲区。</li>
</ul>
</li>
<li>将深度缓冲区复制到纹理对象。
<ul>
<li>当纹理对象用于储存阴影深度信息时，称其为阴影纹理。</li>
<li>将深度缓冲区复制到纹理中的过程称为“阴影贴图”。</li>
</ul>
</li>
<li>第二轮从相机角度渲染场景（正常渲染）。对于每个像素，在阴影纹理中查找相应的位置。
<ul>
<li>如果相机到渲染点的距离大于从阴影纹理检索到的值，则在该像素处绘制的对象离光源的距离比当前离光源最近的对象离光源更远，得出该像素处于阴影中。</li>
</ul>
</li>
</ul>
<p>阴影的处理：仅渲染环境光，忽略漫反射和镜面反射分量。</p>
<h4 id="8-3-1-第一轮-从光源位置绘制">8.3.1 第一轮——从光源位置绘制</h4>
<p>第一轮中并不是真的在显示其中绘制场景，故仅需用到顶点着色器。</p>
<p>通过变换矩阵（构建观察矩阵）移动相机：</p>
<ul>
<li>相机移动到光源的位置</li>
<li>相机方向朝向呈现的区域</li>
</ul>
<p>第一轮需要处理的细节：</p>
<ol>
<li>配置缓冲区和阴影纹理。</li>
<li>禁用颜色输出。</li>
<li>在光源处为视野中的物体构建一个 LookAt 矩阵。</li>
<li>启用 GLSL 第一轮着色器程序，准备接受 MVP 矩阵。
<ul>
<li>M：对象的模型矩阵</li>
<li>V：LookAt 矩阵作为观察矩阵</li>
<li>P：透视矩阵</li>
<li>该 MVP 矩阵 称为 <code>shadowMVP</code>。</li>
</ul>
</li>
<li>为每个对象创建一个 <code>shadowMVP</code> 矩阵，并调用 <code>glDrawArrays()</code>。</li>
</ol>
<p>顶点着色器变成：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> shadowMVP;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">gl_Position</span> = shadowMVP * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器变成：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"><span class="type">void</span> main() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-将深度缓冲区复制到纹理">8.3.2 将深度缓冲区复制到纹理</h4>
<p>OpenGL 提供了两种将深度缓冲区深度数据放入纹理单元的方法：</p>
<ol>
<li>生成空阴影纹理，然后使用命令 <code>glCopyTexImage2D()</code> 将活动的深度缓冲区复制到阴影纹理中。</li>
<li>在第一轮中构建“自定义帧缓冲区”，并使用命令 <code>glFrameBufferTexture2D()</code> 将阴影纹理附加到上面。
<ul>
<li>使用该方法无须将深度缓冲区复制到纹理，因为缓冲区已经附加了纹理，深度信息由 OpenGL 自动放入纹理中。</li>
</ul>
</li>
</ol>
<h4 id="8-3-3-第二轮-从相机位置绘制">8.3.3 第二轮——从相机位置绘制</h4>
<p>第二轮需要渲染完整的场景、其中的所有物体以及光照、材质和装饰场景中物体的纹理，同时还确定阴影。</p>
<p>使用两个 MVP 矩阵：</p>
<ol>
<li>一个将对象坐标转换为屏幕坐标的标准 MVP 矩阵（像之前一样）；</li>
<li>一个是第一轮生成的 shadowMVP 矩阵，用于从光源的角度进行渲染，即从阴影纹理中查找深度信息。</li>
</ol>
<p>从纹理贴图查找像素时，应该处理 OpenGL 相机空间使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 而纹理贴图使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 空间的问题：</p>
<ul>
<li>使用额外的变换矩阵  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。
<ul>
<li>用于从相机空间到纹理空间的转换</li>
</ul>
</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">B = \begin{bmatrix}
0.5 &amp; 0 &amp; 0 &amp; 0.5 \\
0 &amp; 0.5 &amp; 0 &amp; 0.5 \\
0 &amp; 0 &amp; 0.5 &amp; 0.5 \\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80303em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 和 <code>shadowMVP</code> 矩阵相乘，得到 <code>shadowMVP2</code> 矩阵。</p>
<p>第二轮的大概操作：</p>
<ol>
<li>构建变换矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，用于从光照空间转换到纹理空间。</li>
<li>启用阴影纹理，进行查找。</li>
<li>启用颜色输出。</li>
<li>启用 GLSL 第二轮渲染程序。</li>
<li>根据相机正常位置为对象构建 MVP 矩阵。</li>
<li>构建 shadowMVP2 矩阵。着色器用其查找阴影纹理中的像素坐标。</li>
<li>将生成的变换矩阵发送到着色器统一变量。</li>
<li>启用包含顶点、法向量和纹理坐标的缓冲区。</li>
<li>调用 <code>glDrawArrays()</code>。</li>
</ol>
<p>着色器的工作：</p>
<ul>
<li>顶点着色器将顶点位置从相机空间转换为光照空间，将结果发送到顶点属性中的片段着色器。</li>
<li>片段着色器调用 <code>textureProj()</code> 函数指示像素是否处于引用中（返回0或1）。如果位于阴影中，则剔除漫反射和镜面反射。
<ul>
<li>使用特殊采样器变量类型 <code>sampler2DShadow</code>，可以附加到程序中的阴影纹理中。</li>
</ul>
</li>
</ul>
<p>关注细节：正在渲染的像素和阴影纹理中的值的深度比较</p>
<ol>
<li>在模型空间中使用顶点坐标，与 shadowMVP2 相乘生成阴影纹理坐标（对应于投影到光照空间中的顶点坐标，是之前从光源视角生成的）。</li>
<li>经过插值后的光照空间（3D）坐标 (x, y, z) 在片段着色器中使用情况：
<ul>
<li>z 分量表示从光到像素的距离；</li>
<li>(x, y) 分量用于检索存储在阴影纹理（2D）中的深度信息。</li>
</ul>
</li>
<li>将该检索的值（到最靠近光的物体的距离）与 z 进行比较。</li>
</ol>
<p>例子效果展示如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_shadow.jpg" alt="光从左往右发出"></p>
<p>代码：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">5</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line">GLuint renderProgram1, renderProgram2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc, nLoc, sLoc;</span><br><span class="line">GLuint textureID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源属性</span></span><br><span class="line">GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;</span><br><span class="line"><span class="comment">// 材质属性</span></span><br><span class="line">GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line">glm::vec3 currentLightPos, lightPosV;	<span class="comment">// 模型和视觉空间中的光照位置</span></span><br><span class="line"><span class="type">float</span> lightPos[<span class="number">3</span>];	<span class="comment">// 光照位置的浮点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 白光特性</span></span><br><span class="line"><span class="type">float</span> globalAmbient[<span class="number">4</span>] = &#123; <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightAmbient[<span class="number">4</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightDiffuse[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightSpecular[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 材质</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> *ambient, *diffuse, *specular;</span><br><span class="line">	<span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Material gold&#123; Util::<span class="built_in">goldAmbient</span>(), Util::<span class="built_in">goldDiffuse</span>(), Util::<span class="built_in">goldSpecular</span>(), Util::<span class="built_in">goldShininess</span>() &#125;;</span><br><span class="line">Material silver&#123; Util::<span class="built_in">silverAmbient</span>(), Util::<span class="built_in">silverDiffuse</span>(), Util::<span class="built_in">silverSpecular</span>(), Util::<span class="built_in">silverShininess</span>() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阴影相关</span></span><br><span class="line"><span class="type">int</span> scSizeX, scSizeY;</span><br><span class="line">GLuint shadowTex, shadowBuffer;</span><br><span class="line">glm::mat4 lightVmatrix, lightPmatrix;</span><br><span class="line">glm::mat4 shadowMVP1, shadowMVP2;</span><br><span class="line">glm::mat4 b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型相关</span></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">model1</span><span class="params">(<span class="number">48</span>, <span class="number">0.6f</span>, <span class="number">0.4f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 加载的模型还不能使用索引</span></span><br><span class="line"><span class="function">ImportedModel <span class="title">model2</span><span class="params">(<span class="string">&quot;model/pyr.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置相关</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">cameraLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">6.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">lightLoc</span><span class="params">(<span class="number">-3.8f</span>, <span class="number">2.2f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">model1Loc</span><span class="params">(<span class="number">1.6f</span>, <span class="number">0.0f</span>, <span class="number">-0.3f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">model2Loc</span><span class="params">(<span class="number">-1.0f</span>, <span class="number">0.1f</span>, <span class="number">0.3f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">installLights</span><span class="params">(GLuint renderProgram, glm::mat4 vMatrix, Material &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将光源位置转换为视图空间坐标，存入浮点数组</span></span><br><span class="line">	lightPosV = glm::<span class="built_in">vec3</span>(vMatrix * glm::<span class="built_in">vec4</span>(currentLightPos, <span class="number">1.0</span>));</span><br><span class="line">	lightPos[<span class="number">0</span>] = lightPosV.x;</span><br><span class="line">	lightPos[<span class="number">1</span>] = lightPosV.y;</span><br><span class="line">	lightPos[<span class="number">2</span>] = lightPosV.z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器获取光源位置和材质属性</span></span><br><span class="line">	globalAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;globalAmbient&quot;</span>);</span><br><span class="line">	ambLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.ambient&quot;</span>);</span><br><span class="line">	diffLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.diffuse&quot;</span>);</span><br><span class="line">	specLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.specular&quot;</span>);</span><br><span class="line">	posLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.position&quot;</span>);</span><br><span class="line">	mAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.ambient&quot;</span>);</span><br><span class="line">	mDifLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.diffuse&quot;</span>);</span><br><span class="line">	mSpecLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.specular&quot;</span>);</span><br><span class="line">	mShiLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.shininess&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器中为光源与材质统一变量赋值</span></span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, globalAmbLoc, <span class="number">1</span>, globalAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, ambLoc, <span class="number">1</span>, lightAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, diffLoc, <span class="number">1</span>, lightDiffuse);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, specLoc, <span class="number">1</span>, lightSpecular);</span><br><span class="line">	<span class="built_in">glProgramUniform3fv</span>(renderProgram, posLoc, <span class="number">1</span>, lightPos);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mAmbLoc, <span class="number">1</span>, m.ambient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mDifLoc, <span class="number">1</span>, m.diffuse);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mSpecLoc, <span class="number">1</span>, m.specular);</span><br><span class="line">	<span class="built_in">glProgramUniform1f</span>(renderProgram, mShiLoc, m.shininess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// model1的顶点构建</span></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; model1Ind = model<span class="number">1.</span><span class="built_in">getIndices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model<span class="number">1.</span><span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model<span class="number">1.</span><span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; model1Pvalues;	<span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; model1Nvalues;	<span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model<span class="number">1.</span><span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		model1Pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		model1Pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		model1Pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		model1Nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		model1Nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		model1Nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// model2的顶点构建</span></span><br><span class="line">	vert = model<span class="number">2.</span><span class="built_in">getVertices</span>();</span><br><span class="line">	norm = model<span class="number">2.</span><span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; model2Pvalues;	<span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; model2Nvalues;	<span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model<span class="number">2.</span><span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		model2Pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		model2Pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		model2Pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		model2Nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		model2Nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		model2Nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// model1</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * model1Pvalues.<span class="built_in">size</span>(), &amp;model1Pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * model1Nvalues.<span class="built_in">size</span>(), &amp;model1Nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * model1Ind.<span class="built_in">size</span>(), &amp;model1Ind[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// model2</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * model2Pvalues.<span class="built_in">size</span>(), &amp;model2Pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * model2Nvalues.<span class="built_in">size</span>(), &amp;model2Nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupShadowBuffers</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	scSizeX = width;</span><br><span class="line">	scSizeY = height;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建自定义帧缓冲区</span></span><br><span class="line">	<span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;shadowBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建阴影纹理并让它存储深度信息</span></span><br><span class="line">	<span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;shadowTex);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, shadowTex);</span><br><span class="line">	<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT32,</span><br><span class="line">		scSizeX, scSizeY, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram1 = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;shadows/vertex1.glsl&quot;</span>, <span class="string">&quot;shadows/fragment1.glsl&quot;</span>);</span><br><span class="line">	renderProgram2 = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;shadows/vertex2.glsl&quot;</span>, <span class="string">&quot;shadows/fragment2.glsl&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line">	<span class="built_in">setupShadowBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">	b = glm::<span class="built_in">mat4</span>(</span><br><span class="line">		<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制model1</span></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), model1Loc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">25.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	shadowMVP1 = lightPmatrix * lightVmatrix * mMat;</span><br><span class="line">	sLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram1, <span class="string">&quot;shadowMVP&quot;</span>);</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(sLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(shadowMVP1));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model<span class="number">1.</span><span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制model2</span></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), model2Loc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">30.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">40.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	shadowMVP1 = lightPmatrix * lightVmatrix * mMat;</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(sLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(shadowMVP1));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, model<span class="number">2.</span><span class="built_in">getNumVertices</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram2);</span><br><span class="line"></span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram2, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram2, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">	nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram2, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line">	sLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram2, <span class="string">&quot;shadowMVP&quot;</span>);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制model1</span></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), model1Loc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">25.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	currentLightPos = glm::<span class="built_in">vec3</span>(lightLoc);</span><br><span class="line">	<span class="built_in">installLights</span>(renderProgram2, vMat, gold);</span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line">	invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line">	shadowMVP2 = b * lightPmatrix * lightVmatrix * mMat;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(sLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(shadowMVP2));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model<span class="number">1.</span><span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制model2</span></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), model2Loc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">30.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">40.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	currentLightPos = glm::<span class="built_in">vec3</span>(lightLoc);</span><br><span class="line">	<span class="built_in">installLights</span>(renderProgram2, vMat, silver);</span><br><span class="line"></span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line">	invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line">	shadowMVP2 = b * lightPmatrix * lightVmatrix * mMat;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(sLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(shadowMVP2));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, model<span class="number">2.</span><span class="built_in">getNumVertices</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	currentLightPos = glm::<span class="built_in">vec3</span>(lightLoc);</span><br><span class="line">	lightVmatrix = glm::<span class="built_in">lookAt</span>(currentLightPos, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	lightPmatrix = glm::<span class="built_in">perspective</span>(<span class="number">60.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, shadowBuffer);</span><br><span class="line">	<span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, shadowTex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_POLYGON_OFFSET_FILL);</span><br><span class="line">	<span class="built_in">glPolygonOffset</span>(<span class="number">2.0f</span>, <span class="number">4.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">passOne</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDisable</span>(GL_POLYGON_OFFSET_FILL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, shadowTex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDrawBuffer</span>(GL_FRONT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">passTwo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Light&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>第一轮的着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex1.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> shadowMVP;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">gl_Position</span> = shadowMVP * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment1.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>第二轮的着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex2.glsl</span></span><br><span class="line"><span class="meta">#version 460</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient, diffuse, specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Material</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient, diffuse, specular;</span><br><span class="line">	<span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> vNormal, vLightDir, vVertPos, vHalfVec;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> shadowCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> globalAmbient;</span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> norm_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> shadowMVP;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 输出顶点位置</span></span><br><span class="line">	vVertPos = (mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">	<span class="comment">// 获取一个从顶点到光线的向量并输出</span></span><br><span class="line">	vLightDir = light.position - vVertPos;</span><br><span class="line">	<span class="comment">// 在视图空间中获得一个顶点法向量输出</span></span><br><span class="line">	vNormal = (norm_matrix * <span class="type">vec4</span>(vertNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">	<span class="comment">// 计算顶点的半向量</span></span><br><span class="line">	vHalfVec = (vLightDir - vVertPos).xyz;</span><br><span class="line"></span><br><span class="line">	shadowCoord = shadowMVP * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment2.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient, diffuse, specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Material</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient, diffuse, specular;</span><br><span class="line">	<span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> vNormal, vLightDir, vVertPos, vHalfVec;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> shadowCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> globalAmbient;</span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> norm_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> shadowMVP;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2DShadow</span> shadowTex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec3</span> L = <span class="built_in">normalize</span>(vLightDir);</span><br><span class="line">	<span class="type">vec3</span> N = <span class="built_in">normalize</span>(vNormal);</span><br><span class="line">	<span class="type">vec3</span> V = <span class="built_in">normalize</span>(-vVertPos);</span><br><span class="line">	<span class="type">vec3</span> H = <span class="built_in">normalize</span>(vHalfVec);</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> inShadow = <span class="built_in">textureProj</span>(shadowTex, shadowCoord);</span><br><span class="line"></span><br><span class="line">	fragColor = globalAmbient * material.ambient + light.ambient * material.ambient;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inShadow != <span class="number">0.0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fragColor +=</span><br><span class="line">			light.diffuse * material.diffuse * <span class="built_in">max</span>(<span class="built_in">dot</span>(L, N), <span class="number">0.0</span>) +</span><br><span class="line">			light.specular * material.specular * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(H, N), <span class="number">0.0</span>), material.shininess * <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="8-4-柔和阴影">8.4 柔和阴影</h3>
<p>使用百分比临近滤波 PCF 生成柔和阴影。</p>
<p>一种用于实现 PCF 的常见算法是：</p>
<ul>
<li>对每个像素附近的 4 个纹元（纹理图像像素）进行采样，其中样本通过像素对应纹元的特定偏移量选择。</li>
<li>对于每个像素，都需要改变偏移量，并用新的偏移量确定采样的 4 个纹元。</li>
<li>使用交错的方式改变偏移量的方法被称为抖动，它旨在使柔和阴影的边界不会由于采样点不足而看起来“结块”。</li>
</ul>
<p>假设有4种偏移模式，每次取一种计算像素 <code>glFragCorrd mod 2</code> 值选择当前偏移，结果可能为：(0,0)、(1,0)、(0,1)、(1,1)。</p>
<p>偏移模式通常在 x 和 y 方向上指定，具有-1.5、-0.5、+0.5和+1.5不同组合：</p>
<p>4种计算结果对应的偏移模式采样点如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">计算结果</th>
<th style="text-align:center">(0,0)</th>
<th style="text-align:center">(0,1)</th>
<th style="text-align:center">(1,0)</th>
<th style="text-align:center">(1,1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-1.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x-0.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y+1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+0.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y-0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mn>1.5</mn><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_x+1.5,s_y-1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>假设随便一组，对其4个采样点分别调用 <code>textureProj()</code>，将得到的4个结果相加求平均，确定阴影中采样点的百分比，以此百分比作系数，确定渲染当前像素时要应用的漫反射和镜面反射分量。</p>
<p>采样点可以有多个，但渲染速度也会随之下降。</p>
<p>64个采样点柔和阴影效果如下：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_softShadows.jpg" alt="柔和阴影"></p>
<p>仅需修改第二轮的片段着色器：</p>
<details><summary>fragment2.glsl</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient, diffuse, specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Material</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient, diffuse, specular;</span><br><span class="line">	<span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> vNormal, vLightDir, vVertPos, vHalfVec;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> shadowCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> globalAmbient;</span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> norm_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> shadowMVP;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2DShadow</span> shadowTex;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lookup(<span class="type">float</span> ox, <span class="type">float</span> oy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> t = <span class="built_in">textureProj</span>(shadowTex,</span><br><span class="line">		shadowCoord + <span class="type">vec4</span>(ox * <span class="number">0.001</span> * shadowCoord.w, oy * <span class="number">0.001</span> * shadowCoord.w,</span><br><span class="line">			<span class="number">-0.01</span>, <span class="number">0.0</span>));</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> shadowFactor = <span class="number">0.0</span>;</span><br><span class="line">	<span class="type">vec3</span> L = <span class="built_in">normalize</span>(vLightDir);</span><br><span class="line">	<span class="type">vec3</span> N = <span class="built_in">normalize</span>(vNormal);</span><br><span class="line">	<span class="type">vec3</span> V = <span class="built_in">normalize</span>(-vVertPos);</span><br><span class="line">	<span class="type">vec3</span> H = <span class="built_in">normalize</span>(vHalfVec);</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> swidth = <span class="number">2.5</span>;	<span class="comment">// 可调整的阴影扩散量</span></span><br><span class="line">	<span class="comment">// 64 个采样点</span></span><br><span class="line">	<span class="type">float</span> endp = swidth * <span class="number">3.0</span> + swidth / <span class="number">2.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">float</span> m = -endp; m &lt;= endp; m += swidth)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> n = -endp; n &lt;= endp; n += swidth)</span><br><span class="line">			shadowFactor += lookup(m, n);</span><br><span class="line"></span><br><span class="line">	shadowFactor /= <span class="number">64.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">vec4</span> shadowColor = globalAmbient * material.ambient + light.ambient * material.ambient;</span><br><span class="line">	<span class="type">vec4</span> lightedColor = light.diffuse * material.diffuse * <span class="built_in">max</span>(<span class="built_in">dot</span>(L, N), <span class="number">0.0</span>) +</span><br><span class="line">		light.specular * material.specular *</span><br><span class="line">		<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(H, N), <span class="number">0.0</span>), material.shininess * <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">	fragColor = <span class="type">vec4</span>((shadowColor.xyz + shadowFactor * (lightedColor.xyz)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>有些时候，在场景中的某些对象拥有纹理时，添加阴影时必须确保片段着色器正确区分阴影纹理和其他纹理。一种简单的方法是将它们绑定到不同的纹理单元：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2DShadow</span> shadowTex;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> tex;</span><br></pre></td></tr></table></figure>
<p>然后通过绑定值引用两个采样器。</p>
<p>当场景使用多个灯光时，则需要多个阴影纹理，即每个光源需要一个阴影纹理。</p>
<ul>
<li>每个光源都需要单独执行第 1 轮渲染，并在第 2 轮渲染中合并结果。</li>
</ul>
<h2 id="九-天空和背景">九、天空和背景</h2>
<h3 id="9-1-天空盒">9.1 天空盒</h3>
<p>天空盒：</p>
<ol>
<li>实例化一个立方体对象</li>
<li>将立方体的纹理设置为所需的环境</li>
<li>将立方体围绕相机设置</li>
</ol>
<p>如何为地平线制作纹理：</p>
<ul>
<li>使用一个包含6个面的纹理图像。</li>
<li>可使用 Terragen、Blender、PS等软件工具辅助构建贴图图像。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_cubeTexCoord.png" alt="立方体贴图纹理坐标"></p>
<p>如何让天空盒看起来距离很远：</p>
<ul>
<li>确保纹理表现看起来像远处的地平线。</li>
<li>禁用深度测试并先渲染天空盒，然后启用深度测试再渲染其他对象。
<ul>
<li>深度缓冲区的值仍全设为1.0（最远距离）。</li>
</ul>
</li>
<li>使天空盒随着相机移动。</li>
</ul>
<h3 id="9-2-穹顶">9.2 穹顶</h3>
<p>与天空盒类似，不过使用带纹理的球体或半球体代替带纹理的立方体。</p>
<p>一样需要先禁用深度测试渲染穹顶，再将相机置于穹顶的中心位置。</p>
<p>穹顶相比天空盒：</p>
<ul>
<li>优点：不易受到畸变和接缝的影响（尽管在纹理图像<br>
中必须考虑极点处的球形畸变）。</li>
<li>缺点：球体或穹顶模型比立方体模型更复杂，穹顶有更多的顶点，其数量取决于期望的精度。</li>
</ul>
<h3 id="9-3-实现天空盒">9.3 实现天空盒</h3>
<h4 id="9-3-1-从头开始构建天空盒">9.3.1 从头开始构建天空盒</h4>
<p>效果如下图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_skybox.jpg" alt="天空盒"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">5</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc;</span><br><span class="line">GLuint textureID, skyboxTex;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型相关</span></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">model</span><span class="params">(<span class="number">48</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 加载的模型还不能使用索引</span></span><br><span class="line"><span class="comment">//ImportedModel model2(&quot;model/pyr.obj&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置相关</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">cameraLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">modelLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">-0.75</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 立方体天空盒</span></span><br><span class="line">	<span class="type">float</span> cubeVertexPositions[<span class="number">108</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">float</span> cubeTextureCoord[<span class="number">72</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">1.00f</span>, <span class="number">0.666666f</span>, <span class="number">1.00f</span>, <span class="number">0.333333f</span>, <span class="number">0.75f</span>, <span class="number">0.333333f</span>,</span><br><span class="line">		<span class="number">0.75f</span>, <span class="number">0.333333f</span>, <span class="number">0.75f</span>, <span class="number">0.666666f</span>, <span class="number">1.00f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.75f</span>, <span class="number">0.333333f</span>, <span class="number">0.50f</span>, <span class="number">0.333333f</span>, <span class="number">0.75f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.50f</span>, <span class="number">0.333333f</span>, <span class="number">0.50f</span>, <span class="number">0.666666f</span>, <span class="number">0.75f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.50f</span>, <span class="number">0.333333f</span>, <span class="number">0.25f</span>, <span class="number">0.333333f</span>, <span class="number">0.50f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.25f</span>, <span class="number">0.333333f</span>, <span class="number">0.25f</span>, <span class="number">0.666666f</span>, <span class="number">0.50f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.25f</span>, <span class="number">0.333333f</span>, <span class="number">0.00f</span>, <span class="number">0.333333f</span>, <span class="number">0.25f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.00f</span>, <span class="number">0.333333f</span>, <span class="number">0.00f</span>, <span class="number">0.666666f</span>, <span class="number">0.25f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.25f</span>, <span class="number">0.333333f</span>, <span class="number">0.50f</span>, <span class="number">0.333333f</span>, <span class="number">0.50f</span>, <span class="number">0.000000f</span>,</span><br><span class="line">		<span class="number">0.50f</span>, <span class="number">0.000000f</span>, <span class="number">0.25f</span>, <span class="number">0.000000f</span>, <span class="number">0.25f</span>, <span class="number">0.333333f</span>,</span><br><span class="line">		<span class="number">0.25f</span>, <span class="number">1.000000f</span>, <span class="number">0.50f</span>, <span class="number">1.000000f</span>, <span class="number">0.50f</span>, <span class="number">0.666666f</span>,</span><br><span class="line">		<span class="number">0.50f</span>, <span class="number">0.666666f</span>, <span class="number">0.25f</span>, <span class="number">0.666666f</span>, <span class="number">0.25f</span>, <span class="number">1.000000f</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; modelInd = model.<span class="built_in">getIndices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelPvalues;	<span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelTvalues;	<span class="comment">// 纹理坐标</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelNvalues;	<span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		modelTvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">		modelTvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 天空盒</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(cubeTextureCoord), cubeTextureCoord, GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// model</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * modelPvalues.<span class="built_in">size</span>(), &amp;modelPvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * modelTvalues.<span class="built_in">size</span>(), &amp;modelTvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * modelInd.<span class="built_in">size</span>(), &amp;modelInd[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line">	textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;textureImg/brick1.jpg&quot;</span>);</span><br><span class="line">	skyboxTex = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;textureImg/alien.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 天空盒</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line">	<span class="comment">// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置</span></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), cameraLoc);</span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, skyboxTex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);    <span class="comment">// 观察立方体内部，反转方向</span></span><br><span class="line">	<span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="comment">// 无深度测试下绘制天空盒</span></span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制场景对象</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), modelLoc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, glm::<span class="built_in">radians</span>(<span class="number">15.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Skybox&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> tc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	tc = texCoord;</span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> tc;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	fragColor = <span class="built_in">texture</span>(s, tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h4 id="9-3-2-使用opengl立方体贴图">9.3.2 使用OpenGL立方体贴图</h4>
<p>OpenGL 纹理立方体贴图使用带有 3 个变量的纹理坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s, t, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 访问。</p>
<p>立方体贴图的另一个特性是，其中的图像以纹理图像的左上角作为纹理坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p>
<p>另外定义函数 <code>loadCubeMap()</code> 函数读入6个单独的立方体面图像文件，以这种形式再调用 <code>SOIL_load_OGL_cubemap()</code> 进行构建纹理。该函数置于 <code>Util</code> 类中。</p>
<p>效果截图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_skybox2.jpg" alt="天空盒"></p>
<p>代码如下：</p>
<details><summary>新增函数</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">Util::loadCubeMap</span><span class="params">(<span class="type">const</span> std::string &amp;mapDirPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GLuint textureRef;</span><br><span class="line">	std::string xp = mapDirPath + <span class="string">&quot;/xp.jpg&quot;</span>;</span><br><span class="line">	std::string xn = mapDirPath + <span class="string">&quot;/xn.jpg&quot;</span>;</span><br><span class="line">	std::string yp = mapDirPath + <span class="string">&quot;/yp.jpg&quot;</span>;</span><br><span class="line">	std::string yn = mapDirPath + <span class="string">&quot;/yn.jpg&quot;</span>;</span><br><span class="line">	std::string zp = mapDirPath + <span class="string">&quot;/zp.jpg&quot;</span>;</span><br><span class="line">	std::string zn = mapDirPath + <span class="string">&quot;/zn.jpg&quot;</span>;</span><br><span class="line">	textureRef = <span class="built_in">SOIL_load_OGL_cubemap</span>(xp.<span class="built_in">c_str</span>(), xn.<span class="built_in">c_str</span>(), yp.<span class="built_in">c_str</span>(), yn.<span class="built_in">c_str</span>(), zp.<span class="built_in">c_str</span>(), zn.<span class="built_in">c_str</span>(), SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_MIPMAPS);</span><br><span class="line">	<span class="keyword">if</span> (textureRef == <span class="number">0</span>)	std::cout &lt;&lt; <span class="string">&quot;Failed to load texture: &quot;</span> &lt;&lt; mapDirPath &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> textureRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line">GLuint renderProgram, renderProgramCubeMap;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc, vLoc;</span><br><span class="line">GLuint textureID, skyboxTex;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型相关</span></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">model</span><span class="params">(<span class="number">48</span>, <span class="number">0.8f</span>, <span class="number">0.4f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 加载的模型还不能使用索引</span></span><br><span class="line"><span class="comment">//ImportedModel model2(&quot;model/pyr.obj&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置相关</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">cameraLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">modelLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 立方体天空盒</span></span><br><span class="line">	<span class="type">float</span> cubeVertexPositions[<span class="number">108</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; modelInd = model.<span class="built_in">getIndices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelPvalues;	<span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelTvalues;	<span class="comment">// 纹理坐标</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelNvalues;	<span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		modelTvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">		modelTvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 天空盒</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// model</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * modelPvalues.<span class="built_in">size</span>(), &amp;modelPvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * modelTvalues.<span class="built_in">size</span>(), &amp;modelTvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * modelInd.<span class="built_in">size</span>(), &amp;modelInd[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">	renderProgramCubeMap = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertexCubeMap.glsl&quot;</span>, <span class="string">&quot;fragmentCubeMap.glsl&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line">	textureID = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;textureImg/brick1.jpg&quot;</span>);</span><br><span class="line">	skyboxTex = Util::<span class="built_in">loadCubeMap</span>(<span class="string">&quot;textureImg/cubeMap&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试混合立方体相邻的边以减少或消除接缝</span></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 天空盒</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgramCubeMap);</span><br><span class="line">	<span class="comment">// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置</span></span><br><span class="line"></span><br><span class="line">	vLoc = <span class="built_in">glGetUniformLocation</span>(renderProgramCubeMap, <span class="string">&quot;v_matrix&quot;</span>);</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(vLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(vMat));</span><br><span class="line"></span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgramCubeMap, <span class="string">&quot;p_matrix&quot;</span>);</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, skyboxTex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="comment">// 无深度测试下绘制天空盒</span></span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制场景对象</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), modelLoc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, glm::<span class="built_in">radians</span>(<span class="number">35.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Skybox&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>立方体贴图着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertexCubeMap.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> tc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> v_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> p_matrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	tc = vertPos;</span><br><span class="line">	<span class="type">mat4</span> v3_matrix = <span class="type">mat4</span>(<span class="type">mat3</span>(v_matrix));</span><br><span class="line">    <span class="comment">// 大小转换为 3×3，然后转换回 4×4。移除了平移分量，同时保留了旋转（平移值在转换矩阵的第四列中）</span></span><br><span class="line">	<span class="built_in">gl_Position</span> = p_matrix * v3_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragmentCubeMap.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> tc;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">samplerCube</span> samp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	fragColor = <span class="built_in">texture</span>(samp, tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>描绘场景的着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> tc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	tc = texCoord;</span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> tc;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	fragColor = <span class="built_in">texture</span>(s, tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="9-4-环境贴图">9.4 环境贴图</h3>
<p>环境贴图：使用立方体贴图来构造反射对象本身。</p>
<ul>
<li>在光照时计算过反射向量，现在使用反射向量从纹理贴图中查找值。</li>
</ul>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_envmap.gif" alt="环境贴图例子"></p>
<p>仍然需要两组着色器，一组用于立方体贴图，一组用于场景物体（环面）。</p>
<p>程序上：</p>
<ul>
<li><code>makeVertexArray()</code> 函数中：
<ul>
<li>构建环面的法向量缓冲区</li>
<li>去掉环面的纹理坐标缓冲区</li>
</ul>
</li>
<li><code>display()</code> 函数中：
<ul>
<li>创建变换法向量的矩阵并关联到统一变量</li>
<li>激活环面法向量缓冲区</li>
<li>激活立方体贴图为环面的纹理</li>
</ul>
</li>
<li>顶点着色器中：
<ul>
<li>输出变换的顶点和法向量，用于计算反射向量</li>
</ul>
</li>
<li>片段着色器中：
<ul>
<li>计算反射向量</li>
<li>从立方体贴图使用反射向量检索输出颜色</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line">GLuint renderProgram, renderProgramCubeMap;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line">GLuint mvLoc, projLoc, vLoc, nLoc;</span><br><span class="line">GLuint skyboxTex;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rotAmt;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型相关</span></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">model</span><span class="params">(<span class="number">48</span>, <span class="number">0.8f</span>, <span class="number">0.4f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 加载的模型还不能使用索引</span></span><br><span class="line"><span class="comment">//ImportedModel model2(&quot;model/pyr.obj&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置相关</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">cameraLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">modelLoc</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 立方体天空盒</span></span><br><span class="line">	<span class="type">float</span> cubeVertexPositions[<span class="number">108</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">		 <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; modelInd = model.<span class="built_in">getIndices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelPvalues;	<span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelTvalues;	<span class="comment">// 纹理坐标</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; modelNvalues;	<span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		modelPvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		modelTvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">		modelTvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		modelNvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 天空盒</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(cubeVertexPositions), cubeVertexPositions, GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// model</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * modelPvalues.<span class="built_in">size</span>(), &amp;modelPvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * modelTvalues.<span class="built_in">size</span>(), &amp;modelTvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * modelInd.<span class="built_in">size</span>(), &amp;modelInd[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertex.glsl&quot;</span>, <span class="string">&quot;fragment.glsl&quot;</span>);</span><br><span class="line">	renderProgramCubeMap = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;vertexCubeMap.glsl&quot;</span>, <span class="string">&quot;fragmentCubeMap.glsl&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line">	skyboxTex = Util::<span class="built_in">loadCubeMap</span>(<span class="string">&quot;textureImg/lakeCubeMap&quot;</span>);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraLoc.x, -cameraLoc.y, -cameraLoc.z));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 天空盒</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgramCubeMap);</span><br><span class="line">	<span class="comment">// 准备绘制天空盒。模型矩阵将天空盒放置在相机位置</span></span><br><span class="line"></span><br><span class="line">	vLoc = <span class="built_in">glGetUniformLocation</span>(renderProgramCubeMap, <span class="string">&quot;v_matrix&quot;</span>);</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(vLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(vMat));</span><br><span class="line"></span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgramCubeMap, <span class="string">&quot;p_matrix&quot;</span>);</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, skyboxTex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="comment">// 无深度测试下绘制天空盒</span></span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制场景对象</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">	nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rotAmt = currentTime * <span class="number">0.5f</span>;</span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), modelLoc);</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, rotAmt, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line">	invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 环面纹理现在是立方体贴图</span></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, skyboxTex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">	<span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Skybox&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>描绘场景的着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> normal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> vVertPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> norm_matrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	vVertPos = (mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">	vNormal = (norm_matrix * <span class="type">vec4</span>(normal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> vVertPos;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">samplerCube</span> t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec3</span> r = -<span class="built_in">reflect</span>(<span class="built_in">normalize</span>(-vVertPos), <span class="built_in">normalize</span>(vNormal));</span><br><span class="line">	fragColor = <span class="built_in">texture</span>(t, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>环境贴图的主要限制之一是它只能构建反射立方体贴图内容的对象。</p>
<ul>
<li>在场景中渲染的其他对象并不会出现在使用贴图模拟反射的对象中。</li>
<li>可以使用模板缓冲区或其他教程实现反射出多个物体的效果。</li>
</ul>
<hr>
<p>使用 SOIL2 可以很方便加载纹理贴图，但也有其他方法：</p>
<ul>
<li>使用 <code>stb_image.h</code>：
<ul>
<li>包含头文件</li>
<li>使用 <code>glGenTextures()</code> 为立方体贴图创建纹理及其 ID</li>
<li>使用 <code>glBindTexture()</code> 指定纹理 ID 和 <code>GL_TEXTURE_CUBE_MAP</code></li>
<li>使用 <code>stbi_load()</code> 加载纹理文件</li>
<li>使用 <code>glTexImage2D()</code> 将图像分配给立方体的各个面</li>
</ul>
</li>
</ul>
<p><em>SOIL2 以及包含文件 stb_image.h</em></p>
<p><em>也许Terragen对于制作贴图不错。</em></p>
<hr>
<h2 id="十-增强表面细节">十、增强表面细节</h2>
<h3 id="10-1-凹凸贴图">10.1 凹凸贴图</h3>
<p>如果想让一个物体看起来好像有凹凸，一种方法是计算表面确实凹凸不平时其上的法向量，然后模拟法向量。</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_disturbNorm.png" alt="扰动法向量"></p>
<p>使用正弦函数生成凹凸不平的法向量。</p>
<ul>
<li>顶点着色器需要将未经变换的顶点传递给片段着色器</li>
</ul>
<p>效果如图：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_bumps.jpg" alt="过程式凹凸贴图"></p>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">4</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint mvLoc, projLoc, nLoc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源属性</span></span><br><span class="line">GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;</span><br><span class="line"><span class="comment">// 材质属性</span></span><br><span class="line">GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line">glm::vec3 currentLightPos, lightPosV;    <span class="comment">// 模型和视觉空间中的光照位置</span></span><br><span class="line"><span class="type">float</span> lightPos[<span class="number">3</span>];    <span class="comment">// 光照位置的浮点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化光照位置</span></span><br><span class="line">glm::vec3 initialLightLoc = glm::<span class="built_in">vec3</span>(<span class="number">5.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白光特性</span></span><br><span class="line"><span class="type">float</span> globalAmbient[<span class="number">4</span>] = &#123; <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightAmbient[<span class="number">4</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightDiffuse[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightSpecular[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *matAmb = Util::<span class="built_in">silverAmbient</span>();</span><br><span class="line"><span class="type">float</span> *matDif = Util::<span class="built_in">silverDiffuse</span>();</span><br><span class="line"><span class="type">float</span> *matSpe = Util::<span class="built_in">silverSpecular</span>();</span><br><span class="line"><span class="type">float</span> matShi = Util::<span class="built_in">silverShininess</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="function">Torus <span class="title">model</span><span class="params">(<span class="number">48</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>)</span></span>;</span><br><span class="line"><span class="comment">//ImportedModel model(&quot;unicorn.obj&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">installLights</span><span class="params">(glm::mat4 vMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将光源位置转换为视图空间坐标，存入浮点数组</span></span><br><span class="line">	lightPosV = glm::<span class="built_in">vec3</span>(vMatrix * glm::<span class="built_in">vec4</span>(currentLightPos, <span class="number">1.0</span>));</span><br><span class="line">	lightPos[<span class="number">0</span>] = lightPosV.x;</span><br><span class="line">	lightPos[<span class="number">1</span>] = lightPosV.y;</span><br><span class="line">	lightPos[<span class="number">2</span>] = lightPosV.z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器获取光源位置和材质属性</span></span><br><span class="line">	globalAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;globalAmbient&quot;</span>);</span><br><span class="line">	ambLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.ambient&quot;</span>);</span><br><span class="line">	diffLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.diffuse&quot;</span>);</span><br><span class="line">	specLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.specular&quot;</span>);</span><br><span class="line">	posLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.position&quot;</span>);</span><br><span class="line">	mAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.ambient&quot;</span>);</span><br><span class="line">	mDifLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.diffuse&quot;</span>);</span><br><span class="line">	mSpecLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.specular&quot;</span>);</span><br><span class="line">	mShiLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.shininess&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器中为光源与材质统一变量赋值</span></span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, globalAmbLoc, <span class="number">1</span>, globalAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, ambLoc, <span class="number">1</span>, lightAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, diffLoc, <span class="number">1</span>, lightDiffuse);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, specLoc, <span class="number">1</span>, lightSpecular);</span><br><span class="line">	<span class="built_in">glProgramUniform3fv</span>(renderProgram, posLoc, <span class="number">1</span>, lightPos);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mAmbLoc, <span class="number">1</span>, matAmb);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mDifLoc, <span class="number">1</span>, matDif);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mSpecLoc, <span class="number">1</span>, matSpe);</span><br><span class="line">	<span class="built_in">glProgramUniform1f</span>(renderProgram, mShiLoc, matShi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ind = model.<span class="built_in">getIndices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">		tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">	<span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 顶点索引放入缓冲区3</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * ind.<span class="built_in">size</span>(), &amp;ind[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;bumpMap/vertex.glsl&quot;</span>, <span class="string">&quot;bumpMap/fragment.glsl&quot;</span>);</span><br><span class="line">	cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">	nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">35.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基于当前光源位置，初始化光照</span></span><br><span class="line">	currentLightPos = glm::<span class="built_in">vec3</span>(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);</span><br><span class="line">	<span class="built_in">installLights</span>(vMat);</span><br><span class="line"></span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line">	<span class="comment">// 构建 MV 矩阵的逆转置矩阵，用于变换法向量</span></span><br><span class="line">	invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">	<span class="comment">//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());</span></span><br><span class="line">	<span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Bumps&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient;</span><br><span class="line">	<span class="type">vec4</span> diffuse;</span><br><span class="line">	<span class="type">vec4</span> specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> norm_matrix;</span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingLightDir;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingVertPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> originalVertex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	varyingVertPos = (mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">	varyingLightDir = light.position - varyingVertPos;</span><br><span class="line">	varyingNormal = (norm_matrix * <span class="type">vec4</span>(vertNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">	originalVertex = vertPos;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient;</span><br><span class="line">	<span class="type">vec4</span> diffuse;</span><br><span class="line">	<span class="type">vec4</span> specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Material</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient;</span><br><span class="line">	<span class="type">vec4</span> diffuse;</span><br><span class="line">	<span class="type">vec4</span> specular;</span><br><span class="line">	<span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> globalAmbient;</span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingNormal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingLightDir;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingVertPos;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> originalVertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec3</span> L = <span class="built_in">normalize</span>(varyingLightDir);</span><br><span class="line">	<span class="type">vec3</span> N = <span class="built_in">normalize</span>(varyingNormal);</span><br><span class="line">	<span class="type">vec3</span> V = <span class="built_in">normalize</span>(-varyingVertPos);</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> a = <span class="number">0.25</span>;		<span class="comment">// 凸起深度</span></span><br><span class="line">	<span class="type">float</span> b = <span class="number">100.0</span>;	<span class="comment">// 凸起宽度</span></span><br><span class="line">	<span class="type">float</span> x = originalVertex.x;</span><br><span class="line">	<span class="type">float</span> y = originalVertex.y;</span><br><span class="line">	<span class="type">float</span> z = originalVertex.z;</span><br><span class="line">	N.x = varyingNormal.x + a * <span class="built_in">sin</span>(b * x);</span><br><span class="line">	N.y = varyingNormal.y + a * <span class="built_in">sin</span>(b * y);</span><br><span class="line">	N.z = varyingNormal.z + a * <span class="built_in">sin</span>(b * z);</span><br><span class="line">	N = <span class="built_in">normalize</span>(N);</span><br><span class="line"></span><br><span class="line">	<span class="type">vec3</span> R = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-L, N));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算光照与平面法向量间的角度</span></span><br><span class="line">	<span class="type">float</span> cosTheta = <span class="built_in">dot</span>(L, N);</span><br><span class="line">	<span class="comment">// 计算法向量 N 与角平分线向量 H 之间的角度</span></span><br><span class="line">	<span class="type">float</span> cosPhi = <span class="built_in">dot</span>(V, R);</span><br><span class="line"></span><br><span class="line">	fragColor = globalAmbient * material.ambient +</span><br><span class="line">		light.ambient * material.diffuse +</span><br><span class="line">		light.diffuse * material.diffuse * <span class="built_in">max</span>(cosTheta, <span class="number">0.0</span>) +</span><br><span class="line">		light.specular * material.specular * <span class="built_in">pow</span>(<span class="built_in">max</span>(cosPhi, <span class="number">0.0</span>), material.shininess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="10-2-法线贴图">10.2 法线贴图</h3>
<p>凹凸贴图可以使用查找表来替换法向量的形式替代。</p>
<p>以查找表的方法实现凹凸细节叫作法线贴图。</p>
<p>可以将法向量存储在彩色图像文件中，恰好 RGB 三通道对应向量的 xyz。</p>
<ul>
<li>RGB 值以字节形式存储，通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</li>
<li>向量限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1,+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mi>x</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mi>y</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>N</mi><mi>z</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
R=(N_x+1)/2 \\
G=(N_y+1)/2 \\
B=(N_z+1)/2
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>法线贴图使用一个图像（称为法线图）文件，该图像文件包含在光照下所期望表面外观的法向量。</p>
<ul>
<li>法向量的 x 和 y 分量表示其被扰动后与“垂直”方向的偏差，z 分量设置为 1。</li>
<li>严格垂直的向量（即没有偏差）将表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p>但发现图查找到的法向量不能直接使用，因为并没有考虑法向量在物体上的位置以及在相机空间种的方向。</p>
<ul>
<li>建立转换矩阵，将法向量转换到相机空间。</li>
</ul>
<p>在对象顶点出，考虑对象的切平面，取切平面两个相互垂直的向量（切向量和副切向量），可以通过计算切向量和法向量的叉积构建副切向量。</p>
<ul>
<li>如果模型没有定义切向量，还需计算切向量。</li>
<li>对于那些表面无法求导、无法精确求解切向量的模型，其切向量可以通过近似得到。</li>
</ul>
<p>切向量一样通过 VBO 传递到顶点着色器中。</p>
<p>一旦在相机空间中得到法向量、切向量和副切向量，就可以构造矩阵（称为 TBN 矩阵）。</p>
<ul>
<li>该矩阵用于将从法线贴图中检索到的法向量转换为在相机空间中相对于物体表面的法向量。</li>
<li>在片段着色器中，新法向量的计算在 <code>calcNewNormal()</code> 函数中完成。
<ul>
<li>该函数包含 <code>dot(tangent, normal)</code> 的计算确保切向量垂直于法向量。新的切向量和法向量的叉积就是副切向量。</li>
</ul>
</li>
</ul>
<p>制作法线图可以通过 GIMP 和 PS 等工具完成。</p>
<table>
<thead>
<tr>
<th style="text-align:center">法线贴图例子</th>
<th style="text-align:center">法线图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_normMap.jpg"/></td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_normalMapping.jpg"/></td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">5</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint mvLoc, projLoc, nLoc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源属性</span></span><br><span class="line">GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;</span><br><span class="line"><span class="comment">// 材质属性</span></span><br><span class="line">GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line">glm::vec3 currentLightPos, lightPosV;    <span class="comment">// 模型和视觉空间中的光照位置</span></span><br><span class="line"><span class="type">float</span> lightPos[<span class="number">3</span>];    <span class="comment">// 光照位置的浮点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化光照位置</span></span><br><span class="line">glm::vec3 initialLightLoc = glm::<span class="built_in">vec3</span>(<span class="number">-5.0f</span>, <span class="number">2.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白光特性</span></span><br><span class="line"><span class="type">float</span> globalAmbient[<span class="number">4</span>] = &#123; <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightAmbient[<span class="number">4</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightDiffuse[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightSpecular[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *matAmb = Util::<span class="built_in">goldAmbient</span>();</span><br><span class="line"><span class="type">float</span> *matDif = Util::<span class="built_in">goldDiffuse</span>();</span><br><span class="line"><span class="type">float</span> *matSpe = Util::<span class="built_in">goldSpecular</span>();</span><br><span class="line"><span class="type">float</span> matShi = Util::<span class="built_in">goldShininess</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Sphere <span class="title">model</span><span class="params">(<span class="number">48</span>)</span></span>;</span><br><span class="line"><span class="comment">//Torus model(48, 0.5f, 0.2f);</span></span><br><span class="line"><span class="comment">//ImportedModel model(&quot;unicorn.obj&quot;);</span></span><br><span class="line"></span><br><span class="line">GLuint texture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">installLights</span><span class="params">(glm::mat4 vMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将光源位置转换为视图空间坐标，存入浮点数组</span></span><br><span class="line">	lightPosV = glm::<span class="built_in">vec3</span>(vMatrix * glm::<span class="built_in">vec4</span>(currentLightPos, <span class="number">1.0</span>));</span><br><span class="line">	lightPos[<span class="number">0</span>] = lightPosV.x;</span><br><span class="line">	lightPos[<span class="number">1</span>] = lightPosV.y;</span><br><span class="line">	lightPos[<span class="number">2</span>] = lightPosV.z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器获取光源位置和材质属性</span></span><br><span class="line">	globalAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;globalAmbient&quot;</span>);</span><br><span class="line">	ambLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.ambient&quot;</span>);</span><br><span class="line">	diffLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.diffuse&quot;</span>);</span><br><span class="line">	specLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.specular&quot;</span>);</span><br><span class="line">	posLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.position&quot;</span>);</span><br><span class="line">	mAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.ambient&quot;</span>);</span><br><span class="line">	mDifLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.diffuse&quot;</span>);</span><br><span class="line">	mSpecLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.specular&quot;</span>);</span><br><span class="line">	mShiLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.shininess&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器中为光源与材质统一变量赋值</span></span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, globalAmbLoc, <span class="number">1</span>, globalAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, ambLoc, <span class="number">1</span>, lightAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, diffLoc, <span class="number">1</span>, lightDiffuse);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, specLoc, <span class="number">1</span>, lightSpecular);</span><br><span class="line">	<span class="built_in">glProgramUniform3fv</span>(renderProgram, posLoc, <span class="number">1</span>, lightPos);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mAmbLoc, <span class="number">1</span>, matAmb);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mDifLoc, <span class="number">1</span>, matDif);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mSpecLoc, <span class="number">1</span>, matSpe);</span><br><span class="line">	<span class="built_in">glProgramUniform1f</span>(renderProgram, mShiLoc, matShi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ind = model.<span class="built_in">getIndices</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; tang = model.<span class="built_in">getTangents</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; tanvalues;  <span class="comment">// 切线</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">		tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">		tanvalues.<span class="built_in">push_back</span>(tang[i].x);</span><br><span class="line">		tanvalues.<span class="built_in">push_back</span>(tang[i].y);</span><br><span class="line">		tanvalues.<span class="built_in">push_back</span>(tang[i].z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">	<span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 切向量放入缓冲区3</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tanvalues.<span class="built_in">size</span>(), &amp;tanvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 顶点索引放入缓冲区4</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">4</span> * ind.<span class="built_in">size</span>(), &amp;ind[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;normalMap/vertex.glsl&quot;</span>, <span class="string">&quot;normalMap/fragment.glsl&quot;</span>);</span><br><span class="line">	cameraX = <span class="number">0.0f</span>, cameraY = <span class="number">0.0f</span>, cameraZ = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line"></span><br><span class="line">	texture = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;normalMap/castleroofNORMAL.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">	nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">35.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基于当前光源位置，初始化光照</span></span><br><span class="line">	currentLightPos = glm::<span class="built_in">vec3</span>(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);</span><br><span class="line">	<span class="built_in">installLights</span>(vMat);</span><br><span class="line"></span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line">	<span class="comment">// 构建 MV 矩阵的逆转置矩阵，用于变换法向量</span></span><br><span class="line">	invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">3</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">	<span class="comment">//glDrawArrays(GL_TRIANGLES, 0, model.getNumVertices());</span></span><br><span class="line">	<span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, vbo[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">glDrawElements</span>(GL_TRIANGLES, model.<span class="built_in">getNumIndices</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Bumps&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>球体类新增</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sphere.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sphere::init</span><span class="params">(<span class="type">int</span> _prec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	numVertices = (_prec + <span class="number">1</span>) * (_prec + <span class="number">1</span>);</span><br><span class="line">	numIndices = _prec * _prec * <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		vertices.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">		texCoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>());</span><br><span class="line">		normals.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">		tangents.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIndices; ++ i)</span><br><span class="line">		indices.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算三角形顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= _prec; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= _prec; ++ j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">cos</span>(<span class="built_in">toRadians</span>(<span class="number">180.0f</span> - i * <span class="number">180.0f</span> / _prec)));</span><br><span class="line">			<span class="type">float</span> x = - <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">cos</span>(<span class="built_in">toRadians</span>(j * <span class="number">360.0f</span> / _prec)) * <span class="built_in">fabs</span>(<span class="built_in">cos</span>(<span class="built_in">asin</span>(y))));</span><br><span class="line">			<span class="type">float</span> z = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">sin</span>(<span class="built_in">toRadians</span>(j * <span class="number">360.0f</span> / _prec)) * <span class="built_in">fabs</span>(<span class="built_in">cos</span>(<span class="built_in">asin</span>(y))));</span><br><span class="line">			vertices[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">			<span class="comment">// 计算切向量（新增）</span></span><br><span class="line">			<span class="keyword">if</span> (((x == <span class="number">0</span>) <span class="built_in">and</span> (y == <span class="number">1</span>) <span class="built_in">and</span> (z == <span class="number">0</span>)) <span class="built_in">or</span> ((x == <span class="number">0</span>) <span class="built_in">and</span> (y == <span class="number">-1</span>) <span class="built_in">and</span> (z == <span class="number">0</span>)))</span><br><span class="line">				tangents[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				tangents[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">cross</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(x, y, z));</span><br><span class="line">            <span class="comment">// 新增上述计算切向量</span></span><br><span class="line">			texCoords[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec2</span>(j * <span class="number">1.0f</span> / _prec, i * <span class="number">1.0f</span> / _prec);</span><br><span class="line">			normals[i * (_prec + <span class="number">1</span>) + j] = glm::<span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;glm::vec3&gt; <span class="title">Sphere::getTangents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tangents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient;</span><br><span class="line">	<span class="type">vec4</span> diffuse;</span><br><span class="line">	<span class="type">vec4</span> specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertNormal;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">3</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertTangent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> norm_matrix;	<span class="comment">// 用于变换法向量</span></span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingLightDir;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingVertPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingTangent;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> originalVertex;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> tc;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> varyingHalfVector;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	varyingVertPos = (mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">	varyingLightDir = light.position - varyingVertPos;</span><br><span class="line">	tc = texCoord;</span><br><span class="line"></span><br><span class="line">	originalVertex = vertPos;</span><br><span class="line"></span><br><span class="line">	varyingNormal = (norm_matrix * <span class="type">vec4</span>(vertNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">	varyingTangent = (norm_matrix * <span class="type">vec4</span>(vertTangent, <span class="number">0.0</span>)).xyz;</span><br><span class="line"></span><br><span class="line">	varyingHalfVector = <span class="built_in">normalize</span>(<span class="built_in">normalize</span>(varyingLightDir) + <span class="built_in">normalize</span>(-varyingVertPos)).xyz;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line">struct PositionalLight</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient;</span><br><span class="line">	<span class="type">vec4</span> diffuse;</span><br><span class="line">	<span class="type">vec4</span> specular;</span><br><span class="line">	<span class="type">vec3</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Material</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> ambient;</span><br><span class="line">	<span class="type">vec4</span> diffuse;</span><br><span class="line">	<span class="type">vec4</span> specular;</span><br><span class="line">	<span class="type">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> nromsamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> globalAmbient;</span><br><span class="line"><span class="keyword">uniform</span> PositionalLight light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingLightDir;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingNormal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingVertPos;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingTangent;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> originalVertPos;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> tc;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> varyingHalfVector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> calcNewNormal()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec3</span> normal = <span class="built_in">normalize</span>(varyingNormal);</span><br><span class="line">	<span class="type">vec3</span> tangent = <span class="built_in">normalize</span>(varyingTangent);</span><br><span class="line">	tangent = <span class="built_in">normalize</span>(tangent - <span class="built_in">dot</span>(tangent, normal) * normal);</span><br><span class="line">	<span class="type">vec3</span> bitangent = <span class="built_in">cross</span>(normal, tangent);</span><br><span class="line">	<span class="type">mat3</span> tbn = <span class="type">mat3</span>(tangent, bitangent, normal);</span><br><span class="line">	<span class="type">vec3</span> retrievedNormal = <span class="built_in">texture</span>(nromsamp, tc).xyz;</span><br><span class="line">	<span class="type">vec3</span> newNormal = tbn * retrievedNormal;</span><br><span class="line">	newNormal = <span class="built_in">normalize</span>(newNormal);</span><br><span class="line">	<span class="keyword">return</span> newNormal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec3</span> L = <span class="built_in">normalize</span>(varyingLightDir);</span><br><span class="line">	<span class="type">vec3</span> N = calcNewNormal();</span><br><span class="line">	<span class="type">vec3</span> R = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-L, N));</span><br><span class="line">	<span class="type">vec3</span> H = <span class="built_in">normalize</span>(varyingHalfVector);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算光照与平面法向量间的角度</span></span><br><span class="line">	<span class="type">float</span> cosTheta = <span class="built_in">dot</span>(L, N);</span><br><span class="line">	<span class="comment">// 计算法向量 N 与角平分线向量 H 之间的角度</span></span><br><span class="line">	<span class="type">float</span> cosPhi = <span class="built_in">dot</span>(H, N);</span><br><span class="line"></span><br><span class="line">	fragColor = globalAmbient * material.ambient +</span><br><span class="line">		light.ambient * material.ambient +</span><br><span class="line">		light.diffuse * material.diffuse * <span class="built_in">max</span>(<span class="number">0.0</span>, cosTheta) +</span><br><span class="line">		light.specular * material.specular * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0.0</span>, cosPhi), material.shininess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>可以使用纹理加法线贴图，使得模型更逼真。</p>
<ul>
<li>法线贴图也可以使用多级渐远纹理贴图改善效果。</li>
<li>法线贴图的各向异性过滤更有效，它不但减少了闪烁的伪影，同时还保留了细节。</li>
</ul>
<h3 id="10-3-高度贴图">10.3 高度贴图</h3>
<p>使用纹理图像来存储高度值，然后使用该高度值来提升（或降低）顶点位置。</p>
<ul>
<li>含有高度信息的图像称为高度图。</li>
</ul>
<p>使用高度图更改对象的顶点的方法称为高度贴图。</p>
<ul>
<li>黑色为高度低，白色为高度高。</li>
</ul>
<p>效果展示：</p>
<p><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_heightMap.jpg" alt="高度贴图"></p>
<p>用于展示的高度图和纹理图如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">高度图</th>
<th style="text-align:center">纹理图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_height.jpg"/></td>
<td style="text-align:center"><img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/OpenGL_ice.jpg"/></td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<details><summary>main.cpp</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLEW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLFW 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导入 GLM 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Torus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImportedModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">GLuint renderProgram;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numVAO = <span class="number">1</span>, numVBO = <span class="number">3</span>;</span><br><span class="line">GLuint vao[numVAO], vbo[numVBO];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height;</span><br><span class="line"><span class="type">float</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cameraX, cameraY, cameraZ;</span><br><span class="line">GLuint mvLoc, projLoc, nLoc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源属性</span></span><br><span class="line">GLuint globalAmbLoc, ambLoc, diffLoc, specLoc, posLoc;</span><br><span class="line"><span class="comment">// 材质属性</span></span><br><span class="line">GLuint mAmbLoc, mDifLoc, mSpecLoc, mShiLoc;</span><br><span class="line"></span><br><span class="line">glm::mat4 pMat, vMat, mMat, mvMat, invTrMat;</span><br><span class="line">glm::vec3 currentLightPos, lightPosV;    <span class="comment">// 模型和视觉空间中的光照位置</span></span><br><span class="line"><span class="type">float</span> lightPos[<span class="number">3</span>];    <span class="comment">// 光照位置的浮点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化光照位置</span></span><br><span class="line">glm::vec3 initialLightLoc = glm::<span class="built_in">vec3</span>(<span class="number">-5.0f</span>, <span class="number">2.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白光特性</span></span><br><span class="line"><span class="type">float</span> globalAmbient[<span class="number">4</span>] = &#123; <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightAmbient[<span class="number">4</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightDiffuse[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="type">float</span> lightSpecular[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *matAmb = Util::<span class="built_in">goldAmbient</span>();</span><br><span class="line"><span class="type">float</span> *matDif = Util::<span class="built_in">goldDiffuse</span>();</span><br><span class="line"><span class="type">float</span> *matSpe = Util::<span class="built_in">goldSpecular</span>();</span><br><span class="line"><span class="type">float</span> matShi = Util::<span class="built_in">goldShininess</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sphere model(48);</span></span><br><span class="line"><span class="comment">//Torus model(48, 0.5f, 0.2f);</span></span><br><span class="line"><span class="function">ImportedModel <span class="title">model</span><span class="params">(<span class="string">&quot;heightMap/grid.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">GLuint heightMap;</span><br><span class="line">GLuint texture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">windowSizeCallback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">installLights</span><span class="params">(glm::mat4 vMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将光源位置转换为视图空间坐标，存入浮点数组</span></span><br><span class="line">	lightPosV = glm::<span class="built_in">vec3</span>(vMatrix * glm::<span class="built_in">vec4</span>(currentLightPos, <span class="number">1.0</span>));</span><br><span class="line">	lightPos[<span class="number">0</span>] = lightPosV.x;</span><br><span class="line">	lightPos[<span class="number">1</span>] = lightPosV.y;</span><br><span class="line">	lightPos[<span class="number">2</span>] = lightPosV.z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器获取光源位置和材质属性</span></span><br><span class="line">	globalAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;globalAmbient&quot;</span>);</span><br><span class="line">	ambLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.ambient&quot;</span>);</span><br><span class="line">	diffLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.diffuse&quot;</span>);</span><br><span class="line">	specLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.specular&quot;</span>);</span><br><span class="line">	posLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;light.position&quot;</span>);</span><br><span class="line">	mAmbLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.ambient&quot;</span>);</span><br><span class="line">	mDifLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.diffuse&quot;</span>);</span><br><span class="line">	mSpecLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.specular&quot;</span>);</span><br><span class="line">	mShiLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;material.shininess&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在着色器中为光源与材质统一变量赋值</span></span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, globalAmbLoc, <span class="number">1</span>, globalAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, ambLoc, <span class="number">1</span>, lightAmbient);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, diffLoc, <span class="number">1</span>, lightDiffuse);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, specLoc, <span class="number">1</span>, lightSpecular);</span><br><span class="line">	<span class="built_in">glProgramUniform3fv</span>(renderProgram, posLoc, <span class="number">1</span>, lightPos);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mAmbLoc, <span class="number">1</span>, matAmb);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mDifLoc, <span class="number">1</span>, matDif);</span><br><span class="line">	<span class="built_in">glProgramUniform4fv</span>(renderProgram, mSpecLoc, <span class="number">1</span>, matSpe);</span><br><span class="line">	<span class="built_in">glProgramUniform1f</span>(renderProgram, mShiLoc, matShi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeVertexArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;glm::vec3&gt; vert = model.<span class="built_in">getVertices</span>();</span><br><span class="line">	std::vector&lt;glm::vec2&gt; tex = model.<span class="built_in">getTexCoords</span>();</span><br><span class="line">	std::vector&lt;glm::vec3&gt; norm = model.<span class="built_in">getNormals</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; pvalues;    <span class="comment">// 顶点位置</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; tvalues;    <span class="comment">// 纹理坐标</span></span><br><span class="line">	std::vector&lt;<span class="type">float</span>&gt; nvalues;    <span class="comment">// 法向量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">getNumVertices</span>(); ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].x);</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].y);</span><br><span class="line">		pvalues.<span class="built_in">push_back</span>(vert[i].z);</span><br><span class="line">		tvalues.<span class="built_in">push_back</span>(tex[i].s);</span><br><span class="line">		tvalues.<span class="built_in">push_back</span>(tex[i].t);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].x);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].y);</span><br><span class="line">		nvalues.<span class="built_in">push_back</span>(norm[i].z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(numVAO, vao);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenBuffers</span>(numVBO, vbo);</span><br><span class="line">	<span class="comment">// 顶点坐标放入缓冲区0</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * pvalues.<span class="built_in">size</span>(), &amp;pvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 纹理坐标放入缓冲区1</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * tvalues.<span class="built_in">size</span>(), &amp;tvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 法向量放入缓冲区2</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * nvalues.<span class="built_in">size</span>(), &amp;nvalues[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	renderProgram = Util::<span class="built_in">createShadeProgram</span>(<span class="string">&quot;heightMap/vertex.glsl&quot;</span>, <span class="string">&quot;heightMap/fragment.glsl&quot;</span>);</span><br><span class="line">	cameraX = <span class="number">0.03f</span>; cameraY = <span class="number">0.03f</span>; cameraZ = <span class="number">0.8f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">	aspect = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height);</span><br><span class="line">	pMat = glm::<span class="built_in">perspective</span>(<span class="number">1.0472f</span>, aspect, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeVertexArray</span>();</span><br><span class="line"></span><br><span class="line">	texture = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;textureImg/ice.jpg&quot;</span>);</span><br><span class="line">	heightMap = Util::<span class="built_in">loadTexture</span>(<span class="string">&quot;heightMap/height.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(GLFWwindow *window, <span class="type">double</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(renderProgram);</span><br><span class="line"></span><br><span class="line">	mvLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;mv_matrix&quot;</span>);</span><br><span class="line">	projLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;proj_matrix&quot;</span>);</span><br><span class="line">	nLoc = <span class="built_in">glGetUniformLocation</span>(renderProgram, <span class="string">&quot;norm_matrix&quot;</span>);</span><br><span class="line"></span><br><span class="line">	vMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(-cameraX, -cameraY, -cameraZ));</span><br><span class="line">	mMat = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	mMat = glm::<span class="built_in">rotate</span>(mMat, <span class="number">15.0f</span> * <span class="number">3.14159f</span> / <span class="number">180.0f</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基于当前光源位置，初始化光照</span></span><br><span class="line">	currentLightPos = glm::<span class="built_in">vec3</span>(initialLightLoc.x, initialLightLoc.y, initialLightLoc.z);</span><br><span class="line">	<span class="built_in">installLights</span>(vMat);</span><br><span class="line"></span><br><span class="line">	mvMat = vMat * mMat;</span><br><span class="line">	<span class="comment">// 构建 MV 矩阵的逆转置矩阵，用于变换法向量</span></span><br><span class="line">	invTrMat = glm::<span class="built_in">transpose</span>(glm::<span class="built_in">inverse</span>(mvMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(projLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(pMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(mvLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(mvMat));</span><br><span class="line">	<span class="built_in">glUniformMatrix4fv</span>(nLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(invTrMat));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, heightMap);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">	<span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, model.<span class="built_in">getNumVertices</span>());</span><br><span class="line">	<span class="comment">// 利用索引 vbo3 来查找要绘制的顶点</span></span><br><span class="line">	<span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[4]);</span></span><br><span class="line">	<span class="comment">//glDrawElements(GL_TRIANGLES, model.getNumIndices(), GL_UNSIGNED_INT, 0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Bumps&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSetWindowSizeCallback</span>(window, windowSizeCallback);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>顶点着色器和片段着色器</summary>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vertex.glsl</span></span><br><span class="line"><span class="meta">#version 430</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertPos;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> h; <span class="comment">// 高度图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> tc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mv_matrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> proj_matrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec4</span> p = <span class="type">vec4</span>(vertPos, <span class="number">1.0</span>) + <span class="type">vec4</span>((vertNormal * ((<span class="built_in">texture</span>(h, texCoord).r) / <span class="number">5.0</span>f)), <span class="number">1.0</span>f);</span><br><span class="line">	tc = texCoord;</span><br><span class="line">	<span class="built_in">gl_Position</span> = proj_matrix * mv_matrix * p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fragment.glsl</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> tc;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>)  <span class="keyword">uniform</span> <span class="type">sampler2D</span> t;	<span class="comment">// 纹理</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	fragColor = <span class="built_in">texture</span>(t, tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>凹凸贴图或法线贴图的一个基本限制是：</p>
<ul>
<li>虽然能够在所渲染对象的内部提供表面细节，</li>
<li>但是物体轮廓（外边界）无法显示这些细节（仍保持平滑）。</li>
</ul>
<p>高度贴图在用于实际修改顶点位置时修复了这个缺陷，但它也有其自身的局限性。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言入门学习教程</title>
    <url>/2023/python-language-learning/</url>
    <content><![CDATA[<p>个人整理面向入门基础级别的Python语言学习教程。</p>
<h2 id="一-python的基本观念">一. Python的基本观念</h2>
<h3 id="1-1-什么是python语言">1.1 什么是Python语言</h3>
<p>Python是一种 <strong>直译的</strong> 、 <strong>面向对象的</strong> 、 <strong>拥有许多函数库</strong> 的语言。</p>
<p><strong>直译</strong>表明它不需要经过像C语言一样的编译过程，直接由直译器运行。这有好处也有坏处，好处是方便简洁直接运行；坏处是没有编译器的错误检查，即运行到某行才知道错误。</p>
<p><strong>面向对象</strong>表明它是一门高级语言，具有抽象化的概念（也就是对象），能完成众多工作。Python中一切都是对象，而对象的函数称作方法。</p>
<p><strong>拥有许多函数库</strong>表明它有很多内置的套件或者是模块，开源且每个人可贡献，我们直接import调用这些模块即可完成一些复杂的任务。 <em>由于Python的模块众多，此教程只介绍最基本的语法，模块的使用建议查看模块的帮助文档，建议善于查阅资料</em></p>
<p>当然Python也具有垃圾回收的功能，即程序执行时直译器会主动回收不再需要的动态内存空间，减少程序员犯错的机会。</p>
<p>Python也经历了很多版本的迭代，从最初的Python 2.0到Python 3.0、Python 3.x。Python 3在开发时与Python 2不兼容，所以可以认为是两个独立的版本，但后面官方把Python 3.x版本的特性移植到Python 2.6/2.7x中。本教程的演示代码经过Python 3.11.4测试。</p>
<h3 id="1-2-怎么写python程序">1.2 怎么写Python程序</h3>
<p>首先具备Python的直译器，即下载安装Python。<a href="https://www.python.org/downloads/windows/">官网</a>选择尽量较新的Python版本下载。打开下载的Python安装包，选择<code>Customize installation</code>客制化安装，记得勾选下面的“Add python.exe to PATH”。接着默认勾选pip：包管理器，下载包时使用。建议勾选上，再接着更改安装路径，建议安装在非系统盘。最后等待安装完成即可。具体可参考<a href="https://fingsinz.space/2023/8/">这篇博客</a></p>
<p>接着编写Python并执行，Python的后缀名为 <code>.py</code> 。在此介绍两种方式编写Python：记事本和Visual Studio Code。</p>
<ol>
<li>记事本方式：新建记事本，命名为 <code>xxx.py</code> ，在里面编写Python代码，之后启用命令提示符cmd使用python命令直译运行。</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/py-language-leaning_write.jpg" alt="记事本编写Python"></p>
<ol start="2">
<li>Visual Studio Code方式：直接编写代码运行。</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/py-language-leaning_write2.jpg" alt="VSCode编写Python"></p>
<p>在Python中，使用 <code>#</code> 作为整行注释符号，三个单引号或双引号作为整段注释符号。</p>
<p>同时，Python不像C语言，Python的每句最后不需要添加分号 <code>;</code> ，还把相同的缩进作为一整个语句块，这些特性会在后面的代码慢慢体现。</p>
<h3 id="1-3-import模块">1.3 import模块</h3>
<p>想使用 Python 源文件或者特殊模块，只需在另一个源文件里执行 import 语句，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure>
<p>比如引入系统模块： <code>impory sys</code></p>
<p>在此基础教程上，一般不需要使用import便可满足使用。但是在开发程序时，需要其他模块的支持，便需要 <code>import</code> 。</p>
<p><code>from … import</code> ：语句从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>
<p><code>from … import *</code> ：把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>在模块间，需要清楚本模块和引入模块的运行。如果想在模块被引入时，模块中的某一程序块不执行，可以用 <code>__name__</code> 属性来使该程序块仅在该模块自身运行时执行。</p>
<p>举个例子，有两个Python文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;a.py的main中运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;a.py的非main中运行&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b.py运行&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行a.py输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.py的main中运行</span><br></pre></td></tr></table></figure>
<p>运行b.py输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.py的非main中运行</span><br><span class="line">b.py运行</span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="二-函数">二. 函数</h2>
<h3 id="2-1-函数的基本结构">2.1 函数的基本结构</h3>
<p>函数的结构应当如下，包括 <strong>函数名字function_name</strong> 、 <strong>参数arguments</strong> 和 <strong>函数主体Body</strong> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">arguments</span>):</span><br><span class="line">	<span class="comment"># body1</span></span><br><span class="line">	<span class="comment"># body2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>def</code> ：函数代码块的开头，后接函数名字、参数列表和函数主体。</p>
</li>
<li>
<p><strong>函数名字</strong>：标记一个函数的名字。</p>
</li>
<li>
<p><strong>参数列表</strong>：当函数被调用时，可以向参数传递值。参数列表包括函数参数的顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</p>
</li>
<li>
<p><strong>函数主体</strong>：函数内容以冒号 <code>:</code> 开始，并且具有相同的缩进。函数主体包含一组定义函数执行任务的语句。若有返回值的函数使用 <code>return</code> 返回，没有 <code>return</code> 相当于返回 <code>None</code> 。函数主体中遇到返回表示结束函数。</p>
</li>
</ul>
<h3 id="2-2-函数的定义">2.2 函数的定义</h3>
<p>Python与C语言不一样，不存在函数提前声明一说。即想要调用某函数，必先在前面定义该函数，并不存在调用前先使用函数声明而调用后再函数定义。</p>
<p>定义一个函数十分简单，就如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<h3 id="2-3-传递参数和调用函数">2.3 传递参数和调用函数</h3>
<p>直接使用函数名加上传递参数即可调用函数。当函数不需要传递参数时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">doNothing</span>():</span><br><span class="line">	<span class="comment"># do Nothing</span></span><br><span class="line">doNothing()	<span class="comment"># 函数调用</span></span><br></pre></td></tr></table></figure>
<p>在Python中，变量是没有类型的，而对象有不同类型的区分。当函数需要传递参数时，参数列表就简单写个变量名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">c = add(<span class="number">1</span>, <span class="number">2</span>)	<span class="comment"># c = 3</span></span><br></pre></td></tr></table></figure>
<p>Python中一切都是对象。</p>
<p>参数传递时，是按 <strong>对象</strong> 讨论的，分为可变对象传递和不可变对象传递。</p>
<ul>
<li>
<p>不可变对象传递（如整数、字符串、元组传递）时，类似于C语言的值传递，传递的只是一个值，并没有影响对象本身。如果在函数中修改对象的值，则是新生成一个对象。</p>
</li>
<li>
<p>可变对象传递（如列表、字典传递）时，类似于C语言的地址传递，或者说引用传递，修改对象的值，外部的对象也受影响。</p>
</li>
</ul>
<p>调用函数时可使用的正式参数类型有：必需参数、关键字参数、默认参数和不定长参数。</p>
<ul>
<li>必需参数须以正确的顺序传入函数。调用时的数量必须和定义时的一样。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">c = add(<span class="number">1</span>)	<span class="comment"># 错误，必需参数不一致。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关键字参数允许函数调用时参数的顺序与声明时不一致。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">c = sub(b = <span class="number">2</span>, a = <span class="number">1</span>)	<span class="comment"># c = -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认参数会在没有传递参数时使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub1</span>(<span class="params">a, b = <span class="number">1</span></span>):</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">c = sub1(<span class="number">1</span>)	<span class="comment"># 第二参数没有传递，默认b = 1，c = 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不定长参数使得一个函数能处理比当初声明时更多的参数。格式如下，加了 <code>*</code> 的参数会以元组的形式导入，加了 <code>**</code> 的参数会以字典的形式导入；如果单独出现星号 <code>*</code> ，则星号 后的参数必须用关键字传入。不定长参数不过多介绍。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname1</span>(<span class="params">formal_args, *var </span>):	<span class="comment"># 元组形式</span></span><br><span class="line">   <span class="comment"># body</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">functionname2</span>(<span class="params">formal_args, **var </span>):	<span class="comment"># 字典形式</span></span><br><span class="line">   <span class="comment"># body</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):	<span class="comment"># *后参数必须以关键字传入。</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, c = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Python 3.8新增了强制位置参数，举例但不过多介绍。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b + c + d + e + f</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d = <span class="number">40</span>, e = <span class="number">50</span>, f = <span class="number">60</span>)</span><br><span class="line"><span class="comment"># 形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-内置函数">2.4 内置函数</h3>
<p>内置函数有：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>abs()</code></th>
<th style="text-align:center"><code>dict()</code></th>
<th style="text-align:center"><code>help()</code></th>
<th style="text-align:center"><code>min()</code></th>
<th style="text-align:center"><code>setattr()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>all()</code></td>
<td style="text-align:center"><code>dir()</code></td>
<td style="text-align:center"><code>hex()</code></td>
<td style="text-align:center"><code>next()</code></td>
<td style="text-align:center"><code>slice()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>any()</code></td>
<td style="text-align:center"><code>divmod()</code></td>
<td style="text-align:center"><code>id()</code></td>
<td style="text-align:center"><code>object()</code></td>
<td style="text-align:center"><code>sorted()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ascii()</code></td>
<td style="text-align:center"><code>enumerate()</code></td>
<td style="text-align:center"><code>input()</code></td>
<td style="text-align:center"><code>oct()</code></td>
<td style="text-align:center"><code>staticmethod()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bin()</code></td>
<td style="text-align:center"><code>eval()</code></td>
<td style="text-align:center"><code>int()</code></td>
<td style="text-align:center"><code>open()</code></td>
<td style="text-align:center"><code>str()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bool()</code></td>
<td style="text-align:center"><code>exec()</code></td>
<td style="text-align:center"><code>isinstance()</code></td>
<td style="text-align:center"><code>ord()</code></td>
<td style="text-align:center"><code>sum()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bytearray()</code></td>
<td style="text-align:center"><code>filter()</code></td>
<td style="text-align:center"><code>issubclass()</code></td>
<td style="text-align:center"><code>pow()</code></td>
<td style="text-align:center"><code>super()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bytes()</code></td>
<td style="text-align:center"><code>float()</code></td>
<td style="text-align:center"><code>iter()</code></td>
<td style="text-align:center"><code>print()</code></td>
<td style="text-align:center"><code>tuple()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>callable()</code></td>
<td style="text-align:center"><code>format()</code></td>
<td style="text-align:center"><code>len()</code></td>
<td style="text-align:center"><code>property()</code></td>
<td style="text-align:center"><code>type()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>chr()</code></td>
<td style="text-align:center"><code>frozenset()</code></td>
<td style="text-align:center"><code>list()</code></td>
<td style="text-align:center"><code>range()</code></td>
<td style="text-align:center"><code>vars()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>classmethod()</code></td>
<td style="text-align:center"><code>getattr()</code></td>
<td style="text-align:center"><code>locals()</code></td>
<td style="text-align:center"><code>repr()</code></td>
<td style="text-align:center"><code>zip()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>compile()</code></td>
<td style="text-align:center"><code>globals()</code></td>
<td style="text-align:center"><code>map()</code></td>
<td style="text-align:center"><code>reversed()</code></td>
<td style="text-align:center"><code>__import__()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>complex()</code></td>
<td style="text-align:center"><code>hasattr()</code></td>
<td style="text-align:center"><code>max()</code></td>
<td style="text-align:center"><code>round()</code></td>
<td style="text-align:center"><code>reload()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>delattr()</code></td>
<td style="text-align:center"><code>hash()</code></td>
<td style="text-align:center"><code>memoryview()</code></td>
<td style="text-align:center"><code>set()</code></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="2-5-匿名函数">2.5 匿名函数</h3>
<p>Python 使用 <code>lambda</code> 来创建匿名函数。匿名函数即不再使用 <code>def</code> 语句这样标准的形式定义一个函数。</p>
<ul>
<li>
<p><code>lambda</code> 只是一个表达式，函数体比 <code>def</code> 简单很多。</p>
</li>
<li>
<p><code>lambda</code> 的主体是一个表达式，而不是一个代码块。仅仅能在 <code>lambda</code> 表达式中封装有限的逻辑进去。</p>
</li>
<li>
<p><code>lambda</code>  函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p>
</li>
</ul>
<p>其语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 …] : expression</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> a, b : a + b</span><br><span class="line">c = add(<span class="number">1</span>, <span class="number">2</span>)	<span class="comment"># c = 3</span></span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="三-python的变量与基本运算">三. Python的变量与基本运算</h2>
<h3 id="3-1-什么是变量">3.1 什么是变量</h3>
<p>变量是没有类型的，它仅仅是一个对象的引用。而对象具有数据类型。</p>
<p>变量命名应当合法且易懂</p>
<ol>
<li>
<p>必须由英文字母、_（下画线）或中文字开头，建议使用英文字母；</p>
</li>
<li>
<p>变量名称只能由英文字母、数字、_（下画线）或中文字所组成；</p>
</li>
<li>
<p>英文字母大小写是敏感的，例如，Name与name被视为不同变量名称；</p>
</li>
<li>
<p>Python的系统或函数保留字不能用作变量名称。</p>
</li>
</ol>
<ul>
<li>系统保留字有：and、as、assert、break、class、continue、def、del、elif、else、except、False、finally、for、from、global、if、import、in、is、lambda、none、nonlocal、not、or、pass、raise、return、True、try、while、with、yield。</li>
</ul>
<p>如果变量尚未进行设定值或暂时不想存储任何数据，可将值设为 <code>None</code> ，其类型为 <code>NoneType</code> 。</p>
<p>Python的变量同样具有作用域，即变量的使用范围。作用域一共有四种：</p>
<ul>
<li>
<p>Local：局部作用域</p>
</li>
<li>
<p>Enclosing：闭包函数外的函数中</p>
</li>
</ul>
<p><em>如果在一个函数的内部定义了另一个函数，外部的叫外函数，内部的叫内函数。闭包就是在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。</em></p>
<ul>
<li>
<p>Global：全局作用域</p>
</li>
<li>
<p>Built-in：内建作用域</p>
</li>
</ul>
<p>使用变量时，以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span>	<span class="comment"># x 是全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">	x = <span class="number">4</span>	<span class="comment"># x 是局部变量</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">fun2</span>():	<span class="comment"># 构成闭包</span></span><br><span class="line">		x = <span class="number">3</span>	<span class="comment"># x 是闭包环境变量</span></span><br><span class="line">	<span class="keyword">return</span> fun2</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun3</span>():</span><br><span class="line">	<span class="keyword">global</span> x	<span class="comment"># 告诉直译器变量x应该从全局中寻找，x 是全局变量</span></span><br><span class="line">	<span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>由此，使用 <code>global</code> 关键字可以在局部内声明并使用一个全局变量</p>
<h3 id="3-2-运算符">3.2 运算符</h3>
<h4 id="3-2-1-算术运算符">3.2.1 算术运算符</h4>
<ol>
<li>
<p>四则运算： <code>+</code> 、 <code>-</code> 、 <code>*</code> 、 <code>/</code> 。</p>
</li>
<li>
<p>取余运算： <code>%</code> ，计算除法运算中的余数。</p>
</li>
<li>
<p>整除运算： <code>//</code> ，计算除法运算中的整数部分。</p>
</li>
<li>
<p>次幂运算： <code>**</code> ，计算次幂。</p>
</li>
</ol>
<h4 id="3-2-2-赋值运算符">3.2.2 赋值运算符</h4>
<ul>
<li>赋值运算： <code>=</code> ，为变量设定值，并由其引申得下表。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">实例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center"><code>a += b</code></td>
<td style="text-align:center"><code>a = a + b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center"><code>a -= b</code></td>
<td style="text-align:center"><code>a = a - b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center"><code>a *= b</code></td>
<td style="text-align:center"><code>a = a * b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center"><code>a /= b</code></td>
<td style="text-align:center"><code>a = a / b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center"><code>a %= b</code></td>
<td style="text-align:center"><code>a = a % b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>//=</code></td>
<td style="text-align:center"><code>a //= b</code></td>
<td style="text-align:center"><code>a = a // b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>**=</code></td>
<td style="text-align:center"><code>a **= b</code></td>
<td style="text-align:center"><code>a = a ** b</code></td>
</tr>
</tbody>
</table>
<ul>
<li>等号具有多重使用方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = y = z = <span class="number">10</span> <span class="comment"># 连等，合法</span></span><br><span class="line">x, y, z = <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> <span class="comment"># 多重指定赋值，合法</span></span><br><span class="line">x, y = y, x <span class="comment"># 交换，合法</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-比较运算符">3.2.3 比较运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">关系运算符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">实例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center">a &gt; b</td>
<td style="text-align:center">检查a是否大于b</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center">a &lt; b</td>
<td style="text-align:center">检查a是否小于b</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">a &gt;= b</td>
<td style="text-align:center">检查a是否大于或等于b</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">a &lt;= b</td>
<td style="text-align:center">检查a是否小于或等于b</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
<td style="text-align:center">a == b</td>
<td style="text-align:center">检查a是否等于b</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">a != b</td>
<td style="text-align:center">检查a是否不等于b</td>
</tr>
</tbody>
</table>
<h4 id="3-2-4-位运算符">3.2.4 位运算符</h4>
<p>位运算符是对数据转化为二进制，再逐位进行运算。如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><msub><mn>0</mn><mn>10</mn></msub><mo>=</mo><mn>0011110</mn><msub><mn>0</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">60_{10} = 00111100_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">6</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，再对每一位进行逻辑运算。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">按位与运算符，对两个操作数的每一位执行逻辑与操作</td>
<td style="text-align:center"><code>A &amp; B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center">按位或运算符，对两个操作数的每一位执行逻辑或操作</td>
<td style="text-align:center"><code>A \| B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">按位异或运算符，对两个操作数的每一位执行逻辑异或操作</td>
<td style="text-align:center"><code>A ^ B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">按位取反运算符，对两个操作数的每一位执行逻辑取反操作</td>
<td style="text-align:center"><code>~A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">将操作数的所有位向左移动指定的位数。左移n位相当于乘以2的n次方</td>
<td style="text-align:center"><code>A &lt;&lt; n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">将操作数的所有位向右移动指定的位数。右移n位相当于除以2的n次方</td>
<td style="text-align:center"><code>A &gt;&gt; n</code></td>
</tr>
</tbody>
</table>
<h4 id="3-2-5-逻辑运算符">3.2.5 逻辑运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">and</td>
<td style="text-align:center">逻辑与运算符，如果两个操作数都非零，则条件为真。</td>
<td style="text-align:center">A and B</td>
</tr>
<tr>
<td style="text-align:center">or</td>
<td style="text-align:center">逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真</td>
<td style="text-align:center">A or B</td>
</tr>
<tr>
<td style="text-align:center">not</td>
<td style="text-align:center">逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td style="text-align:center">not A</td>
</tr>
</tbody>
</table>
<h4 id="3-2-6-成员运算符">3.2.6 成员运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:center">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td style="text-align:center">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td style="text-align:center">not in</td>
<td style="text-align:center">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td style="text-align:center">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<h4 id="3-2-7-身份运算符">3.2.7 身份运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:center">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td style="text-align:center">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td style="text-align:center">not in</td>
<td style="text-align:center">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td style="text-align:center">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<h4 id="3-2-8-删除变量">3.2.8 删除变量</h4>
<ul>
<li>使用 <code>del</code> 删除变量，回收所占的内存空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">del</span> x</span><br><span class="line"><span class="comment"># 后面不能再使用x</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-python的断行">3.3 Python的断行</h3>
<ul>
<li>
<p>Python的语句可以不使用 <code>;</code> ，但也可以 <code>;</code> 进行语句分割。总体上不推荐使用。</p>
</li>
<li>
<p>Python中若语句过长，可以使用 <code>\</code> 或 <code>#</code> 进行分行。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = (a +\</span><br><span class="line">	 b +\</span><br><span class="line">	 c)</span><br><span class="line"></span><br><span class="line">y = (d + <span class="comment"># 可做注释</span></span><br><span class="line">	 e + <span class="comment"># 可做注释</span></span><br><span class="line">	 f )</span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="四-python的基本数据类型">四. Python的基本数据类型</h2>
<h3 id="4-1-type-函数">4.1 type()函数</h3>
<ul>
<li><code>type()</code> 可以返回变量的数据类型。如</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="built_in">type</span>(x) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-数值数据类型">4.2 数值数据类型</h3>
<h4 id="4-2-1-什么是数值数据类型">4.2.1 什么是数值数据类型</h4>
<p>数值数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。</p>
<p>Python 支持三种不同的数值类型：</p>
<ul>
<li>
<p>整型(int)：通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。</p>
</li>
<li>
<p>浮点型(float)：浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</p>
</li>
<li>
<p>复数(comple)：复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
</li>
</ul>
<h4 id="4-2-2-数值类型的运算">4.2.2 数值类型的运算</h4>
<p>普通的算术运算可以运行在数值数据类型中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a + b</span><br><span class="line">a - b</span><br><span class="line">a * b</span><br><span class="line">a / b</span><br><span class="line">a // b</span><br><span class="line">a ** b</span><br><span class="line">a % b</span><br></pre></td></tr></table></figure>
<p>当浮点数与整数运算时，同样会进行隐式类型转换为更高级的浮点数。</p>
<p>同样也可以使用强制类型转换： <code>int()</code> 、 <code>float()</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">float</span>(a)</span><br><span class="line">b = <span class="number">5.5</span></span><br><span class="line"><span class="built_in">int</span>(b)</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-数值类型的方法">4.2.3 数值类型的方法</h4>
<p>进制转换类型方法：</p>
<ol>
<li>
<p>转二进制： <code>bin()</code></p>
</li>
<li>
<p>转八进制： <code>oct()</code></p>
</li>
<li>
<p>转十六进制： <code>hex()</code></p>
</li>
</ol>
<p>数学方法：</p>
<ol>
<li>
<p><code>abs(x)</code>	：返回数字的绝对值，如 <code>abs(-10)</code> 返回 10</p>
</li>
<li>
<p><code>ceil(x)</code> ：返回数字的上入整数，如 <code>math.ceil(4.1)</code> 返回 5</p>
</li>
<li>
<p><code>exp(x)</code>	：返回e的x次幂(ex),如 <code>math.exp(1)</code> 返回2.718281828459045</p>
</li>
<li>
<p><code>fabs(x)</code> ：以浮点数形式返回数字的绝对值，如 <code>math.fabs(-10)</code> 返回10.0</p>
</li>
<li>
<p><code>floor(x)</code> ：返回数字的下舍整数，如 <code>math.floor(4.9)</code> 返回 4</p>
</li>
<li>
<p><code>log(x)</code>	：如 <code>math.log(math.e)</code> 返回1.0， <code>math.log(100,10)</code> 返回2.0</p>
</li>
<li>
<p><code>log10(x)</code> ：返回以10为基数的x的对数，如 <code>math.log10(100)</code> 返回 2.0</p>
</li>
<li>
<p><code>max(x1, x2,...)</code> ：返回给定参数的最大值，参数可以为序列。</p>
</li>
<li>
<p><code>min(x1, x2,...)</code> ：返回给定参数的最小值，参数可以为序列。</p>
</li>
<li>
<p><code>modf(x)</code> ：返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p>
</li>
<li>
<p><code>pow(x, y)</code> ：相当于 <code>x**y</code> 运算后的值。</p>
</li>
<li>
<p><code>round(x [,n])</code>	：返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。</p>
</li>
<li>
<p><code>sqrt(x)</code> ：返回数字x的平方根。</p>
</li>
</ol>
<p>除此之外还有三角函数、随机数函数等……</p>
<h3 id="4-3-布尔值数据类型">4.3 布尔值数据类型</h3>
<ul>
<li>Python的布尔值（Boolean）数据类型具有两种值：True（真）或False（假）。数据类型代号是bool。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="literal">True</span></span><br><span class="line"><span class="built_in">type</span>(x) <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果使用类型转换，True对应1，False对应0。</li>
</ul>
<h3 id="4-4-字符串数据类型">4.4 字符串数据类型</h3>
<h4 id="4-4-1-什么是字符串数据类型">4.4.1 什么是字符串数据类型</h4>
<ul>
<li>Python的字符串没有严格规定是单引号还是双引号，只要匹配即可。其数据类型代号是str。如果字符串中有单引号，为了避免出错，使用双引号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;python&#x27;</span></span><br><span class="line">y = <span class="string">&quot;Tom&#x27;s house&quot;</span></span><br><span class="line"><span class="built_in">type</span>(x) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果字符串长度大于一行，可以使用三个单引号或三个双引号包夹。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;&#x27;&#x27;xxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="string">	xxxxxxxxxxxxxxxx&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python 不支持单字符类型，单字符在Python中也是作为一个字符串使用。</li>
</ul>
<h4 id="4-4-1-字符串的运算">4.4.1 字符串的运算</h4>
<ul>
<li>字符串的连接可以直接使用 <code>+</code> 运算。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">z = x + y <span class="comment"># z为12</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串可以直接使用 <code>*</code> 运算，表示复制该字符串多少次</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">z = x * <span class="number">5</span> <span class="comment"># z为11111，是字符串</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串可以使用 <code>[]</code> 索引获取字符串中的字符，从0数起，-1 为从末尾的开始位置。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">e</td>
<td style="text-align:center">l</td>
<td style="text-align:center">l</td>
<td style="text-align:center">o</td>
</tr>
<tr>
<td style="text-align:center">-5</td>
<td style="text-align:center">-4</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">-2</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">str</span>[<span class="number">2</span>] <span class="comment"># l</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串可以使用 <code>[:]</code> 截取字符串的一部分，遵循左闭右开，-1 为从末尾的开始位置。。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">str</span>[<span class="number">2</span>:<span class="number">4</span>] <span class="comment"># ll</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用 <code>in</code> 或 <code>not in</code> 判断某字符是否在字符串中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="string">&#x27;h&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>		<span class="comment"># 为真</span></span><br><span class="line"><span class="string">&#x27;h&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>	<span class="comment"># 为假</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-字符串的类型转换">4.4.2 字符串的类型转换</h4>
<ul>
<li>强制转换为字符串： <code>str()</code> 函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">111</span>	<span class="comment"># x为111，是整型</span></span><br><span class="line">y = <span class="number">222</span>	<span class="comment"># y为222，是整型</span></span><br><span class="line">z = <span class="built_in">str</span>(<span class="number">111</span>) + <span class="built_in">str</span>(<span class="number">222</span>) <span class="comment"># z为111222，是字符串</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串强制转换为整数： <code>int()</code> 函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;111&#x27;</span>	<span class="comment"># x为111，是字符串</span></span><br><span class="line">y = <span class="string">&#x27;222&#x27;</span>	<span class="comment"># y为222，是字符串</span></span><br><span class="line">z = <span class="built_in">int</span>(<span class="number">111</span>) + <span class="built_in">int</span>(<span class="number">222</span>) <span class="comment"># z为333，是整型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串转换为码值： <code>chr(x)</code> 函数返回x的ASCII码值， <code>ord(x)</code> 函数返回x的Unicode码值。</li>
</ul>
<h4 id="4-4-3-转义字符">4.4.3 转义字符</h4>
<ul>
<li>转义字符</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">十六进制值</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\'</code></td>
<td style="text-align:center">27</td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\&quot;</code></td>
<td style="text-align:center">22</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">5C</td>
<td style="text-align:center">反斜杠</td>
</tr>
<tr>
<td style="text-align:center"><code>\a</code></td>
<td style="text-align:center">07</td>
<td style="text-align:center">响铃</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">08</td>
<td style="text-align:center">BackSpace键</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">0C</td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">0A</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center"><code>\o</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">八进制表示</td>
</tr>
<tr>
<td style="text-align:center"><code>\x</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">十六进制表示</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">0D</td>
<td style="text-align:center">光标移到最左</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">09</td>
<td style="text-align:center">Tab键</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">0B</td>
<td style="text-align:center">垂直定位</td>
</tr>
</tbody>
</table>
<ul>
<li>在字符串前加 <code>r</code> ，可以让转义字符不被转义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello\nWorld&quot;</span>	<span class="comment"># 换行符生效</span></span><br><span class="line">str2 = <span class="string">r&quot;Hello\nWorld&quot;</span>	<span class="comment"># 换行符不生效，原样输出</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-4-字符串的函数方法">4.4.4 字符串的函数方法</h4>
<p>字符串的函数方法有许多，此处列出常用的几个。</p>
<ol>
<li>
<p><code>count(str, beg=0,end=len(string))</code>，返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数。</p>
</li>
<li>
<p><code>endswith(suffix, beg=0, end=len(string))</code>，检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False。</p>
</li>
<li>
<p><code>expandtabs(tabsize=8)</code>，把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</p>
</li>
<li>
<p><code>find(str, beg=0, end=len(string))</code>，检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1。</p>
</li>
<li>
<p><code>index(str, beg=0, end=len(string))</code>，跟find()方法一样，只不过如果str不在字符串中会报一个异常。</p>
</li>
<li>
<p><code>isalnum()</code>，如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。</p>
</li>
<li>
<p><code>isalpha()</code>，如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。</p>
</li>
<li>
<p><code>isdigit()</code>，如果字符串只包含数字则返回 True 否则返回 False。</p>
</li>
<li>
<p><code>isnumeric()</code>，如果字符串中只包含数字字符，则返回 True，否则返回 False。</p>
</li>
<li>
<p><code>isspace()</code>，如果字符串中只包含空白，则返回 True，否则返回 False。</p>
</li>
<li>
<p><code>join(seq)</code>，以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串。</p>
</li>
<li>
<p><code>len(string)</code>，返回字符串长度。</p>
</li>
<li>
<p><code>ljust(width[, fillchar])</code>，返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</p>
</li>
<li>
<p><code>lower()</code>，转换字符串中所有大写字符为小写。</p>
</li>
<li>
<p><code>max(str)</code>，返回字符串 str 中最大的字母。</p>
</li>
<li>
<p><code>min(str)</code>，返回字符串 str 中最小的字母。</p>
</li>
<li>
<p><code>replace(old, new [, max])</code>，把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</p>
</li>
<li>
<p><code>rfind(str, beg=0,end=len(string))</code>，类似于 find()函数，不过是从右边开始查找。</p>
</li>
<li>
<p><code>rindex( str, beg=0, end=len(string))</code>，类似于 index()，不过是从右边开始。</p>
</li>
<li>
<p><code>rjust(width,[, fillchar])</code>，返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串。</p>
</li>
<li>
<p><code>rstrip()</code>，删除字符串末尾的空格或指定字符。</p>
</li>
<li>
<p><code>split(str=&quot;&quot;, num=string.count(str))</code>，以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串。</p>
</li>
<li>
<p><code>startswith(substr, beg=0,end=len(string))</code>，检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</p>
</li>
<li>
<p><code>upper()</code>，转换字符串中的小写字母为大写</p>
</li>
</ol>
<p>具体的函数解释用法可以边用边搜索。</p>
<p></br></br></br></p>
<h2 id="五-python的输入和输出">五. Python的输入和输出</h2>
<h3 id="5-1-辅助帮助说明输出">5.1 辅助帮助说明输出</h3>
<ul>
<li>使用 <code>help()</code> 函数可以列出Python指令或函数的使用说明。</li>
</ul>
<h3 id="5-2-输出">5.2 输出</h3>
<h4 id="5-2-1-通过print-函数输出">5.2.1 通过print()函数输出</h4>
<p>该函数的语法格式为： <code>print(*args, sep=' ', end='\n', file=None, flush=False)</code></p>
<ul>
<li>
<p><code>*args</code> ：输出的数据，可以输出多个，使用逗号隔开。</p>
</li>
<li>
<p><code>sep</code> ：表示输出多个数据时的分隔字符，默认是空格。</p>
</li>
<li>
<p><code>end</code> ：当数据输出结束时插入的字符，默认是插入换行。</p>
</li>
<li>
<p><code>file</code> ：数据输出位置，默认是sys.stdout，也就是屏幕。</p>
</li>
<li>
<p><code>flush</code> ：是否清除数据流的缓冲区，默认是不清除。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">1.5</span></span><br><span class="line"><span class="built_in">print</span>(x * y, end=<span class="string">&#x27;\t&#x27;</span>)	<span class="comment"># 输出x乘y，以Tab作为结束</span></span><br><span class="line"><span class="built_in">print</span>(x, y, sep=<span class="string">&#x27;,&#x27;</span>)	<span class="comment"># 输出x和y，以“,”为分隔符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：15.0    10,1.5</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-格式化print-的输出">5.2.2 格式化print()的输出</h4>
<p>可以使用这样的格式输出： <code>print(&quot;输出格式字符串&quot; % (变量))</code> ，输出格式字符串中，与C语言类似。</p>
<ul>
<li>
<p><code>%d</code> 表示格式化整数输出。</p>
</li>
<li>
<p><code>%f</code> 表示格式化浮点数输出。</p>
</li>
<li>
<p><code>%x</code> 表示格式化16进制数输出。</p>
</li>
<li>
<p><code>%o</code> 表示格式化8进制数输出。</p>
</li>
<li>
<p><code>%s</code> 表示格式化字符串输出。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">9.9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d\t%f\t%s&quot;</span> % (x, x, x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d\t%f\t%s&quot;</span> % (y, y, y))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">10      10.000000       10</span><br><span class="line">9       9.900000        9.9</span><br></pre></td></tr></table></figure>
<p>与C语言类似，在控制浮点数的输出时，有如下语法：</p>
<ul>
<li><code>%nd</code> ：格式化整数输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带正号表明输出在左边加上符号，若n带负号表示数据靠左输出。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">11111</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;|%2d| |%+2d| |%-2d| |%6d| |%+6d| |%-6d| &quot;</span> % (x, x, x, x, x, x))</span><br><span class="line"><span class="comment"># 输出结果：|11111| |+11111| |11111| | 11111| |+11111| |11111 |</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>%no</code> ：格式化八进制输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带正号表明输出在左边加上符号，若n带负号表示数据靠左输出。</p>
</li>
<li>
<p><code>%nx</code> ：格式化十六进制输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带正号表明输出在左边加上符号，若n带负号表示数据靠左输出。</p>
</li>
<li>
<p><code>%ns</code> ：格式化八进制输出。若n不带符号表明保留n格空间，保留空间不足将完整输出数据。若n带负号表示数据靠左输出。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;|%2s| |%-2s| |%6s| |%-6s|&quot;</span> % (x, x, x, x))</span><br><span class="line"><span class="comment"># 输出结果：|Hello| |Hello| | Hello| |Hello |</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>%m.nf</code> ：格式化浮点数输出。m表示保留多少格数输出（包括小数点），n表示小数部分保留位数。若带上正号表明输出在左边加上符号，若带上符号表明数据靠左输出。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3.14159</span></span><br><span class="line">x = <span class="number">3.14159</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;|%5f| |%10f| |%5.2f| |%+5.2f| |%-5.2f|&quot;</span> % (x, x, x, x, x))</span><br><span class="line"><span class="comment"># 输出结果：|3.141590| |  3.141590| | 3.14| |+3.14| |3.14 |</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-format-函数">5.2.3 format()函数</h4>
<p>使用 <code>format()</code> 函数的输出格式为： <code>print(&quot;输出格式字符串&quot; .format(变量, ...))</code></p>
<ul>
<li>
<p>输出格式字符串中输出变量的位置使用 <code>&#123;&#125;</code> 表示。</p>
</li>
<li>
<p><code>&#123;&#125;</code> 中填入 <code>!a</code> (使用 ascii()), <code>!s</code> (使用 str()) 和 <code>!r</code> (使用 repr()) 可以用于在格式化某个值之前对其进行转化。</p>
</li>
<li>
<p>格式内容如下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">数字</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">输出</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3.1415926</td>
<td style="text-align:center"><code>&#123;:.2f&#125;</code></td>
<td style="text-align:center">3.14</td>
<td style="text-align:center">保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:center">3.1415926</td>
<td style="text-align:center"><code>&#123;:+.2f&#125;</code></td>
<td style="text-align:center">+3.14</td>
<td style="text-align:center">带符号保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:center">-1</td>
<td style="text-align:center"><code>&#123;:+.2f&#125;</code></td>
<td style="text-align:center">-1.00</td>
<td style="text-align:center">带符号保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:center">2.71828</td>
<td style="text-align:center"><code>&#123;:.0f&#125;</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">不带小数</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>&#123;:0&gt;2d&#125;</code></td>
<td style="text-align:center">05</td>
<td style="text-align:center">数字补零（填充左边，宽度为2）</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>&#123;:x&lt;4d&#125;</code></td>
<td style="text-align:center">5xxx</td>
<td style="text-align:center">数字补x（填充右边，宽度为4）</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><code>&#123;:x&lt;4d&#125;</code></td>
<td style="text-align:center">10xx</td>
<td style="text-align:center">数字补x（填充右边，宽度为4）</td>
</tr>
<tr>
<td style="text-align:center">1000000</td>
<td style="text-align:center"><code>&#123;:,&#125;</code></td>
<td style="text-align:center">1,000,000</td>
<td style="text-align:center">以逗号分隔的数字格式</td>
</tr>
<tr>
<td style="text-align:center">0.25</td>
<td style="text-align:center"><code>&#123;:.2%&#125;</code></td>
<td style="text-align:center">25.00%</td>
<td style="text-align:center">百分比格式</td>
</tr>
<tr>
<td style="text-align:center">1000000000</td>
<td style="text-align:center"><code>&#123;:.2e&#125;</code></td>
<td style="text-align:center">1.00e+09</td>
<td style="text-align:center">指数记法</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><code>&#123;:10d&#125;</code></td>
<td style="text-align:center">13</td>
<td style="text-align:center">右对齐，宽度为10</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><code>&#123;:&lt;10d&#125;</code></td>
<td style="text-align:center">13</td>
<td style="text-align:center">左对齐，宽度为10</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><code>&#123;:^10d&#125;</code></td>
<td style="text-align:center">13</td>
<td style="text-align:center">中间对齐，宽度为10</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>&#123;:b&#125;</code></td>
<td style="text-align:center">1011</td>
<td style="text-align:center">二进制表示</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>&#123;:d&#125;</code></td>
<td style="text-align:center">11</td>
<td style="text-align:center">十进制表示</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>&#123;:o&#125;</code></td>
<td style="text-align:center">13</td>
<td style="text-align:center">八进制表示</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>&#123;:x&#125;</code></td>
<td style="text-align:center">b</td>
<td style="text-align:center">十六进制表示</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>&#123;:#x&#125;</code></td>
<td style="text-align:center">0xb</td>
<td style="text-align:center">十六进制表示</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>&#123;:#X&#125;</code></td>
<td style="text-align:center">0xB</td>
<td style="text-align:center">十六进制表示</td>
</tr>
</tbody>
</table>
<h4 id="5-2-4-dir-函数">5.2.4 dir()函数</h4>
<p>通过 <code>dir()</code> 函数可以列出Python的函数。</p>
<p>其格式为： <code>dir(__builtins__)</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(dit(a)) <span class="comment"># 列出int的所有函数</span></span><br></pre></td></tr></table></figure>
<p>再结合 <code>help()</code> 函数即可了解每个函数的意义。</p>
<h3 id="5-3-输入">5.3 输入</h3>
<p>通过 <code>input()</code> 函数输入一行文本。</p>
<p>该函数的格式为： <code>value = input(&quot;promt:&quot;)</code></p>
<ul>
<li>
<p>value：输入数据存入到该变量中，不论输入什么，value都是字符串数据类型，需要进行处理。</p>
</li>
<li>
<p>promt：输入提示词。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入的数字是&#123;&#125;，其类型是&#123;&#125;&quot;</span>.<span class="built_in">format</span>(a, <span class="built_in">type</span>(a)))</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入的数字是&#123;&#125;，其类型是&#123;&#125;&quot;</span>.<span class="built_in">format</span>(b, <span class="built_in">type</span>(b)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行窗口：</span></span><br><span class="line"><span class="comment"># 请输入一个数字：6</span></span><br><span class="line"><span class="comment"># 输入的数字是6，其类型是&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 请输入一个数字：6</span></span><br><span class="line"><span class="comment"># 输入的数字是6，其类型是&lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="六-python的条件结构">六. Python的条件结构</h2>
<h3 id="6-1-if语句">6.1 if语句</h3>
<p>if语句的基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断):</span><br><span class="line">	程序代码块</span><br></pre></td></tr></table></figure>
<p>如果条件判断是True，则执行程序代码区块，如果条件判断是False,则不执行程序代码区块。如果程序代码区块只有一道指令，可将上述语法写成： <code>if(条件判断): 程序代码</code></p>
<p>实际上，Python的条件结构可以不带 <code>()</code> ，但此教程带上了 <code>()</code> ，为了看起来更清晰。</p>
<p>在Python内是使用缩进方式区隔if语句的程序代码区块，编辑程序时可以用Tab键内缩或是直接内缩4个字符空间，表示这是if语句的程序代码区块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你成年了&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你的年龄是&#123;&#125;&quot;</span>.<span class="built_in">format</span>(age))</span><br></pre></td></tr></table></figure>
<p>实际上不一定非得缩进4格字符空间，任意相同缩进的连续语句都可看作是同一代码块。</p>
<h3 id="6-2-if-else语句">6.2 if-else语句</h3>
<p>程序设计时更常用的功能是条件判断为True时执行某一个程序代码区块，当条件判断为False时执行另一段程序代码区块，此时可以使用if…else语句，它的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断):</span><br><span class="line">	程序代码块一</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	程序代码块二</span><br></pre></td></tr></table></figure>
<p>如果条件判断是True,则执行程序代码区块一，如果条件判断是False,则执行程序代码区块二。</p>
<h3 id="6-3-if-elif-else语句">6.3 if-elif-else语句</h3>
<p>当程序进行多重判断时，可以使用if-elif-else语句，它的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断一):</span><br><span class="line">	程序代码块一</span><br><span class="line"><span class="keyword">elif</span> (条件判断二):</span><br><span class="line">	程序代码块二</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	程序代码块n</span><br></pre></td></tr></table></figure>
<p>如果条件判断一是True则执行程序代码区块一，然后离开条件判断。否则检查条件判断二，如果是True则执行程序代码区块二，然后离开条件判断。如果条件判断是False则持续进行检查，上述elif的条件判断可以不断扩充，如果所有条件判断是False则执行程序代码区块。</p>
<p>举个例子，分数采取A、B、C、D、F，通常90-100分是A，80-89分是B，70-79分是C，60-69分是D，低于60分是F。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的分数：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你的成绩是A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (score &gt;= <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">89</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你的成绩是B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (score &gt;= <span class="number">70</span> <span class="keyword">and</span> score &lt;= <span class="number">79</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你的成绩是C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt;= <span class="number">69</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你的成绩是D&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;你的成绩是F&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-4-嵌套的if语句">6.4 嵌套的if语句</h3>
<p>if语句中有其他的if语句，称作if的嵌套。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断一):</span><br><span class="line">	<span class="keyword">if</span> (条件判断A):</span><br><span class="line">		程序代码块A</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		程序代码块B</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	程序代码块二</span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="七-python的循环结构">七. Python的循环结构</h2>
<h3 id="7-1-for循环">7.1 for循环</h3>
<p>for循环的一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> sequence:</span><br><span class="line">    <span class="comment"># statements</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># statements</span></span><br></pre></td></tr></table></figure>
<p>for循环可以遍历任何可迭代对象，如一个列表、元组或者一个字符串。</p>
<p>这个“sequence”可以配合 <code>range()</code> 函数使用，完成一个计数作用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">	<span class="built_in">print</span>(number)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<p>注意， <code>range()</code> 函数区间左闭右开，其作用是生成一个数列，它有以下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">6</span>)	<span class="comment"># 生成0到5，步长为1的数列</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)	<span class="comment"># 生成1到4，步长为1的数列</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)	<span class="comment"># 生成0到9，步长为3的数列</span></span><br></pre></td></tr></table></figure>
<p>同时，for循环可以使用else语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环主体</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环结束后执行的代码</span></span><br></pre></td></tr></table></figure>
<p>当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 <code>else</code> 子句中的代码，如果在循环过程中遇到了 <code>break</code> 语句，则会中断循环，此时不会执行 <code>else</code> 子句。可以查看下面这两个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  <span class="comment"># do Nothing</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Finally finished!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  <span class="keyword">if</span> x == <span class="number">6</span>: <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Finally finished!&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Finally finished!</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="7-2-while循环">7.2 while循环</h3>
<p><code>while</code> 语句的一般形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( condition <span class="keyword">is</span> true ):</span><br><span class="line">	sentences;</span><br></pre></td></tr></table></figure>
<p>此处 <code>condition</code> 为表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。循环体可以是一条语句，也可以是一个语句块（用花括号包起来）。 <code>while</code> 循环的特点是先判断条件表达式，后执行循环体语句。</p>
<p><code>while</code> 语句的运行顺序是：从上至下，先判断条件表达式是否为真，为真则执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<p>同时，while循环也可以使用else语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    <span class="comment"># statements</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># statements</span></span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> (count, <span class="string">&quot; 小于 5&quot;</span>)</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (count, <span class="string">&quot; 大于或等于 5&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">0  小于 5</span><br><span class="line">1  小于 5</span><br><span class="line">2  小于 5</span><br><span class="line">3  小于 5</span><br><span class="line">4  小于 5</span><br><span class="line">5  大于或等于 5</span><br></pre></td></tr></table></figure>
<h3 id="7-3-break-continue和pass">7.3 break、continue和pass</h3>
<ul>
<li><code>break</code> 语句可以跳出 <code>for</code> 和 <code>while</code> 的循环体。如果从 <code>for</code> 或 <code>while</code> 循环中终止，任何对应的循环 else 块将不执行。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/py-language-leaning_break.png" alt="break的过程"></p>
<ul>
<li><code>continue</code> 语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/py-language-leaning_continue.png" alt="continue的过程"></p>
<ul>
<li><code>pass</code> 语句不做任何事情，一般用做占位语句。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：finish</span></span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="八-python面向对象">八. Python面向对象</h2>
<h3 id="8-1-面向对象的相关概念">8.1 面向对象的相关概念</h3>
<p>这里有一些关于面向对象的概念：</p>
<ul>
<li>
<p>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li>
<p>方法：类中定义的函数。</p>
</li>
<li>
<p>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li>
<p>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>
</li>
<li>
<p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li>
<p>局部变量：定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li>
<p>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</p>
</li>
<li>
<p>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</p>
</li>
<li>
<p>实例化：创建一个类的实例，类的具体对象。</p>
</li>
<li>
<p>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<h3 id="8-2-类的定义">8.2 类的定义</h3>
<p>语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>比如，我有一个类，它是描述狗的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">	weight = <span class="literal">None</span>	<span class="comment"># 类的公有属性，此处是狗的体重</span></span><br><span class="line">	color = <span class="literal">None</span>	<span class="comment"># 类的公有属性，此处是狗的颜色</span></span><br><span class="line">	__name = <span class="literal">None</span>	<span class="comment"># 类的私有属性，此处是狗的名字</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):	<span class="comment"># 类的方法，此处是发出声音方法</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;汪&quot;</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog()	<span class="comment"># 类的实例化</span></span><br><span class="line">dog.sound()	<span class="comment"># 类的实例调用类的方法</span></span><br></pre></td></tr></table></figure>
<p>对于属性而言，公有属性一般是基本属性，在类外部可以直接访问（比如 <code>dog.weight</code> ）；私有属性不可以在类外部访问（比如 <code>dog.__name</code> 是不允许的），在类内部的属性中使用时 <code>self.__name</code> 。同理方法也有公有和私有之分，私有方法以两个下划线开头。</p>
<p>对于类的方法而言，与普通的函数只有一个特别的区别，就是类的方法必须有一个额外的第一个参数名称, 按照惯例它的名称是 <code>self</code> 。 <code>self</code> 代表了类的实例，代表当前对象的地址。</p>
<p>实际上也不非得是 <code>self</code> ，全部换成别的也行。</p>
<h3 id="8-3-类的方法">8.3 类的方法</h3>
<h4 id="8-3-1-构造方法">8.3.1 构造方法</h4>
<p>构造方法的函数名为 <code>__init__</code> ，语法像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="variable language_">self</span>.data = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>类定义了 <code>__init__()</code> 方法，类的实例化操作会自动调用 <code>__init__()</code> 方法。如上面的狗类，给他完善一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">	weight = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是狗的体重</span></span><br><span class="line">	color = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是狗的颜色</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, c</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line">		<span class="variable language_">self</span>.color = c</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):	<span class="comment"># 类的方法，此处是发出声音方法</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;汪&quot;</span>)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是一只&#123;&#125;色的狗，重量是&#123;&#125;kg&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.color, <span class="variable language_">self</span>.weight))</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="number">10</span>, <span class="string">&#x27;黑&#x27;</span>)	<span class="comment"># 类的实例化，并且实例化时设定属性值</span></span><br><span class="line">dog.about()	<span class="comment"># 输出关于狗狗的信息</span></span><br><span class="line">dog.sound()	<span class="comment"># 类的实例调用类的方法</span></span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-其他方法">8.3.2 其他方法</h4>
<p>有构造方法，自然也有析构方法，他们是对立的。析构方法是释放对象时使用。一般隐式自动调用，函数名为 <code>__del__</code> 。</p>
<p>类还有一些方法：</p>
<ul>
<li>
<p><code>__repr__</code> : 打印，转换</p>
</li>
<li>
<p><code>__setitem__</code> : 按照索引赋值</p>
</li>
<li>
<p><code>__getitem__</code> : 按照索引获取值</p>
</li>
<li>
<p><code>__len__</code> : 获得长度</p>
</li>
<li>
<p><code>__cmp__</code> : 比较运算</p>
</li>
<li>
<p><code>__call__</code> : 函数调用</p>
</li>
<li>
<p><code>__add__</code> : 加运算</p>
</li>
<li>
<p><code>__sub__</code> : 减运算</p>
</li>
<li>
<p><code>__mul__</code>: 乘运算</p>
</li>
<li>
<p><code>__truediv__</code>: 除运算</p>
</li>
<li>
<p><code>__mod__</code>: 求余运算</p>
</li>
<li>
<p><code>__pow__</code>: 乘方</p>
</li>
</ul>
<h3 id="8-4-类的继承">8.4 类的继承</h3>
<p>类的继承允许一个子类继承另一个类（称作父类），继承父类的属性和方法。集成的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(<span class="title class_ inherited__">BaseClassName</span>):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>拿回上面的例子，狗类应该是继承自动物类的，因为狗包含在动物里。而动物都有重量这个属性；在狗类里，除了继承重量这一属性，还可以添加新的属性，比如颜色：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">	weight = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是动物的体重，未知设为None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):	<span class="comment"># 狗类继承动物类</span></span><br><span class="line">	color = <span class="literal">None</span>	<span class="comment"># 类的属性，此处添加狗的颜色，未知设为None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, c</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line">		<span class="variable language_">self</span>.color = c</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):	<span class="comment"># 类的方法，此处是发出声音方法</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;汪&quot;</span>)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是一只&#123;&#125;色的狗，重量是&#123;&#125;kg&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.color, <span class="variable language_">self</span>.weight))</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="number">10</span>, <span class="string">&#x27;黑&#x27;</span>)	<span class="comment"># 类的实例化，并且实例化时设定属性值</span></span><br><span class="line">dog.about()	<span class="comment"># 输出关于狗狗的信息</span></span><br><span class="line">dog.sound()	<span class="comment"># 类的实例调用类的方法</span></span><br></pre></td></tr></table></figure>
<p>实际上，还可以继承多个父类，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>如狗类从动物类里继承得到重量这一属性，同时也可以从花类里继承得到颜色这一属性，虽然会有点怪，但这确实可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">	weight = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是动物的体重，未知设为None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flower</span>:</span><br><span class="line">	color = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是花的颜色，未知设为None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c</span>):</span><br><span class="line">		<span class="variable language_">self</span>.color = c</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Animal, Flower):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, c</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line">		<span class="variable language_">self</span>.color = c</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):	<span class="comment"># 类的方法，此处是发出声音方法</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;汪&quot;</span>)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是一只&#123;&#125;色的狗，重量是&#123;&#125;kg&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.color, <span class="variable language_">self</span>.weight))</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="number">10</span>, <span class="string">&#x27;黑&#x27;</span>)	<span class="comment"># 类的实例化，并且实例化时设定属性值</span></span><br><span class="line">dog.about()	<span class="comment"># 输出关于狗狗的信息</span></span><br><span class="line">dog.sound()	<span class="comment"># 类的实例调用类的方法</span></span><br></pre></td></tr></table></figure>
<p>即使狗类里面没有属性，但是通过继承可以得到想要的属性。</p>
<p>但是如果继承太多，方法名字重复了或者父类提供的方法不能满足需求，可以进行方法重写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">	weight = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是动物的体重，未知设为None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这只动物的重量是&#123;&#125;kg&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.weight))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flower</span>:</span><br><span class="line">	color = <span class="literal">None</span>	<span class="comment"># 类的属性，此处是花的颜色，未知设为None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c</span>):</span><br><span class="line">		<span class="variable language_">self</span>.color = c</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这朵花的颜色是&#123;&#125;色&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.color))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Animal, Flower):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, c</span>):</span><br><span class="line">		<span class="variable language_">self</span>.weight = w</span><br><span class="line">		<span class="variable language_">self</span>.color = c</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是一只&#123;&#125;色的狗，重量是&#123;&#125;kg&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.color, <span class="variable language_">self</span>.weight))</span><br><span class="line"></span><br><span class="line">animal = Animal(<span class="number">20</span>)</span><br><span class="line">flower = Flower(<span class="string">&#x27;红&#x27;</span>)</span><br><span class="line">dog = Dog(<span class="number">10</span>, <span class="string">&#x27;黑&#x27;</span>)	<span class="comment"># 类的实例化，并且实例化时设定属性值</span></span><br><span class="line">animal.about()</span><br><span class="line">flower.about()</span><br><span class="line">dog.about()	<span class="comment"># 输出关于狗狗的信息</span></span><br></pre></td></tr></table></figure>
<p>上述代码则对 <code>about()</code> 函数进行了重写，以满足狗类的需求。</p>
<p>重写方法或者重写运算符可以实现一些特殊的功能。</p>
<p>但是对于构造函数，子类不重写 <code>__init__()</code> ，实例化子类时，会自动调用父类定义的 <code>__init__()</code> 。如果重写了 <code>__init__</code> 时，实例化子类，就不会调用父类已经定义的 <code>__init__</code> 。还有一种情况，如果重写了 <code>__init__()</code> 函数，仍想调用父类构造方法时，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(子类, <span class="variable language_">self</span>).__init__(...)</span><br><span class="line"><span class="comment"># 或者是：父类名称.__init__(self, ...)</span></span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="九-列表-list">九. 列表 List</h2>
<h3 id="9-1-什么是列表">9.1 什么是列表</h3>
<p>Python的列表可以存储相同数据类型的数据，也可以存储不同数据类型的数据。</p>
<p>定义列表的语法格式为： <code>listName = [元素1, …, 元素n]</code></p>
<p>列表的每一个数据称作元素，置于括号 <code>[]</code> 中，用逗号隔开。</p>
<p>其中空列表为没有任何元素的列表。</p>
<p>同样，当我们不需要这个列表时，使用 <code>del</code> 删除列表。</p>
<h3 id="9-2-列表的运算和方法">9.2 列表的运算和方法</h3>
<h4 id="9-2-1-输出列表">9.2.1 输出列表</h4>
<p>当我们有一个列表时，直接使用print()函数即可输出整个列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># 输出结果：[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-读取-修改和删除列表元素">9.2.2 读取、修改和删除列表元素</h4>
<p>可以通过列表名称与索引读取列表元素的内容，元素的索引值从0开始。修改同理，只需要更改存储的数据即可。</p>
<p>当索引值为负值时，表示从列表结尾数起，-1为最后一个元素，-2为最后第2个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>]) 	<span class="comment"># 5</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)		<span class="comment"># [1, 3, 6, 7]</span></span><br></pre></td></tr></table></figure>
<p>同时可以使用 <code>in</code> 运算符判断某元素是否在列表中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> <span class="built_in">list</span>) 	<span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>如果希望删除列表的元素，同样使用 <code>del</code> 进行。</p>
<ul>
<li>
<p><code>del list[i]</code> ：删除索引为i的元素。</p>
</li>
<li>
<p><code>del list[start:end]</code> ：删除索引从start到end-1的所有元素。</p>
</li>
<li>
<p><code>del list[start:end:step]</code> ：每隔step，删除索引从start到end-1的元素。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)	<span class="comment"># [1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)	<span class="comment"># [1, 3, 7, 9]</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)	<span class="comment"># [1, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="9-2-3-列表切片">9.2.3 列表切片</h4>
<p>在设计程序时，常会需要取得列表前几个元素、后几个元素、某区间元素或是依照一定规则排序的元素，所取得的系列元素也可称子列表，这个过程也称列表切片(list slices)。</p>
<ul>
<li>
<p><code>list[start:end]</code> ：读取从索引start到(end-1)索引的列表元素。</p>
</li>
<li>
<p><code>list[:n]</code> ：取得列表前n个。</p>
</li>
<li>
<p><code>list[n:]</code> ：取得列表索引n到最后。</p>
</li>
<li>
<p><code>list[-n:]</code> ：取得列表后n名。</p>
</li>
<li>
<p><code>list[:]</code> ：取得所有元素。</p>
</li>
<li>
<p><code>list[start:end:step]</code> ：每隔step,读取从索引start到(end-l)<br>
索引的列表元素。</p>
</li>
</ul>
<h4 id="9-2-4-列表的统计方法">9.2.4 列表的统计方法</h4>
<ul>
<li><code>max()</code> ：取得列表的最大值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="built_in">list</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>min()</code> ：取得列表的最小值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(<span class="built_in">list</span>)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>sum()</code> ：取得列表的总和。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">list</span>)) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<h4 id="9-2-5-列表的元素个数">9.2.5 列表的元素个数</h4>
<ul>
<li><code>len()</code> ：判断列表中元素个数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>也可通过 <code>len()</code> 函数判断列表是否为空。</p>
<h4 id="9-2-6-列表的加法-乘法">9.2.6 列表的加法、乘法</h4>
<p>列表与列表相加表示列表的结合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(list1 + list2) <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>列表与数字相乘表示列表元素重复多少次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span> * <span class="number">3</span>) <span class="comment"># [1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-列表的其他方法">9.3 列表的其他方法</h3>
<ol>
<li>
<p><code>list.append(obj)</code> ：在列表末尾添加新的对象。</p>
</li>
<li>
<p><code>list.count(obj)</code> ：统计某个元素在列表中出现的次数。</p>
</li>
<li>
<p><code>list.extend(seq)</code> ：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。</p>
</li>
<li>
<p><code>list.index(obj)</code> ：从列表中找出某个值第一个匹配项的索引位置。</p>
</li>
<li>
<p><code>list.insert(index, obj)</code> ：将对象插入列表。</p>
</li>
<li>
<p><code>list.pop([index=-1])</code> ：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。</p>
</li>
<li>
<p><code>list.remove(obj)</code> ：移除列表中某个值的第一个匹配项。</p>
</li>
<li>
<p><code>list.reverse()</code> ：反向列表中元素。</p>
</li>
<li>
<p><code>list.sort(key=None, reverse=False)</code> ：对原列表进行排序。</p>
</li>
<li>
<p><code>list.clear()</code> ：清空列表。</p>
</li>
<li>
<p><code>list.copy()</code> ：返回复制后的新列表。有兴趣可了解深拷贝和浅拷贝。</p>
</li>
</ol>
<p>具体的函数解释用法可以边用边搜索。</p>
<p></br></br></br></p>
<h2 id="十-元组-tuple">十. 元组 Tuple</h2>
<h3 id="10-1-什么是元组">10.1 什么是元组</h3>
<p>Python的元组与列表类似，不同之处在于元组的元素 <strong>不能修改</strong> 。元组使用小括号 <code>( )</code> ，列表使用方括号 <code>[ ]</code> 。</p>
<p>定义元组的语法格式为： <code>tupName = (元素1, 元素2, ...)</code></p>
<p>元组的每一个数据称作元素，置于括号 <code>()</code> 中，用逗号隔开。如果元组中只包含一个元素时，需要在元素后面添加逗号 <code>,</code> ，否则括号会被当作运算符使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>
<p>其中空元组为没有任何元素的元组。</p>
<p>同样，当我们不需要这个元组时，使用 <code>del</code> 删除元组。</p>
<h3 id="10-2-元组的运算和方法">10.2 元组的运算和方法</h3>
<h4 id="10-2-1-输出元组">10.2.1 输出元组</h4>
<p>当我们有一个元组时，直接使用print()函数即可输出整个元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure>
<h4 id="10-2-2-读取元组元素">10.2.2 读取元组元素</h4>
<p>元组同样通过下标索引访问元组中的值。与列表类似。</p>
<p>但通过索引修改元组元素的操作是不被允许的，但是可以通过 <code>+</code> 进行元组的拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)</span><br></pre></td></tr></table></figure>
<p>同时也不允许删除元组中的元素值，只能通过 <code>del</code> 删除整个元组。</p>
<h4 id="10-2-3-元组截取">10.2.3 元组截取</h4>
<p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素。</p>
<ul>
<li>
<p><code>tup[start:end]</code> ：读取从索引start到(end-1)索引的列表元素。</p>
</li>
<li>
<p><code>tup[:n]</code> ：取得列表前n个。</p>
</li>
<li>
<p><code>tup[n:]</code> ：取得列表索引n到最后。</p>
</li>
<li>
<p><code>tup[-n:]</code> ：取得列表后n名。</p>
</li>
<li>
<p><code>tup[:]</code> ：取得所有元素。</p>
</li>
<li>
<p><code>tup[start:end:step]</code> ：每隔step,读取从索引start到(end-l)<br>
索引的列表元素。</p>
</li>
</ul>
<h4 id="10-2-4-列表的统计函数">10.2.4 列表的统计函数</h4>
<ul>
<li><code>max()</code> ：取得元组的最大值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(tup)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>min()</code> ：取得元组的最小值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(tup)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<h4 id="10-2-5-元组的元素个数">10.2.5 元组的元素个数</h4>
<p>函数 <code>len()</code> 计算元组中元素个数。</p>
<h4 id="10-2-6-元组的加法-乘法">10.2.6 元组的加法、乘法</h4>
<p>元组支持 <code>+</code> 、 <code>+=</code> 、 <code>*</code> 运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)</span><br></pre></td></tr></table></figure>
<p>tup3 就是一个新的元组，它包含了 tup1 和 tup2 中的所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">tup1 += tup2</span><br><span class="line"><span class="built_in">print</span>(tup1)</span><br></pre></td></tr></table></figure>
<p>tup1 就变成了一个新的元组，它包含了 tup1 和 tup2 中的所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1 * <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>乘法的作用依然是复制。</p>
<p></br></br></br></p>
<h2 id="十一-字典-dict">十一. 字典 Dict</h2>
<h3 id="11-1-什么是字典">11.1 什么是字典</h3>
<p>字典是另一种可变容器模型，由键值对组成，且可存储任意类型对象。</p>
<p>字典的每个键值对用冒号 <code>:</code> 分割，每个对之间用逗号 <code>,</code> 分割，整个字典包括在花括号 <code>&#123;&#125;</code> 中 ,格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2, ...&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，键值对的键必须是唯一的，值可以不唯一。 <strong>创建时如果同一个键被赋值两次，后一个值会被记住。</strong></p>
<p>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。</p>
<p>同时创建空字典时，可以使用 <code>d = &#123;&#125;</code> 直接创建，也可以使用 <code>d= dict()</code> 函数创建。所以字典的名字不能取dict。</p>
<h3 id="11-2-字典的运算和方法">11.2 字典的运算和方法</h3>
<h4 id="11-2-1-输出字典">11.2.1 输出字典</h4>
<p>直接使用 <code>print()</code> 输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;apple&#x27;</span> : <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span> : <span class="string">&#x27;香蕉&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<h4 id="11-2-2-读取-修改和删除字典">11.2.2 读取、修改和删除字典</h4>
<p>与列表、元组使用索引值不同，字典需要把键放到方括号中。如果访问了字典里没有的键，就会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;apple&#x27;</span> : <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span> : <span class="string">&#x27;香蕉&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;apple&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>修改字典内容也是直接使用键访问设定新值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;apple&#x27;</span> : <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span> : <span class="string">&#x27;香蕉&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d[<span class="string">&#x27;apple&#x27;</span>] = <span class="string">&#x27;大苹果&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p>向字典添加新内容的方法是增加新的键值对：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;apple&#x27;</span> : <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span> : <span class="string">&#x27;香蕉&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d[<span class="string">&#x27;mango&#x27;</span>] = <span class="string">&#x27;芒果&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p>删除已有键值对如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;apple&#x27;</span> : <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span> : <span class="string">&#x27;香蕉&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>字典还有删除整个字典和清空字典的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;apple&#x27;</span> : <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span> : <span class="string">&#x27;香蕉&#x27;</span>&#125;</span><br><span class="line">d = clear()	<span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> d	<span class="comment"># 删除字典</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-字典的键值对数">11.2.3 字典的键值对数</h4>
<p>函数 <code>len()</code> 计算字典中键值对数。</p>
<h3 id="11-3-字典的方法">11.3 字典的方法</h3>
<ol>
<li>
<p><code>dict.clear()</code> ：删除字典内所有元素</p>
</li>
<li>
<p><code>dict.copy()</code> ：返回一个字典的复制</p>
</li>
<li>
<p><code>dict.fromkeys()</code> ：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</p>
</li>
<li>
<p><code>dict.get(key, default=None)</code> ：返回指定键的值，如果键不在字典中返回 default 设置的默认值</p>
</li>
<li>
<p><code>key in dict</code> ：如果键在字典dict里返回true，否则返回false</p>
</li>
<li>
<p><code>dict.items()</code> ：以列表返回一个视图对象</p>
</li>
<li>
<p><code>dict.keys()</code> ：返回一个视图对象</p>
</li>
<li>
<p><code>dict.setdefault(key, default=None)</code> ：和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</p>
</li>
<li>
<p><code>dict.update(dict2)</code> ：把字典dict2的键/值对更新到dict里</p>
</li>
<li>
<p><code>dict.values()</code> ：返回一个视图对象</p>
</li>
<li>
<p><code>pop(key[,default])</code> ：删除字典key（键）所对应的值，返回被删除的值。</p>
</li>
<li>
<p><code>popitem()</code> ：返回并删除字典中的最后一对键和值。</p>
</li>
</ol>
<p></br></br></br></p>
<h2 id="十二-集合-set">十二. 集合 Set</h2>
<h3 id="12-1-什么是集合">12.1 什么是集合</h3>
<p>集合（set）是一个无序的不重复元素序列。集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。</p>
<p>可以使用大括号 <code>&#123; &#125;</code> 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 <code>set()</code> 函数创建集合。创建一个空集合必须用 <code>set()</code> ，因为 { } 是用来创建一个空字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parame1 = &#123;value01,value02,...&#125;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">parame2 = <span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure>
<h3 id="12-2-集合基本操作">12.2 集合基本操作</h3>
<h4 id="12-2-1-添加元素">12.2.1 添加元素</h4>
<p><code>s.add(x)</code> ，将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p>
<p><code>s.update(x)</code> 也可以添加元素，且参数可以是列表，元组，字典等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.add(<span class="number">2</span>)</span><br><span class="line">s.update([<span class="number">4</span>,<span class="number">6</span>], [<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<h4 id="12-2-2-移除元素">12.2.2 移除元素</h4>
<p><code>s.remove(x)</code> ，将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p>
<p><code>s.discard(x)</code> ，将元素 x 从集合 s 中移除，如果元素不存在，不会发生错误。</p>
<p><code>s.pop()</code> ，随机删除集合中的一个元素。</p>
<h4 id="12-2-3-计算集合元素个数">12.2.3 计算集合元素个数</h4>
<p><code>len(s)</code> ，计算集合 s 元素的个数。</p>
<h4 id="12-2-4-清空集合">12.2.4 清空集合</h4>
<p><code>s.clear()</code> ，清空集合 s 。</p>
<h4 id="12-2-5-判断元素是否在集合中">12.2.5 判断元素是否在集合中</h4>
<p><code>x in s</code> ，存在返回True，不存在返回False。</p>
<h3 id="12-3-集合的方法">12.3 集合的方法</h3>
<ul>
<li>
<p><code>add()</code> ：为集合添加元素</p>
</li>
<li>
<p><code>clear()</code> ：移除集合中的所有元素</p>
</li>
<li>
<p><code>copy()</code> ：拷贝一个集合</p>
</li>
<li>
<p><code>difference()</code> ：返回多个集合的差集</p>
</li>
<li>
<p><code>difference_update()</code> ，移除集合中的元素，该元素在指定的集合也存在。</p>
</li>
<li>
<p><code>discard()</code> ，删除集合中指定的元素</p>
</li>
<li>
<p><code>intersection()</code> ，返回集合的交集</p>
</li>
<li>
<p><code>intersection_update()</code> ，返回集合的交集。</p>
</li>
<li>
<p><code>isdisjoint()</code> ，判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</p>
</li>
<li>
<p><code>issubset()</code> ，判断指定集合是否为该方法参数集合的子集。</p>
</li>
<li>
<p><code>issuperset()</code> ，判断该方法的参数集合是否为指定集合的子集</p>
</li>
<li>
<p><code>pop()</code> ，随机移除元素</p>
</li>
<li>
<p><code>remove()</code> ，移除指定元素</p>
</li>
<li>
<p><code>symmetric_difference()</code> ，返回两个集合中不重复的元素集合。</p>
</li>
<li>
<p><code>symmetric_difference_update()</code> ，移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</p>
</li>
<li>
<p><code>union()</code> ，返回两个集合的并集</p>
</li>
<li>
<p><code>update()</code> ，给集合添加元素</p>
</li>
</ul>
<p>具体使用解释可自行搜索。</p>
<p></br></br></br></p>
<h2 id="十三-迭代器和生成器">十三. 迭代器和生成器</h2>
<h3 id="13-1-迭代器">13.1 迭代器</h3>
<p>迭代器是一个可以 <strong>记住遍历的位置</strong> 的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：</p>
<ul>
<li>
<p><code>iter()</code> ：创建一个迭代器对象。</p>
</li>
<li>
<p><code>next()</code> ：返回下一个迭代器对象。</p>
</li>
</ul>
<p>字符串，列表或元组对象都可用于创建迭代器。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">	<span class="built_in">print</span>(x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment">#输出结果：1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>还可以把一个类作为一个迭代器使用，需要实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法。此处举例：创建一个返回数字的迭代器，初始值为 1，逐步递增 1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.a = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		x = <span class="variable language_">self</span>.a</span><br><span class="line">		<span class="variable language_">self</span>.a += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>当迭代完成时，会触发 <code>StopIteration</code> ，可以在 <code>__next__()</code> 中设置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.a = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> <span class="variable language_">self</span>.a &lt;= <span class="number">20</span>:</span><br><span class="line">			x = <span class="variable language_">self</span>.a</span><br><span class="line">			<span class="variable language_">self</span>.a += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		<span class="keyword">else</span>:	<span class="comment"># 设置迭代完成条件</span></span><br><span class="line">			<span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<h3 id="13-2-生成器">13.2 生成器</h3>
<p>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator）。</p>
<p><code>yield</code>  是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>当在生成器函数中使用 <code>yield</code> 语句时，函数的执行将会暂停，并将 <code>yield</code> 后面的表达式作为当前迭代的值返回。</p>
<p>然后，每次调用生成器的 <code>next()</code> 方法或使用 <code>for</code> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <code>yield</code>  语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>下面是一个简单的示例，展示了生成器函数的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></table></figure>
<p>再举一个例子，计算斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): 	<span class="comment"># 生成器函数计算斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a		<span class="comment"># 在此返回数列的项 a</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="十四-推导式">十四. 推导式</h2>
<h3 id="14-1-列表推导式">14.1 列表推导式</h3>
<p>格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [表达式 for 变量 in 列表] </span></span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [表达式 for 变量 in 列表 if 条件]</span></span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</p>
</li>
<li>
<p>for out_exp in input_list：迭代input_list将out_exp传入到out_exp_res表达式中。</p>
</li>
<li>
<p>if condition: 条件语句，可以过滤列表中不符合条件的值。</p>
</li>
</ul>
<p>推导出来是一个列表。</p>
<p>举个例子，求30以内能被4整除的整数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>
<p>再举个例子，求列表中长度大于3的字符串并大写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aasdad&quot;</span>, <span class="string">&quot;asdw&quot;</span>, <span class="string">&quot;wadhjuio&quot;</span>]</span><br><span class="line"><span class="built_in">str</span> = [x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span> <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<h3 id="14-2-字典推导式">14.2 字典推导式</h3>
<p>格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure>
<p>原理与列表推导式类似，推导出来的是一个字典。看一个例子，给出三个数字作为键，以对应的平方作为值，创建字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">d = &#123;i : i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p>再来一个例子，以列表中偶数索引为键，奇数索引为值创建字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>]</span><br><span class="line">d = &#123;<span class="built_in">list</span>[i] : <span class="built_in">list</span>[i + <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">list</span>), <span class="number">2</span>) <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)	<span class="comment"># &#123;&#x27;apple&#x27;: &#x27;苹果&#x27;, &#x27;banana&#x27;: &#x27;香蕉&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-集合推导式">14.3 集合推导式</h3>
<p>格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure>
<p>原理类似，推导出来的是一个集合。</p>
<h3 id="14-4-元组推导式-生成器表达式">14.4 元组推导式（生成器表达式）</h3>
<p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>
<p>格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure>
<p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <code>()</code> 圆括号将各部分括起来，而列表推导式用的是中括号 <code>[]</code> ，另外元组推导式返回的结果是一个生成器对象。需要使用 <code>tuple()</code> 函数，可以直接将生成器对象转换成元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(a)		<span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x000002B53CC81FF0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))	<span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a))	<span class="comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">tuple</span>(a)))	<span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p></br></br></br></p>
<h2 id="十五-文件的读写">十五. 文件的读写</h2>
<h3 id="15-1-打开文件">15.1 打开文件</h3>
<p>Python的 <code>open()</code> 方法用于打开一个文件，并返回文件对象。注意打开文件使用完后记得关闭文件 <code>close()</code></p>
<p>在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <code>OSError</code> 异常。</p>
<p>该函数的完整格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>file: 必需，文件路径（相对或者绝对路径）。</p>
</li>
<li>
<p>mode: 可选，文件打开模式</p>
</li>
<li>
<p>buffering: 设置缓冲</p>
</li>
<li>
<p>encoding: 一般使用utf8</p>
</li>
<li>
<p>errors: 报错级别</p>
</li>
<li>
<p>newline: 区分换行符</p>
</li>
<li>
<p>closefd: 传入的file参数类型</p>
</li>
<li>
<p>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</p>
</li>
</ul>
<p>一般情况下，只需传入file参数和mode参数即可。</p>
<p>mode参数有：</p>
<ul>
<li>
<p><code>t</code> ：文本模式 (默认)。</p>
</li>
<li>
<p><code>x</code> ：写模式，新建一个文件，如果该文件已存在则会报错。</p>
</li>
<li>
<p><code>b</code> ：二进制模式。</p>
</li>
<li>
<p><code>+</code> ：打开一个文件进行更新(可读可写)。</p>
</li>
<li>
<p><code>r</code> ：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</p>
</li>
<li>
<p><code>rb</code> ：以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</p>
</li>
<li>
<p><code>r+</code> ：打开一个文件用于读写。文件指针将会放在文件的开头。</p>
</li>
<li>
<p><code>rb+</code> ：以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</p>
</li>
<li>
<p><code>w</code> ：打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</p>
</li>
<li>
<p><code>wb</code> ：以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</p>
</li>
<li>
<p><code>w+</code> ：打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</p>
</li>
<li>
<p><code>wb+</code> ：以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</p>
</li>
<li>
<p><code>a</code> ：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p>
</li>
<li>
<p><code>ab</code> ：以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p>
</li>
<li>
<p><code>a+</code> ：打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</p>
</li>
<li>
<p><code>ab+</code> ：以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</p>
</li>
</ul>
<h3 id="15-2-文件对象的方法">15.2 文件对象的方法</h3>
<p>使用 <code>open()</code> 函数会创建一个file对象，file对象有以下常用函数：</p>
<ol>
<li>
<p><code>file.close()</code> ：关闭文件。关闭后文件不能再进行读写操作。</p>
</li>
<li>
<p><code>file.flush()</code> ：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</p>
</li>
<li>
<p><code>file.fileno()</code> ：返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</p>
</li>
<li>
<p><code>file.isatty()</code> ：如果文件连接到一个终端设备返回 True，否则返回 False。</p>
</li>
<li>
<p><code>file.read([size])</code> ：从文件读取指定的字节数，如果未给定或为负则读取所有。</p>
</li>
<li>
<p><code>file.readline([size])</code> ：读取整行，包括 “\n” 字符。</p>
</li>
<li>
<p><code>file.readlines([sizeint])</code> ：读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</p>
</li>
<li>
<p><code>file.seek(offset[, whence])</code> ：移动文件读取指针到指定位置</p>
</li>
<li>
<p><code>file.tell()</code> ：返回文件当前位置，是从文件开头开始算起的字节数。</p>
</li>
<li>
<p><code>file.truncate([size])</code> ：从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</p>
</li>
<li>
<p><code>file.write(str)</code> ：将字符串写入文件，返回的是写入的字符长度。</p>
</li>
<li>
<p><code>file.writelines(sequence)</code> ：向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</p>
</li>
</ol>
<p>方法众多，需要时再查阅资料再学习。</p>
<h3 id="15-3-读取文件">15.3 读取文件</h3>
<p><code>file.read()</code> 方法：</p>
<ul>
<li>
<p>为了读取一个文件的内容，调用 <code>file.read(size)</code>, 这将读取一定数目的数据, 然后作为字符串或字节对象返回。</p>
</li>
<li>
<p><code>size</code> 是一个可选的数字类型的参数。 当 <code>size</code> 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.txt中内容：</span></span><br><span class="line"><span class="comment"># 111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># 111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><code>file.readline()</code> 方法：</p>
<ul>
<li><code>file.readline()</code> 会从文件中读取单独的一行。换行符为 ‘\n’。 <code>file.readline()</code> 如果返回一个空字符串, 说明已经已经读取到最后一行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.txt中内容：</span></span><br><span class="line"><span class="comment"># 111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.readline()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)	<span class="comment"># 输出结果：111</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><code>file.readlines()</code> 方法：</p>
<ul>
<li><code>f.readlines()</code> 将返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.txt中内容：</span></span><br><span class="line"><span class="comment"># 111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)	<span class="comment"># 输出结果：[&#x27;111\n&#x27;, &#x27;222&#x27;]</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h3 id="15-4-文件写入">15.4 文件写入</h3>
<p><code>file.write()</code> 方法：</p>
<ul>
<li><code>f.write(string)</code> 将 string 写入到文件中, 然后返回写入的字符数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.txt中为空</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">num = f.write(<span class="string">&#x27;111\n222&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)	<span class="comment"># 7</span></span><br><span class="line"><span class="comment"># test.txt输出结果：</span></span><br><span class="line"><span class="comment"># 111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>给大二的你</title>
    <url>/2024/tosophomore/</url>
    <content><![CDATA[<p>如今大三将完，给大二朋友的一些话。</p>
<p>关键词：经验</p>
<span id="more"></span>
<hr>
<p>相信经过大一一年的学习生活，你对学校、课程以及你自身有了一定的认识。你是适合卷的还是适合躺的，还是半躺半卷的，相信你也知道了。</p>
<p>比如我是不爱卷的，顺其自然，爱啥啥，绩点也不高。</p>
<p>在接下来的大二学年，希望你能再次做出一个选择：</p>
<ul>
<li>
<p>考研？保研？</p>
</li>
<li>
<p>就业？</p>
</li>
<li>
<p>考公？考编？</p>
</li>
</ul>
<p>如果你是记住了我去年提过的小小建议——<strong>提高广度</strong>，那么你对于你的求学生涯乃至职业生涯估计是有所了解的，对你做出上面的选择也是有帮助的。</p>
<p>另外你可能会问，为什么大二甚至还没踏入大二就要决定我未来的路？</p>
<ul>
<li>
<p>其实这也就是两三年后的事情，说慢不慢的。</p>
</li>
<li>
<p>如果你要考研，你现在可就轻松多了，把你的课过了、学分到手了，继续坚持你喜欢的兴趣爱好，等到大三再准备考研即可（不至于大二就复习考研吧，有点过于紧张了）；</p>
</li>
<li>
<p>如果你要保研，可能现在触发稍迟了，保研看的是你前三年的绩点，以及有的学校会看你的创新得分，所以志向保研的你在大二就需要多去打比赛，去满足保研的条件，必然是辛苦的；</p>
</li>
<li>
<p>如果你要就业，你就要审视你学习的课程与实际企业需求的技能之间的匹配度了，大学教的课程与时代脱节是正常的，与企业招聘岗位需求存在差别，此时你需要面向你的就业方向，强化你的技术。</p>
</li>
</ul>
<hr>
<p>下面还是一些关于计算机方面在大二时的建议：</p>
<p>相信你也会有关于计算机专业方面更广泛的认识，你也应该知道计算机专业很庞大，远远不只是计算机。此时的你对计算机（笔记本电脑）的操作应该是娴熟的，而不只是玩游戏和看视频的工具。</p>
<p>计算机专业的你在大二期间，不仅需要保持对计算机的兴趣，继续扩宽计算机视野，还要多操作多动手。</p>
<p>关于如何过好大二学年，以下是我的拙见：</p>
<blockquote>
<p>计算机基础能力方面：</p>
<ul>
<li>
<p>编程语言：这个不用多说，需要熟悉一门编程语言，且了解其他编程语言，这是你的计算机表达能力。</p>
</li>
<li>
<p>数据结构、计算机网络、计算机组成原理、操作系统：这个我在之前就提及过的知识方向，大一可能来不及或者忘了开始，现在还不迟，你依然可以从这些方面入手。</p>
</li>
<li>
<p>Linux系统：建议开始熟悉 Linux 系统，使用 Linux 系统，上手方法可以是下载虚拟机软件，或者是 WSL，或者是实装系统。</p>
</li>
<li>
<p>Git 工具：更多是代码管理方面，你需要养成代码的管理能力，包括但不限于代码迭代的变化记录、代码的提交保存和代码格式的控制等等。</p>
</li>
</ul>
</blockquote>
<p>计算机专业的你在大二更应该明确好方向，做好对保研、考研、就业等方向的选择。</p>
<ol>
<li>保研方面：</li>
</ol>
<blockquote>
<ul>
<li>
<p>保证你具备高绩点，学院排名靠前；</p>
</li>
<li>
<p>了解并尽量满足你的学校学院保研条件，针对性卷技术，多参加比赛；</p>
</li>
<li>
<p>保研的过程很累很辛苦，做好心理准备。专心走保研的路，下面的 2、3 条建议可以忽略。</p>
</li>
</ul>
</blockquote>
<ol start="2">
<li>考研方面：</li>
</ol>
<blockquote>
<ul>
<li>
<p>你还可以玩一年，或者一如既往的卷绩点、参加比赛、参加实验室项目，增加你的项目经历，这并不紧要；</p>
</li>
<li>
<p>可以谈个恋爱、发展兴趣爱好等等，你这一年比较轻松；</p>
</li>
<li>
<p>适时挑选考研目标院校，了解目标学校考研政策、招生简章之类的；</p>
</li>
<li>
<p>可以忽略第 3 条建议，也可听从。</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li>就业方面：这是一些关于专业技能实践上的一些建议</li>
</ol>
<blockquote>
<ul>
<li>
<p>选择好你的发展方向，选择好你的角色，也建议选择好你的主语言（语言只是工具，但最好熟悉一门），据 <a href="https://roadmap.sh/">roadmap 发展路线</a> 上的分类，具有：前端、后端、运维、全站、AI 工程师、数据分析师、安卓 / IOS 方向、数据库方向、区块链方向、质量保证工程师（QA）、软件架构师、网络空间安全、UX 设计、游戏开发、机器人开发等角色。</p>
</li>
<li>
<p>确定好你的方向，在 <a href="https://roadmap.sh/">https://roadmap.sh/</a> 或其他地方了解你的方向的发展路线，顺着发展路线学习。</p>
</li>
<li>
<p>了解、熟悉并使用你的角色上的一个或多个框架（或技术）。比如 C++ 方向上的 boost 框架、Java 方向上的 Spring Boot 框架、测试工程师方向上的测试框架、网络安全方向上的渗透、前端框架 Vue 等。</p>
</li>
<li>
<p>阅读关于你的方向上的一些开源项目，将其代码跑起来，并尝试做出些许修改，最后做出自己的项目。大二的时候可以尝试准备自己简历上的项目经历。</p>
</li>
<li>
<p>刷题还是要坚持，刷题网站有牛客竞赛、洛谷、力扣、Acwing 等等。</p>
</li>
</ul>
</blockquote>
<p>计算机专业一定要注重自学，要学会学习，不要盲目上课，真正重要的是你是否学习到了知识。</p>
<p>以上可能有遗漏没提及的点，仅提供方向，望多方听取建议，选择适合自己的。</p>
<p>如果想和我交流，或者是想要资料，建议发送到邮箱：<strong><a href="mailto:fingsinz@foxmail.com">fingsinz@foxmail.com</a></strong>。</p>
<p>希望大二有所收获。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验之谈</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>基于YOLOv5的电瓶车识别入门级项目记录</title>
    <url>/2023/yolov5/</url>
    <content><![CDATA[<p>一次基于YOLOv5的深度学习项目，在GPU服务器完成模型训练，在Windows 10下进行图像识别推理（C++）。</p>
<h2 id="零-前言">零 —— 前言</h2>
<p>此篇博客是我亲手做的一次项目记录（2023.7.3~2023.7.14），在GPU服务器完成基于YOLOv5的模型训练，在Windows 10下将训练得到的权重文件作基本处理转化为.onnx文件和.engine文件分别进行C++下的推理，最后并做了简单界面，效果如下图。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_chengguo.jpg" alt="成品展示"></p>
<p>本人学术不精，此篇博客可能会因为一些深度学习上的知识不熟悉而造成的表达错误，此博客只是记录此次项目过程，并尽力使其有参考性、使其可复刻。</p>
<p>项目代码放在<a href="https://gitee.com/fingsinz/ele-bicycle-detection/">码云Gitee仓库</a></p>
<p><br /><br /><br /></p>
<h2 id="壹-环境准备">壹 —— 环境准备</h2>
<p>本项目需要的环境：</p>
<ul>
<li><u>Python环境</u>：YOLOv5所需</li>
<li><u>CUDA环境</u>：调用显卡进行显存加速</li>
<li><u>OpenCV环境</u>：进行图像处理</li>
</ul>
<p>我的环境是CUDA12.0，OpenCV4.5.2，训练所用Python3.8.10，本机Windows 10所用Python3.11.4。</p>
<p>下载安装CUDA可参考<a href="https://fingsinz.space/2023/5/#more">这篇博客</a><br>
配置OpenCV和CUDA环境可参考<a href="https://fingsinz.space/2023/9/#more">这篇博客</a>。</p>
<p><br /><br /><br /></p>
<h2 id="贰-数据准备">贰 —— 数据准备</h2>
<h3 id="2-1-数据集结构">2.1 数据集结构</h3>
<p>本项目需要的数据集（不公开）：</p>
<ul>
<li><u>校园内电瓶车463张</u>：435张用于训练，28张用于验证</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_dataset.jpg" alt="数据集文件结构"></p>
<p>这个数量上和比例上并不良好，也没有设测试集，建议照片尽量多，并按8:1:1的比例分配在训练集、验证集和测试集。</p>
<ul>
<li>训练集：用于YOLOv5模型调试神经网络；相当于学生的课本，学生根据课本里的内容来掌握知识。</li>
<li>验证集：验证集用来查看训练效果；相当于作业，通过作业可以知道不同学生学习情况、进步的速度快慢。</li>
<li>测试集：用来测试网络的实际学习能力；相当于考试，考的题是平常都没有见过，考察学生举一反三的能力。</li>
</ul>
<p>数据集的文件结构应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataset</span><br><span class="line">|---images</span><br><span class="line">|   |---train</span><br><span class="line">|   |---val</span><br><span class="line">|   |---test</span><br><span class="line">|---labels</span><br><span class="line">|   |---train</span><br><span class="line">|   |---val</span><br><span class="line">|   |---test</span><br></pre></td></tr></table></figure>
<h3 id="2-2-处理数据集">2.2 处理数据集</h3>
<p>使用<a href="https://zhuanlan.zhihu.com/p/550021453">LabelImg</a>进行对图片标记。或自行搜索使用安装教程。</p>
<p>打标签时，选择YOLO格式，生成的是.txt文件，用于模型训练。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_labeling.jpg" alt="使用LabelImg工具对数据集进行打标签"></p>
<p>打完标签后，在labels文件夹下的train文件夹、val文件夹和test文件夹会生成一个对应images各文件夹的.txt文件，还会生成一个classes.txt文件。故labels文件夹下的各个文件夹会多一个文件。</p>
<p>最后命名此数据集为<code>eleb</code>。</p>
<p><br /><br /><br /></p>
<h2 id="叁-模型训练及分析">叁 —— 模型训练及分析</h2>
<h3 id="3-1-部署yolov5">3.1 部署YOLOv5</h3>
<p>训练模型需要在专业的GPU加速服务器上运行， <strong>请勿尝试在自己的电脑上跑模型</strong>。</p>
<p>挑选GPU服务器可参考<a href="https://fingsinz.space/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/gpuserver/#more">这篇博客</a>。</p>
<h4 id="3-1-1-使用社区镜像自动部署yolov5">3.1.1 使用社区镜像自动部署YOLOv5</h4>
<p>我使用的是AutoDL算力云，其社区镜像默认安装了YOLOv5。在算力市场中寻找合适的地区，GPU型号尽量好，按量计费租用。我此次租用的是：<u>芜湖区-RTX3090</u>，1.58r/h，跑四百多张图片估计是四个小时左右。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_ser.jpg" alt="租用GPU服务器"></p>
<p>租用实例后开机，我选择JupyterLab的方式连接服务器。为了方便，我把默认的<code>yolov5</code>文件夹转到（剪贴粘贴）数据盘。有文件如下：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_yolov5.jpg" alt="yolov5文件夹"></p>
<h4 id="3-1-2-手动部署yolov5">3.1.2 手动部署YOLOv5</h4>
<p>建议租用Ubuntu系统，在有Python、Git等环境下，服务器新建文件夹，使用git命令克隆<a href="https://github.com/ultralytics/yolov5">YOLOv5仓库</a>或者网页下载压缩包解压部署。如果有缺少的库可以<code>pip install</code>安装。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5.git</span><br></pre></td></tr></table></figure>
<p>至此YOLOv5部署完毕。</p>
<h3 id="3-2-上传数据">3.2 上传数据</h3>
<p>将我们准备好的数据集压缩成.zip压缩文件，上传到<code>yolov5/data/eleb</code>（数据集根目录，新建文件夹eleb），由于文件比较大，上传速度也比较慢，比较费时间，也可以在服务器上创建文件夹后多选文件上传。</p>
<p>在终端上进入<code>yolov5/data</code>运行下面的指令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">unzip xx.zip</span><br></pre></td></tr></table></figure>
<p>如果提示有包没下载就去下载。</p>
<p>解压后，复制data文件夹下的<code>coco.yaml</code>，并命名为数据集的名字。在上面我将数据集名字命名为<code>eleb</code>，故复制并命名为<code>eleb.yaml</code>。</p>
<p>将eleb.yaml编辑如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练集、验证集、测试集路径设置</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">./data/eleb</span>    <span class="comment"># 数据集根目录</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train</span>  <span class="comment"># 训练集目录</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/val</span>      <span class="comment"># 验证集目录</span></span><br><span class="line"><span class="attr">test:</span>                <span class="comment"># 测试集目录，此处没设立</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签的类，此项目只有一个类</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line">  <span class="attr">0:</span> <span class="string">elebike</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Download script/URL (optional) 不管，默认</span></span><br><span class="line"><span class="attr">download:</span> <span class="comment">#https://ultralytics.com/assets/coco128-seg.zip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3-配置训练参数">3.3 配置训练参数</h3>
<h4 id="3-3-1-修改train-py文件">3.3.1 修改train.py文件</h4>
<p><strong>回到<code>yolov5/</code>目录，找到<code>train.py</code>文件打开，找到<code>parse_opt()</code>函数，更改部分参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model.yaml是模型配置文件，在文件夹yolov5/models中，此处我使用yolov5l.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--cfg&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;yolov5l.yaml path&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置数据集的yaml文件，即eleb.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=ROOT / <span class="string">&#x27;data/eleb.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dataset.yaml path&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练轮数，默认300轮</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">300</span>, <span class="built_in">help</span>=<span class="string">&#x27;total training epochs&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练时所有GPU的总批量大小，为-1则自动</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>, <span class="built_in">help</span>=<span class="string">&#x27;所有GPU的总批量大小, -1 for autobatch&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练输入的照片大小，默认为640 × 640</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--imgsz&#x27;</span>, <span class="string">&#x27;--img&#x27;</span>, <span class="string">&#x27;--img-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">640</span>, <span class="built_in">help</span>=<span class="string">&#x27;train, val image size (pixels)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面保持默认即可</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-修改val-py文件">3.3.2 修改val.py文件</h4>
<p><strong>回到<code>yolov5/</code>目录，找到<code>val.py</code>文件打开，找到<code>parse_opt()</code>函数，更改部分参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置数据集的yaml文件，即eleb.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=ROOT / <span class="string">&#x27;data/eleb.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dataset.yaml path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-修改模型配置">3.3.3 修改模型配置</h4>
<p><strong>进入<code>yolov5/models/</code>目录，找到<code>train.py</code>设置的模型配置.yaml文件，我这里使用的是yolov5l模型，打开yolov5l.yaml，修改<code>nc</code>（分类数），此项目修改为1：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">1</span>  <span class="comment"># number of classes</span></span><br><span class="line"><span class="attr">depth_multiple:</span> <span class="number">1.0</span>  <span class="comment"># model depth multiple</span></span><br><span class="line"><span class="attr">width_multiple:</span> <span class="number">1.0</span>  <span class="comment"># layer channel multiple</span></span><br><span class="line"><span class="attr">anchors:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  <span class="comment"># P3/8</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  <span class="comment"># P4/16</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  <span class="comment"># P5/32</span></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure>
<p>至此训练参数配置完毕。</p>
<p>启动终端，进入yolov5文件夹，我这里是进入<code>autodl-tmp/yolov5/</code>，输入命令启动训练：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python train.py</span><br></pre></td></tr></table></figure>
<p>如下图即开始训练</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_train2.jpg" alt="训练开始"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_train.jpg" alt="训练结束"></p>
<h3 id="3-4-训练可能出现的问题">3.4 训练可能出现的问题</h3>
<p>如果出现训练过程长时间的<code>R</code>和<code>P</code>值为<code>0</code>或者<code>val/box_loss</code>和<code>val/obj_loss</code>为<code>nan</code>的情况，参考<a href="https://blog.csdn.net/weixin_55249340/article/details/125855686">此篇博客</a>。</p>
<p>如果仍不能解决，可以考虑重新手动部署YOLOv5，接着修改参数运行train.py启动训练，如果缺少库就pip install安装。</p>
<h3 id="3-5-训练结果分析">3.5 训练结果分析</h3>
<p>等待训练结束，在 <code>yolov5/runs/train</code> 文件夹就存放在训练的数据，其中weights文件夹中还存放着此次训练的权重文件，用于后续推理。</p>
<h4 id="3-5-1-保存训练结果">3.5.1 保存训练结果</h4>
<p>在训练结果文件夹（我的是<code>runs/train/exp2</code>）中新建.py文件，输入下面代码，接着使用终端进入<code>runs/train/exp2</code>，使用命令<code>python save.py</code>可以变成压缩包，下载压缩包即下载全部训练结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># save.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_files</span>(<span class="params">dir_name=<span class="string">&#x27;.&#x27;</span>, ignore=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">for</span> dir_name,subdirs,files <span class="keyword">in</span> os.walk(dir_name):</span><br><span class="line">        <span class="keyword">if</span> ignore <span class="keyword">and</span> os.path.basename(dir_name) <span class="keyword">in</span> ignore: </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> ignore <span class="keyword">and</span> file_name <span class="keyword">in</span> ignore:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> os.path.join(dir_name, file_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_tar_file</span>(<span class="params">dir_name=<span class="string">&#x27;.&#x27;</span>, tar_file_name=<span class="string">&#x27;tarfile.tar&#x27;</span>, ignore=<span class="literal">None</span></span>):</span><br><span class="line">    tar = tarfile.<span class="built_in">open</span>(tar_file_name, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> recursive_files(dir_name, ignore):</span><br><span class="line">        tar.add(file_name)</span><br><span class="line"></span><br><span class="line">    tar.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dir_name = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">tar_file_name = <span class="string">&#x27;train.tar&#x27;</span></span><br><span class="line">ignore = &#123;<span class="string">&#x27;.ipynb_checkpoints&#x27;</span>, <span class="string">&#x27;__pycache__&#x27;</span>, tar_file_name&#125;</span><br><span class="line">make_tar_file(dir_name, tar_file_name, ignore)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将训练结果下载到电脑上，解压有如下文件：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_results.jpg" alt=""></p>
<h4 id="3-5-2-曲线类分析">3.5.2 曲线类分析</h4>
<ul>
<li>P_curve：准确率Precision和置信度Confidence的关系图，当设置某置信度时对应某个类别的识别准确率。随着置信度设置越高，某个类别识别准确率越高。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_P_curve.png" alt="P曲线"></p>
<ul>
<li>R_curve：召回率Recall和置信度Confidence的关系图，当设置某置信度时对应某个类别的查找完全的概率。随着置信度设置越高，某个类别能被查找完全的概率越低。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_R_curve.png" alt="R曲线"></p>
<ul>
<li>PR_cruve：准确率Precision和召回率Recall的关系图，尽可能希望准确率高的同时召回率也高，即曲线与坐标轴围成的面积越大，模型越好。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_PR_curve.png" alt="PR曲线"></p>
<ul>
<li>F1_curve：精确率和召回率的调和平均数，某个分类对应F1的值，1为最好，0为最差。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_F1_curve.png" alt="F1曲线"></p>
<h4 id="3-5-3-混淆矩阵分析">3.5.3 混淆矩阵分析</h4>
<ul>
<li>confusion_matrix：矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例，可以方便地看出机器是否将两个不同的类混淆。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_confusion_matrix.png" alt="混淆矩阵"></p>
<h4 id="3-5-4-标签相关分析">3.5.4 标签相关分析</h4>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_labels.jpg" alt="标签相关labels.jpg"></p>
<ul>
<li>左上角为训练集的数据量；</li>
<li>右上角是框的尺寸和数量；</li>
<li>左下角是打标签目标框中心点位置，由图可知中心点多为中心偏上。</li>
<li>右下角是打标签目标框的高和宽，由图可知多聚集在0.2×0.2</li>
</ul>
<h4 id="3-5-5-训练验证结果分析">3.5.5 训练验证结果分析</h4>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_results.png" alt="results.png"></p>
<p>前面加<code>train</code>为训练集的情况，加<code>val</code>表示验证集的情况。</p>
<ul>
<li>
<p>定位损失box_loss：预测框与标定框之间的误差。</p>
</li>
<li>
<p>置信度损失obj_loss：计算网络的置信度。</p>
</li>
<li>
<p>分类损失cls_loss：计算锚框与对应标定分类是否正确。</p>
</li>
<li>
<p>precision：模型精度。</p>
</li>
<li>
<p>recall：真实为positive的准确率，即正样本有多少被找出来了。</p>
</li>
<li>
<p>mAP：Mean Average Precision，均值平均精度，mAP_0.5表示阈值大于0.5的平均mAP。</p>
</li>
<li>
<p>mAP_0.5:0.95：表示不同<a href="https://blog.csdn.net/gaoyu1253401563/article/details/86484851">IoU</a>阈值（从0.5到0.95，步长0.05）上的平均mAP。</p>
</li>
</ul>
<h4 id="3-5-6-其余分析">3.5.6 其余分析</h4>
<ul>
<li>
<p><code>train_batch</code>、 <code>val_batch</code>表示一批次读取的照片数。</p>
</li>
<li>
<p><code>results.csv</code>存放着每轮训练的数据。</p>
</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="肆-模型转化处理-基于-onnx文件推理">肆 —— 模型转化处理（基于.onnx文件推理）</h2>
<h3 id="4-1-转化为-onnx文件">4.1 转化为.onnx文件</h3>
<p>将我们的.pt文件经过服务器上YOLOv5自带的<code>export.py</code>处理后即可得到.onnx文件。即下面的命令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights yolov5s.pt --include onnx</span><br></pre></td></tr></table></figure>
<p>我输入的是（位于yolov5文件夹）：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights runs/train/exp2/weights/best.pt --include onnx</span><br></pre></td></tr></table></figure>
<h3 id="4-2-通过c-利用-onnx文件进行推理识别">4.2 通过C++利用.onnx文件进行推理识别</h3>
<h4 id="4-2-1-记录处理的数据结构">4.2.1 记录处理的数据结构</h4>
<p>将置信度阈值<code>confThreshold</code>、NMS非极大值抑制阈值<code>nmsThreshold</code>、目标置信度阈值<code>objThreshold</code>和识别模型路径<code>modelpath</code>打包成结构体，用于识别时参数的配置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义配置结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Configuration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> confThreshold; <span class="comment">// Confidence threshold</span></span><br><span class="line">	<span class="type">float</span> nmsThreshold;  <span class="comment">// Non-maximum suppression threshold</span></span><br><span class="line">	<span class="type">float</span> objThreshold;  <span class="comment">// Object Confidence threshold</span></span><br><span class="line">	string modelpath;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建<code>YOLOv5</code>类，其成员变量有置信度阈值<code>confThreshold</code>、NMS非极大值抑制阈值<code>nmsThreshold</code>、目标置信度阈值<code>objThreshold</code>，以及输入图片宽度<code>inpWidth</code>、输入图片高度<code>inpHeight</code>两个照片参数，识别种类数<code>num_classes</code>，类名<code>classes</code>；</p>
<p>主要函数为检测函数<code>detect</code>，辅助函数为预测画框函数<code>drawPred</code>和调整图片大小函数<code>resize_image</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOLOv5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">YOLOv5</span>(Configuration config, <span class="type">bool</span> isCuda);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">(Mat &amp;frame)</span></span>;  <span class="comment">// 检测函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> confThreshold;</span><br><span class="line">	<span class="type">float</span> nmsThreshold;</span><br><span class="line">	<span class="type">float</span> objThreshold;</span><br><span class="line">	<span class="type">int</span> inpWidth;</span><br><span class="line">	<span class="type">int</span> inpHeight;</span><br><span class="line">	<span class="type">int</span> num_classes;</span><br><span class="line">	string classes[<span class="number">1</span>] = &#123; <span class="string">&quot;eleb&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//vector&lt;string&gt; class_names;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> keep_ratio = <span class="literal">true</span>;</span><br><span class="line">	Net net;   <span class="comment">// dnn里的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">drawPred</span><span class="params">(<span class="type">float</span> conf, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, Mat &amp;frame, <span class="type">int</span> classid)</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">resize_image</span><span class="params">(Mat srcimg, <span class="type">int</span> *newh, <span class="type">int</span> *neww, <span class="type">int</span> *top, <span class="type">int</span> *left)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-检测识别函数">4.2.2 检测识别函数</h4>
<ol>
<li>进行预处理：对输入图像（帧）进行大小调整和归一化处理，以便为模型做准备。调整后的图像会被转换为Blob，一个具有NCHW 维度（图像数、通道数、高度、宽度）的 4D 矩阵。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat dstimg = <span class="keyword">this</span>-&gt;<span class="built_in">resize_image</span>(frame, &amp;newh, &amp;neww, &amp;padh, &amp;padw);</span><br><span class="line">Mat blob = <span class="built_in">blobFromImage</span>(dstimg, <span class="number">1</span> / <span class="number">255.0</span>, <span class="built_in">Size</span>(<span class="keyword">this</span>-&gt;inpWidth, <span class="keyword">this</span>-&gt;inpHeight), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;net.<span class="built_in">setInput</span>(blob);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>模型推理：在Blob上运行模型以获得输出，即边界框和类别概率列表。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;Mat&gt; outs;</span><br><span class="line"><span class="keyword">this</span>-&gt;net.forward(outs, <span class="keyword">this</span>-&gt;net.<span class="built_in">getUnconnectedOutLayersNames</span>());</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>进行后处理：如果输出超过2维，则会对其进行重塑。对于每个边界框，它会检查对象的置信度是否高于阈值。计算最大类得分，同时检查其是否高于置信度阈值。如果超过了，就会保存边界框、置信度和类ID。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_proposal; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (obj_conf &gt; <span class="keyword">this</span>-&gt;objThreshold)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (max_class_socre &gt; <span class="keyword">this</span>-&gt;confThreshold)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            confidences.<span class="built_in">push_back</span>((<span class="type">float</span>) max_class_socre);</span><br><span class="line">            boxes.<span class="built_in">push_back</span>(<span class="built_in">Rect</span>(left, top, (<span class="type">int</span>) (w * ratiow), (<span class="type">int</span>) (h * ratioh)));</span><br><span class="line">            classIds.<span class="built_in">push_back</span>(class_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>非最大值抑制 (NMS)：NMS用于移除重叠的边界框。剩余的边界框在原始图像上绘制。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">dnn::<span class="built_in">NMSBoxes</span>(boxes, confidences, <span class="keyword">this</span>-&gt;confThreshold, <span class="keyword">this</span>-&gt;nmsThreshold, indices);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; indices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">drawPred</span>(confidences[idx], box.x, box.y, box.x + box.width, box.y + box.height, frame, classIds[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-预测画框函数">4.2.3 预测画框函数</h4>
<p>预测画框函数用于将预测函数所得到的目标区域，经OpenCV的工具在图片上绘制出方框。首先传入的参数有置信度，图片的四个角落点，Mat类型图片和类id，接着借助OpenCV的<code>rectangle</code>函数和<code>putText</code>函数绘制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制预测目标的边界框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YOLOv5::drawPred</span><span class="params">(<span class="type">float</span> conf, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, Mat &amp;frame, <span class="type">int</span> classid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 绘制一个显示边界框的矩形</span></span><br><span class="line">	<span class="built_in">rectangle</span>(frame, <span class="built_in">Point</span>(left, top), <span class="built_in">Point</span>(right, bottom), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到目标的类名和置信度</span></span><br><span class="line">	string label = cv::format(<span class="string">&quot;%.2f&quot;</span>, conf);</span><br><span class="line">	label = <span class="keyword">this</span>-&gt;classes[classid] + <span class="string">&quot;:&quot;</span> + label;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制目标的类名和置信度文本</span></span><br><span class="line">	<span class="type">int</span> baseLine;</span><br><span class="line">	Size labelSize = <span class="built_in">getTextSize</span>(label, FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, <span class="number">1</span>, &amp;baseLine);</span><br><span class="line">	top = <span class="built_in">max</span>(top, labelSize.height);</span><br><span class="line">	<span class="built_in">putText</span>(frame, label, <span class="built_in">Point</span>(left, top), FONT_HERSHEY_SIMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-主函数">4.2.4 主函数</h4>
<p>本程序通过<code>main</code>函数的参数进行传参。如C/C++语言语法， <code>argc</code> 是argument count的缩写，表示传入main函数中的参数个数，包括这个程序本身； <code>argv</code> 是 argument vector的缩写，表示传入 <code>main</code> 函数中的参数列表，其中 <code>argv[0]</code> 表示这个程序的名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//yolov5-onnx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Run like this:\n    &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; yolov5s.onnx input.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Configuration yolo_nets = &#123; <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, argv[<span class="number">1</span>] &#125;; <span class="comment">// 初始化数据</span></span><br><span class="line">	<span class="function">YOLOv5 <span class="title">yolo_model</span><span class="params">(yolo_nets, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	Mat srcimg = <span class="built_in">imread</span>(argv[<span class="number">2</span>]);  <span class="comment">// 读入图片</span></span><br><span class="line">	yolo_model.<span class="built_in">detect</span>(srcimg);     <span class="comment">// 进行推理</span></span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, srcimg); <span class="comment">// 输出图片</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">yolov5-onnx.exe best.onnx input.jpg</span><br></pre></td></tr></table></figure>
<p><br /><br /><br /></p>
<h2 id="伍-模型转化加速处理-基于-engine文件推理">伍 —— 模型转化加速处理（基于.engine文件推理）</h2>
<h3 id="5-1-转化为-engine文件">5.1 转化为.engine文件</h3>
<h4 id="5-1-1-通过yolov5自带的export-py转换">5.1.1 通过YOLOv5自带的export.py转换</h4>
<p>将我们的.pt文件经过服务器上YOLOv5自带的<code>export.py</code>处理后即可得到.engine文件（可能会自动下载TensorRT）。即下面的命令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights yolov5s.pt --include engine</span><br></pre></td></tr></table></figure>
<p>我输入的是（位于yolov5文件夹）：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights runs/train/exp2/weights/best.pt --include engine</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-通过自己下载安装的tensorrt转换">5.1.2 通过自己下载安装的TensorRT转换</h4>
<p>在<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/5/#more">安装TensorRT</a>后，在TensorRT文件夹下有一个名为 <code>bin</code> 的文件夹，里面存在一个<code>trtexec.exe</code>文件。可以通过这个文件进行文件转换。在 <code>bin</code> 目录启动命令提示符，命令格式如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=best.onnx --saveEngine=best.engine</span><br></pre></td></tr></table></figure>
<h3 id="5-2-通过c-利用-engine文件进行推理识别">5.2 通过C++利用.engine文件进行推理识别</h3>
<h4 id="5-2-1-记录识别结果的数据结构">5.2.1 记录识别结果的数据结构</h4>
<p>一个记录识别结果的结构体，包括检测物体置信度 <code>score</code>，目标预测框 <code>box</code> 和类ID <code>class_id</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	cv::Rect box;</span><br><span class="line">	<span class="type">int</span> class_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-日志模块">5.2.2 日志模块</h4>
<p>在构建TensorRT Runtime时需要作为参数传入。日志模块必须继承自<code>nvinfer1::ILogger</code>类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TensorRT需要日志</span></span><br><span class="line"><span class="comment">// 参考: https://github.com/cyrusbehr/tensorrt-cpp-api</span></span><br><span class="line"><span class="keyword">using</span> Severity = nvinfer1::ILogger::Severity;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : <span class="keyword">public</span> nvinfer1::ILogger</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Severity severity, <span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Severity severity, <span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (severity &lt;= Severity::kWARNING)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger logger;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-计算内存大小模块">5.2.3 计算内存大小模块</h4>
<p>一个计算内存大小的辅助函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">get_memory_size</span><span class="params">(<span class="type">const</span> nvinfer1::Dims &amp;dims, <span class="type">const</span> <span class="type">int32_t</span> elem_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">accumulate</span>(dims.d, dims.d + dims.nbDims, <span class="number">1</span>, std::<span class="built_in">multiplies</span>&lt;<span class="type">int64_t</span>&gt;()) * <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(elem_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-4-检测识别模块">5.2.4 检测识别模块</h4>
<p>基于.engine文件的推理识别涉及到显卡的调用，故需用到CUDA的Context。</p>
<p>CUDA的Context是由CUDA驱动程序创建的数据结构，包含执行CUDA操作所需的所有信息，如设备代码、数据以及线程、内存和硬件设置等资源。每个线程都有一个当前Context，该线程上的所有CUDA操作都在该Context中执行。</p>
<ol>
<li>初始化YOLOv5模型</li>
</ol>
<ul>
<li>首先从<code>engine_file_path</code>指定的文件中加载TensorRT引擎。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取TensorRT引擎</span></span><br><span class="line"><span class="function">std::ifstream <span class="title">engine_file</span><span class="params">(engine_file_path, std::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (engine_file.<span class="built_in">fail</span>())</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Failed to read model file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">engine_file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ifstream::end);</span><br><span class="line"><span class="keyword">auto</span> fsize = engine_file.<span class="built_in">tellg</span>();</span><br><span class="line">engine_file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ifstream::beg);</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">engineData</span><span class="params">(fsize)</span></span>;</span><br><span class="line">engine_file.<span class="built_in">read</span>(engineData.<span class="built_in">data</span>(), fsize);</span><br></pre></td></tr></table></figure>
<ul>
<li>其次，推演运行时 <code>nvinfer1::IRuntime</code> 是一切资源的源头，是第一个需要被初始化的对象，注意运行时的初始化需要将辅助模块中定义好的 <code>logger</code> 作为传入参数。同时这段代码使用 <code>unique_ptr</code> 来跟踪初始化后的运行时对象。引擎 <code>nvinfer1::ICudaEngine</code> 存储了模型的权重参数，它的初始化分2步：首先将模型文件读入内存，然后使用运行时的 <code>deserializeCudaEngine</code> 方法初始化引擎对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化IRuntime和ICudaEngine</span></span><br><span class="line">std::unique_ptr&lt;nvinfer1::IRuntime&gt; runtime&#123; nvinfer1::<span class="built_in">createInferRuntime</span>(logger) &#125;;</span><br><span class="line">std::unique_ptr&lt;nvinfer1::ICudaEngine&gt; mEngine&#123; runtime-&gt;<span class="built_in">deserializeCudaEngine</span>(engineData.<span class="built_in">data</span>(), fsize) &#125;;</span><br><span class="line"><span class="keyword">if</span> (mEngine.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Failed to deserialize CUDA engine.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后创建CUDA的context，并为输入和输出绑定分配CUDA内存。引擎的本质是专为TensorRT优化后的模型。可使用<code>createExecutionContext</code> 方法来构建推演环境 <code>nvinfer1::IExecutionContext</code> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;nvinfer1::IExecutionContext&gt; context&#123; mEngine-&gt;<span class="built_in">createExecutionContext</span>() &#125;;</span><br><span class="line"><span class="keyword">if</span> (context.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Failed to create CUDA context.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>准备模型输入</li>
</ol>
<ul>
<li>了解模型结构，通过<a href="https://netron.app">netron.app</a>输入.onnx文件查看自己的神经网络结构。我这里输入名字为 <code>images</code> ，尺寸为3×640×640；输出名字为 <code>output0</code> ，尺寸为1×25200×6。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_model.jpg" alt="模型结构"></p>
<ul>
<li>TensorRT的模型推演在GPU上进行，需要在显存上为用于计算的数据申请空间。输入尺寸为3×640×640，使用内存大小计算函数得到显存中应当开辟的空间大小，然后使用 <code>cudaMalloc</code> 申请显存。其中 <code>cuda_mem_input</code> 为指向该显存区域的指针。为了方便后续推演，这里使用一个指针数组 <code>bindings</code> 记录下与推演有关的内存区域。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录与推演相关的内存区域</span></span><br><span class="line"><span class="type">void</span> *bindings[<span class="number">5</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *input_name = <span class="string">&quot;images&quot;</span>;</span><br><span class="line"><span class="type">int32_t</span> input_idx = mEngine-&gt;<span class="built_in">getBindingIndex</span>(input_name);</span><br><span class="line"><span class="keyword">if</span> (input_idx == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: failed to get input by name: &quot;</span> &lt;&lt; input_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算显存大小并开辟</span></span><br><span class="line"><span class="type">int32_t</span> channels = <span class="number">3</span>, height = <span class="number">640</span>, width = <span class="number">640</span>;</span><br><span class="line">nvinfer1::Dims4 input_dims &#123; <span class="number">1</span>, channels, height, width &#125;;</span><br><span class="line"><span class="type">size_t</span> input_mem_size = <span class="built_in">get_memory_size</span>(input_dims, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="type">void</span>* cuda_mem_input &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMalloc</span>(&amp;cuda_mem_input, input_mem_size) != cudaSuccess) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR: input cuda memory allocation failed, size = &quot;</span> &lt;&lt; input_mem_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bindings[<span class="number">0</span>] = cuda_mem_input;</span><br></pre></td></tr></table></figure>
<ul>
<li>同时还需为输出区域计算并开辟内存。模型的输出包含一个或多个对象，必须为每个输出对象分配独立的显存区域。在循环体中，首先通过 <code>getBindingDimensions</code> 获得输出每个对象的维度，然后计算其占据的显存区域大小，并调用 <code>cudaMalloc</code> 函数分配显存，最后将指向该存储区域的指针存入之前创建好的 <code>bindings</code> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; output_node_names&#123; <span class="string">&quot;output0&quot;</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; output_mem_sizes;</span><br><span class="line"><span class="type">bool</span> output_mem_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_node_names.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> output_idx = mEngine-&gt;<span class="built_in">getBindingIndex</span>(output_node_names[i].<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (output_idx == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR: failed to get output by name: &quot;</span> &lt;&lt; output_node_names[i] &lt;&lt; std::endl;</span><br><span class="line">		output_mem_initialized = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> output_dims = context-&gt;<span class="built_in">getBindingDimensions</span>(output_idx);</span><br><span class="line">	<span class="keyword">auto</span> output_size = <span class="built_in">get_memory_size</span>(output_dims, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	output_mem_sizes.<span class="built_in">push_back</span>(output_size);</span><br><span class="line">	<span class="type">void</span> *cuda_mem_output&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cudaMalloc</span>(&amp;cuda_mem_output, output_size) != cudaSuccess)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR: output cuda memory allocation failed, size = &quot;</span> &lt;&lt; output_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		output_mem_initialized = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bindings[<span class="number">1</span> + i] = cuda_mem_output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>显存空间初始化完成后，还需要初始化最后一个对象 <code>cudaStream</code> 。它用来在异步操作中同步结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaStream_t stream&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaStreamCreate</span>(&amp;stream) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: cuda stream creation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从<code>image_file_path</code>中读取图像，将其调整为所需尺寸，并复制到GPU内存中。输入图像在进入神经网络之前，首先会进行预处理操作。典型的预处理操作包括：缩放到指定尺寸、减去均值、归一化、除方差。另外如果模型对输入通道的顺序有要求，预处理也会调整通道顺序。YOLOv5的输入大小为640x640像素，通道顺序为RGB， 预处理也非常简单，像素值除以255即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat img_bgr = cv::<span class="built_in">imread</span>(image_file_path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line">cv::<span class="built_in">resize</span>(img_bgr, img_bgr, cv::<span class="built_in">Size</span>(width, height));</span><br><span class="line"><span class="type">int32_t</span> tmp = height * width * channels;</span><br><span class="line"><span class="type">float</span> *input_buffer = <span class="keyword">new</span> <span class="type">float</span>[tmp]();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; channels; c++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, HW = height * width; j &lt; HW; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		input_buffer[c * HW + j] = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(img_bgr.data[j * channels + <span class="number">2</span> - c]) / <span class="number">255.0f</span>;</span><br><span class="line">		<span class="comment">// 其中 img_bgr.data 为指向像素存储区域的指针，而括号内下表运算中的 +2 实现了BGR数据到RGB的转换。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据预处理的操作是在HOST（CPU）侧完成，在推演之前还需要将预处理后的数据拷贝到GPU一侧。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMemcpyAsync</span>(cuda_mem_input, input_buffer, input_mem_size, cudaMemcpyHostToDevice, stream) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: CUDA memory copy of input failed, size = &quot;</span> &lt;&lt; input_mem_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行推理</li>
</ol>
<ul>
<li>使用执行Context的 <code>enqueueV2</code> 方法异步运行模型。 <code>enqueueV2</code> 是真正触发模型推演的操作。参数中的 <code>bindings</code> 是之前记录的指向输入与输出显存的指针数组。 <code>stream</code> 是在初始化资源章节创建的 <code>cudaStream</code> 对象，用于同步数据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> status = context-&gt;<span class="built_in">enqueueV2</span>(bindings, stream, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!status)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: TensorRT inference failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>模型输出后处理</li>
</ol>
<ul>
<li>首先按照输出数据的规格申请输出内存空间。为输出结果 <code>output0</code> 申请了一份内存空间，并将指向这些内存区域的指针存储在 <code>output_buffers</code> 指针数组中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span> *&gt; output_buffers;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_mem_sizes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> *buf = <span class="keyword">new</span> <span class="type">float</span>[output_mem_sizes[i] / <span class="built_in">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">	output_buffers.<span class="built_in">push_back</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接着将输出从GPU内存复制到CPU内存。使用 <code>cudaMemcpyAsync</code> 函数。其中参数 <code>output_buffers</code> 为刚才申请好的内存空间， <code>bindings</code> 为GPU一侧的显存空间， <code>output_mem_sizes</code> 为输出结果所占据的内存大小， <code>cudaMemcpyDeviceToHost</code> 指定了拷贝操作的方向，由于这是一个异步操作，所以要使用 <code>stream</code> 作为同步数据的依据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_mem_sizes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> mem_to_host_result = <span class="built_in">cudaMemcpyAsync</span>(output_buffers[i], bindings[<span class="number">1</span> + i], output_mem_sizes[i], cudaMemcpyDeviceToHost, stream);</span><br><span class="line">	<span class="keyword">if</span> (mem_to_host_result != cudaSuccess)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR: CUDA memory copy of output &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; failed, size = &quot;</span> &lt;&lt; output_mem_sizes[i] &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>等待同步，已经调用了3个异步操作函数，因此这里需要使用同步操作来等待执行真正完成。同步之后，模型推演的结果才真正存储在了内存 <code>output_buffers</code> 中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cudaStreamSynchronize</span>(stream);</span><br></pre></td></tr></table></figure>
<ul>
<li>对输出进行后处理。首先定义三个向量分别存储检测获得的物体边界框 <code>boxes</code> 、分值 <code>scores</code> 与类别ID <code>class_ids</code> 。此次训练的YOLOv5模型有1个输出，即 <code>output0</code> 。 其本身是一个巨大的矩阵，其行数为25200，代表模型给出的物体检测结果。为此，可以定义一个指针 <code>p</code> 指向 <code>output0</code> ，然后通过一个循环来轮询结果。 此次训练中， <code>output0</code> 每行具有6个元素：第0~3个元素为物体边界框中心x，物体边界框中心y，物体边界框宽度和物体边界框高度；第4个元素为预测框分值；第5个元素是物体类别ID的概率，可以按照最大值获取到分类结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span>&gt; scores;</span><br><span class="line">std::vector&lt;cv::Rect&gt; boxes;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; class_ids;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *p = output_buffers[<span class="number">0</span>]; <span class="comment">// 指向output0的第一个元素</span></span><br><span class="line"><span class="type">int</span> step = <span class="number">6</span>, proposal_count = <span class="number">25200</span>;</span><br><span class="line"><span class="type">float</span> score_threshold = <span class="number">0.5</span>, nms_threshold = <span class="number">0.45</span>; <span class="comment">// 分支阈值和NMS阈值</span></span><br><span class="line"><span class="type">float</span> scale = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; proposal_count; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 置信度低于分数阈值</span></span><br><span class="line">	<span class="type">float</span> obj_score = p[<span class="number">4</span>]; <span class="comment">// 第4个元素是预测框分值</span></span><br><span class="line">	<span class="keyword">if</span> (obj_score &lt; score_threshold)</span><br><span class="line">	&#123;</span><br><span class="line">		p += step;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断对象分类</span></span><br><span class="line">	<span class="type">int</span> c_id = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">float</span> c_score = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; step; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[j] &gt; c_score)</span><br><span class="line">		&#123;</span><br><span class="line">			c_score = p[j];</span><br><span class="line">			c_id = j - <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	scores.<span class="built_in">push_back</span>(c_score * obj_score);</span><br><span class="line">	class_ids.<span class="built_in">push_back</span>(c_id);</span><br><span class="line">	boxes.<span class="built_in">push_back</span>(cv::<span class="built_in">Rect</span>((p[<span class="number">0</span>] - p[<span class="number">2</span>] / <span class="number">2</span>) / scale, (p[<span class="number">1</span>] - p[<span class="number">3</span>] / <span class="number">2</span>) / scale, p[<span class="number">2</span>] / scale, p[<span class="number">3</span>] / scale));</span><br><span class="line">	p += step; <span class="comment">// 指向下一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用了OpenCV提供的NMS方法 <code>cv::dnn::NMSBoxes</code> 。其中 <code>boxes</code> 为存储了 <code>Rect</code> 类的向量， <code>scores</code> 为存储了分值的向量， <code>score_threshold</code> 为检测分值阈值， <code>nms_threshold</code> 为NMS操作的阈值， <code>indices</code> 为一个空向量，用来存储NMS的结果。最后按照 <code>indices</code> 给出的物体序号提取最终结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行非最大值抑制以消除具有较低置信度的冗余重叠框</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">cv::dnn::<span class="built_in">NMSBoxes</span>(boxes, scores, score_threshold, nms_threshold, indices);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集检测结果</span></span><br><span class="line">std::vector&lt;Result&gt; results;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : indices) </span><br><span class="line">&#123;</span><br><span class="line">    results.<span class="built_in">push_back</span>(Result &#123; scores[i], boxes[i], class_ids[i] &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>保存结果：它将包含绘制结果的图像保存下来。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : results)</span><br><span class="line">&#123;</span><br><span class="line">	cv::<span class="built_in">rectangle</span>(img_bgr, r.box, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::<span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, img_bgr);</span><br></pre></td></tr></table></figure>
<h4 id="5-2-5-主函数设计">5.2.5 主函数设计</h4>
<p>此程序主函数与基于.onnx文件推理程序类似，通过<code>main</code>函数的参数进行传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//yolov5-engine.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Run like this:\n    &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; yolov5s.engine input.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="built_in">run</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">yolov5-engine.exe best.engine input.jpg</span><br></pre></td></tr></table></figure>
<p><br /><br /><br /></p>
<h2 id="陆-打包软件">陆 —— 打包软件</h2>
<h3 id="6-1-基于-onnx文件图像推理程序打包">6.1 基于.onnx文件图像推理程序打包</h3>
<p>打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在<code>output/</code>文件夹也输出一张照片并做名字冲突处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导出名冲突</span></span><br><span class="line"><span class="function">string <span class="title">getUniqueFileName</span><span class="params">(<span class="type">const</span> std::string &amp;fileName, <span class="type">const</span> std::string &amp;outputDirectory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string baseName, extension;</span><br><span class="line">	<span class="type">size_t</span> dotIndex = fileName.<span class="built_in">rfind</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (dotIndex != string::npos)</span><br><span class="line">	&#123;</span><br><span class="line">		baseName = fileName.<span class="built_in">substr</span>(<span class="number">0</span>, dotIndex);</span><br><span class="line">		extension = fileName.<span class="built_in">substr</span>(dotIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		baseName = fileName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string newFileName = fileName;</span><br><span class="line">	<span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifstream(outputDirectory + newFileName).<span class="built_in">good</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		newFileName = baseName + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(counter) + extension;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newFileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份存储</span></span><br><span class="line">string dir = <span class="string">&quot;output/&quot;</span>; <span class="comment">//文件夹路径</span></span><br><span class="line"><span class="keyword">if</span> (_access(dir.<span class="built_in">c_str</span>(), <span class="number">0</span>) == <span class="number">-1</span>)<span class="comment">//判断该文件夹是否存在</span></span><br><span class="line">&#123;</span><br><span class="line">	_mkdir(dir.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, srcimg);</span><br><span class="line">string newname = <span class="built_in">getUniqueFileName</span>(<span class="string">&quot;result.jpg&quot;</span>, <span class="string">&quot;output/&quot;</span>);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;output/&quot;</span> + newname, srcimg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考<a href="https://fingsinz.space/2023/11/#more">此博客</a>进行打包即可。</p>
<p>打包之后即可移植到其他PC设备使用。</p>
<h3 id="6-2-基于-engine文件图像推理程序打包">6.2 基于.engine文件图像推理程序打包</h3>
<p>同理，打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在<code>output/</code>文件夹也输出一张照片并做名字冲突处理。</p>
<p>由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考<a href="https://fingsinz.space/2023/11/#more">此博客</a>进行打包即可。</p>
<p>注意一点，由于.engine文件需要调用显卡驱动，故不能移植到别的电脑使用（暂时我是没成功）。</p>
<h3 id="6-3-整体打包">6.3 整体打包</h3>
<p>此次项目整体打包采用Qt作为前端页面，将上面两个打包好的程序结合，使用时只需调用指定程序模块即可。具体Qt打包可参考<a href="https://fingsinz.space/2023/10/">此博客</a></p>
<p>具体代码不细展开，分享于<a href="https://gitee.com/fingsinz/ele-bicycle-detection/">码云仓库</a>。</p>
<p><br /><br /><br /></p>
<h2 id="柒-总结及后话">柒 —— 总结及后话</h2>
<p>实际上，如5.1的步骤，将参数改为.trt，即可导出.trt文件。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=best.onnx --saveEngine=best.trt</span><br></pre></td></tr></table></figure>
<p>至于如何根据.trt文件设计算法进一步进行推测识别，此次项目未能完成，有待补充，深度学习很多方面的知识也有待补充。故此次项目仅能作为一个带有启发性的入门级别的项目。</p>
<p>深度学习是机器学习领域中的一个新的研究方向，旨在让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。深度学习试图为数据的高层次摘要进行建模，通过使用多个处理层和对这些层的结果进行线性和非线性的转换，来实现对数据的识别和理解。深度学习在搜索技术、数据挖掘、机器翻译、自然语言处理、多媒体学习、语音、推荐和个性化技术等领域都取得了了很多成果。经过这次项目，我感受到了深度学习的有趣，写下这篇博客，用于记录与分享。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>深度学习</tag>
        <tag>YOLOv5</tag>
        <tag>OpenCV</tag>
        <tag>TensorRT</tag>
      </tags>
  </entry>
  <entry>
    <title>两个用过的导航页</title>
    <url>/2023/%E5%AF%BC%E8%88%AA%E9%A1%B5/</url>
    <content><![CDATA[<p>介绍两个我常用的导航页——果汁导航页和青柠起始页。导航页就是一个网站的目录，其包含了很多常用其他网站的快捷方式。</p>
<p>关键词：导航页</p>
<span id="more"></span>
<hr>
<ol>
<li>果汁导航</li>
</ol>
<p>果汁导航页包括互联网搜索功能，还有各种生活学习用到的网页快捷方式。每层目录下还收纳了很多相关网站，包括影视、知识、新闻、等网站，丰富度很高，也很容易因为内容太多眼花缭乱忘记了有这么样的功能。更多功能可以自己探索发现收藏。可登录使用也可不登录使用。</p>
<p>地址：<a href="http://guozhivip.com">果汁导航 - guozhivip.com</a></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E6%9E%9C%E6%B1%81%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA.png" alt="果汁导航"></p>
<ol start="2">
<li>青柠起始页</li>
</ol>
<p>一个简约的起始页，具有搜索功能，当搜索框聚焦时，背景具有毛玻璃效果。点击时钟可以到达另一页，此页可以添加一些常用的网站快捷方式（需登录），自定义程度高。丰富度不高，简约型网站。</p>
<p>地址：<a href="https://limestart.cn/">青柠起始页 - limestart.cn</a></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E9%9D%92%E6%9F%A0%E8%B5%B7%E5%A7%8B%E9%A1%B5.jpg" alt="青柠起始页主页"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E9%9D%92%E6%9F%A0%E8%B5%B7%E5%A7%8B%E9%A1%B51.jpg" alt="青柠起始页附页"></p>
<ul>
<li>附：设置为浏览器起始页</li>
</ul>
<p>以Edge浏览器为例，打开设置页面，选择<code>开始、主页和新建标签页</code>，将启动时页面改为想要的导航页，更方便自己浏览器使用。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E8%AE%BE%E7%BD%AE.jpg" alt="设置"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>导航页</tag>
      </tags>
  </entry>
</search>
