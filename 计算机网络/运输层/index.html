<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="运输层协议概述进程之间的通信
运输层向它上面的应用层提供通信服务。

两台主机进行通信就是两台主机中的应用进程互相通信。通信的两端应当是两个主机中的应用进程。

端到端的通信时应用进程之间的通信。



两个主要协议
用户数据报协议UDP（User Datagram Protocol）和传输控制协议" />
  

  
  
  
  
  
  
  <title>运输层 | Fingsinz&#39;s space</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="运输层协议概述进程之间的通信 运输层向它上面的应用层提供通信服务。  两台主机进行通信就是两台主机中的应用进程互相通信。通信的两端应当是两个主机中的应用进程。  端到端的通信时应用进程之间的通信。    两个主要协议 用户数据报协议UDP（User Datagram Protocol）和传输控制协议TCP（Transmission Control Protocol）。  当使用面向连接的TCP协议">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="Fingsinz&#39;s space">
<meta property="og:description" content="运输层协议概述进程之间的通信 运输层向它上面的应用层提供通信服务。  两台主机进行通信就是两台主机中的应用进程互相通信。通信的两端应当是两个主机中的应用进程。  端到端的通信时应用进程之间的通信。    两个主要协议 用户数据报协议UDP（User Datagram Protocol）和传输控制协议TCP（Transmission Control Protocol）。  当使用面向连接的TCP协议">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fingsinz.github.io/.io//%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%BA%E8%BF%9B%E7%A8%8B%E6%8F%90%E4%BE%9B%E9%80%9A%E4%BF%A1.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//UDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A33.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP-%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AA%97%E5%8F%A3.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//SACK.jpg">
<meta property="og:image" content="https://fingsinz.github.io/.io//TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg">
<meta property="article:published_time" content="2023-05-28T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-29T15:05:53.152Z">
<meta property="article:author" content="Fingsinz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fingsinz.github.io/.io//%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%BA%E8%BF%9B%E7%A8%8B%E6%8F%90%E4%BE%9B%E9%80%9A%E4%BF%A1.jpg">
  
  
    <link rel="icon" href="/css/images/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 6.3.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Fingsinz&#39;s space" rel="home">Fingsinz&#39;s space</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">主页Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/categories/daily">日常Daily</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/notes">笔记Notes</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">归档Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about">关于About</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-运输层" class="post-运输层 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      运输层
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://fingsinz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/" data-id="cli8zk3o7000c24do3pkk5oz1" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ul>
<li><p>运输层向它上面的应用层提供通信服务。</p>
</li>
<li><p>两台主机进行通信就是两台主机中的应用进程互相通信。通信的两端应当是两个主机中的<strong>应用进程</strong>。</p>
</li>
<li><p>端到端的通信时应用进程之间的通信。</p>
</li>
</ul>
<p><img src="/.io//%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%BA%E8%BF%9B%E7%A8%8B%E6%8F%90%E4%BE%9B%E9%80%9A%E4%BF%A1.jpg" alt="运输层对应用进程提供的逻辑通信"></p>
<h3 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h3><ul>
<li><p>用户数据报协议UDP（User Datagram Protocol）和传输控制协议TCP（Transmission Control Protocol）。</p>
</li>
<li><p>当使用<strong>面向连接</strong>的TCP协议时，逻辑通信通道相当于一条全双工的可靠信道。当使用<strong>无连接</strong>的UDP协议时，逻辑通信通道是不可靠通道。</p>
</li>
<li><p>UDP和TCP的例子</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用层协议</th>
<th align="center">运输层协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">名字转换</td>
<td align="center">DNS（域名系统）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">文件传送</td>
<td align="center">TFTP（简单文件传送协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">路由选择协议</td>
<td align="center">RIP（路由信息协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">IP地址配置</td>
<td align="center">DHCP（动态主机配置协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">网络管理</td>
<td align="center">SNMP（简单网络管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">远程文件服务器</td>
<td align="center">NFS（网络文件系统）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">IP电话</td>
<td align="center">专用协议</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">流式多媒体通信</td>
<td align="center">专用协议</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">多播</td>
<td align="center">IGMP（网际组管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">电子邮件</td>
<td align="center">SMTP（简单邮件传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程终端接入</td>
<td align="center">TELNET（远程终端协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">万维网</td>
<td align="center">HTTP（超文本传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">文件传送</td>
<td align="center">FTP（文件传送协议）</td>
<td align="center">TCP</td>
</tr>
</tbody></table>
<h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ul>
<li><p>虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（即最后交付目的进程）就由TCP或UDP来完成。</p>
</li>
<li><p>运行在计算机中的<strong>进程</strong>是用<strong>进程标识符</strong>来标志的。</p>
</li>
<li><p>应用层和运输层的通信的抽象终点称为协议端口，简称为端口。每一个端口用一个称为端口号的正整数来标志。</p>
</li>
</ul>
<p>TCP&#x2F;IP运输层中，端口号只具有本地意义，端口号为了标志本计算机应用层中各个进程和运输层交互时的层间接口。</p>
<ul>
<li><p><strong>在协议栈层间的抽象的协议端口是软件端口</strong>，<strong>路由器或交换机上的端口是硬件端口</strong>。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的地点。</p>
</li>
<li><p>端口只有本地意义，不同主机的相同端口其实并没有联系。</p>
</li>
<li><p>端口分为服务器端使用的端口号和客户端使用的端口号。</p>
</li>
</ul>
<h4 id="服务器端使用的端口"><a href="#服务器端使用的端口" class="headerlink" title="服务器端使用的端口"></a>服务器端使用的端口</h4><ul>
<li><p>熟知端口号（系统端口号），数值一般为0~1023。</p>
</li>
<li><p>登记端口号，数值为1024~49151。使用这个范围的端口号必须在IANA登记，避免重复。</p>
</li>
</ul>
<h4 id="客户端使用的端口号"><a href="#客户端使用的端口号" class="headerlink" title="客户端使用的端口号"></a>客户端使用的端口号</h4><ul>
<li>又称为短暂端口号，数值为49152~65535。仅在客户进程运行时才动态选择。</li>
</ul>
<h4 id="常用熟知端口号"><a href="#常用熟知端口号" class="headerlink" title="常用熟知端口号"></a>常用熟知端口号</h4><table>
<thead>
<tr>
<th align="center">应用程序</th>
<th align="center">FTP</th>
<th align="center">TELNET</th>
<th align="center">SMTP</th>
<th align="center">DNS</th>
<th align="center">TFTP</th>
<th align="center">HTTP</th>
<th align="center">SNMP</th>
<th align="center">SNMP(trap)</th>
<th align="center">HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">熟知端口号</td>
<td align="center">21</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">53</td>
<td align="center">69</td>
<td align="center">80</td>
<td align="center">161</td>
<td align="center">162</td>
<td align="center">443</td>
</tr>
</tbody></table>
<h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><h3 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h3><h4 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h4><ol>
<li><p><strong>UDP 是无连接的</strong>，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p>
</li>
<li><p><strong>UDP使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p>
</li>
<li><p><strong>UDP 是面向报文的</strong>。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP一次交付一个完整的报文。</p>
</li>
<li><p><strong>UDP没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。</p>
</li>
<li><p><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。</p>
</li>
<li><p><strong>UDP的首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</p>
</li>
</ol>
<h4 id="面向报文的UDP"><a href="#面向报文的UDP" class="headerlink" title="面向报文的UDP"></a>面向报文的UDP</h4><ul>
<li><p>发送方UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
</li>
<li><p>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。</p>
</li>
<li><p>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p>
</li>
<li><p>应用程序必须选择合适大小的报文。</p>
</li>
</ul>
<p>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。</p>
<p>若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。</p>
<h3 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h3><p><img src="/.io//UDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.jpg"></p>
<ul>
<li>UDP的首部字段包括4个字段，如下：</li>
</ul>
<ol>
<li><p>源端口（Source Port）：2个字节，源端口号是发送端的端口号，用于接收端确定接收数据的应用程序。</p>
</li>
<li><p>目的端口（Destination Port）：2个字节，目的端口号是接收端的端口号，用于接收数据的应用程序。</p>
</li>
<li><p>长度（Length）：2个字节，指的是UDP数据报的长度，包括首部和数据，单位是字节。</p>
</li>
<li><p>校验和（Checksum）：2个字节，UDP数据报的校验和，包括UDP首部和数据，校验和可以用来检测数据是否在传输过程中被损坏。</p>
</li>
</ol>
<ul>
<li>UDP的<strong>伪首部</strong>是在计算UDP校验和时使用的。由于UDP数据报的校验和只检测UDP数据报本身的完整性，而不检测IP数据报头部的完整性，因此在计算UDP校验和时需要加入IP首部的某些字段，这些字段被称为UDP伪首部。UDP伪首部的格式如下：</li>
</ul>
<ol>
<li><p>源IP地址（Source IP Address）：4个字节，指的是发送端的IP地址。</p>
</li>
<li><p>目的IP地址（Destination IP Address）：4个字节，指的是接收端的IP地址。</p>
</li>
<li><p>零（Zero）：1个字节，保留字段，值为0。</p>
</li>
<li><p>协议（Protocol）：1个字节，指的是上层协议的类型，UDP协议的值为17。</p>
</li>
<li><p>UDP长度（UDP Length）：2个字节，指的是UDP数据报的长度，包括UDP首部和数据，单位是字节。</p>
</li>
</ol>
<ul>
<li>加入UDP伪首部后，计算校验和的方法如下：</li>
</ul>
<ol>
<li><p>将UDP伪首部的各字段和UDP数据报的首部和数据按16位字进行分组。</p>
</li>
<li><p>对于最后一个不足16位的分组，用0来填充。</p>
</li>
<li><p>将各分组按位求和，如果溢出则回卷到低位。</p>
</li>
<li><p>对结果按位取反，得到的就是UDP校验和。</p>
</li>
</ol>
<h2 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h2><h3 id="TCP最主要的特点"><a href="#TCP最主要的特点" class="headerlink" title="TCP最主要的特点"></a>TCP最主要的特点</h3><ol>
<li><strong>TCP是面向连接的运输层协议</strong>。</li>
</ol>
<p>为虚连接，逻辑连接。</p>
<ol start="2">
<li><p>每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的（一对一）。</p>
</li>
<li><p>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p>
</li>
<li><p>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。</p>
</li>
<li><p>面向字节流。</p>
</li>
</ol>
<p>TCP中的“流”(stream)指的是流入或流出进程的字节序列。“面向字节流”的含义是：虽然应用程序和TCP 的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p>
<p>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</p>
<p>TCP对连续的数据进行分段传输。</p>
<p><img src="/.io//TCP%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5.jpg"></p>
<h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><ul>
<li><p>把连接作为最基本的抽象。</p>
</li>
<li><p>每一条TCP连接有2个端点。TCP连接的端点叫做套接字(socket)或插口。端口号拼接到(contatenated with) IP 地址即构成了套接字。</p>
</li>
</ul>
<p><code>套接字socket=(IP地址:端口号)</code>，IP地址取点分十进制记法。</p>
<p>每一条TCP连接唯一地被通信两端的两个端点（两个套接字）所确定。</p>
<p><code>TCP连接 ::= &#123;socket1, socket2&#125; = &#123;(IP1:port1), (IP2:port2)&#125;</code></p>
<ul>
<li>TCP连接就是由协议软件所提供的一种抽象。同一个IP地址可以有多个不同的TCP连接。一同一个端口号也可以出现在多个不同的TCP连接中。</li>
</ul>
<h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p><img src="/.io//TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg"></p>
<ol>
<li><p>源端口号（Source Port）：占用2个字节，表示发送方使用的端口号；</p>
</li>
<li><p>目的端口号（Destination Port）：占用2个字节，表示接收方使用的端口号；</p>
</li>
<li><p>序号（Sequence Number）：占用4个字节，表示本报文段数据的第一个字节的序号；</p>
</li>
</ol>
<p>TCP协议是面向连接的可靠传输协议，因此每个TCP报文段都有一个序号，用于标识该报文段中第一个字节的位置。序号是一个32位的无符号整数，因此最大可表示$2^{32}-1$个字节，即4GB。序号的作用是使接收方能够按正确的顺序重新组装收到的数据，以及检测是否有丢失的数据。</p>
<ol start="4">
<li>确认号（Acknowledgement Number）：占用4个字节，表示期望收到对方下一个报文段的第一个字节的序号；</li>
</ol>
<p>TCP协议使用确认号机制来实现可靠传输。每个TCP报文段都包含一个确认号，用于告知发送方已经成功接收到了哪些数据。确认号是一个32位的无符号整数，表示期望收到对方下一个报文段的第一个字节的序号。例如，如果确认号为1000，则表示期望收到对方下一个报文段中的第1000个字节开始的数据。</p>
<ol start="5">
<li>数据偏移（Data Offset）：占用4个比特，表示TCP报文段首部的长度，以4字节为单位。最小值为5，最大值为15；</li>
</ol>
<p>表示TCP报文段首部的长度，以4字节为单位。由于TCP报文段首部中的选项字段长度是可变的，因此需要使用数据偏移字段来确定首部的长度。最小值为5，表示没有选项字段；最大值为15，表示选项字段占据了整个首部。</p>
<ol start="6">
<li><p>保留（Reserved）：占用6个比特，保留为0；</p>
</li>
<li><p>控制位（Flags）：占用6个比特，用于控制TCP的连接建立、维护和中断等功能。常用的标志位有URG、ACK、PSH、RST、SYN和FIN，具体含义如下：</p>
</li>
</ol>
<ul>
<li><p>URG：表示紧急指针是否有效；</p>
</li>
<li><p>ACK：表示确认号是否有效；</p>
</li>
<li><p>PSH：表示接收方应该尽快将数据交给应用层；</p>
</li>
<li><p>RST：表示连接复位；</p>
</li>
<li><p>SYN：表示连接建立请求；</p>
</li>
<li><p>FIN：表示连接中断请求。</p>
</li>
</ul>
<ol start="8">
<li>窗口大小（Window）：占用2个字节，表示发送方的缓冲区大小；</li>
</ol>
<p>用于告知对方自己的缓冲区大小。窗口大小是一个16位的无符号整数，表示接收方还能够接收多少字节的数据。发送方应该根据接收方的窗口大小来控制发送速度，以避免发送过多的数据导致接收方缓冲区溢出。</p>
<ol start="9">
<li>校验和（Checksum）：占用2个字节，用于检验TCP报文段的正确性；</li>
</ol>
<p>用于检验TCP报文段的正确性。校验和是一个16位的无符号整数，由发送方计算，并由接收方进行验证。计算校验和时，需要将TCP报文段的首部和数据部分一起进行校验。如果校验和不匹配，接收方会丢弃该报文段，并向发送方发送一个重传请求。</p>
<ol start="10">
<li>紧急指针（Urgent Pointer）：占用2个字节，表示紧急数据的最后一个字节的序号。该字段只有在URG标志为1时才有效；</li>
</ol>
<p>用于标识紧急数据的位置。紧急指针是一个16位的无符号整数，表示紧急数据的最后一个字节的序号。当发送方需要发送紧急数据时，可以设置URG标志，并在紧急指针字段中指定紧急数据的位置。接收方在接收到紧急数据时，应该立即将其交给应用层处理。</p>
<ol start="11">
<li><p>选项（Options）：长度可变，用于支持TCP的各种选项功能，如最大报文段长度、时间戳等。</p>
</li>
<li><p>填充（Fill up）：长度可变，用于满足首部格式。</p>
</li>
</ol>
<p>填充字段的长度为0到3个字节，具体长度取决于选项字段的长度。如果选项字段的长度已经使整个首部的长度为4的倍数，那么填充字段的长度就为0。否则，填充字段的长度等于使整个首部长度为4的倍数的最小字节数减去首部长度。填充字段的值全部为0。</p>
<h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><ul>
<li>理想的传输条件应该满足：传输信道不产生差错；不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li>
</ul>
<h4 id="停止等待协议（基于自动重传请求ARQ）"><a href="#停止等待协议（基于自动重传请求ARQ）" class="headerlink" title="停止等待协议（基于自动重传请求ARQ）"></a>停止等待协议（基于自动重传请求ARQ）</h4><ul>
<li>“停止等待”就是每发送完一个分组（即传送的数据单元）就停止发送，等待对方的确认。在收到确认后再发送下一个分组。全双工通信的双方既是发送方也是接收方。</li>
</ul>
<ol>
<li>无差错情况</li>
</ol>
<p><img src="/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.jpg"></p>
<ol start="2">
<li>出现差错</li>
</ol>
<p><img src="/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99.jpg"></p>
<p>发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。发送方只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器。</p>
<p>注意：发送方发送一个分组后，必须暂时保留已发送的分组副本。分组和确认分组进行编号，明确哪个分组被确认。超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些，避免不必要的重传。</p>
<ol start="3">
<li>确认丢失和确认迟到</li>
</ol>
<p><img src="/.io//TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpg"></p>
<ul>
<li>信道利用率$U$</li>
</ul>
<p>假设发送方发送分组需要的时间是$T_D$。显然，$T_D&#x3D;\frac {分组长度}{数据率}$。再假定分组正确到达接收方后，接收方处理分组时间可以忽略不计，同时立即发回确认。假定接收方发送确认分组需要时间$T_A$。如果发送方处理确认分组的时间也可以忽略不计，那么发送方在经过时间$(T_D+RTT+T_A)$后就可以再发送下一个分组，$RTT$是往返时间。所以粗略计算下：</p>
<p>$$<br>U&#x3D;\frac {T_D}{T_D+RTT+T_A}<br>$$</p>
<ul>
<li>实际上，停止等待协议的信道利用率极低。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p><img src="/.io//%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg"></p>
<ul>
<li><p>发送方可以连续发送分组，每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
</li>
<li><p>接收方采用累积确认，在接收到几个分组后，对按序到达的最后一个分组发送确认。</p>
</li>
<li><p>优点：容易实现，即使确认丢失也不必重传。</p>
</li>
<li><p>缺点：不能向发送方反应出接收方已经正确收到的所有分组的信息。</p>
</li>
</ul>
<h3 id="可靠传输的具体实现"><a href="#可靠传输的具体实现" class="headerlink" title="可靠传输的具体实现"></a>可靠传输的具体实现</h3><h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><ul>
<li>TCP的滑动窗口是以字节为单位的。</li>
</ul>
<p>假定A收到B发来的确认报文段，其中窗口是20字节，而确认号是31（表明B期望收到的下一个序号是31，而序号30为止的数据已经收到）。根据收到的确认报文段，A可以构造出自己的发送窗口，如下：<br><img src="/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31.jpg"></p>
<p>发送窗口的位置由前沿和后沿的位置共同决定，要么不动，要么前移。在发送窗口大小发生变化时，后沿前移，前沿不动。假定A发送了序号为31~41的数据，此时发送位置并未改变，但发送窗口内靠后面有11个字节表示已发送但未收到确认。而发送窗口靠前面的9个字节是允许发送但未发送的。<br><img src="/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.jpg"><br>由图可以确定发送窗口状态的三个指针：$P_1$、$P_2$、$P_3$，$P_3-P_1$为A的发送窗口，$P_2-P_1$为已发送但未收到确认的字节数，$P_3-P_2$为允许发生但当前未发送的字节数（有用窗口或有效窗口）。</p>
<p>再看一下B的接收窗口。B的接收窗口大小是20。在接收窗口外面，到30号为止的数据是已经发送过确认并且已经交付主机了。因此在B 可以不再保留这些数据。接收窗口内的序号（31~50）是允许接收的。如上图，假定B收到了序号为32和33的数据。但这些数据没有按序到达，因为序号为31的数据没有收到（也许丢失了，也许滞留在网络中的某处）。请注意，B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31（即期望收到的序号），而不能是32或33。</p>
<p>现在假定B收到了序号为31的数据，并把序号为31<del>33的数据交付主机，然后B删除这些数据。接着把接收窗口向前移动3个序号，同时给A发送确认，其中窗口值仍为20，但确认号是34。这表明B已经收到了到序号33 为止的数据。B还收到了序号为37、38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中。A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了，可发送的序号范围是42</del>53。<br><img src="/.io//%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A33.jpg"></p>
<p>当A的发送窗口已满，可用窗口减小为0，便停止发送。</p>
<p>存在一种可能性：发送窗口的所有数据正确到达B，B也发出了确认，可这些确认滞留在网络中。于是A在超时计时器控制下重传部分数据，直到收到B的确认。</p>
<ul>
<li>发送缓存与发送窗口</li>
</ul>
<p><strong>发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程从TCP的接收缓存中读取字节流。</strong></p>
<p><img src="/.io//TCP-%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AA%97%E5%8F%A3.jpg"></p>
<p>缓存空间和序号空间是有限的且循环使用的。实际上缓存或窗口中的字节数非常之大。</p>
<p>发送缓存用来暂时存放：（1）发送应用程序传送给发送方TCP准备发送的数据；（2）TCP已发送出但未收到确认的数据。发送窗口通常是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确认的字节，就是还保留在发送缓存中的被写入的字节数。发送应用程序必须控制写入缓存的速率，否则会因为太快而发送缓存没有存放数据的空间。</p>
<p>接收缓存用来暂时存放：（1）按序到达的、但未被接收应用程序读取的数据；（2）未按序到达的数据。如果收到的分组被检测出有差错，就要丢弃。如果接受应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时从接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。</p>
<p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大，因为有一定的时间滞后。对于不按序到达的数据如何处理是没有明确规定。TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。</p>
<h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><ul>
<li>一个报文段发出时间和收到确认时间之差称为报文段的往返时间$RTT$。TCP保留了RTT的一个加权平均往返时间$RTT_S$（又称为平滑的往返时间，S表示Smoothed）。每当第一次测量到$RTT$样本时，$RTT_S$值就取为所测量到的$RTT$样本值，但以后每测量到一个新的$RTT$样本，就计算一次$RTT_S$：</li>
</ul>
<p>$$<br>新的RTT_S&#x3D;(1-α)×(旧的RTT_S)+α×(新的RTT样本)<br>$$</p>
<p>$0\leq α&lt;1$，$α$在标准RFC 6298推荐为0.125。</p>
<ul>
<li>超时计时器设置的超时重传时间RTO（Retransmission Time-Out）应略大于$RTT_S$，RFC 6298建议计算：</li>
</ul>
<p>$$<br>RTO&#x3D;RTT_S+4×RTT_D<br>$$</p>
<p>$RTT_D$是$RTT$的偏差的加权平均值，RFC 6298建议计算：第一次测量时，$RTT_D$取$RTT$样本值的一半，之后$新的RTT_D&#x3D;(1-β)×(旧的RTT_D)+β×\vert RTT_S-新的RTT样本\vert$，此处$β$是个小于1的系数，推荐值为0.25。</p>
<ul>
<li>为了避免因重传报文段被误认为原报文段而反复确认导致$RTT_S$和$RTO$变大，甚至越来越大，提出一种算法：<strong>报文段每重传一次，就把超时重传时间RTO增大一些。典型做法是取新的重传时间为旧的重传时间的两倍</strong>。</li>
</ul>
<h4 id="选择确认SACK（Selective-ACK）"><a href="#选择确认SACK（Selective-ACK）" class="headerlink" title="选择确认SACK（Selective ACK）"></a>选择确认SACK（Selective ACK）</h4><p>TCP的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块。可以看出，序号1<del>1000收到了，但序号1001</del>1500没有收到。接下来的字节流又收到了，可是又缺少了3001～3500。再后面从序号4501起又没有收到。也就是说，接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。因此在图中用四个指针标记这些边界。请注意，第一个字节块的左边界$L_1$&#x3D;1501，但右边界$R_1$&#x3D;3001 而不是3000。这就是说，左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号。同理，第二个字节块的左边界$L_2$&#x3D;3501，而右边界$R_2$&#x3D;4501。</p>
<p>TCP的首部没有哪个字段能够提供上述这些字节块的边界信息。RFC 2018规定，如果要使用选择确认SACK，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界。由于首部选项的长度最多只有40字节，而指明一个边界就要用掉4字节（因为序号有32位，需要使用4个字节表示），因此在选项中最多只能指明4个字节块的边界信息。这是因为4个字节块共有8个边界，因而需要用32个字节来描述。另外还需要两个字节。一个字节用来指明是 SACK 选项，另一个字节是指明这个选项要占用多少字节。如果要报告五个字节块的边界信息，那么至少需要42个字节。这就超过了选项长度的40 字节的上限。</p>
<p><img src="/.io//SACK.jpg"><br><em>其实SACK文档并未指明发送方如何响应SACK，所以还是重传所有未被确认的数据块。</em></p>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><ul>
<li>流量控制（flow control）一般是指让发送方的发送速率不要太快，让接收方来得及接收。</li>
</ul>
<h4 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h4><h4 id="TCP的传输效率"><a href="#TCP的传输效率" class="headerlink" title="TCP的传输效率"></a>TCP的传输效率</h4><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><h4 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h4><ul>
<li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞(congestion)。</li>
</ul>
<p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<p>出现拥塞的原因：$\sum {对资源需求}&gt;可用资源$</p>
<ul>
<li><p>拥塞常常趋于恶化。</p>
</li>
<li><p>拥塞控制和流量控制的区别</p>
</li>
</ul>
<p>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程。</p>
<p>流量控制往往是指点对点通信量的控制，是个端到端的问题。</p>
<p>简单的例子，设某光纤网络链路传输速率为1000Gbit&#x2F;s，有一台巨型计算机向一台个人电脑以1Gbit&#x2F;s的速率传输文件。网络带宽足够，不存在拥塞问题。但需要流量控制，使得个人电脑来得及接收。而如果有另一个网络，链路传输速率为1Mbit&#x2F;s，而有1000台大型计算机连接在此网络，假定有500台计算机分别向其余500台计算机以100kbit&#x2F;s的速率发送文件，那么整个网络的输入负载超过网络所能承受的。</p>
<ul>
<li>分组的丢失作为一个拥塞的标志。</li>
</ul>
<p><img src="/.io//TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg"></p>
<ul>
<li>拥塞控制可分为开环控制和闭环控制。</li>
</ul>
<p>开环控制就是在设计网络时事先将有关发生拥塞的因素考虑到，力求网络在工作时不产生拥塞。一旦整个系统运行起来，不再中途改正。</p>
<p>闭环控制是基于反馈环路的概念：（1）检测网络系统以便检测到拥塞在何时、何处发生；（2）把拥塞发生的信息传送到可采取行动的地方；（3）调整网络系统的运行以解决出现的问题。</p>
<ul>
<li>检测网络的拥塞的指标。</li>
</ul>
<p>由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差等等。</p>
<h4 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h4><ul>
<li><p>拥塞的判断：重传定时器超时、收到三个相同的ACK。</p>
</li>
<li><p>TCP拥塞控制算法：慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）、快恢复（fast recovery）。</p>
</li>
</ul>
<h5 id="慢开始（Slow-start）"><a href="#慢开始（Slow-start）" class="headerlink" title="慢开始（Slow start）"></a>慢开始（Slow start）</h5><ul>
<li>基于窗口的拥塞控制，发送方维持拥塞窗口cwnd（congestion window），拥塞窗口的大小取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。</li>
</ul>
<p>慢开始的“慢”是因为一开始cwnd&#x3D;1，只发送一个报文段试探。比设置cwnd为大值，将大量报文段注入网络中要慢得多。慢开始的cwnd的增长速率并不慢。</p>
<ul>
<li>算法的思路：让TCP发送方从发送一个 MSS (Maximum Segment Size，最大分段大小) 开始，每收到一个 ACK 就将窗口大小加倍，直到达到一个阈值（ssthresh），这个阈值通常被设置为网络容量的一半。一旦窗口大小达到了 ssthresh，就进入拥塞避免状态，此时窗口大小每次只能增加 1&#x2F;MSS。</li>
</ul>
<p>慢开始门限（阈值）ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。</p>
<ul>
<li><p>在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值。$拥塞窗口cwnd每次的增加量&#x3D;min(N,SMSS)$，其中 N是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。当$N&lt;SMSS$时，拥塞窗口每次的增加量要小于SMSS。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。</p>
</li>
<li><p>初始拥塞窗口cwnd</p>
</li>
</ul>
<p>旧的规定下，在刚刚开始发送报文段时，先把初始拥塞窗口cwnd设置为1至2个发送方的最大报文段SMSS（Sender Maximum Segment Size）的数值；</p>
<p>新的RFC5681 把初始拥塞窗口cwnd设置为不超过2至4个SMSS的数值。</p>
<p>当$cwnd &lt; ssthresh$，使用慢开始算法。</p>
<p>当$cwnd &gt; ssthresh$，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当$cwnd &#x3D; ssthresh$，慢开始算法和拥塞避免算法皆可。</p>
<h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><ul>
<li>算法的思路：让拥塞窗口cwnd 缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。</li>
</ul>
<p>因此在拥塞避免阶段就有“加法增大”(Additive Increase)的特点。这表明在拥塞避免阶段，拥塞窗口cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<ul>
<li>当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：$ssthresh&#x3D; max(cwnd&#x2F;2, 2)$，$cwnd&#x3D;1$，执行慢开始算法</li>
</ul>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<h5 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h5><h5 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h5><h4 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h4><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><ul>
<li><p>运输链接有三个阶段：连接建立、数据传送、连接释放。</p>
</li>
<li><p>TCP的连接建立：采用三报文握手。</p>
</li>
<li><p>TCP的连接释放：采用四报文握手。</p>
</li>
<li><p>TCP的有限状态机。</p>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/">
    <time datetime="2023-05-28T16:00:00.000Z" class="entry-date">
        2023-05-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="prev"><span class="meta-nav">←</span> 网络层</a></span>
    
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">5</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/articles/1/">记第一次成功创建博客</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a>
          </li>
        
          <li>
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2023 Fingsinz
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>